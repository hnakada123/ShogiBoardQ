--- a/include/mainwindow.h
+++ b/include/mainwindow.h
@@ -361,6 +361,7 @@
     void movePieceImmediately();
     void resetGameFlags();
     void initializePositionStringsForMatch_();
+    void startInitialEngineMoveIfNeeded_();
     void startInitialEngineMoveEvH_();
     void setGameOverMove(MatchCoordinator::Cause cause, bool loserIsPlayerOne);
     QChar glyphForPlayer(bool isPlayerOne) const;
--- a/src/app/mainwindow.cpp
+++ b/src/app/mainwindow.cpp
@@ -1172,10 +1172,9 @@
     // 司令塔へ構成/起動のみ委譲（startNewGame は既に済）
     m_match->configureAndStart(opt);
 
-    // ★ エンジンが先手のモードでは、この場で初手エンジンを必ず起動する
-    if (opt.mode == EvenEngineVsHuman || opt.mode == HandicapEngineVsHuman) {
-        startInitialEngineMoveEvH_();
-    }
+    // ★ 初手がエンジン手番なら、この場で初手エンジンを必ず起動する（先手・後手どちらでも）
+    startInitialEngineMoveIfNeeded_();
+}
 }
 
 // 棋譜解析結果を表示するためのテーブルビューを設定および表示する。
@@ -4551,19 +4550,9 @@
     m_positionPonder1.clear();
     if (!m_positionStrList.isEmpty()) m_positionStrList.clear();
 
-    // 開始局面の種別（従来ダイアログ）
-    const int startingPositionNumber =
-        m_startGameDialog ? m_startGameDialog->startingPositionNumber() : 1; // 0=現在, 1=初期(など)
-
-    // ベースの "position ..." を決める
-    // - 「現在の局面」なら SFEN 指定を使う（m_startSfenStr が空/ "startpos" なら startpos にフォールバック）
-    // - それ以外は初期局面として startpos を使う
-    if (startingPositionNumber == 0) {
-        if (!m_startSfenStr.isEmpty() && m_startSfenStr != QStringLiteral("startpos")) {
-            m_positionStr1 = QStringLiteral("position sfen %1 moves").arg(m_startSfenStr);
-        } else {
-            m_positionStr1 = QStringLiteral("position startpos moves");
-        }
+    // m_startSfenStr が使えるなら必ず SFEN をベースにする（駒落ち "w" 開始にも対応）
+    if (!m_startSfenStr.isEmpty() && m_startSfenStr != QStringLiteral("startpos")) {
+        m_positionStr1 = QStringLiteral("position sfen %1 moves").arg(m_startSfenStr);
     } else {
         m_positionStr1 = QStringLiteral("position startpos moves");
     }
@@ -4578,6 +4567,7 @@
     //      const QString wTime = QString::number(wMs);
     //    のようにその場で生成してください。
 }
+
 
 // EvH（エンジンが先手）の初手を起動する（position ベース → go → bestmove を適用）
 void MainWindow::startInitialEngineMoveEvH_()
@@ -4670,6 +4660,113 @@
     }
 }
 
+
+// 駒落ち（"w" 開始）など、開始手番が後手で、後手がエンジンのときに初手を自動で指させる。
+// 先手エンジン（EvH）の場合もここから既存の startInitialEngineMoveEvH_() を呼ぶ。
+void MainWindow::startInitialEngineMoveIfNeeded_()
+{
+    if (!m_match || !m_gameController) return;
+
+    const bool engineIsP1 =
+        (m_playMode == EvenEngineVsHuman) || (m_playMode == HandicapEngineVsHuman);
+    const bool engineIsP2 =
+        (m_playMode == EvenHumanVsEngine) || (m_playMode == HandicapHumanVsEngine);
+
+    // いまの手番（SFENに基づき、MatchCoordinator→ShogiGameController で設定済み）
+    const auto sideToMove = m_gameController->currentPlayer();
+
+    // 1) 先手エンジンなら既存処理で初手を実行
+    if (engineIsP1 && sideToMove == ShogiGameController::Player1) {
+        startInitialEngineMoveEvH_();
+        return;
+    }
+
+    // 2) 後手エンジンで後手番から開始（＝香落ちなど "w - 1"）
+    if (!(engineIsP2 && sideToMove == ShogiGameController::Player2)) return;
+
+    // 司令塔から主エンジンを取得
+    Usi* eng = m_match->primaryEngine();
+    if (!eng) {
+        qWarning() << "[HvE] engine instance not ready; skip first move.";
+        return;
+    }
+
+    // ベースの "position ... moves" が空なら初期化（安全側）
+    if (m_positionStr1.isEmpty()) {
+        initializePositionStringsForMatch_();
+    }
+    if (!m_positionStr1.startsWith("position ")) {
+        qWarning() << "[HvE] position base is invalid:" << m_positionStr1;
+        m_positionStr1 = QStringLiteral("position startpos moves");
+    }
+
+    // エンジン初手（後手）の思考 → bestmove の from/to を受け取る
+    QPoint eFrom(-1, -1), eTo(-1, -1);
+
+    // 時間ルールを取得（後手の秒読みに注意）
+    const auto tc = m_match->timeControl();
+    const int  engineByoyomiMs = tc.byoyomiMs2;   // 後手（エンジン）用
+    const bool useByoyomi      = tc.useByoyomi;
+
+    // USIへ渡す btime/wtime はその場で取得（pre-add整形は司令塔側に委譲）
+    const auto [bTime, wTime] = currentBWTimesForUSI_();
+
+    try {
+        // USI "position ... moves" と "go ..." を一括で処理して bestmove を返す
+        eng->handleEngineVsHumanOrEngineMatchCommunication(
+            m_positionStr1,        // [in/out] position base に bestmove を連結してくる
+            m_positionPonder1,     // [in/out] 使っていなければ空のままでOK
+            eFrom, eTo,            // [out] エンジンの着手が返る
+            engineByoyomiMs,
+            bTime, wTime,
+            tc.incMs1, tc.incMs2,
+            useByoyomi
+            );
+    } catch (const std::exception& e) {
+        displayErrorMessage(e.what());
+        return;
+    }
+
+    // 返ってきた bestmove を盤へ適用
+    bool ok = false;
+    try {
+        ok = m_gameController->validateAndMove(
+            eFrom, eTo, m_lastMove, m_playMode,
+            m_currentMoveIndex, m_sfenRecord, m_gameMoves
+            );
+    } catch (const std::exception& e) {
+        displayErrorMessage(e.what());
+        return;
+    }
+    if (!ok) return;
+
+    // ハイライト・思考時間の反映
+    if (m_boardController)
+        m_boardController->showMoveHighlights(eFrom, eTo);
+
+    const qint64 thinkMs = eng->lastBestmoveElapsedMs();
+    // この直後は人間手番＝直前に指したのは P2（エンジン）
+    if (m_shogiClock) {
+        m_shogiClock->setPlayer2ConsiderationTime(static_cast<int>(thinkMs));
+        // byoyomi/Fischer適用 & 直近考慮秒の確定
+        m_shogiClock->applyByoyomiAndResetConsideration2();
+    }
+
+    // UI更新と履歴
+    updateTurnAndTimekeepingDisplay();
+    m_positionStrList.append(m_positionStr1);
+    redrawEngine1EvaluationGraph();
+    pumpUi();
+
+    // 次は人間手番：クリック受付と人間用タイマー
+    const bool gameOver = (m_match && m_match->gameOverState().isOver);
+    if (!gameOver) {
+        if (m_shogiView) m_shogiView->setMouseClickMode(true);
+        QTimer::singleShot(0, this, [this]{
+            if (m_match) m_match->armHumanTimerIfNeeded();
+        });
+    }
+}
 // mainwindow.cpp のどこでもOK（他のメンバ実装と同じスコープ）
 void MainWindow::updateTurnDisplay()
 {
--- a/src/core/matchcoordinator.cpp
+++ b/src/core/matchcoordinator.cpp
@@ -67,7 +67,7 @@
     }
 
     // 司令塔の手番も同期（既存のままでもOKですが念のため）
-    m_cur = P1;
+    m_cur = (m_gc && m_gc->currentPlayer() == ShogiGameController::Player2) ? P2 : P1;
     updateTurnDisplay_(m_cur);
 
     if (m_hooks.log) m_hooks.log(QStringLiteral("MatchCoordinator: startNewGame done"));
