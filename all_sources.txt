#ifndef ABOUTCOORDINATOR_H
#define ABOUTCOORDINATOR_H

class QWidget;

namespace AboutCoordinator {

// 「バージョン情報」ダイアログを表示します。
void showVersionDialog(QWidget* parent);

// プロジェクトWebサイトを既定ブラウザで開きます。
void openProjectWebsite();

} // namespace AboutCoordinator

#endif // ABOUTCOORDINATOR_H
#ifndef ABSTRACTLISTMODEL_H
#define ABSTRACTLISTMODEL_H

#include <QAbstractTableModel>

// Tは具体的なリスト項目の型を指すテンプレートパラメータ
template<typename T>
class AbstractListModel : public QAbstractTableModel
{
public:
    // コンストラクタ
    explicit AbstractListModel(QObject *parent = nullptr)
        // 基底クラスのコンストラクタにparentを渡す。
        : QAbstractTableModel(parent)
    {
    }

    // デストラクタ
    ~AbstractListModel()
    {
        // リストの全項目を削除する（QtのqDeleteAll関数を使用する）。
        qDeleteAll(list);
    }

    // 行数を返すメソッド。基底クラスの純粋仮想関数をオーバーライドする。
    int rowCount(const QModelIndex &parent = QModelIndex()) const override
    {
        // QModelIndex引数はこのメソッド内では使用しない。
        Q_UNUSED(parent)

        // リストの項目数を返す。
        return list.count();
    }

    // リストに項目を追加する。
    void appendItem(T *item)
    {
        // リストに項目を追加する前にモデルの状態を変更することを通知する。
        beginInsertRows(QModelIndex(), list.count(), list.count());

        // リストに項目を追加する。
        list.append(item);

        // モデルの状態の変更を完了することを通知する。
        endInsertRows();
    }

    void prependItem(T *item)
    {
        // リストに項目を追加する前にモデルの状態を変更することを通知する。
        // インデックスを0に変更する。
        beginInsertRows(QModelIndex(), 0, 0);

        // リストの先頭に項目を追加する。
        list.prepend(item);

        // モデルの状態の変更を完了することを通知する。
        endInsertRows();
    }

    // リストから特定の項目を削除する。
    void removeItem(T *item)
    {
        // 削除する項目のインデックスを取得する。
        const int idx = list.indexOf(item);

         // 項目が存在する場合
        if (idx != -1) {
            // リストから項目を削除する前にモデルの状態を変更することを通知する。
            beginRemoveRows(QModelIndex(), idx, idx);

            // リストから項目を削除する。
            list.removeAll(item);

            // モデルの状態の変更を完了することを通知する。
            endRemoveRows();
        }
    }

    // リストから最後の項目を削除する。
    void removeLastItem()
    {
        // リストが空でない場合
        if (!list.isEmpty()) {
            // 最後の項目のインデックスを取得します
            const int lastIdx = list.count() - 1;

            // リストから項目を削除する前にモデルの状態を変更することを通知する。
            beginRemoveRows(QModelIndex(), lastIdx, lastIdx);

            // リストから最後の項目を削除する。
            list.removeLast();

            // モデルの状態の変更を完了することを通知する。
            endRemoveRows();
        }
    }

    // リストから全ての項目を削除する。
    void clearAllItems()
    {
        // モデル全体のリセットを開始することを通知する。
        beginResetModel();

        // リスト内の全てのポインタを削除し、その後リストをクリアする。
        qDeleteAll(list);

        // リストから全ての項目を削除する。
        list.clear();

        // モデル全体のリセットを完了することを通知する。
        endResetModel();
    }

protected:
    // テンプレート型Tのポインタを項目とするリスト
    QList<T*> list;
};

#endif // ABSTRACTLISTMODEL_H
#ifndef ANALYSISCOORDINATOR_H
#define ANALYSISCOORDINATOR_H

#include <QObject>
#include <QPointer>
#include <QStringList>
#include <QVector>

class EngineAnalysisTab; // 任意。ツリーハイライト等に使うなら setter で渡す

// ゲーム（または任意の範囲）の位置ごとに USIエンジンで解析を回し、結果を signal で通知する司令塔。
// - エンジンへの具体的な送信は行わず、"requestSendUsiCommand" を emit するだけ（疎結合）
// - エンジン側の出力は onEngineInfoLine/onEngineBestmoveReceived で受け取る（slot）
// - 盤面位置は sfenRecord（各手数に対応した "position sfen ... moves ..." の配列）を参照
class AnalysisCoordinator : public QObject
{
    Q_OBJECT
public:
    struct Deps {
        // 各 ply に対応した "position ..." コマンド列（KifuLoadCoordinator 等で構築済み想定）
        // 例：sfenRecord[ply] が「その手数の局面を再現する position コマンド」
        QStringList* sfenRecord = nullptr;
    };

    struct Options {
        int  startPly   = 0;     // 解析開始 ply（0以上）
        int  endPly     = -1;    // 解析終了 ply（-1 は sfenRecord の末尾まで）
        int  movetimeMs = 1000;  // 1局面あたりの思考時間（ms）
        int  multiPV    = 1;     // MultiPV（setoption で設定）
        bool centerTree = true;  // 解析進捗時にツリーをセンタリングするか
    };

    enum Mode {
        Idle,
        SinglePosition,  // 1局面のみ
        RangePositions   // 指定範囲を順次
    };
    Q_ENUM(Mode)

    explicit AnalysisCoordinator(const Deps& d, QObject* parent = nullptr);

    void setDeps(const Deps& d);
    void setAnalysisTab(EngineAnalysisTab* tab); // 任意（ツリーハイライト用）
    void setOptions(const Options& opt);

    // --- 操作 API ---
    void startAnalyzeRange();          // Options の startPly..endPly を順次解析
    void startAnalyzeSingle(int ply);  // 指定 ply を 1回解析
    void stop();                       // 現在の解析を中断

signals:
    // Coordinator → エンジン送信器（UsiEngine等）へ：USIテキストを送ってください
    void requestSendUsiCommand(const QString& line);

    // 解析ライフサイクル
    void analysisStarted(int startPly, int endPly, AnalysisCoordinator::Mode mode);
    void analysisFinished(AnalysisCoordinator::Mode mode);

    // 進捗（info 行をパースしたサマリ。score は cp or mate のどちらかが有効）
    void analysisProgress(int ply,
                          int depth,
                          int seldepth,
                          int scoreCp,     // 未設定時は INT_MIN
                          int mate,        // 未設定時は 0（詰みなし）/ 正負で手数
                          const QString& pv,
                          const QString& rawInfoLine);

    // 位置コマンドを発行した（デバッグ/ログ用）
    void positionPrepared(int ply, const QString& positionCmd);

public slots:
    // エンジン側の標準出力（"info ..."）を接続してください
    void onEngineInfoLine(const QString& line);
    // エンジン側の "bestmove ..." を接続してください
    void onEngineBestmoveReceived(const QString& line);

private:
    struct ParsedInfo {
        int depth    = -1;
        int seldepth = -1;
        int scoreCp  = std::numeric_limits<int>::min(); // INT_MIN=未設定
        int mate     = 0; // 0=未設定/詰み無し、正負で手数（先手勝ち:+ / 後手勝ち:- とする慣例）
        QString pv;
    };

    Deps    m_deps;
    Options m_opt;

    Mode m_mode = Idle;
    bool m_running = false;
    int  m_currentPly = -1;

    QPointer<EngineAnalysisTab> m_analysisTab; // 任意

    // 内部
    void startRange_();
    void startSingle_(int ply);
    void nextPlyOrFinish_();
    void sendAnalyzeForPly_(int ply);
    static bool parseInfoUSI_(const QString& line, ParsedInfo* out);

    // USI 便利
    void send_(const QString& line); // requestSendUsiCommand をまとめる
};

#endif // ANALYSISCOORDINATOR_H
#ifndef ANALYSISFLOWCONTROLLER_H
#define ANALYSISFLOWCONTROLLER_H

#include <QObject>
#include <QPointer>
#include <functional>

class KifuAnalysisDialog;
class EngineAnalysisTab;
class KifuAnalysisListModel;
class AnalysisCoordinator;
class AnalysisResultsPresenter;
class Usi;
class UsiCommLogModel;
class KifuDisplay;
class QWidget;

class AnalysisFlowController : public QObject
{
    Q_OBJECT
public:
    struct Deps {
        QStringList*                 sfenRecord = nullptr;   // required
        QList<KifuDisplay *>*        moveRecords = nullptr;  // optional
        KifuAnalysisListModel*       analysisModel = nullptr;// required
        EngineAnalysisTab*           analysisTab = nullptr;  // optional
        Usi*                         usi = nullptr;          // required
        UsiCommLogModel*             logModel = nullptr;     // optional（info/bestmove 橋渡し）
        int                          activePly = 0;
        std::function<void(const QString&)> displayError;    // required
    };

    explicit AnalysisFlowController(QObject* parent = nullptr);
    void start(const Deps& d, KifuAnalysisDialog* dlg);

    // ダイアログの生成・exec も含めて丸ごと実行する入口
    void runWithDialog(const Deps& d, QWidget* parent);

private slots:
    void onUsiCommLogChanged_();
    void onAnalysisProgress_(int ply, int depth, int seldepth,
                             int scoreCp, int mate,
                             const QString& pv, const QString& raw);

private:
    QPointer<AnalysisCoordinator>      m_coord;
    QPointer<AnalysisResultsPresenter> m_presenter;

    // cached deps
    QStringList*           m_sfenRecord = nullptr;
    QList<KifuDisplay *>*  m_moveRecords = nullptr;
    KifuAnalysisListModel* m_analysisModel = nullptr;
    EngineAnalysisTab*     m_analysisTab = nullptr;
    Usi*                   m_usi = nullptr;
    UsiCommLogModel*       m_logModel = nullptr;
    int                    m_activePly = 0;
    int                    m_prevEvalCp = 0;  // 前回評価値（差分算出用）
    std::function<void(const QString&)> m_err;

    void applyDialogOptions_(KifuAnalysisDialog* dlg);
};

#endif // ANALYSISFLOWCONTROLLER_H
#ifndef ANALYSISRESULTSPRESENTER_H
#define ANALYSISRESULTSPRESENTER_H

#include <QObject>
#include <QPointer>

class QDialog;
class QTableView;
class QHeaderView;
class QAbstractItemModel;
class QTimer;
class KifuAnalysisListModel;

class AnalysisResultsPresenter : public QObject
{
    Q_OBJECT
public:
    explicit AnalysisResultsPresenter(QObject* parent=nullptr);

    // モデルを受け取り、非モーダルで表示（UIは都度作り直し）
    void showWithModel(KifuAnalysisListModel* model);

    QTableView* view() const { return m_view; }
    QDialog* dialog() const { return m_dlg; }

private slots:
    void reflowNow();
    void onModelReset();
    void onRowsInserted(const QModelIndex&, int, int);
    void onDataChanged(const QModelIndex&, const QModelIndex&, const QList<int>&);
    void onLayoutChanged();
    void onScrollRangeChanged(int, int);

private:
    void buildUi(KifuAnalysisListModel* model);
    void connectModelSignals(KifuAnalysisListModel* model);

    QPointer<QDialog> m_dlg;
    QPointer<QTableView> m_view;
    QPointer<QHeaderView> m_header;
    QTimer* m_reflowTimer;
};

#endif // ANALYSISRESULTSPRESENTER_H
#ifndef ANALYSISTABWIRING_H
#define ANALYSISTABWIRING_H

#include <QObject>

class QWidget;
class QTabWidget;
class EngineAnalysisTab;
class ShogiEngineThinkingModel;
class UsiCommLogModel;

// EngineAnalysisTab 周辺の生成と配線だけを担当する小さなワイヤリングクラス
class AnalysisTabWiring : public QObject
{
    Q_OBJECT
public:
    struct Deps {
        QWidget*        centralParent = nullptr;  // EngineAnalysisTab の親にする QWidget（通常は MainWindow の central）
        UsiCommLogModel* log1 = nullptr;          // USIログ(先手)
        UsiCommLogModel* log2 = nullptr;          // USIログ(後手)
    };

    explicit AnalysisTabWiring(const Deps& d, QObject* parent = nullptr);

    // 一度だけ UI を構築し、モデルを配線する（再入しても多重生成しない）
    EngineAnalysisTab* buildUiAndWire();

    // アクセサ（MainWindow 側へ返す）
    EngineAnalysisTab*           analysisTab() const { return m_analysisTab; }
    QTabWidget*                  tab()         const { return m_tab; }
    ShogiEngineThinkingModel*    thinking1()   const { return m_think1; }
    ShogiEngineThinkingModel*    thinking2()   const { return m_think2; }

signals:
    // 必要なら MainWindow はこの signal を受けて自身のスロットに繋げられます
    void branchNodeActivated(int row, int ply);

private:
    Deps                         m_d;
    EngineAnalysisTab*           m_analysisTab = nullptr;
    QTabWidget*                  m_tab         = nullptr;
    ShogiEngineThinkingModel*    m_think1      = nullptr;
    ShogiEngineThinkingModel*    m_think2      = nullptr;
};

#endif // ANALYSISTABWIRING_H
#ifndef APPTOOLTIPFILTER_H
#define APPTOOLTIPFILTER_H
#pragma once

#include <QObject>

class QWidget;
class QMenuBar;
class QToolBar;
class QMenu;
class QEvent;
class QPoint;
class QString;
class GlobalToolTip;

/*
 * AppToolTipFilter
 * アプリ全体のツールチップ表示を「標準の QToolTip」から自前の GlobalToolTip に置き換えるイベントフィルタ。
 * 役割：対象ウィジェット（メニューバー／ツールバー／ツールボタン／メニュー等）に install し、
 *       ToolTip イベントの発生・消滅に合わせて GlobalToolTip を表示／非表示にする。
 * 備考：シグナルは持たないため Q_OBJECT は不要。必要になったら将来的に追加可。
 */
class AppToolTipFilter : public QObject {
public:
    // コンストラクタ
    // 役割：イベントフィルタを初期化し、内部で使用する GlobalToolTip を生成。
    explicit AppToolTipFilter(QWidget* parent = nullptr);

    // ツールチップの文字サイズ（pt）を調整
    // 役割：内部の GlobalToolTip に委譲してフォントサイズを変更。
    void setPointSizeF(qreal pt);

    // ルート（通常は MainWindow）以下に一括で装着
    // 役割：root 自身と、既に存在する子（QMenuBar/QToolBar/QMenu/QToolButton）へ eventFilter を install。
    // 注意：動的に追加される子には自動では適用されないため、必要に応じて都度 installOn* を呼ぶ。
    void installOn(QWidget* root);

    // 個別に装着したい場合（ユーティリティ）
    // 役割：特定のウィジェットに対し、このフィルタをインストールする。
    void installOnMenuBar(QMenuBar* mb);
    void installOnToolBar(QToolBar* tb);
    void installOnMenu(QMenu* menu);

    // コンパクト表示切り替え（既定：true）
    // 役割：GlobalToolTip 側のフォント／余白／角丸を小さめに一括調整。
    void setCompact(bool on = true);

protected:
    // イベントフィルタ本体
    // 役割：QEvent::ToolTip を横取りして GlobalToolTip を表示。
    //       Leave/Hide/Close/FocusOut/WindowDeactivate/MouseButtonPress では非表示にする。
    // 注意：ツールチップを表示した場合は true を返し、標準の QToolTip を抑止。
    bool eventFilter(QObject* obj, QEvent* ev) override;

private:
    // 内部の GlobalToolTip インスタンス（所有：this の parent ツリーにぶら下げる）
    GlobalToolTip* m_tip = nullptr;

    // 表示するテキストを選ぶヘルパ
    // 役割：QMenuBar の場合は actionAt() を用いてアイテムごとに判定。
    //       アイコン無しアクションはツールチップを出さない（空文字を返す）。
    //       それ以外は QWidget::toolTip() を採用（trim 済み）。
    QString pickTextForWidget(QWidget* w, const QPoint& localPos) const;
};

#endif // APPTOOLTIPFILTER_H
#ifndef BOARDIMAGEEXPORTER_H
#define BOARDIMAGEEXPORTER_H

#include <QObject>
class QWidget;
class QImage;

class BoardImageExporter final {
public:
    static void copyToClipboard(QWidget* boardWidget);
    static void saveImage(QWidget* parent, QWidget* boardWidget);
};

#endif // BOARDIMAGEEXPORTER_H
#ifndef BOARDINTERACTIONCONTROLLER_H
#define BOARDINTERACTIONCONTROLLER_H

#include <QObject>
#include <QPoint>
#include <QColor>          // ← QColor をヘッダで使うので追加
#include "shogiview.h"     // ← ShogiView::FieldHighlight を使うために必須

class ShogiGameController;

class BoardInteractionController : public QObject
{
    Q_OBJECT
public:
    enum class Mode { HumanVsHuman, HumanVsEngine, Edit };

    explicit BoardInteractionController(ShogiView* view,
                                        ShogiGameController* gc,
                                        QObject* parent = nullptr);

    void setMode(Mode m) { m_mode = m; }
    Mode mode() const { return m_mode; }

    // 選択中（オレンジ）のみを消し、直前手の赤/黄は残す
    void clearSelectionHighlight();

    // 局面移動等でハイライトだけ反映したい時
    void showMoveHighlights(const QPoint& from, const QPoint& to);
    void clearAllHighlights();

public slots:
    void onLeftClick(const QPoint& pt);
    void onRightClick(const QPoint& pt);

    // 呼び元で着手が適用された結果を通知
    void onMoveApplied(const QPoint& from, const QPoint& to, bool success);

signals:
    void moveRequested(const QPoint& from, const QPoint& to);
    void selectionChanged(const QPoint& pos);

private:
    // ハイライト系ヘルパ（Main から移植）
    void selectPieceAndHighlight(const QPoint& field);
    void updateHighlight(ShogiView::FieldHighlight*& hl, const QPoint& field, const QColor& color);
    void deleteHighlight(ShogiView::FieldHighlight*& hl);
    void addNewHighlight(ShogiView::FieldHighlight*& hl, const QPoint& pos, const QColor& color);
    void resetSelectionAndHighlight();
    void finalizeDrag();
    void togglePiecePromotionOnClick(const QPoint& field);

    static constexpr int kBlackStandFile = 10;
    static constexpr int kWhiteStandFile = 11;

private:
    ShogiView* m_view = nullptr;
    ShogiGameController* m_gc = nullptr;

    Mode m_mode = Mode::HumanVsHuman;

    // クリック状態
    QPoint m_clickPoint;
    bool   m_waitingSecondClick = false;
    QPoint m_firstClick;

    // ハイライト
    ShogiView::FieldHighlight* m_selectedField  = nullptr; // 選択中（オレンジ）
    ShogiView::FieldHighlight* m_selectedField2 = nullptr; // 直前の移動元（赤）
    ShogiView::FieldHighlight* m_movedField     = nullptr; // 移動先（黄）
};

#endif // BOARDINTERACTIONCONTROLLER_H
#ifndef BOARDSYNCPRESENTER_H
#define BOARDSYNCPRESENTER_H

#include <QObject>
#include <QStringList>
#include <QVector>
#include <QPoint>

class ShogiGameController;
class ShogiView;
class BoardInteractionController;
class ShogiMove;

class BoardSyncPresenter : public QObject
{
    Q_OBJECT
public:
    struct Deps {
        ShogiGameController* gc = nullptr;
        ShogiView* view = nullptr;
        BoardInteractionController* bic = nullptr;
        const QStringList* sfenRecord = nullptr;        // 参照（外部所有）
        const QVector<ShogiMove>* gameMoves = nullptr;  // 参照（外部所有）
    };

    explicit BoardSyncPresenter(const Deps& deps, QObject* parent=nullptr);

    // SFEN を適用して盤を描画
    void applySfenAtPly(int ply) const;

    // 盤描画＋最終手のハイライトまで一括適用（ply=0 はハイライト無し）
    void syncBoardAndHighlightsAtRow(int ply) const;

    // ユーティリティ：ハイライトの明示クリア
    void clearHighlights() const;

private:
    static inline QPoint toOne(const QPoint& z) { return QPoint(z.x() + 1, z.y() + 1); }

    ShogiGameController* m_gc;
    ShogiView* m_view;
    BoardInteractionController* m_bic;
    const QStringList* m_sfenRecord;
    const QVector<ShogiMove>* m_gameMoves;
};

#endif // BOARDSYNCPRESENTER_H
#ifndef BRANCHCANDIDATESCANDIDATESCONTROLLER_H
#define BRANCHCANDIDATESCANDIDATESCONTROLLER_H

#include <QObject>
#include <QVector>
#include <QSet>
#include <QString>
#include "kifdisplayitem.h"
#include "branchdisplayplan.h"   // ★ 共通型（BranchCandidateDisplayItem など）
#include "kifuvariationengine.h"

class KifuBranchListModel;
class RecordPane;

class BranchCandidatesController : public QObject
{
    Q_OBJECT
public:
    explicit BranchCandidatesController(KifuVariationEngine* ve,
                                        KifuBranchListModel* model,
                                        QObject* parent = nullptr);

    // クリック（候補の行）→ Plan メタに従って行/手へジャンプ
    Q_INVOKABLE void activateCandidate(int rowIndex);

    // ★Plan 方式：MainWindow 側で作った Plan をそのまま流し込む
    void refreshCandidatesFromPlan(int ply1,
                                   const QVector<BranchCandidateDisplayItem>& items,
                                   const QString& baseLabel);

    // （互換）旧ロジックの名残り。Plan専用化により実質ノーオペにしておく。
    void refreshCandidatesForPly(int /*ply*/,
                                 bool /*includeMainline*/,
                                 const QString& /*prevSfen*/,
                                 const QSet<int>& /*restrictVarIds*/);

    // RecordPane のシグナルを自身に配線（MainWindow から配線コードを追い出す）
    void attachRecordPane(RecordPane* pane);

public slots:
    // RecordPane 側の「分岐セルが選ばれた」→ 自身の activateCandidate() へ
    void onRecordPaneBranchActivated(const QModelIndex& index);

signals:
    // 旧来イベント（必要なら残す）
    void applyLineRequested(const QList<KifDisplayItem>& disp,
                            const QStringList& usiStrs);
    void backToMainRequested();

    // ★Plan専用：候補クリック時に MainWindow 側で行/手へジャンプ
    void planActivated(int row, int ply1);

private:
    struct PlanMeta {
        int     targetRow  = -1;
        int     targetPly  =  0;   // 1-based
        QString label;
        QString lineName;          // "Main" or "VarN"
    };

    void applyHighlight_(); // 内部一元処理

    KifuVariationEngine*         m_ve    = nullptr;  // 参照だけ残す（現状Planでは未使用）
    KifuBranchListModel*         m_model = nullptr;
    bool                         m_planMode = true; // 常にPlanモード
    QVector<PlanMeta>            m_planMetas;       // 表示に対応するクリック時メタ

    // ★ハイライトの現在値（vid/ply）。invokeMethod 経由で更新される
    int m_activeVid = -1;
    int m_activePly = -1;
};

#endif // BRANCHCANDIDATESCANDIDATESCONTROLLER_H
#ifndef BRANCHDISPLAYPLAN_H
#define BRANCHDISPLAYPLAN_H

#include <QString>
#include <QVector>
#include <QHash>

// 分岐候補の 1 アイテム（分岐候補欄の 1 行に相当）
struct BranchCandidateDisplayItem {
    int row   = -1;          // 切替先の行（Main=0, Var0=1, Var1=2, ...）
    int varN  = -1;          // -1=Main, 0..=VarN （表示の都合で保持）
    QString lineName;        // "Main" or "VarN"
    QString label;           // 指し手ラベル（例: "▲２六歩(27)"）
};

// ある行(r)の、ある手数(ply1)に表示する計画（「分岐候補表示あり」の中身）
struct BranchCandidateDisplay {
    int ply = 0;             // 1-based 手数
    QString baseLabel;       // その行(r)の ply 手目のラベル（基準表示）
    QVector<BranchCandidateDisplayItem> items;  // 表示候補たち
};

// 行 r → ( 手 ply1 → 計画 ) の二段 map
using BranchDisplayPlanByPly  = QHash<int, BranchCandidateDisplay>;
using BranchDisplayPlanTable  = QHash<int, BranchDisplayPlanByPly>;

#endif // BRANCHDISPLAYPLAN_H
#ifndef BRANCHWIRINGCOORDINATOR_H
#define BRANCHWIRINGCOORDINATOR_H

#include <QObject>
#include <QModelIndex>

class RecordPane;
class KifuBranchListModel;
class KifuVariationEngine;
class BranchCandidatesController;
class KifuLoadCoordinator;

class BranchWiringCoordinator : public QObject
{
    Q_OBJECT
public:
    struct Deps {
        RecordPane*              recordPane = nullptr;
        KifuBranchListModel*     branchModel = nullptr;    // nullなら内部で生成
        KifuVariationEngine*     variationEngine = nullptr;
        KifuLoadCoordinator*     kifuLoader = nullptr;     // applyResolvedRowAndSelect の委譲先
        QObject*                 parent = nullptr;
    };

    explicit BranchWiringCoordinator(const Deps& d);

    // MainWindow::setupBranchView_ 相当
    void setupBranchView();

    // MainWindow::setupBranchCandidatesWiring_ 相当
    void setupBranchCandidatesWiring();

    // ★ 追加：後から Loader を差し替えるための軽量 setter
    void setKifuLoader(KifuLoadCoordinator* loader);

public slots:
    // MainWindow::onRecordPaneBranchActivated_ 相当
    void onRecordPaneBranchActivated(const QModelIndex& index);

    // MainWindow::onBranchPlanActivated_ 相当
    void onBranchPlanActivated(int row, int ply1);

    // MainWindow::onBranchNodeActivated_ 相当
    void onBranchNodeActivated(int row, int ply);

private:
    void applyResolvedRowAndSelect_(int row, int selPly);

private:
    RecordPane*                  m_recordPane = nullptr;
    KifuBranchListModel*         m_branchModel = nullptr;
    KifuVariationEngine*         m_varEngine = nullptr;
    KifuLoadCoordinator*         m_loader = nullptr;

    BranchCandidatesController*  m_branchCtl = nullptr;
};

#endif // BRANCHWIRINGCOORDINATOR_H
#ifndef CHANGEENGINESETTINGSDIALOG_H
#define CHANGEENGINESETTINGSDIALOG_H

#include <QDialog>
#include <QVBoxLayout>
#include <QLabel>
#include <QLineEdit>
#include <QComboBox>
#include <QCheckBox>
#include <QSettings>
#include <QDir>
#include "longlongspinbox.h"
#include "engineoptions.h"

namespace EngineSettings {
// ファイルまたはディレクトリ選択のためのEnum型の定義
enum class FileType {
    File = 0,
    Directory = 1
};
}

namespace Ui {
class ChangeEngineSettingsDialog;
}

// 将棋エンジン設定を変更するダイアログ
class ChangeEngineSettingsDialog : public QDialog
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit ChangeEngineSettingsDialog(QWidget *parent = nullptr);

    // デストラクタ
    ~ChangeEngineSettingsDialog();

    // 将棋エンジン番号のsetter
    void setEngineNumber(const int &engineNumber);

    // 将棋エンジン名のsetter
    void setEngineName(const QString &engineName);

    // "エンジン設定"ダイアログを作成する。
    void setupEngineOptionsDialog();

private:
    // UIコンポーネントのポインタを保持するためのポインタ変数
    Ui::ChangeEngineSettingsDialog* ui;

    // エンジン番号
    int m_engineNumber;

    // エンジン名
    QString m_engineName;

    // エンジンオプションのリスト
    QList<EngineOption> m_optionList;

    // エンジンオプションウィジェットのレイアウト
    QVBoxLayout* optionWidgetsLayout;

    // オプションUIのためのウィジェットを格納する構造体
    // 各メンバー変数は、デフォルトではnullptrに設定しておく。
    struct OptionWidgets
    {
        // テキスト入力用のLineEdit
        QLineEdit* lineEdit = nullptr;

        // オプション名を表示するためのLabel
        QLabel* optionNameLabel = nullptr;

        // オプションの説明や制約を表示するラベル
        QLabel* optionDescriptionLabel = nullptr;

        // 数値入力用のスピンボックス
        LongLongSpinBox* integerSpinBox = nullptr;

        // オン/オフを切り替えるためのチェックボックス
        QCheckBox* optionCheckBox = nullptr;

        // ファイルやディレクトリの選択ダイアログを開くボタン
        QPushButton* selectionButton = nullptr;

        // 複数の選択肢から選ぶためのコンボボックス。
        QComboBox* comboBox = nullptr;
    };

    // オプションUIのウィジェットを管理するためのOptionWidgets構造体のインスタンスを作成する。
    OptionWidgets m_optionWidgets;

    // エンジンオプションのためのウィジェットを格納するリスト
    QList<OptionWidgets> m_engineOptionWidgetsList;

    // 開くファイル名
    QString m_openFileName;

    // 設定ファイルから選択したエンジンのオプションを読み込む。
    void readEngineOptions();

    // エンジンオプションに基づいてUIコンポーネントを作成して配置する。
    void createOptionWidgets();

    // イベントフィルター関数。QObject型のobjとQEvent型のeを引数に取る。
    bool eventFilter(QObject *obj, QEvent *e);

    // ボタンが押された場合、ボタンの色を変える。
    void changeStatusColorTypeButton();

    // 一つのオプションを読み込む。
    EngineOption readOption(const QSettings& settings) const;

    // ファイルまたはディレクトリの選択ダイアログを開き、選択されたパスを返す。
    QString openSelectionDialog(QWidget* parent, int fileType, const QString& initialDir = QDir::homePath());

    // エンジンオプションのためのテキストボックスを作成する。
    void createTextBox(const EngineOption& option, QVBoxLayout* layout);

    // エンジンオプションのためのスピンボックスを作成する。
    void createSpinBox(const EngineOption& option, QVBoxLayout* layout);

    // エンジンオプションのためのチェックボックスを作成する。
    void createCheckBox(const EngineOption& option, QVBoxLayout* layout);

    // エンジンオプションのためのボタンを作成する。
    void createButton(const EngineOption& option, QVBoxLayout* layout);

    // エンジンオプションのためのコンボボックスを作成する。
    void createComboBox(const EngineOption& option, QVBoxLayout* layout);

    // オプションのタイプに応じたUIコンポーネントを作成し、レイアウトに追加する。
    void createWidgetForOption(const EngineOption& option);

    // 設定ファイルにエンジンのオプション設定を保存する。
    void saveOptionsToSettings();

private slots:
    // 設定画面で"フォルダ・ディレクトリの選択"ボタンあるいは"ファイルの選択"ボタンをクリックした場合にディレクトリ、ファイルを選択する画面を表示する。
    void openFile();

    // エンジンオプションを既定値に戻す。
    void restoreDefaultOptions();

    // 設定ファイルに追加エンジンのオプションを書き込む。
    void writeEngineOptions();

    // ボタンが押された場合、ボタンの色を変える。
    void changeColorTypeButton();
};

#endif // CHANGEENGINESETTINGSDIALOG_H
#ifndef CONSIDERATIONDIALOG_H
#define CONSIDERATIONDIALOG_H

#include <QDialog>

namespace Ui {
class ConsiderationDialog;
}

// 検討ダイアログを表示する。
class ConsiderationDialog : public QDialog
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit ConsiderationDialog(QWidget *parent = nullptr);

    // デストラクタ
    ~ConsiderationDialog();

    // 1手あたりの思考時間（秒数）を取得する。
     int getByoyomiSec() const;

    // エンジン番号を取得する。
    int getEngineNumber() const;

    // エンジン名を取得する。
    const QString& getEngineName() const;

    // エンジンの名前とディレクトリを格納する構造体
    struct Engine
    {
        QString name;
        QString path;
    };

    // エンジンの名前とディレクトリを格納するリストを取得する。
    const QList<ConsiderationDialog::Engine>& getEngineList() const;

    bool unlimitedTimeFlag() const;

private slots:
    // エンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
    void showEngineSettingsDialog();

    // エンジン名、エンジン番号、時間無制限フラグ、検討時間フラグ、検討時間を取得する。
    void processEngineSettings();

private:
    // UI
    Ui::ConsiderationDialog* ui;

    // 選択したエンジン名
    QString m_engineName;

    // 選択したエンジン番号
    int m_engineNumber;

    // "時間無制限"を選択した場合、true
    bool m_unlimitedTimeFlag;

    // 1手あたりの思考時間（秒数）
    int m_byoyomiSec;

    // エンジンの名前とディレクトリを格納するリスト
    QList<Engine> engineList;

    // 設定ファイルからエンジンの名前とディレクトリを読み込む。
    void readEngineNameAndDir();
};

inline bool ConsiderationDialog::unlimitedTimeFlag() const
{
    return m_unlimitedTimeFlag;
}

#endif // CONSIDERATIONDIALOG_H
#ifndef CONSIDERATIONFLOWCONTROLLER_H
#define CONSIDERATIONFLOWCONTROLLER_H

#include <QObject>
#include <functional>

class QWidget;
class ConsiderationDialog;
class MatchCoordinator;

/**
 * 単一局面の「検討」実行を司る薄いフローコントローラ。
 * MainWindow から UI と司令塔(MatchCoordinator)の橋渡しだけを引き剥がす。
 */
class ConsiderationFlowController : public QObject
{
    Q_OBJECT
public:
    struct Deps {
        MatchCoordinator* match = nullptr;               // 司令塔
        std::function<void(const QString&)> onError;     // 任意: エラー表示
    };

    explicit ConsiderationFlowController(QObject* parent=nullptr);

    /**
     * 検討ダイアログを表示して、OKなら司令塔へ startAnalysis を投げます。
     * @param positionStr 送信する "position ..." 文字列（MainWindow側で既に用意）
     */
    void runWithDialog(const Deps& d, QWidget* parent, const QString& positionStr);

private:
    void startAnalysis_(MatchCoordinator* match,
                        const QString& enginePath,
                        const QString& engineName,
                        const QString& positionStr,
                        int byoyomiMs);
};

#endif // CONSIDERATIONFLOWCONTROLLER_H
#ifndef ELIDELABEL_H
#define ELIDELABEL_H

#include <QLabel>
#include <QTimer>

/*
 * ElideLabel
 * ラベル内テキストが「幅に収まらない場合だけ」視認性を高める工夫を行う QLabel 派生。
 * 役割：
 *  - 通常はエリプシス（…）で省略表示
 *  - ホバー中は自動で横スクロール（任意）
 *  - 左ドラッグで手動パン（任意）
 *  - 下線の簡易装飾（任意）
 * 備考：スクロールは QTimer による一定ピクセル移動（m_pxPerTick / m_intervalMs）。
 */
class ElideLabel : public QLabel
{
    Q_OBJECT
public:
    // コンストラクタ
    // 役割：サイズポリシーと自動スクロール用タイマーを初期化（タイマーは未起動）。
    explicit ElideLabel(QWidget* parent = nullptr);

    // フルテキストを設定するセッター。
    // 役割：表示の元になる完全な文字列を更新し、ツールチップ／省略文字列を再計算。
    // 注意：同一文字列なら何もしない（不要な再計算・再描画を抑制）。
    void setFullText(const QString& text);

    // 現在のフルテキストを返す。
    // 役割：省略やスクロールの元データ参照用。
    QString fullText() const;

    // エリプシス位置（左/中/右）を設定。
    // 役割：Qt::TextElideMode を更新し、幅に合わせて省略文字列を再計算。
    void setElideMode(Qt::TextElideMode mode);

    // 現在のエリプシス位置を取得。
    Qt::TextElideMode elideMode() const;

    // 追加：ホバー自動スクロール / ドラッグ手動パン / 下線
    // 幅不足のときだけホバーで自動スクロールするかを切り替え。
    void setSlideOnHover(bool on);
    // 自動スクロールの速度（1ティックあたりの移動ピクセル）。役割：最低 1px に丸め。
    void setSlideSpeed(int pxPerTick);
    // 自動スクロールのティック間隔（ms）。役割：稼働中なら即座に反映。
    void setSlideInterval(int ms);
    // 下線を描くか（簡易装飾）。役割：paintEvent で 1px ラインを引く。
    void setUnderline(bool on);
    // 左ドラッグでの手動パンを許可。役割：押下/移動/解放イベントで参照。
    void setManualPanEnabled(bool on);

    // サイズヒント
    // 役割：高さはフォントに依存、幅はレイアウトに任せる（QLabel 既定を踏襲）。
    QSize sizeHint() const override;

protected:
    // 描画イベント
    // 役割：通常はエリプシス描画、スクロール中（自動 or ドラッグ）かつ溢れ時はループ描画。
    void paintEvent(QPaintEvent*) override;

    // リサイズ時は省略文字列を再計算して表示更新。
    void resizeEvent(QResizeEvent*) override;

#if QT_VERSION >= QT_VERSION_CHECK(6,0,0)
    // ホバー開始（Qt 6+）：自動スクロール開始条件を再評価。
    void enterEvent(QEnterEvent*) override;
#else
    // ホバー開始（Qt 5）：自動スクロール開始条件を再評価。
    void enterEvent(QEvent*) override;
#endif

    // ホバー終了：自動スクロール停止＆オフセットを先頭に戻す。
    void leaveEvent(QEvent*) override;

    // 手動パン：左押下でドラッグ開始（条件を満たすとき）。
    void mousePressEvent(QMouseEvent*) override;
    // 手動パン：ドラッグ中は差分でオフセット更新。
    void mouseMoveEvent(QMouseEvent*) override;
    // 手動パン：解放で終了し、必要なら自動スクロールを再開。
    void mouseReleaseEvent(QMouseEvent*) override;

private:
    // 省略文字列を最新化。
    // 役割：contentsRect().width() に基づいて elidedText を作り直し、必要ならスクロール開始判定。
    void updateElidedText();

    // 自動スクロール開始条件を評価して起動。
    // 役割：ホバー中・はみ出し・非ドラッグ・許可フラグの全条件を満たしたときのみ開始。
    void startSlideIfNeeded();

    // 自動スクロール停止（タイマー停止＆カーソル復帰）。
    void stopSlide();

    // はみ出し判定（フルテキスト幅 > 内容幅）。
    bool isOverflowing() const;

    // ───────── 内部状態 ─────────
    QString m_fullText;                    // 元テキスト
    QString m_elidedText;                  // 省略済みテキスト（表示用キャッシュ）
    Qt::TextElideMode m_mode = Qt::ElideMiddle; // 省略位置

    // スライド関連
    bool   m_slideOnHover = false;         // ホバー時の自動スクロール許可
    bool   m_manualPan    = false;         // ドラッグ手動パン許可
    bool   m_underline    = false;         // 下線装飾フラグ
    QTimer m_timer;                         // 自動スクロール用タイマー
    int    m_offset       = 0;             // 描画オフセット(px)
    int    m_gap          = 24;            // ループ時の空白（継ぎ目を隠す）
    int    m_pxPerTick    = 2;             // 自動スクロール速度(px/ティック)
    int    m_intervalMs   = 16;            // タイマー間隔(ms) ≒ 60fps
    int    m_lastDragX    = 0;             // 手動パンのドラッグ基準X
    bool   m_dragging     = false;         // ドラッグ中か
};

#endif // ELIDELABEL_H
#ifndef ENGINEANALYSISTAB_H
#define ENGINEANALYSISTAB_H

#include <QWidget>
#include <QVector>
#include <QList>
#include <QStringList>
#include <QMap>
#include <QPair>
#include <QHash>
#include <QSet>
#include <QAbstractItemModel>

class QTabWidget;
class QTableView;
class QTextBrowser;
class QPlainTextEdit;
class QGraphicsView;
class QGraphicsScene;
class QGraphicsPathItem;
class QHeaderView;

class EngineInfoWidget;
class ShogiEngineThinkingModel;
class UsiCommLogModel;

#include "kifdisplayitem.h"

class EngineAnalysisTab : public QWidget
{
    Q_OBJECT

public:
    explicit EngineAnalysisTab(QWidget* parent=nullptr);

    void buildUi();

    void setModels(ShogiEngineThinkingModel* m1, ShogiEngineThinkingModel* m2,
                   UsiCommLogModel* log1, UsiCommLogModel* log2);

    // 既存コードの m_tab をそのまま使えるように
    QTabWidget* tab() const;

    // --- 分岐ツリー：MainWindow から供給する軽量行データ ---
    struct ResolvedRowLite {
        int startPly = 1;                  // 行の開始手（本譜は常に1）
        QList<KifDisplayItem> disp;        // 表示テキスト列（「▲７六歩(77)」など）
        QStringList sfen;                  // 0..N の局面列（未使用でもOK）
    };

    // ツリーの全行データをセット（row=0:本譜、row=1..:分岐）
    void setBranchTreeRows(const QVector<ResolvedRowLite>& rows);

    // ツリー上で (row, ply) をハイライト（必要なら centerOn）
    void highlightBranchTreeAt(int row, int ply, bool centerOn=false);

    // --- 互換API（MainWindowの既存呼び出しを満たす） ---
    // 2番目エンジンのビュー（情報＆思考表）の表示/非表示
    void setSecondEngineVisible(bool on);
    // 旧名エイリアス（上と同義）
    void setDualEngineVisible(bool on) { setSecondEngineVisible(on); }

    // 1/2の思考モデルを別々に差し替え
    void setEngine1ThinkingModel(ShogiEngineThinkingModel* m);
    void setEngine2ThinkingModel(ShogiEngineThinkingModel* m);

    // 旧API（プレーンテキストでコメントを設定）
    void setCommentText(const QString& text);

    // 分岐ツリー用の種類とロール
    enum BranchNodeKind { BNK_Start = 1, BNK_Main = 2, BNK_Var = 3 };
    static constexpr int BR_ROLE_KIND     = 0x200;
    static constexpr int BR_ROLE_PLY      = 0x201; // 本譜ノードの ply
    static constexpr int BR_ROLE_STARTPLY = 0x202; // 分岐の開始手
    static constexpr int BR_ROLE_BUCKET   = 0x203; // 同一開始手内での分岐Index

    // item->data 用ロールキー
    static constexpr int ROLE_ROW = 0x501;
    static constexpr int ROLE_PLY = 0x502;
    static constexpr int ROLE_ORIGINAL_BRUSH = 0x503;
    static constexpr int ROLE_NODE_ID = 0x504;     // ★ 追加：グラフノードID

    // ===== 追加：分岐ツリー・グラフAPI（初期構築時に使用） =====
    // 再構築の先頭で呼ぶ（内部グラフをクリア）
    void clearBranchGraph();

    // 矩形を生成した直後に呼ぶ：ノード登録して nodeId を返す
    // ※戻り値は各矩形に setData(ROLE_NODE_ID, id) して保持してください
    int registerNode(int vid, int row, int ply, QGraphicsPathItem* item);

    // 罫線を引く直前に、接続する2つのノード id で呼ぶ
    void linkEdge(int prevId, int nextId);

    // アクセサ： (row,ply) → nodeId（無ければ -1）
    int nodeIdFor(int row, int ply) const {
        return m_nodeIdByRowPly.value(qMakePair(row, ply), -1);
    }

    // ★ 追加（HvE/EvE の配線で使う）
    EngineInfoWidget* info1() const { return m_info1; }
    EngineInfoWidget* info2() const { return m_info2; }
    QTableView*       view1() const { return m_view1; }
    QTableView*       view2() const { return m_view2; }

public slots:
    void setAnalysisVisible(bool on);
    void setCommentHtml(const QString& html);

signals:
    // ツリー上のノード（行row, 手ply）がクリックされた
    void branchNodeActivated(int row, int ply);

    // MainWindow に「何を適用したいか」を伝える
    void requestApplyStart();                         // 開始局面へ
    void requestApplyMainAtPly(int ply);             // 本譜の ply 手へ

private:
    // --- 内部：ツリー描画 ---
    void rebuildBranchTree();
    QGraphicsPathItem* addNode(int row, int ply, const QString& text);
    void addEdge(QGraphicsPathItem* from, QGraphicsPathItem* to);

    // ---- 追加：フォールバック探索とハイライト実体（実装は .cpp） ----
    int  graphFallbackToPly_(int row, int targetPly) const;
    void highlightNodeId_(int nodeId, bool centerOn);

    // --- UI ---
    QTabWidget* m_tab=nullptr;
    EngineInfoWidget *m_info1=nullptr, *m_info2=nullptr;
    QTableView *m_view1=nullptr, *m_view2=nullptr;
    QPlainTextEdit* m_usiLog=nullptr;
    QTextBrowser* m_comment=nullptr;
    QGraphicsView* m_branchTree=nullptr;
    QGraphicsScene* m_scene=nullptr;

    // --- モデル参照（所有しない） ---
    ShogiEngineThinkingModel* m_model1=nullptr;
    ShogiEngineThinkingModel* m_model2=nullptr;
    UsiCommLogModel* m_log1=nullptr;
    UsiCommLogModel* m_log2=nullptr;

    // --- 分岐データ ---
    QVector<ResolvedRowLite> m_rows;   // 行0=本譜、行1..=ファイル登場順の分岐

    // クリック判定用： (row,ply) -> node item（既存）
    QMap<QPair<int,int>, QGraphicsPathItem*> m_nodeIndex;

    // ==== 追加：罫線フォールバック用のグラフ ====
    struct BranchGraphNode {
        int id   = -1;
        int vid  = -1;   // 0=Main / 1..=VarN
        int row  = -1;   // ResolvedRow の行インデックス
        int ply  =  0;   // グローバル手数（1-based。初期局面は 0）
        QGraphicsPathItem* item = nullptr;
    };

    // (row,ply) -> nodeId
    QHash<QPair<int,int>, int> m_nodeIdByRowPly;
    // nodeId -> ノード
    QHash<int, BranchGraphNode> m_nodesById;
    // nodeId の前後リンク集合
    QHash<int, QVector<int>> m_prevIds;
    QHash<int, QVector<int>> m_nextIds;
    // 行ごとの入口ノード（分岐開始ノード等）
    QHash<int, int> m_rowEntryNode;
    // 連番発行
    int m_nextNodeId = 1;
    // 直前に黄色にした item
    QGraphicsPathItem* m_prevSelected = nullptr;

    // ツリークリック検出
    bool eventFilter(QObject* obj, QEvent* ev) override;

    int resolveParentRowForVariation_(int row) const;

    // すでに Q_OBJECT が付いている前提
private slots:
    void onModel1Reset_();
    void onModel2Reset_();
    void onLog1Changed_();
    void onLog2Changed_();

private:
    void reapplyViewTuning_(QTableView* v, QAbstractItemModel* m);

    // 既に導入済みのヘルパ（前回案）
private:
    void tuneColumnsForThinkingView_(QTableView* v);
    void applyNumericFormattingTo_(QTableView* view, QAbstractItemModel* model);
    static int findColumnByHeader_(QAbstractItemModel* model, const QString& title);
};

#endif // ENGINEANALYSISTAB_H
#ifndef ENGINEINFOWIDGET_H
#define ENGINEINFOWIDGET_H

#include <QWidget>
class QLineEdit; class QLabel;
class UsiCommLogModel;

class EngineInfoWidget : public QWidget {
    Q_OBJECT
public:
    explicit EngineInfoWidget(QWidget* parent=nullptr);
    void setModel(UsiCommLogModel* model);
    void setDisplayNameFallback(const QString& name);

private slots:
    void onNameChanged();
    void onPredChanged();
    void onSearchedChanged();
    void onDepthChanged();
    void onNodesChanged();
    void onNpsChanged();
    void onHashChanged();

private:
    UsiCommLogModel* m_model=nullptr;
    QLineEdit *m_engineName=nullptr, *m_pred=nullptr, *m_searched=nullptr;
    QLineEdit *m_depth=nullptr, *m_nodes=nullptr, *m_nps=nullptr, *m_hash=nullptr;
    QString m_fallbackName;
};

#endif // ENGINEINFOWIDGET_H
#ifndef ENGINEOPTIONS_H
#define ENGINEOPTIONS_H

#include <QString>
#include <QStringList>

// エンジンオプションの構造体
struct EngineOption
{
    QString name;           // オプション名
    QString type;           // オプションの型
    QString defaultValue;   // オプションのデフォルト値
    QString min;            // オプションの最小値
    QString max;            // オプションの最大値
    QString currentValue;   // オプションの現在の値
    QStringList valueList;  // combo型の場合の値のリスト
};

#endif // ENGINEOPTIONS_H
﻿#ifndef ENGINEREGISTRATIONDIALOG_H
#define ENGINEREGISTRATIONDIALOG_H

#include <QDialog>
#include <QProcess>
#include <QSettings>
#include "engineoptions.h"

namespace Ui {
class EngineRegistrationDialog;
}

// エンジンの構造体
struct Engine
{
    // エンジン名
    QString name;

    // エンジンの実行ファイル名
    QString path;
};

// エンジン登録ダイアログ
class EngineRegistrationDialog : public QDialog
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit EngineRegistrationDialog(QWidget *parent = nullptr);

    // デストラクタ
    ~EngineRegistrationDialog();

private slots:
    // 追加ボタンが押されたときに呼び出されるスロット
    void addEngineFromFileSelection();

    // 削除ボタンが押されたときに呼び出されるスロット
    void removeEngine();

    // 設定ボタンが押されたときに呼び出されるスロット
    void configureEngine();

    // 将棋エンジンの出力を１行ずつ読み取り、エンジン情報やオプション情報を取得する。
    void processEngineOutput();

    // QProcessのエラーが発生したときに呼び出されるスロット
    void onProcessError(const QProcess::ProcessError error);

    // プロセスの標準エラー出力を処理する。
    void processEngineErrorOutput();

signals:
    // MainWindowにエラーを報告するためのシグナル
    void errorReported(const QString& errorMessage);

private:
    Ui::EngineRegistrationDialog *ui;

    // 将棋エンジンのプロセス
    QProcess* m_process;

    // エラーが発生したかどうかを示すフラグ
    bool m_errorOccurred;

    // 将棋エンジンから"option name"行を保存するリスト
    QStringList m_optionLines;

    // 将棋エンジンのファイル名
    QString m_fileName;

    // 将棋エンジンのディレクトリ
    QString m_engineDir;

    // エンジン名
    QString m_engineIdName;

    // エンジンのリスト
    QList<Engine> m_engineList;

    // エンジンオプションのリスト
    //QList<EngineOption> m_optionList;
    QList<EngineOption> m_engineOptions;

    // comboタイプのオプションの文字列リスト
    QStringList m_concatenatedOptionValuesList;

    // コマンド文字列の定数
    static constexpr char UsiCommand[] = "usi\n";
    static constexpr char QuitCommand[] = "quit\n";
    static constexpr char IdNamePrefix[] = "id name";
    static constexpr char OptionNamePrefix[] = "option name";
    static constexpr char UsiOkPrefix[] = "usiok";

    // 文法チェックの結果を保持する構造体
    struct ValidationResult {
        bool isValid;
        QString errorMessage;
    };

    // USI optionコマンドの文法をチェックする関数
    ValidationResult checkOptionSyntax(const QString& optionCommand);

    // シグナル・スロットの接続を行う。
    void initializeSignals() const;

    // 設定ファイルにエンジン名と絶対パス付きの実行ファイル名を書き込む。
    void saveEnginesToSettingsFile() const;

    // usiコマンドの出力からエンジンオプションを取り出す。
    void getEngineOptions();

    // 設定ファイルに追加エンジンのオプションを書き込む。；
    void saveEngineOptionsToSettings() const;

    // 指定されたエンジン情報を設定ファイルに保存する。
    void saveEngineToSettings(QSettings& settings, const Engine& engine) const;

    // 設定ファイルから[Engines]グループを削除する。
    void removeEnginesGroup() const;

    // 設定ファイルからエンジン名グループを削除する。
    void removeEngineNameGroup(const QString& removeEngineName) const;

    // エンジン登録ダイアログから選択したエンジンを削除する。
    void removeSelectedEngineFromList(QString& removeEngineName);

    // comboタイプのオプションの文字列を作成する。
    void concatenateComboOptionValues();

    // 将棋エンジンを起動し、対局開始に関するコマンドを送信する。
    void startAndInitializeEngine(const QString& engineFile);

    // 将棋エンジンを起動する。
    void startEngine(const QString& engineFile);

    // usiコマンドを将棋エンジンに送信する。
    void sendUsiCommand() const;

    // quitコマンドを将棋エンジンに送信する。
    void sendQuitCommand() const;

    // 登録したいエンジンが既に登録されている場合、重複エラーのメッセージを表示する。
    void duplicateEngine();

    // 設定ファイルからエンジン名と絶対パス付きの実行ファイル名を読み込み、GUIのリストウィジェットにエンジン名を追加する。
    void loadEnginesFromSettings();

    // 設定ファイルからエンジン名と絶対パス付きの実行ファイル名を読み込む。
    Engine readEngineFromSettings(const QSettings& settings) const;

    // ファイルのパスが有効かどうかを検証する。
    bool validateEnginePath(const QString& filePath) const;

    // 将棋エンジンからの出力を解析する。
    void parseEngineOutput(const QString& line);

    // エンジン登録が重複している場合、重複エラーのメッセージを表示する。
    void handleDuplicateEngine(const QString& engineName);

    // エンジン名と絶対パスでの実行ファイル名を取得する。
    void processIdName(const QString& line);

    // エンジンオプション構造体に値を設定する。
    void addOption(const QString& name, const QString& type, const QString& defaultValue, const QString& min,
                   const QString& max, const QString& currentValue);

    // 将棋エンジンから送信されたオプション行を解析し、エンジンオプションリストに追加する。
    void parseOptionLine(const QString& line);

    // エラーメッセージを表示する。
    void showErrorMessage(const QString &errorMessage);
};

#endif // ENGINEREGISTRATIONDIALOG_H
#ifndef ENGINESETTINGSCONSTANTS_H
#define ENGINESETTINGSCONSTANTS_H

namespace EngineSettingsConstants {
// 設定ファイル
static constexpr auto SettingsFileName = "ShogiBoardQ.ini";

// エンジングループ名
static constexpr auto EnginesGroupName = "Engines";

// エンジン名を指定するキー
static constexpr char EngineNameKey[] = "name";

// エンジンの実行ファイルパスを指定するキー
static constexpr char EnginePathKey[] = "path";

// オプション名を指定するキー
static constexpr char EngineOptionNameKey[] = "name";

// オプションの型（例：check, spin）を指定するキー
static constexpr char EngineOptionTypeKey[] = "type";

// オプションのデフォルト値を指定するキー
static constexpr char EngineOptionDefaultKey[] = "default";

// オプションの最小値（spin型の場合）を指定するキー
static constexpr char EngineOptionMinKey[] = "min";

// オプションの最大値（spin型の場合）を指定するキー
static constexpr char EngineOptionMaxKey[] = "max";

// オプションの現在値を指定するキー
static constexpr char EngineOptionValueKey[] = "value";

// combo型のオプションで選択可能な値のリストを指定するキー
static constexpr char EngineOptionValueListKey[] = "valueList";
}

#endif // ENGINESETTINGSCONSTANTS_H
#ifndef ENGINESETTINGSCOORDINATOR_H
#define ENGINESETTINGSCOORDINATOR_H

class QWidget;

namespace EngineSettingsCoordinator {

// エンジン設定ダイアログを表示します。
void openDialog(QWidget* parent);

} // namespace EngineSettingsCoordinator

#endif // ENGINESETTINGSCOORDINATOR_H
#ifndef ERRORBUS_H
#define ERRORBUS_H

#include <QObject>
#include <QString>

class ErrorBus final : public QObject {
    Q_OBJECT
public:
    static ErrorBus& instance() {
        static ErrorBus inst;
        return inst;
    }

signals:
    void errorOccurred(const QString& message);

public:
    // どこからでも呼べる公開API
    void postError(const QString& message) {
        emit errorOccurred(message);
    }

private:
    explicit ErrorBus(QObject* parent = nullptr) : QObject(parent) {}
    Q_DISABLE_COPY_MOVE(ErrorBus)
};

#endif // ERRORBUS_H
#ifndef EVALGRAPHPRESENTER_H
#define EVALGRAPHPRESENTER_H

#include <QtCore/QList>

class MatchCoordinator;  // 前方宣言（ポインタ使用のみ／重い依存を避ける）

namespace EvalGraphPresenter {

// 主エンジンの評価値(cp)を配列へ追記します。
// - scoreCp: 評価値の蓄積先（呼び出し側の m_scoreCp を渡す）
// - match  : エンジン参照用（nullptr 可。nullptr の場合は 0 を追記）
void appendPrimaryScore(QList<int>& scoreCp, MatchCoordinator* match);

// セカンダリエンジンの評価値(cp)を配列へ追記します。
// - scoreCp: 評価値の蓄積先（呼び出し側の m_scoreCp を渡す）
// - match  : エンジン参照用（nullptr 可。nullptr の場合は 0 を追記）
void appendSecondaryScore(QList<int>& scoreCp, MatchCoordinator* match);

} // namespace EvalGraphPresenter

#endif // EVALGRAPHPRESENTER_H
#ifndef EVALUATIONCHARTWIDGET_H
#define EVALUATIONCHARTWIDGET_H

#pragma once
#include <QWidget>

class QChart;
class QLineSeries;
class QValueAxis;
class QChartView;

class EvaluationChartWidget : public QWidget
{
    Q_OBJECT
public:
    explicit EvaluationChartWidget(QWidget* parent = nullptr);

    void appendScoreP1(int ply, int cp, bool invert = false);
    void appendScoreP2(int ply, int cp, bool invert = false);
    void clearAll();

    void removeLastP1();
    void removeLastP2();

    int countP1() const;
    int countP2() const;

private:
    QChart*      m_chart = nullptr;
    QLineSeries* m_s1    = nullptr;
    QLineSeries* m_s2    = nullptr;
    QValueAxis*  m_axX   = nullptr;
    QValueAxis*  m_axY   = nullptr;
    QChartView*  m_chartView = nullptr;
};

#endif // EVALUATIONCHARTWIDGET_H
#ifndef GAMELAYOUTBUILDER_H
#define GAMELAYOUTBUILDER_H

#include <QObject>

class QWidget;
class QVBoxLayout;
class QSplitter;
class QTabWidget;

class GameLayoutBuilder : public QObject {
    Q_OBJECT
public:
    struct Deps {
        QWidget*     shogiView = nullptr;          // 左ペイン
        QWidget*     recordPaneOrWidget = nullptr; // 右ペイン（RecordPane）
        QTabWidget*  analysisTabWidget = nullptr;  // 下段タブ（EngineAnalysisTab 等）
    };

    explicit GameLayoutBuilder(const Deps& d, QObject* parent=nullptr);

    QSplitter* buildHorizontalSplit();                   // 左右分割を作る
    void       attachToCentralLayout(QVBoxLayout* vbox); // 中央レイアウトへ貼る

    QSplitter* splitter() const { return m_splitter; }

private:
    Deps       m_d;
    QSplitter* m_splitter = nullptr;
};

#endif // GAMELAYOUTBUILDER_H
#ifndef GAMESTARTCOORDINATOR_H
#define GAMESTARTCOORDINATOR_H

#include <QObject>
#include <QString>
#include <QDialog>

// 既存の司令塔
#include "matchcoordinator.h"

class QWidget;
class ShogiClock;
class ShogiGameController;
class ShogiView;

/**
 * @brief 対局開始を司るコーディネータ
 *
 * 責務:
 *  - （MainWindow 等で構築済みの）StartOptions を受け取り、対局を開始する
 *  - 将棋時計の初期化を “依頼シグナル” で通知（具体的なセットは UI 層に委譲）
 *  - 対局開始前の UI/内部状態クリアを “依頼シグナル” で通知
 *  - 必要に応じて初手 go（エンジン初手）をトリガ
 *
 * 注意:
 *  - ここでは具体的な ShogiClock API を呼びません（プロジェクト差異を吸収するため）
 *    → MainWindow 側で既存ロジックをスロット接続してください（ラムダ禁止）
 */
class GameStartCoordinator : public QObject
{
    Q_OBJECT
public:
    struct Deps {
        MatchCoordinator*     match  = nullptr;  // 必須
        ShogiClock*           clock  = nullptr;  // 任意（時間適用リクエストを出すだけ）
        ShogiGameController*  gc     = nullptr;  // 任意（開始前の状態同期で使う場合）
        ShogiView*            view   = nullptr;  // 任意（開始前の表示更新で使う場合）
    };

    // 時間設定（必要分だけ。単位はミリ秒）
    struct TimeSide {
        qint64 baseMs      = 0;  // 持ち時間
        qint64 byoyomiMs   = 0;  // 秒読み
        qint64 incrementMs = 0;  // フィッシャー（1手加算）
    };
    struct TimeControl {
        bool    enabled = false;
        TimeSide p1;
        TimeSide p2;
    };

    // 起動パラメータ
    struct StartParams {
        MatchCoordinator::StartOptions opt;     // 既存の StartOptions をそのまま注入
        TimeControl                    tc;      // 時計適用のために併送
        bool autoStartEngineMove = true;        // 先手がエンジンなら初手 go を起動
    };

    // ★ MainWindow から「開始前の適用（時計/人手前など）」を依頼するための軽量入力
    struct Request {
        int       mode = 0;           // PlayMode を int で受ける（enum 依存を避ける）
        QString   startSfen;          // "startpos ..." or "<sfen> [b|w] ..."
        bool      bottomIsP1 = true;  // 「人を手前」初期希望
        QWidget*  startDialog = nullptr; // 持ち時間UI（QWidgetなら型不問：objectNameとproperty参照）
        ShogiClock* clock = nullptr;     // 任意（参照のみ）
    };

    struct Ctx {
        ShogiView*             view = nullptr;
        ShogiGameController*   gc = nullptr;
        ShogiClock*            clock = nullptr;
        QDialog*               startDlg = nullptr;
        QString*               startSfenStr = nullptr;
        QString*               currentSfenStr = nullptr;

        // 追加（元MainWindowの状態を渡すため）
        int   selectedPly = -1;       // 例: qMax(0, m_currentMoveIndex)
        bool  resumeFromCurrent = true;

        // ★ 追加：棋譜欄モデル／SFEN履歴（MainWindow が持っていたものを注入）
        KifuRecordListModel* kifuModel  = nullptr;
        QStringList*         sfenRecord = nullptr;

        // 追加：この関数で使う情報
        bool                 isReplayMode = false;     // 再生モード中は時計を動かさない

        // MainWindow 側へ初期msを戻したい場合（NULLなら無視）
        qint64*                 initialTimeP1MsOut = nullptr;
        qint64*                 initialTimeP2MsOut = nullptr;

        bool bottomIsP1 = true;  // 手前が先手なら true（MainWindow の m_bottomIsP1 をそのまま渡す）
    };


public:
    explicit GameStartCoordinator(const Deps& deps, QObject* parent = nullptr);

    // メイン API: StartOptions を受け取り対局を開始
    void start(const StartParams& params);

    // 開始前の時計/表示ポリシー適用（MainWindow::startGameBasedOnMode 内から呼ぶ）
    void prepare(const Request& req);

    // ★ 段階実行 API（MainWindow から逐次呼び出し可能）
    void prepareDataCurrentPosition(const Ctx& c);
    void prepareInitialPosition(const Ctx& c);
    void initializeGame(const Ctx& c);
    void setTimerAndStart(const Ctx& c);

    // ダイアログ状態を読み、対局モードを返す（MainWindow::setPlayMode の移管）
    PlayMode setPlayMode(const Ctx& c) const;

    // これを追加：SFENの手番とダイアログ設定を整合させて PlayMode を決定
    static PlayMode determinePlayModeAlignedWithTurn(
        int initPositionNumber,
        bool isPlayer1Human,
        bool isPlayer2Human,
        const QString& startSfen
        );

    // ★追加：司令塔の生成＆初期配線をまとめて実施（所有は parent にぶら下げます）
    MatchCoordinator* createAndWireMatch(const MatchCoordinator::Deps& deps,
                                         QObject* parentForMatch);

    // GameStartCoordinator.h （public: セクションに追加）
    void applyPlayersNamesForMode(ShogiView* view,
                                  PlayMode mode,
                                  const QString& human1,
                                  const QString& human2,
                                  const QString& engine1,
                                  const QString& engine2) const;

signals:
    // （開始前フック）UI/状態を初期化してほしい
    void requestPreStartCleanup();

    // 時計適用の依頼（MainWindow 側の既存ロジックへ接続してください）
    void requestApplyTimeControl(const GameStartCoordinator::TimeControl& tc);

    // 互換用エイリアス（どちらか一方だけ接続してください：ラムダ不要）
    void applyTimeControlRequested(const GameStartCoordinator::TimeControl& tc);

    // 進捗通知
    void willStart(const MatchCoordinator::StartOptions& opt);
    void started(const MatchCoordinator::StartOptions& opt);
    void startFailed(const QString& reason);

    void requestUpdateTurnDisplay();

    // ★追加：MatchCoordinator の主要シグナルを転送（re-emit）する
    void timeUpdated(qint64 p1ms, qint64 p2ms, bool p1turn, qint64 urgencyMs);
    void requestAppendGameOverMove(const MatchCoordinator::GameEndInfo& info);
    void boardFlipped(bool nowFlipped);
    void gameOverStateChanged(const MatchCoordinator::GameOverState& st);
    void matchGameEnded(const MatchCoordinator::GameEndInfo& info);

private:
    bool validate_(const StartParams& params, QString& whyNot) const;

    // ダイアログからの抽出ヘルパ（型非依存：objectName + property 読み）
    static int  readIntProperty (const QObject* root, const char* objectName,
                               const char* prop = "value",   int  def = 0);
    static bool readBoolProperty(const QObject* root, const char* objectName,
                                 const char* prop = "checked", bool def = false);
    static TimeControl extractTimeControlFromDialog(const QWidget* dlg);

private:
    MatchCoordinator*    m_match = nullptr;
    ShogiClock*          m_clock = nullptr;
    ShogiGameController* m_gc    = nullptr;
    ShogiView*           m_view  = nullptr;

    // 対局モード判定（MainWindow から移管）
    PlayMode determinePlayMode(int initPositionNumber,
                               bool isPlayer1Human,
                               bool isPlayer2Human) const;

signals:
    // エラー表示を UI に委譲（MainWindow::displayErrorMessage 相当）
    void requestDisplayError(const QString& message) const;

private:
    // これを追加：SFENから手番('b' or 'w')を抽出
    static QChar turnFromSfen_(const QString& sfen);

public:
    // 再開 SFEN が指定されていれば盤へ適用し、必要なら即時描画まで行う軽量ユーティリティ
    static void applyResumePositionIfAny(ShogiGameController* gc,
                                         ShogiView* view,
                                         const QString& resumeSfen);

private:
    TimeControl buildTimeControlFromDialog_(QDialog* startDlg) const;
};

Q_DECLARE_METATYPE(GameStartCoordinator::TimeControl)
Q_DECLARE_METATYPE(GameStartCoordinator::Request)

#endif // GAMESTARTCOORDINATOR_H
#ifndef GLOBALTOOLTIP_H
#define GLOBALTOOLTIP_H
#pragma once

#include <QFrame>

class QLabel;
class QPoint;
class QString;

/*
 * GlobalToolTip
 * 軽量なツールチップ風ポップアップ（QFrame 派生）。
 * 役割：任意のグローバル座標付近にプレーンテキストを表示する小さなフローティング UI を提供。
 * 特徴：
 *  - Qt::ToolTip | Qt::FramelessWindowHint（実装側）により枠なし・フォーカス奪取なしで表示
 *  - HTML は無効化し、文字列は HTML エスケープして安全に表示（XSS 対策）
 *  - setCompact(true) で余白・角丸・フォントを小さめに一括変更可能
 * 注意：シグナル/スロットは持たない。必要に応じて Q_OBJECT 化やアニメーションの拡張を検討。
 */
class GlobalToolTip : public QFrame {
public:
    // コンストラクタ
    // 役割：基本スタイルと内部レイアウト（QLabel）を構築。
    explicit GlobalToolTip(QWidget* parent = nullptr);

    // ツールチップを表示
    // 役割：スクリーン座標 globalPos の少し右下に、plainText をプレーン表示する。
    // 注意：plainText は実装側で toHtmlEscaped() され、HTML は無効化される。
    void showText(const QPoint& globalPos, const QString& plainText);

    // ツールチップを非表示
    // 役割：単純なラッパ。将来的なフェード等のフックとしても利用可。
    void hideTip();

    // コンパクト表示の切り替え（既定：true）
    // 役割：フォントサイズ・余白・角丸を小さめに調整して、全体の見た目を詰める。
    void setCompact(bool on = true);

    // 文字サイズ（pt）を直接指定
    // 役割：任意のポイントサイズに変更し、内容に合わせてウィジェットのサイズも更新する。
    // 注意：一部スタイル環境でフォントが上書きされるため、実装側で StyleSheet も併用している。
    void setPointSizeF(qreal pt);

private:
    // テキスト表示用の内部ラベル（所有：this）
    QLabel* m_label = nullptr;
};

#endif // GLOBALTOOLTIP_H

#ifndef KIFDISPLAYITEM_H
#define KIFDISPLAYITEM_H

#include <QString>
#include <QtGlobal>
#include <QMetaType>
#include <QList>     // ← 追加

struct KifDisplayItem
{
    QString prettyMove;
    QString timeText;
    QString comment;
    int     ply = 0;

    KifDisplayItem() = default;

    explicit KifDisplayItem(const QString& move,
                            const QString& time = QString(),
                            const QString& cmt  = QString(),
                            int plyNumber       = 0)
        : prettyMove(move), timeText(time), comment(cmt), ply(plyNumber) {}

    bool operator==(const KifDisplayItem& o) const noexcept {
        return prettyMove == o.prettyMove && timeText == o.timeText
               && comment == o.comment && ply == o.ply;
    }
    bool operator!=(const KifDisplayItem& o) const noexcept { return !(*this == o); }
};

// ★ メタタイプ宣言はこのヘッダに「1か所だけ」
Q_DECLARE_METATYPE(KifDisplayItem)
Q_DECLARE_METATYPE(QList<KifDisplayItem>)   // ← これが無いと QList<...> の接続でコケます

#endif // KIFDISPLAYITEM_H
#pragma once
#include <QString>
#include <QStringList>

// NOTE:
// このヘッダは「namespace KifReader」スタイルです。
// 互換のため、旧名 readLinesAuto(...) も inline ラッパとして残しています。
namespace KifReader {

// 文字コードを自動判別してテキストを1行ずつ取得します。
// - usedEncoding: 実際に使われたエンコーディング名（例: "utf-8", "cp932", "euc-jp"）
// - warn: 読み込み中の注意点（必要なら）を追記します。
bool readAllLinesAuto(const QString& filePath,
                      QStringList& outLines,
                      QString* usedEncoding = nullptr,
                      QString* warn = nullptr);

// 互換API（旧名）: 既存コードが KifReader::readLinesAuto(...) を呼んでいても動作します。
inline bool readLinesAuto(const QString& filePath,
                          QStringList& outLines,
                          QString* usedEncoding = nullptr,
                          QString* warn = nullptr)
{
    return readAllLinesAuto(filePath, outLines, usedEncoding, warn);
}

} // namespace KifReader
#ifndef KIFTOSFENCONVERTER_H
#define KIFTOSFENCONVERTER_H

#include <QString>
#include <QStringList>
#include <QList>
#include <QVector>
#include <QPair>
#include <QMap>
#include "shogimove.h"
#include "kifdisplayitem.h"

// KIFの「(キーワード)：(内容)」行を表すペア
struct KifGameInfoItem {
    QString key;    // 例: "開始日時"
    QString value;  // 例: "2025/03/02 09:00"
};

// ==== 分岐用データ構造 ====
// 1本の手順（分岐ライン）
struct KifLine {
    int startPly = 1;            // どの手目から開始か（例: 5）
    QString baseSfen;            // 分岐開始局面（メインを startPly-1 まで進めたSFEN）
    QStringList usiMoves;        // 分岐のUSI列
    QList<KifDisplayItem> disp;  // 表示用（▲△＋時間）: 先頭=分岐の最初の手
    QStringList sfenList;        // base含む局面列（0=base, 以降=各手後）
    QVector<ShogiMove> gameMoves;// GUI用指し手列
    bool endsWithTerminal=false;
};
// 変化（どの手から始まるか）
struct KifVariation {
    int startPly = 1;  // 例: 「変化：65手」なら 65
    KifLine line;
};

// 解析結果（本譜＋変化）
struct KifParseResult {
    KifLine mainline;
    QVector<KifVariation> variations;
};

class KifToSfenConverter
{
public:
    // 既存API：本譜の初期SFEN（手合割から判定）
    static QString detectInitialSfenFromFile(const QString& kifPath, QString* detectedLabel = nullptr);

    // 既存API：本譜のUSI列のみを抽出（終局/中断で打ち切り）
    static QStringList convertFile(const QString& kifPath, QString* errorMessage = nullptr);

    // 既存API：本譜の「指し手＋時間」（コメントも格納）を抽出
    static QList<KifDisplayItem> extractMovesWithTimes(const QString& kifPath, QString* errorMessage = nullptr);

    // 新API：本譜＋全変化をまとめて抽出（コメントも格納）
    static bool parseWithVariations(const QString& kifPath, KifParseResult& out, QString* errorMessage = nullptr);

    // 手合→初期SFEN（ユーザー提供のマップ）
    static QString mapHandicapToSfen(const QString& label);

    // 追加: KIFファイルから「対局情報」を抽出して順序付きで返す
    //   - ファイル全体を走査して「： or :」の区切りを持つ行を収集
    //   - 同一キーが複数回出る場合は値を改行で連結（備考など）
    //   - 値中の「\n」文字列は実改行に変換
    static QList<KifGameInfoItem> extractGameInfo(const QString& filePath);

    // 追加（任意）：キー→値 へ高速アクセスしたい場合のマップ版
    static QMap<QString, QString> extractGameInfoMap(const QString& filePath);

    static bool buildInitialSfenFromBod(const QStringList& lines, QString& outSfen,
                                        QString* detectedLabel = nullptr, QString* warn = nullptr);

private:
    // ---------- ヘルパ（共通） ----------
    static bool isSkippableLine(const QString& line);
    static bool isBoardHeaderOrFrame(const QString& line);
    static bool isBodHeader(const QString& line);
    static bool containsAnyTerminal(const QString& s, QString* matched = nullptr);
    static int  asciiDigitToInt(QChar c);
    static int  zenkakuDigitToInt(QChar c);
    static int  kanjiDigitToInt(QChar c);
    static QChar rankNumToLetter(int r); // 1..9 -> 'a'..'i'

    // 目的地（「同」対応）を読む
    static bool findDestination(const QString& line, int& toFile, int& toRank, bool& isSameAsPrev);

    // 1行の指し手をUSIに変換（prevTo参照；成功で更新）
    static bool convertMoveLine(const QString& line,
                                QString& usi,
                                int& prevToFile, int& prevToRank);

    // 「打」用：駒種（漢字）→ USIドロップ文字（'P','L',...）
    static QChar pieceKanjiToUsiUpper(const QString& s);

    // Promoted表記が含まれているか（"成" かつ "不成" でない）
    static bool isPromotionMoveText(const QString& line);
};

#endif // KIFTOSFENCONVERTER_H
#ifndef KIFUANALYSISDIALOG_H
#define KIFUANALYSISDIALOG_H

#include <QDialog>

namespace Ui {
class KifuAnalysisDialog;
}

// 棋譜解析ダイアログのUIを設定する。
class KifuAnalysisDialog : public QDialog
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit KifuAnalysisDialog(QWidget *parent = nullptr);

    // エンジンの名前とディレクトリを格納する構造体
    struct Engine
    {
        QString name;
        QString path;
    };

    // エンジンの名前とディレクトリを格納するリストを取得する。
    QList<Engine> engineList() const;

    // "開始局面から"を選択したかどうかのフラグを取得する。
    bool initPosition() const;

    // 1手あたりの思考時間（秒数）を取得する。
    int byoyomiSec() const;

     // エンジン番号を取得する。
    int engineNumber() const;

    // エンジン名を取得する。
    QString engineName() const;

private slots:
    // エンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
    void showEngineSettingsDialog();

    // OKボタンが押された場合、エンジン名、エンジン番号、解析局面フラグ、思考時間を取得する。
    void processEngineSettings();

private:
    // UI
    Ui::KifuAnalysisDialog* ui;

    // 選択したエンジン名
    QString m_engineName;

    // 選択したエンジン番号
    int m_engineNumber;

    // "開始局面から"を選択した場合、true
    bool m_initPosition;

    // 1手あたりの思考時間（秒数）
    int m_byoyomiSec;

    // エンジンの名前とディレクトリを格納するリスト
    QList<Engine> m_engineList;

    // 設定ファイルからエンジンの名前とディレクトリを読み込む。
    void readEngineNameAndDir();
};

#endif // KIFUANALYSISDIALOG_H
#ifndef KIFUANALYSISLISTMODEL_H
#define KIFUANALYSISLISTMODEL_H

#include <QVariant>
#include "abstractlistmodel.h"
#include "kifuanalysisresultsdisplay.h"

// 棋譜解析結果をGUI上で表示するためのクラス
class KifuAnalysisListModel : public AbstractListModel<KifuAnalysisResultsDisplay>
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit KifuAnalysisListModel(QObject *parent = nullptr);

    // 列数を返すメソッド
    int columnCount(const QModelIndex &parent = QModelIndex()) const override;

    // データを返すメソッド
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;

    // ヘッダを返すメソッド
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
};

#endif // KIFUANALYSISLISTMODEL_H

#ifndef KIFUANALYSISRESULTSDISPLAY_H
#define KIFUANALYSISRESULTSDISPLAY_H

#include <QObject>
#include <QString>

class KifuAnalysisResultsDisplay : public QObject
{
    Q_OBJECT
public:
    // コンストラクタ
    explicit KifuAnalysisResultsDisplay(QObject *parent = nullptr);

    // コンストラクタ
    KifuAnalysisResultsDisplay(const QString& currentMove, const QString& evaluationValue, const QString& evaluationDifference,
                               const QString& principalVariation, QObject* parent = nullptr);

private:
    // 指し手
    QString m_currentMove;

    // 評価値
    QString m_evaluationValue;

    // 評価値差
    QString m_evaluationDifference;

    // 読み筋
    QString m_principalVariation;

public:
    // 指し手を取得する。
    QString currentMove() const;

    // 評価値を取得する。
    QString evaluationValue() const;

    // 評価値差を取得する。
    QString evaluationDifference() const;

    // 読み筋を取得する。
    QString principalVariation() const;
};

#endif // KIFUANALYSISRESULTSDISPLAY_H
#ifndef KIFUBRANCHDISPLAY_H
#define KIFUBRANCHDISPLAY_H

#include <QObject>
#include <QString>

// 棋譜欄を表示するクラス
class KifuBranchDisplay : public QObject
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit KifuBranchDisplay(QObject *parent = nullptr);

    // コンストラクタ
    KifuBranchDisplay(const QString &currentMove, QObject *parent = nullptr);

    // 指し手を取得する。
    QString currentMove() const;

    void setCurrentMove(const QString &newCurrentMove);

private:
    // 指し手
    QString m_currentMove;
};

#endif // KIFUBRANCHDISPLAY_H
#ifndef KIFUBRANCHLISTMODEL_H
#define KIFUBRANCHLISTMODEL_H

#include <QVariant>
#include <QVector>
#include <QRectF>
#include "abstractlistmodel.h"
#include "kifubranchdisplay.h"
#include "kifdisplayitem.h"

// 分岐候補欄のモデル
class KifuBranchListModel : public AbstractListModel<KifuBranchDisplay>
{
    Q_OBJECT
public:
    explicit KifuBranchListModel(QObject *parent = nullptr);

    // 1列（指し手）
    int columnCount(const QModelIndex &parent = QModelIndex()) const override;

    // 候補行 + （必要なら）最後に「本譜へ戻る」
    int rowCount(const QModelIndex &parent = QModelIndex()) const override;

    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

    // ---- 追加API ----
    // 候補クリア
    void clearBranchCandidates();

    // KIF表示用（prettyMove/time）から候補を一括設定
    void setBranchCandidatesFromKif(const QList<KifDisplayItem>& rows);

    // 最下段に「本譜へ戻る」を表示する/しない
    void setHasBackToMainRow(bool enabled);
    bool hasBackToMainRow() const;

    // 指定行が「本譜へ戻る」か？
    bool isBackToMainRow(int row) const;
    // 「本譜へ戻る」行のindex（無効時は -1）
    int backToMainRowIndex() const;

    // 表示行 index のラベルを返す（BackToMain 行ならその文字列が返る）
    QString labelAt(int row) const {
        if (row < 0 || row >= m_rows.size()) return {};
        return m_rows.at(row).label;  // m_rows[i].label を使っている前提
    }

    // BackToMain を除いた“実質の候補数”
    int branchCandidateCount() const {
        int n = rowCount();
        return n - (m_hasBackToMainRow ? 1 : 0);
    }

    // BackToMain を除いた最初の候補の行インデックス（なければ -1）
    int firstBranchRowIndex() const {
        if (rowCount() == 0) return -1;
        return m_hasBackToMainRow ? (rowCount() >= 2 ? 1 : -1) : 0;
    }

    // --- 追加: カスタムロール ---
    enum Roles {
        DispCountRole = Qt::UserRole + 1,  // 行ごとの最大手数（0..N）
    };

    // 候補リスト＋分岐グラフの全消去
    void clear();

private:  
    struct RowItem {
        QString label;
        // …既存のフィールド（variationId など）がある前提…
        bool isBackToMain = false; // 使っていないなら m_hasBackToMainRow だけでもOK
    };
    QVector<RowItem> m_rows;
    bool m_hasBackToMainRow = false;

private:
    int m_activeVid = -1;
    int m_activePly = -1; // グローバル手数

signals:
    void activeNodeChanged(int nodeId);        // 任意（ビューの再レイアウト等）
    void activeVidPlyChanged(int vid, int ply);// 任意（ログ用など）

private:
    struct Node {
        int id = -1;
        int vid = -1;          // 0=本譜, 1..=変化
        int ply = 0;           // グローバル手数
        int row = 0;           // 表示行（Main=0, VarN）
        QRectF rect;           // 画面上の矩形（必要なら）
        int prevId = -1;       // 直前
        QVector<int> nextIds;  // 直後（分岐なら複数）
    };

    // ハイライト内部状態
    int m_activeNodeId = -1;
    int m_mainVid = 0;

    // グラフ保持
    QVector<Node> m_nodes;                // nodeId = index
    QHash<quint64, int> m_key2node;       // key=(vid<<32)|ply  -> nodeId

private:
    static inline quint64 vpKey(int vid, int ply) {
        return (quint64(uint32_t(vid)) << 32) | uint32_t(ply);
    }
    void setActiveNode_(int nodeId);      // 低レベル切替
    bool graphFallbackToPly_(int targetPly, bool preferPrev);

    // --- 追加: QML等でロール名が欲しい場合に備えて ---
    QHash<int, QByteArray> roleNames() const override;

    // --- 追加: 行の最大手数を算出するヘルパ ---
    int rowMaxPly_(int row) const;
};

#endif // KIFUBRANCHLISTMODEL_H
#ifndef KIFUCONTENTBUILDER_H
#define KIFUCONTENTBUILDER_H

#include <QString>
#include <QStringList>
#include <QList>
#include <QVector>
#include "kiftosfenconverter.h"
#include "playmode.h"
#include "kifdisplayitem.h"
#include "kifutypes.h" // ResolvedRow用

class QTableWidget;
class KifuRecordListModel;

// 保存に必要な情報をまとめた構造体
struct KifuExportContext {
    // UI/Model参照（読み取り専用）
    const QTableWidget* gameInfoTable = nullptr;
    const KifuRecordListModel* recordModel = nullptr;
    const QVector<ResolvedRow>* resolvedRows = nullptr;
    const QList<KifDisplayItem>* liveDisp = nullptr;

    // ゲーム状態
    QString startSfen;
    PlayMode playMode = NotStarted;
    QString human1;
    QString human2;
    QString engine1;
    QString engine2;
};

class KifuContentBuilder
{
public:
    // メインの構築関数
    static QStringList buildKifuDataList(const KifuExportContext& ctx);

private:
    // 内部ヘルパ
    static QList<KifGameInfoItem> collectGameInfo(const KifuExportContext& ctx);
    static QList<KifDisplayItem> collectMainline(const KifuExportContext& ctx);
    static void resolvePlayerNames(const KifuExportContext& ctx, QString& outBlack, QString& outWhite);
};

#endif // KIFUCONTENTBUILDER_H
#ifndef KIFUDISPLAY_H
#define KIFUDISPLAY_H

#include <QObject>
#include <QString>

// 棋譜欄を表示するクラス
class KifuDisplay : public QObject
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit KifuDisplay(QObject *parent = nullptr);

    // コンストラクタ
    KifuDisplay(const QString &currentMove, const QString &timeSpent, QObject *parent = nullptr);

    // 指し手を取得する。
    QString currentMove() const;

    // 消費時間を取得する。  
    QString timeSpent() const;

private:
    // 指し手
    QString m_currentMove;

    // 消費時間
    QString m_timeSpent;

};

#endif // KIFUDISPLAY_H
#ifndef KIFUIOSERVICE_H
#define KIFUIOSERVICE_H

#include <QString>
#include <QStringList>
#include <QDateTime>

#include "playmode.h"

namespace KifuIoService {

QString makeDefaultSaveFileName(PlayMode mode,
                                const QString& human1,
                                const QString& human2,
                                const QString& engine1,
                                const QString& engine2,
                                const QDateTime& now);

bool writeKifuFile(const QString& filePath,
                   const QStringList& kifuLines,
                   QString* errorText);

} // namespace

#endif // KIFUIOSERVICE_H
#ifndef KIFULOADCOORDINATOR_H
#define KIFULOADCOORDINATOR_H

#include <QObject>
#include <QTableWidget>
#include <QDockWidget>
#include <QStyledItemDelegate>

#include "kiftosfenconverter.h"
#include "engineanalysistab.h"
#include "shogiview.h"
#include "recordpane.h"
#include "branchcandidatescontroller.h"
#include "kifurecordlistmodel.h"
#include "kifutypes.h"
#include "branchdisplayplan.h"

class NavigationPresenter;
class EngineAnalysisTab;

class KifuLoadCoordinator : public QObject
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit KifuLoadCoordinator(QVector<ShogiMove>& gameMoves,
                        QVector<ResolvedRow>& resolvedRows,
                        QStringList& positionStrList,
                        int& activeResolvedRow,
                        int& activePly,
                        int& currentSelectedPly,
                        int& currentMoveIndex,
                        QStringList* sfenRecord,
                        QTableWidget* gameInfoTable,
                        QDockWidget* gameInfoDock,
                        EngineAnalysisTab* analysisTab,
                        QTabWidget* tab,
                        ShogiView* shogiView,
                        RecordPane* recordPane,
                        KifuRecordListModel* kifuRecordModel,
                        KifuBranchListModel* kifuBranchModel,
                        BranchCandidatesController* branchCtl,
                        QTableView* kifuBranchView,
                        QHash<int, QMap<int, ::BranchCandidateDisplay>>& branchDisplayPlan,
                        QObject* parent=nullptr);

    // --- 装飾（棋譜テーブル マーカー描画） ---
    class BranchRowDelegate : public QStyledItemDelegate {
    public:
        explicit BranchRowDelegate(QObject* parent = nullptr);
        ~BranchRowDelegate() override;        // ← 宣言だけにする
        void setMarkers(const QSet<int>* marks) { m_marks = marks; }
        void paint(QPainter* painter,
                   const QStyleOptionViewItem& option,
                   const QModelIndex& index) const override;
    private:
        const QSet<int>* m_marks = nullptr;
    };
    BranchRowDelegate* m_branchRowDelegate = nullptr;

    // --- 分岐候補（テキスト）側の索引 ---
    struct BranchCandidate {
        QString text;  // 「▲２六歩(27)」
        int row;       // resolved 行
        int ply;       // 1始まり
    };

    void loadKifuFromFile(const QString& filePath);

    void setAnalysisTab(EngineAnalysisTab* tab);

    void setBranchCandidatesController(BranchCandidatesController* ctl);

    void updateBranchTreeFromLive(int currentPly);

public slots:
    void applyResolvedRowAndSelect(int row, int selPly);

    // ★ 新規公開：行(row)・手数(ply1)の分岐候補を“表示のみ”更新
    //   （内部で showBranchCandidatesFromPlan を呼ぶラッパー）
    void showBranchCandidates(int row, int ply1);

    // 棋譜テーブルの「本譜行」選択が変わったときに呼ぶ
    void onMainMoveRowChanged(int selPly);

private slots:
    void onBackToMainButtonClicked_();

signals:
    void errorOccurred(const QString& errorMessage);
    void setReplayMode(bool on);
    void displayGameRecord(const QList<KifDisplayItem> disp);
    void syncBoardAndHighlightsAtRow(int ply1);
    void enableArrowButtons();
    void setupBranchCandidatesWiring_();


private:
    bool m_loadingKifu = false;
    QTableWidget* m_gameInfoTable;
    QDockWidget*  m_gameInfoDock;
    EngineAnalysisTab* m_analysisTab;
    QTabWidget* m_tab;
    ShogiView* m_shogiView;
    QStringList m_usiMoves;
    QStringList* m_sfenRecord;
    QVector<ShogiMove>& m_gameMoves;
    QStringList& m_positionStrList;
    QList<KifDisplayItem> m_dispMain;
    QList<KifDisplayItem> m_dispCurrent;
    QStringList           m_sfenMain;
    QVector<ShogiMove>    m_gmMain;
    QHash<int, QList<KifLine>> m_variationsByPly;
    QList<KifLine> m_variationsSeq;
    RecordPane* m_recordPane;
    QVector<ResolvedRow>& m_resolvedRows;
    int& m_activeResolvedRow;
    int& m_activePly;
    int& m_currentSelectedPly;
    int& m_currentMoveIndex;
    KifuRecordListModel* m_kifuRecordModel;
    KifuBranchListModel* m_kifuBranchModel;
    BranchCandidatesController* m_branchCtl;
    QTableView* m_kifuBranchView;
    int m_branchPlyContext = -1;
    QSet<int> m_branchablePlySet;
    QHash<int, QHash<QString, QList<BranchCandidate>>> m_branchIndex;
    // 行(row) → (ply → 表示計画) の保持
    // 例: m_branchDisplayPlan[row][ply]
    QHash<int, QMap<int, BranchCandidateDisplay>>& m_branchDisplayPlan;
    std::unique_ptr<KifuVariationEngine> m_varEngine;
    bool m_branchTreeLocked = false;  // ← 分岐ツリーの追加・変更を禁止するロック
    NavigationPresenter* m_navPresenter = nullptr;

    QString prepareInitialSfen(const QString& filePath, QString& teaiLabel) const;
    void populateGameInfo(const QList<KifGameInfoItem>& items);
    void addGameInfoTabIfMissing();
    void applyPlayersFromGameInfo(const QList<KifGameInfoItem>& items);
    QString findGameInfoValue(const QList<KifGameInfoItem>& items, const QStringList& keys) const;
    void rebuildSfenRecord(const QString& initialSfen, const QStringList& usiMoves, bool hasTerminal);
    void rebuildGameMoves(const QString& initialSfen, const QStringList& usiMoves);
    void showRecordAtPly(const QList<KifDisplayItem>& disp, int selectPly);
    void showBranchCandidatesFromPlan(int row, int ply1);
    void updateKifuBranchMarkersForActiveRow();
    void ensureBranchRowDelegateInstalled();
    void logImportSummary(const QString& filePath,
                          const QStringList& usiMoves,
                          const QList<KifDisplayItem>& disp,
                          const QString& teaiLabel,
                          const QString& warnParse,
                          const QString& warnConvert) const;
    void buildResolvedLinesAfterLoad();
    void dumpBranchSplitReport() const;
    QString rowNameFor_(int row) const;
    QString labelAt_(const ResolvedRow& rr, int ply) const;
    bool prefixEqualsUpTo_(int rowA, int rowB, int p) const;

    void dumpBranchCandidateDisplayPlan() const;
    void ensureResolvedRowsHaveFullSfen();
    void ensureResolvedRowsHaveFullGameMoves();
    void dumpAllRowsSfenTable() const;
    void dumpAllLinesGameMoves() const;
    void buildBranchCandidateDisplayPlan();
    void ensureNavigationPresenter_();

    // 追加（private）
    QList<KifDisplayItem> collectDispFromRecordModel_() const;

    // ★ 追加：現在表示中の行（m_activeResolvedRow）の分岐手をモデルへ反映
    void applyBranchMarksForCurrentLine_();
};

#endif // KIFULOADCOORDINATOR_H
#ifndef KIFURECORDLISTMODEL_H
#define KIFURECORDLISTMODEL_H

#include <QVariant>
#include <QSet>                    // ★ 追加
#include "abstractlistmodel.h"
#include "kifudisplay.h"

class KifuRecordListModel : public AbstractListModel<KifuDisplay>
{
    Q_OBJECT
public:
    explicit KifuRecordListModel(QObject *parent = nullptr);

    int columnCount(const QModelIndex &parent = QModelIndex()) const override;
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

    bool prependItem(KifuDisplay* item);
    Q_INVOKABLE bool removeLastItem();
    Q_INVOKABLE bool removeLastItems(int n);

    // ★ 追加：分岐のある手（ply1=1..N）集合をセット
    void setBranchPlyMarks(const QSet<int>& ply1Set);
    QSet<int> branchPlyMarks() const { return m_branchPlySet; }

private:
    // ★ 追加：分岐あり手の集合（モデルの行番号＝ply1と一致。0は「開始局面」で除外）
    QSet<int> m_branchPlySet;
};

#endif // KIFURECORDLISTMODEL_H
#ifndef KIFUSAVECOORDINATOR_H
#define KIFUSAVECOORDINATOR_H

#include <QString>
#include <QStringList>
#include "playmode.h"   // ★ 前方宣言をやめ、実体定義を取り込む

class QWidget;

namespace KifuSaveCoordinator {

// ダイアログを出して保存。成功時は保存パス、失敗/キャンセルは空文字。
QString saveViaDialog(QWidget* parent,
                      const QStringList& kifuLines,
                      PlayMode mode,
                      const QString& human1,
                      const QString& human2,
                      const QString& engine1,
                      const QString& engine2,
                      QString* outError = nullptr);

// 既存ファイルへ上書き保存
bool overwriteExisting(const QString& path,
                       const QStringList& kifuLines,
                       QString* outError = nullptr);

} // namespace KifuSaveCoordinator

#endif // KIFUSAVECOORDINATOR_H
#ifndef KIFUTYPES_H
#define KIFUTYPES_H

#include <QString>
#include <QVector>

#include "kifdisplayitem.h"
#include "shogimove.h"

struct ResolvedRow {
    int startPly = 1;
    int parent   = -1;                 // ★追加：親行。Main は -1
    QList<KifDisplayItem> disp;
    QStringList sfen;
    QVector<ShogiMove> gm;
    int varIndex = -1;                 // 本譜 = -1
};

#endif // KIFUTYPES_H
#ifndef KIFUVARIATIONENGINE_H
#define KIFUVARIATIONENGINE_H

#include <QList>
#include <QVector>
#include <QHash>
#include <QPair>
#include <QString>
#include <QSet>

// ★ 実体定義を提供するヘッダを必ずインクルードする
// KifDisplayItem / KifLine / KifVariation / KifParseResult が定義されているヘッダ
#include "kiftosfenconverter.h"   // ← あなたのプロジェクトではここに KifParseResult 等が定義されています

#include <QList>
#include <QVector>
#include <QHash>
#include <QPair>
#include <QString>
#include <QSet>

// 指し手1手のUSI文字列（例: "7g7f", "P*5e", "7g7f+" など）
using UsiMove = QString;

// 分岐候補1件（分岐欄に表示するラベル＋内部ID）
struct BranchCandidate {
    QString label;   // 例: "１六歩(17)"
    int     variationId = -1; // エンジン内部で付与する連番ID
    int     ply = 0;          // 何手目の候補か（クリック時の参照用）
    bool    isBlack = false;  // 先後（色分け用）
    bool    isMainline = false;
};

// “後勝ちで合成”した1本分（UIへ返す最終形）
struct ResolvedLine {
    int startPly = 1;                 // 見た目上 1 から
    QList<KifDisplayItem> disp;       // 1..N 表示列
    QVector<UsiMove>      usi;        // 1..N USI列（可能な限り前半上書きを反映）
    // SFENは MainWindow 側の rebuildSfenRecord() を用いて再構築してください
};

// 純ロジック：分岐候補の列挙と「後勝ち」合成を担当（UI/Qtビューから独立）
class KifuVariationEngine {
public:
    KifuVariationEngine();

    // 読み込み直後に呼ぶ：本譜と分岐一式を取り込み、内部インデックスを構築
    // sfenMain はここでは保持しません（SFEN再構築は呼び出し側の既存関数を使うため）
    void ingest(const KifParseResult& res,
                const QList<QString>& sfenMain,        // 0..N（未使用だが将来拡張のため受けておく）
                const QVector<UsiMove>& usiMain,       // 1..N
                const QList<KifDisplayItem>& dispMain  // 1..N
                );

    // ある手数 ply に対する“分岐候補”を返す。includeMainline=true で本譜の手も候補に含める。
    QList<BranchCandidate> branchCandidatesForPly(int ply,
                                                  bool includeMainline = true) const;

    // 分岐候補がクリックされた際：後勝ちで一本の列を合成して返す
    ResolvedLine resolveAfterWins(int variationId) const;

    // ★追加: RESOLVED 側から「VarN(=sourceIndex)に対応する id」を知るための API
    int varIdForSourceIndex(int sourceIndex) const {
        auto it = m_sourceToId.find(sourceIndex);
        return (it == m_sourceToId.end()) ? -1 : it.value();
    }

    QList<BranchCandidate> branchCandidatesForPly(int ply,
                                                  bool includeMainline,
                                                  const QString& contextPrevSfen) const;

    struct Variation {
        int id = -1;
        int fileOrder = -1;
        bool isMainline = false;
        int startPly = 1;
        QList<KifDisplayItem> disp;
        QVector<UsiMove>      usi;

        int sourceIndex = -1;         // 既存（前に追加済み）
        QList<QString> sfen;          // ★追加：0..(手数) の局面。mainは初期局面を含む
        // 変化は [0]=startPly-1手後（基底）, [1..]=各手後 の想定
    };

    QList<QString> mainlineSfen() const;
    QList<QString> sfenForVariationId(int variationId) const;
    int variationIdFromSourceIndex(int sourceIndex) const;

private:
    QString prevSfenFor(int vid, int li) const;

    // インデックス
    QList<KifDisplayItem> m_dispMain;    // 本譜 1..N
    QVector<UsiMove>      m_usiMain;     // 本譜 1..N
    QList<Variation>      m_vars;        // 本譜 + 変化群（fileOrder昇順）
    // ply -> [(variationId, localIdx)]  localIdx はその variation 内での 0 始まり
    QHash<int, QVector<QPair<int,int>>> m_idx;

    static QString pickLabel(const KifDisplayItem& d); // "１六歩(17)" を返す（prettyMove 流用）

    QHash<int,int> m_sourceToId;  // ★追加: key=sourceIndex(vi), value=variation id

public:
    // sourceIndex(=Var0->0, Var1->1, ...) から vid を得る
    int idForSourceIndex(int sourceIndex) const;
};

#endif // KIFUVARIATIONENGINE_H
#ifndef LEGALMOVESTATUS_H
#define LEGALMOVESTATUS_H

struct LegalMoveStatus {
    bool nonPromotingMoveExists;  // 成らない状態での合法手が存在するかどうか
    bool promotingMoveExists;     // 成る状態での合法手が存在するかどうか

    // コンストラクタ
    LegalMoveStatus(bool nonPromoting = false, bool promoting = false)
        : nonPromotingMoveExists(nonPromoting), promotingMoveExists(promoting) {}
};

#endif // LEGALMOVESTATUS_H
#ifndef LONGLONGSPINBOX_H
#define LONGLONGSPINBOX_H

#include <QtWidgets/QAbstractSpinBox>

// Qtには、long long型の値を直接扱うためのQSpinBoxは存在しない。
// このため、QAbstractSpinBoxを継承して、long long型の値を扱うクラス
class LongLongSpinBox : public QAbstractSpinBox
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit LongLongSpinBox(QWidget* parent = nullptr);

    // 現在の値を取得する。
    qlonglong value() const;

    // スピンボックスの範囲を設定する。
    void setSpinBoxRange(qlonglong min, qlonglong max);

public slots:
    // スピンボックスに値を設定する。
    void setSpinBoxValue(qlonglong value);

signals:
    // long long型の値が変更されたときにシグナルを送信する。
    void longLongValueChanged(qlonglong i);

    // 文字列型の値が変更されたときにシグナルを送信する。
    void textValueChanged(const QString& text);

protected:
    // キーボードイベントを処理する。
    void keyPressEvent(QKeyEvent* event) override;

    // フォーカスが外れたときのイベントを処理する。
    void focusOutEvent(QFocusEvent* event) override;

    // スピンボックスのステップが有効かどうかを確認する。
    StepEnabled stepEnabled() const override;

    // スピンボックスの値をステップに応じて増減する。
    void stepBy(int steps) override;

    // 入力された値を検証する。
    QValidator::State validate(QString& input, int& pos) const override;

private:
    // スピンボックスに入力した値を確定させ、その値が有効であれば内部の値に反映させる。
    // 入力した値が無効な場合、現在の値を再設定して入力内容をリセットする。
    void finalizeEditing();

    // 必要に応じて編集を終了する。
    void finalizeEditingIfNeeded();

    // スピンボックスの最小値
    qlonglong m_minValue;

    // スピンボックスの最大値
    qlonglong m_maxValue;

    // スピンボックスの現在の値
    qlonglong m_currentValue;

    // 1ステップの増減幅
    const qlonglong m_singleStepValue;

    // クラスのコピーコンストラクタとコピー代入演算子を明示的に削除し、コピー操作を禁止する。
    Q_DISABLE_COPY(LongLongSpinBox)
};

#endif // LONGLONGSPINBOX_H
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

// ==============================
// Qt includes
// ==============================
#include <QMainWindow>
#include <QDockWidget>
#include <QSplitter>
#include <QStyledItemDelegate>
#include <QTableWidget>
#include <QTime>
#include <QVBoxLayout>

// ==============================
// Project includes (types used by value ＝前方宣言できないもの優先)
// ==============================
#include "playmode.h"                 // PlayMode を値で使用
#include "shogimove.h"                // QVector<ShogiMove> をメンバで保持
#include "matchcoordinator.h"         // MatchCoordinator::GameEndInfo を値で使用
#include "kifurecordlistmodel.h"      // KifDisplayItem を値で使用（disp 等）
#include "kifuanalysislistmodel.h"    // KifGameInfoItem を値で使用

// ==============================
// Project includes（依存の強いモジュール）
// ==============================
#include "kifubranchlistmodel.h"
#include "shogienginethinkingmodel.h"
#include "shogigamecontroller.h"
#include "usi.h"
#include "startgamedialog.h"
#include "kifuanalysisdialog.h"
#include "usicommlogmodel.h"
#include "considerationdialog.h"
#include "tsumeshogisearchdialog.h"
#include "shogiclock.h"
#include "navigationcontext.h"
#include "recordpane.h"
#include "engineanalysistab.h"
#include "boardinteractioncontroller.h"
#include "kifuvariationengine.h"
#include "branchcandidatescontroller.h"
#include "kifuloadcoordinator.h"
#include "kifutypes.h"
#include "positioneditcontroller.h"
#include "gamestartcoordinator.h"
#include "analysisflowcontroller.h"

// ==============================
// Macros / aliases
// ==============================
#define SHOGIBOARDQ_DEBUG_KIF 1   // 0にすればログは一切出ません


QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE

// ==============================
// Forward declarations（ポインタ/参照のみ使用する型）
// ==============================
class QPainter;
class QStyleOptionViewItem;
class QModelIndex;
class NavigationController;
class QGraphicsView;
class QGraphicsPathItem;
class QTableView;
class QEvent;
class ShogiView;
class BoardSyncPresenter;
class AnalysisResultsPresenter;
class GameStartCoordinator;
class AnalysisCoordinator;
class GameRecordPresenter;
class BranchWiringCoordinator;
class TimeDisplayPresenter;
class AnalysisTabWiring;
class RecordPaneWiring;
class UiActionsWiring;
class GameLayoutBuilder;
class INavigationContext;

// ============================================================
// MainWindow
// ============================================================
class MainWindow : public QMainWindow, public INavigationContext
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget* parent = 0);

    // -------- INavigationContext (public) --------
    bool hasResolvedRows() const override;
    int  resolvedRowCount() const override;
    int  activeResolvedRow() const override;
    int  maxPlyAtRow(int row) const override;
    int  currentPly() const override;
    void applySelect(int row, int ply) override;

protected:
    Ui::MainWindow* ui = nullptr;

    // QMainWindow
    void closeEvent(QCloseEvent* event) override;

private:
    // ========================================================
    // Private Data Members（用途別にグルーピング）
    // ========================================================

    // --- 基本状態 / ゲーム状態 ---
    QString  m_startSfenStr;
    QString  m_currentSfenStr;
    QString  m_resumeSfenStr; // 再開用
    bool     m_errorOccurred = false;
    int      m_currentMoveIndex = 0;
    QString  m_lastMove;
    PlayMode m_playMode = NotStarted;

    // --- 将棋盤 / コントローラ類 ---
    ShogiView*                   m_shogiView = nullptr;
    ShogiGameController*         m_gameController = nullptr;
    BoardInteractionController*  m_boardController = nullptr;

    // --- USI / エンジン連携 ---
    Usi*        m_usi1 = nullptr;
    Usi*        m_usi2 = nullptr;
    QString     m_positionStr1;
    QStringList m_positionStrList;
    QStringList m_usiMoves;

    // --- UI 構成 ---
    QTabWidget* m_tab = nullptr; // EngineAnalysisTab 内部の QTabWidget を流用
    QWidget*    m_gameRecordLayoutWidget = nullptr; // 右側（RecordPane）
    QSplitter*  m_hsplit = nullptr;

    // --- ダイアログ / 補助ウィンドウ ---
    StartGameDialog*         m_startGameDialog = nullptr;
    ConsiderationDialog*     m_considerationDialog = nullptr;
    TsumeShogiSearchDialog*  m_tsumeShogiSearchDialog = nullptr;
    KifuAnalysisDialog*      m_analyzeGameRecordDialog = nullptr;

    // --- モデル群 ---
    KifuRecordListModel*       m_kifuRecordModel  = nullptr;
    KifuBranchListModel*       m_kifuBranchModel  = nullptr;
    ShogiEngineThinkingModel*  m_modelThinking1   = nullptr;
    ShogiEngineThinkingModel*  m_modelThinking2   = nullptr;
    KifuAnalysisListModel*     m_analysisModel    = nullptr;
    UsiCommLogModel*           m_lineEditModel1   = nullptr; // Engine 1 info
    UsiCommLogModel*           m_lineEditModel2   = nullptr; // Engine 2 info

    // --- 記録 / 評価 / 表示用データ ---
    QList<int>        m_scoreCp;
    QString           m_humanName1, m_humanName2;
    QString           m_engineName1, m_engineName2;
    QStringList*      m_sfenRecord   = nullptr;
    QList<KifuDisplay *>* m_moveRecords = nullptr;
    QStringList       m_kifuDataList;
    QString           defaultSaveFileName;
    QString           kifuSaveFileName;
    QVector<ShogiMove> m_gameMoves;

    // --- 時計 / 時刻管理 ---
    ShogiClock* m_shogiClock = nullptr;
    qint64      m_initialTimeP1Ms = 0;
    qint64      m_initialTimeP2Ms = 0;

    QVector<ResolvedRow> m_resolvedRows;
    int m_activeResolvedRow = 0;

    // --- KIFヘッダ（対局情報）タブ ---
    QDockWidget*  m_gameInfoDock  = nullptr;
    QTableWidget* m_gameInfoTable = nullptr;

    // --- 棋譜表示／分岐操作・表示関連 ---
    QTableView* m_kifuBranchView        = nullptr; // 旧UI互換の受け皿
    QTableView* m_analysisResultsView   = nullptr; // 解析結果テーブル
    QList<KifDisplayItem> m_dispMain;
    QSet<int> m_branchablePlySet;
    QVector<QString> m_commentsByRow;
    int m_activePly          = 0;
    int m_currentSelectedPly = 0;
    QMetaObject::Connection m_connKifuRowChanged;
    bool m_onMainRowGuard = false; // 再入防止

    // --- 装飾（棋譜テーブル マーカー描画） ---
    class BranchRowDelegate : public QStyledItemDelegate {
    public:
        explicit BranchRowDelegate(QObject* parent = nullptr)
            : QStyledItemDelegate(parent) {}
        void setMarkers(const QSet<int>* marks) { m_marks = marks; }
        void paint(QPainter* painter,
                   const QStyleOptionViewItem& option,
                   const QModelIndex& index) const override;
    private:
        const QSet<int>* m_marks = nullptr;
    };

    // --- 新UI部品 / ナビゲーション ---
    RecordPane*           m_recordPane = nullptr;
    NavigationController* m_nav = nullptr;
    EngineAnalysisTab*    m_analysisTab = nullptr;

    // --- 試合進行（司令塔） ---
    MatchCoordinator* m_match = nullptr;
    QMetaObject::Connection m_timeConn{};
    bool m_isReplayMode = false;

    // ========================================================
    // Private Methods（用途別）
    // ========================================================

    // --- UI / 表示更新 ---
    void updateGameRecord(const QString& elapsedTime);
    void updateTurnStatus(int currentPlayer);
    void redrawEngine1EvaluationGraph();
    void redrawEngine2EvaluationGraph();

    // --- 初期化 / セットアップ ---
    void initializeComponents();
    void setupHorizontalGameLayout();
    void initializeCentralGameDisplay();
    void ensureClockReady_();
    void initMatchCoordinator();
    void setupRecordPane();
    void setupEngineAnalysisTab();
    void setupBoardInteractionController();

    // --- ゲーム開始/切替 ---
    void initializeNewGame(QString& startSfenStr);
    void startNewShogiGame(QString& startSfenStr);
    void setEngineNamesBasedOnMode();

    // --- 入出力 / 設定 ---
    void saveWindowAndBoardSettings();
    void loadWindowSettings();

    // --- KIF ヘッダ（対局情報）周り ---
    void ensureGameInfoTable();

    // --- 分岐 / 変化 ---
    void applyResolvedRowAndSelect(int row, int selPly);

    // --- ユーティリティ ---
    void setPlayersNamesForMode();
    void setCurrentTurn();

    void setGameOverMove(MatchCoordinator::Cause cause, bool loserIsPlayerOne);
    void appendKifuLine(const QString& text, const QString& elapsedTime);

    // コメントを両画面にブロードキャスト
    void broadcastComment(const QString& text, bool asHtml=false);

    std::unique_ptr<KifuVariationEngine> m_varEngine;

public slots:
    // --- ファイル I/O / 外部操作（★重複宣言禁止：ここだけに置く） ---
    void chooseAndLoadKifuFile();
    void saveShogiBoardImage();
    void copyBoardToClipboard();
    void openWebsiteInExternalBrowser();
    void saveKifuToFile();
    void overwriteKifuFile();

    // --- エラー/一般UI ---
    void displayErrorMessage(const QString& message);
    void saveSettingsAndClose();
    void resetToInitialState();
    void onFlowError_(const QString& msg);

    // --- ダイアログ表示 ---
    void displayPromotionDialog();
    void displayEngineSettingsDialog();
    void displayVersionInformation();
    void displayConsiderationDialog();
    void displayKifuAnalysisDialog();
    void displayTsumeShogiSearchDialog();

    // --- 追加：不足でエラーになっていた slots ---
    void toggleEngineAnalysisVisibility();
    void undoLastTwoMoves();

    // --- 盤編集 / 表示 ---
    void beginPositionEditing();
    void finishPositionEditing();

    // --- ゲーム開始 / 終了 ---
    void initializeGame();
    void handleResignation();

    void onActionFlipBoardTriggered(bool checked = false);

    void handleBreakOffGame();

    // 検討（ConsidarationMode）の手動終了（quit 送信）
    void handleBreakOffConsidaration();

    void movePieceImmediately();

    void onRecordPaneMainRowChanged_(int row);

private slots:
    void onMatchGameEnded(const MatchCoordinator::GameEndInfo& info);
    void flipBoardAndUpdatePlayerInfo();

    // --- 時計 / タイムアウト ---
    void onPlayer1TimeOut();
    void onPlayer2TimeOut();

    // --- ボタン有効/無効 ---
    void disableArrowButtons();
    void enableArrowButtons();

    // --- 盤面・反転 ---
    void onBoardFlipped(bool nowFlipped);

    void onReverseTriggered();

    // --- 司令塔（時計/進行）通知受け口 ---
    void onRequestAppendGameOverMove(const MatchCoordinator::GameEndInfo& info);

    // --- クリック/移動要求（コントローラ配線） ---
    void onMoveRequested_(const QPoint& from, const QPoint& to);

    // --- リプレイ（UI 側単一ソース管理） ---
    void setReplayMode(bool on);

    // --- 内部配線 ---
    void connectBoardClicks_();
    void connectMoveRequested_();

private slots:
    void onMoveCommitted(ShogiGameController::Player mover, int ply);
    void displayGameRecord(const QList<KifDisplayItem> disp);
    void syncBoardAndHighlightsAtRow(int ply1);
    void onRecordRowChangedByPresenter(int row, const QString& comment);

private:
    QWidget*     m_central = nullptr;
    QVBoxLayout* m_centralLayout = nullptr;

    BranchCandidatesController* m_branchCtl = nullptr;

    // 行(row) → (ply → 表示計画) の保持
    // 例: m_branchDisplayPlan[row][ply]
    QHash<int, QMap<int, BranchCandidateDisplay>> m_branchDisplayPlan;

    // 選択（行row, 手数ply）から、ハイライトすべき(variation id, ply)を解決
    std::pair<int,int> resolveBranchHighlightTarget(int row, int ply) const;

    // 直近の手番と残時間（回転直後の復元に使う）
    bool   m_lastP1Turn = true;
    qint64 m_lastP1Ms   = 0;
    qint64 m_lastP2Ms   = 0;

    // 描画ヘルパ
    void setupNameAndClockFonts_();           // フォント明示設定

private slots:
    void onBranchNodeActivated_(int row, int ply);
    void onGameOverStateChanged(const MatchCoordinator::GameOverState& st);
    void onTurnManagerChanged(ShogiGameController::Player now);

private:
    // いま下段が先手(P1)か？ true=先手が手前、false=後手が手前
    bool m_bottomIsP1 = true;


    bool m_isLiveAppendMode = false;
    void exitLiveAppendMode_();   // 終局で選択を元に戻す

    bool m_isResumeFromCurrent = false;

    void ensureTurnSyncBridge_();

    KifuLoadCoordinator* m_kifuLoadCoordinator = nullptr;

private:
    PositionEditController* m_posEdit = nullptr;

    void ensurePositionEditController_();

private slots:
    void onErrorBusOccurred(const QString& msg);
    void onPreStartCleanupRequested_();
    void onApplyTimeControlRequested_(const GameStartCoordinator::TimeControl& tc);

private:
    // --- ctorの分割先 ---
    void setupCentralWidgetContainer_();   // centralWidget と QVBoxLayout を一度だけ構築
    void configureToolBarFromUi_();        // ツールバーのアイコン/スタイル初期化
    void buildGamePanels_();               // 棋譜ペイン/分岐配線/レイアウト/タブなどUI骨格
    void restoreWindowAndSync_();          // ウィンドウ設定の復元（同期は initializeComponents 内で実施）
    void connectAllActions_();             // メニュー/アクション群のconnect
    void connectCoreSignals_();            // GC/ビュー/エラーバス等のconnect
    void installAppToolTips_();            // コンパクトツールチップのインストール
    void finalizeCoordinators_();          // 司令塔やフォント/位置編集コントローラの最終初期化

private:
    BoardSyncPresenter* m_boardSync = nullptr;
    AnalysisResultsPresenter* m_analysisPresenter = nullptr;

    void ensureBoardSyncPresenter_();
    void ensureAnalysisPresenter_();

    GameStartCoordinator* m_gameStart = nullptr;
    void ensureGameStartCoordinator_();

    GameRecordPresenter* m_recordPresenter {nullptr};
    void ensureRecordPresenter_();
    QPointer<AnalysisFlowController> m_analysisFlow;

    GameStartCoordinator* m_gameStartCoordinator = nullptr;

    // hooks 用のメンバー関数（ラムダ不使用）
    void requestRedrawEngine1Eval_();
    void requestRedrawEngine2Eval_();
    void initializeNewGame_(const QString& s);
    void showMoveHighlights_(const QPoint& from, const QPoint& to);
    void appendKifuLineHook_(const QString& text, const QString& elapsed);

    BranchWiringCoordinator* m_branchWiring = nullptr;

    TimeDisplayPresenter* m_timePresenter = nullptr;

    AnalysisTabWiring* m_analysisWiring = nullptr;

    qint64 getRemainingMsFor_(MatchCoordinator::Player p) const;
    qint64 getIncrementMsFor_(MatchCoordinator::Player p) const;
    qint64 getByoyomiMs_() const;

    void showGameOverMessageBox_(const QString& title, const QString& message);

private slots:
    void onResignationTriggered();

    // MainWindow の private メンバに追加
private:
    RecordPaneWiring*     m_recordPaneWiring = nullptr;
    UiActionsWiring*      m_actionsWiring    = nullptr;   // 既に作っていればそのまま
    GameLayoutBuilder*    m_layoutBuilder    = nullptr;   // 既に作っていればそのまま

    void ensureKifuLoadCoordinatorForLive_();
    void refreshBranchTreeLive_();

    QList<KifDisplayItem> m_liveDisp;

private:
    bool getMainRowGuard_() const;
    void setMainRowGuard_(bool on);
    bool isHvH_() const;
    bool isHumanSide_(ShogiGameController::Player p) const;
    void updateTurnAndTimekeepingDisplay_();

    void initializeEditMenuForStartup();
    void applyEditMenuEditingState(bool editing);

    QString resolveCurrentSfenForGameStart_() const;
};

#endif // MAINWINDOW_H
#ifndef MATCHCOORDINATOR_H
#define MATCHCOORDINATOR_H

#include <QObject>
#include <QString>
#include <functional>
#include <QStringList>
#include <QVector>
#include <QDateTime>
#include <QElapsedTimer>

#include "shogigamecontroller.h"
#include "shogimove.h"
#include "playmode.h"

class UsiCommLogModel;
class ShogiEngineThinkingModel;
class ShogiGameController;
class ShogiClock;
class ShogiView;
class Usi;
class KifuRecordListModel;
class BoardInteractionController;
class StartGameDialog;

// 対局進行/終局/時計/USI送受のハブ（寿命は Main 側で管理）
class MatchCoordinator : public QObject {
    Q_OBJECT

public:
    enum Player : int { P1 = 1, P2 = 2 };

    // ★ BreakOff を追加（中断終局）
    enum class Cause : int { Resignation = 0, Timeout = 1, BreakOff = 2 };

    struct GoTimes {
        qint64 btime = 0;   // 先手 残り(ms)
        qint64 wtime = 0;   // 後手 残り(ms)
        qint64 byoyomi = 0; // 共通 秒読み(ms)
        qint64 binc = 0;    // 先手 増加(ms)
        qint64 winc = 0;    // 後手 増加(ms)
    };

    struct GameEndInfo {
        Cause  cause = Cause::Resignation;
        Player loser = P1;
    };

    // 直近の終局状態（既存仕様を維持）
    struct GameOverState {
        bool        isOver       = false;
        bool        moveAppended = false;
        bool        hasLast      = false;
        bool        lastLoserIsP1= false;
        GameEndInfo lastInfo;
        QDateTime   when;
    };

    struct Hooks {
        // --- UI/描画系の委譲 ---
        std::function<void(Player cur)> updateTurnDisplay; // 盤面の手番表示/ハイライト
        std::function<void(const QString& p1, const QString& p2)> setPlayersNames;
        std::function<void(const QString& e1, const QString& e2)> setEngineNames;
        std::function<void(bool inProgress)> setGameActions; // NewGame/Resign 等のON/OFF
        std::function<void()> renderBoardFromGc;             // gc→view 反映
        std::function<void(const QString& title, const QString& message)> showGameOverDialog;
        std::function<void(const QString& msg)> log;         // 任意ログ
        // 追加：直前の着手（移動元→先）のハイライト
        std::function<void(const QPoint& from, const QPoint& to)> showMoveHighlights;

        // --- 時計読み出し（ShogiClock API 差異吸収） ---
        std::function<qint64(Player)> remainingMsFor; // 残り時間
        std::function<qint64(Player)> incrementMsFor; // フィッシャー増加
        std::function<qint64()> byoyomiMs;            // 秒読み（共通）

        // HvE: 人間側の手番（P1/P2）を返す（finishHumanTimer...で使用）
        std::function<Player()> humanPlayerSide = nullptr;

        // --- USI 送受（go/stop/任意生コマンド） ---
        std::function<void(Usi* which, const GoTimes& t)> sendGoToEngine;
        std::function<void(Usi* which)> sendStopToEngine;
        std::function<void(Usi* which, const QString& cmd)> sendRawToEngine; // 任意

        // --- 新規対局の初期化（GUI固有処理） ---
        std::function<void(const QString& sfenStart)> initializeNewGame;

        // ★ 棋譜1行追記（例：text="▲７六歩", elapsed="00:03/00:00:06"）
        std::function<void(const QString& text, const QString& elapsed)> appendKifuLine;

        std::function<void()> appendEvalP1; // P1(先手)エンジンが着手確定 → 評価値を1本目に追記
        std::function<void()> appendEvalP2; // P2(後手)エンジンが着手確定 → 評価値を2本目に追記
    };

    struct Deps {
        ShogiGameController* gc = nullptr;
        ShogiClock*          clock = nullptr;
        ShogiView*           view = nullptr;
        Usi*                 usi1 = nullptr;
        Usi*                 usi2 = nullptr;
        UsiCommLogModel*           comm1 = nullptr;
        ShogiEngineThinkingModel*  think1 = nullptr;
        UsiCommLogModel*           comm2 = nullptr;
        ShogiEngineThinkingModel*  think2 = nullptr;
        Hooks                hooks;
        QStringList* sfenRecord = nullptr;
    };

    explicit MatchCoordinator(const Deps& deps, QObject* parent=nullptr);
    ~MatchCoordinator() override;

    // 外部 API
    void startNewGame(const QString& sfenStart);
    void handleResign();                 // 人間の投了
    void handleEngineResign(int idx);    // エンジン投了通知(1 or 2)
    void notifyTimeout(Player loser);    // ★ 時間切れ通知（UI→司令塔）
    void flipBoard();                    // 盤反転 + 表示更新
    void onTurnFinishedAndSwitch();      // 手番切替時（時計/UI更新 + go送信）
    void updateUsiPtrs(Usi* e1, Usi* e2);// エンジン再生成時などに差し替え
    void handleBreakOff();               // ★ 中断（UI→司令塔）

    // === 時間管理（MainWindowから移譲） ===
    struct TimeControl {
        bool useByoyomi    = false;
        int  byoyomiMs1    = 0;
        int  byoyomiMs2    = 0;
        int  incMs1        = 0;
        int  incMs2        = 0;
        bool loseOnTimeout = false;
    };

    void setTimeControlConfig(bool useByoyomi,
                              int byoyomiMs1, int byoyomiMs2,
                              int incMs1,     int incMs2,
                              bool loseOnTimeout);
    const TimeControl& timeControl() const;

    // HvH/HvE: 1手の開始エポック管理（KIF表示用）
    void   markTurnEpochNowFor(Player side, qint64 nowMs = -1);
    qint64 turnEpochFor(Player side) const;
    void   resetTurnEpochs();

    // HvH: ターン計測
    void armTurnTimerIfNeeded();
    void finishTurnTimerAndSetConsiderationFor(Player mover);

    // HvE: 人間の計測
    void armHumanTimerIfNeeded();
    void finishHumanTimerAndSetConsideration();
    void disarmHumanTimerIfNeeded();

    // USI時間
    void computeGoTimesForUSI(qint64& outB, qint64& outW) const;
    void refreshGoTimes();
    int  computeMoveBudgetMsForCurrentTurn() const;

    // --- public: Main からの委譲で呼ばれるAPIを追加 ---
public:
    // MainWindow::initializePositionStringsForMatch_ の置き換え
    void initializePositionStringsForStart(const QString& sfenStart);

    // MainWindow::startInitialEngineMoveIfNeeded_ / startInitialEngineMoveEvH_ の置き換え
    void startInitialEngineMoveIfNeeded();

    void onHumanMove_HvE(const QPoint& humanFrom, const QPoint& humanTo);

    // 追加：人間の整形済み棋譜文字列（prettyMove）を受け取る版
    void onHumanMove_HvE(const QPoint& humanFrom, const QPoint& humanTo, const QString& prettyMove);

public:
    // --- 既存の Deps 等はそのまま ---

    // UNDO に必要な参照（ランタイム状態を司令塔に集約）
    struct UndoRefs {
        KifuRecordListModel*          recordModel      = nullptr;
        QVector<ShogiMove>*           gameMoves        = nullptr;
        QStringList*                  positionStrList  = nullptr;  // 可：null
        QStringList*                  sfenRecord       = nullptr;  // 可：null
        int*                          currentMoveIndex = nullptr;

        ShogiGameController*          gc       = nullptr;
        BoardInteractionController*   boardCtl = nullptr;
        ShogiClock*                   clock    = nullptr;
        ShogiView*                    view     = nullptr;
    };

    // MainWindow に残す UI/雑務（評価値巻戻し/ハイライト/表示更新/ガード）のフック群
    struct UndoHooks {
        std::function<bool()>                         getMainRowGuard;               // 省略可
        std::function<void(bool)>                     setMainRowGuard;               // 省略可
        std::function<void(int /*ply*/)>              updateHighlightsForPly;        // 推奨
        std::function<void()>                         updateTurnAndTimekeepingDisplay; // 推奨
        std::function<void(int /*moveNumber*/)>       handleUndoMove;                // 推奨（評価値等）
        std::function<bool(ShogiGameController::Player)> isHumanSide;                // 必須
        std::function<bool()>                         isHvH;                         // 必須（H2H 共有タイマか）
    };

    // MainWindow から一度セット
    void setUndoBindings(const UndoRefs& refs, const UndoHooks& hooks);

    // ← これが MainWindow::undoLastTwoMoves の移行先
    bool undoTwoPlies();

private slots:
    void armTimerAfterUndo_();

private:
    bool tryRemoveLastItems_(QObject* model, int n);
    bool m_isUndoInProgress = false;
    UndoRefs  u_;
    UndoHooks h_;

// --- private: 内部ヘルパ ---
private:
    void initPositionStringsFromSfen_(const QString& sfenBase);
    void startInitialEngineMoveFor_(Player engineSide);  // 先手/後手どちらでも1手だけ指す

signals:
    void gameOverShown();
    void boardFlipped(bool nowFlipped);
    void gameStarted();
    void gameEnded(const GameEndInfo& info);

    // MainWindow はこれを受けて m_bTime/m_wTime を表示用に更新するだけ
    void timesForUSIUpdated(qint64 bMs, qint64 wMs);

    // p1ms/p2ms: 両者の残りミリ秒
    // p1turn   : 現在手番が先手なら true
    // urgencyMs: 盤の緊急カラー用 ms（非緊急なら std::numeric_limits<qint64>::max()）
    void timeUpdated(qint64 p1ms, qint64 p2ms, bool p1turn, qint64 urgencyMs);

private:
    // NOTE: QPointer は使わず raw ポインタ（寿命は Main 側で管理）
    ShogiGameController* m_gc   = nullptr;
    ShogiClock*          m_clock= nullptr;
    ShogiView*           m_view = nullptr;
    Usi*                 m_usi1 = nullptr;
    Usi*                 m_usi2 = nullptr;
    Hooks                m_hooks;

    Player m_cur = P1;

private:
    // Main から段階的に移す関数群
    void setPlayersNamesForMode_();
    void setEngineNamesBasedOnMode_();
    void setGameInProgressActions_(bool inProgress);
    void renderShogiBoard_();
    void updateTurnDisplay_(Player p);

    // 時計/USI 時間計算
    GoTimes computeGoTimes_() const;

    // 終局処理
    void stopClockAndSendStops_();
    void displayResultsAndUpdateGui_(const GameEndInfo& info);

public:
    // MainWindow からエンジン初期化/開始を委譲するための統一API
    // side: P1 or P2
    void initializeAndStartEngineFor(Player side,
                                     const QString& enginePathIn,
                                     const QString& engineNameIn);

    // resign シグナルの配線（司令塔→自分の onXxx に直結）
    void wireResignSignals();

    // ゲームオーバー（win+quit）を一方のエンジンに送る
    void sendGameOverWinAndQuitTo(int idx); // idx: 1 or 2

    // エンジン破棄（片方 or 両方）
    void destroyEngine(int idx);   // idx: 1 or 2
    void destroyEngines();

    // （移行ステップ用）ポインタ参照が必要な場合に備えたアクセサ
    Usi* enginePtr(int idx) const; // 1 or 2 → Usi*

private:
    // resign 配線の実装（内部ユーティリティ）
    void wireResignToArbiter_(Usi* engine, bool asP1);

    // 保有エンジンから index を求める（1/2/0）
    int indexForEngine_(const Usi* p) const;

    // 共通ロジック：時計と手番を読んで timeUpdated(...) を発火
    void emitTimeUpdateFromClock_();

private slots:
    void onEngine1Resign();
    void onEngine2Resign();
    void kickNextEvETurn_();  // EvE を1手ずつ進める
    void onClockTick_();

    void onUsiBestmoveDuringTsume_(const QString& bestmove);

    void onUsiError_(const QString& msg);

public slots:
    // 即時に現在値で timeUpdated(...) を発火（UIをすぐ同期させたい時に使う）
    void pokeTimeUpdateNow();

public:
    // ↓↓↓ 追加（PlayMode を司令塔に設定）
    void setPlayMode(PlayMode m);

    // ↓↓↓ 追加（EvE 用のエンジン生成・配線・初期化）
    void initEnginesForEvE(const QString& engineName1,
                           const QString& engineName2);

    // ↓↓↓ 追加（エンジン手進行ロジックの集約）
    bool engineThinkApplyMove(Usi* engine,
                              QString& positionStr,
                              QString& ponderStr,
                              QPoint* outFrom,
                              QPoint* outTo);

    bool engineMoveOnce(Usi* eng,
                        QString& positionStr,
                        QString& ponderStr,
                        bool /*useSelectedField2*/,
                        int engineIndex,
                        QPoint* outTo);

    bool playOneEngineTurn(Usi* mover,
                           Usi* receiver,
                           QString& positionStr,
                           QString& ponderStr,
                           int engineIndex);

    // ↓↓↓ 追加（PlayMode に応じた WIN+QUIT 通知を内包）
    void sendGameOverWinAndQuit();

private:
    PlayMode                 m_playMode = NotStarted;
    UsiCommLogModel*         m_comm1    = nullptr;
    ShogiEngineThinkingModel*m_think1   = nullptr;
    UsiCommLogModel*         m_comm2    = nullptr;
    ShogiEngineThinkingModel*m_think2   = nullptr;

public:
    // 対局開始のためのオプション
    struct StartOptions {
        PlayMode mode = NotStarted;
        QString  sfenStart;

        // エンジン情報（必要なら空でもOK）
        QString engineName1;
        QString enginePath1;
        QString engineName2;
        QString enginePath2;

        // HvE の場合、エンジンがどちら側か
        bool engineIsP1 = false;
        bool engineIsP2 = false;
    };

    // 対局開始フローを一元化
    void configureAndStart(const StartOptions& opt);

    // ==== 追加：検討用オプション ====
    struct AnalysisOptions {
        QString  enginePath;   // 検討に使うエンジン実行ファイル
        QString  engineName;   // 表示用エンジン名
        QString  positionStr;  // "position sfen ... [moves ...]" の完全文字列
        int      byoyomiMs = 0;           // 0=無制限、>0=秒→ms
        PlayMode mode      = ConsidarationMode; // 既定で検討モード
    };

    // ==== 追加：検討API ====
    void startAnalysis(const AnalysisOptions& opt);
    void stopAnalysis();
    bool isAnalysisActive() const;

    // ==== 追加：棋譜解析 継続API ====
    // 既に startAnalysis() 済みの単発エンジンを使い回し、次の position を送って解析を継続する（途中では quit しない）
    void continueAnalysis(const QString& positionStr, int byoyomiMs);

public:
    Usi* primaryEngine() const;   // HvE/EvH で司令塔が使う主エンジン（これまで m_usi1 に相当）
    Usi* secondaryEngine() const; // ★ 追加

private:
    // 内部ヘルパ
    void startHumanVsHuman_(const StartOptions& opt);
    void startHumanVsEngine_(const StartOptions& opt, bool engineIsP1);
    void initPositionStringsForEvE_();        // ← 新規ヘルパ
    void startEngineVsEngine_(const StartOptions& /*opt*/);

private:
    // USI "position ... moves" の作業用バッファ
    QString m_positionStr1, m_positionPonder1;
    QString m_positionStr2, m_positionPonder2;

    // 棋譜／SFEN 記録（ShogiGameController::validateAndMove の引数用）
    int m_currentMoveIndex = 0;

    // ★変更：内部保持をやめ、共有ポインタに
    QStringList* m_sfenRecord = nullptr;

    QVector<ShogiMove> m_gameMoves;
    // EvE 専用の棋譜保持（MainWindow から独立）
    QStringList        m_eveSfenRecord;
    QVector<ShogiMove> m_eveGameMoves;
    int                m_eveMoveIndex = 0;

private:
    // 「その手の開始」エポック（KIFの消費時間計算に使用）
    qint64 m_turnEpochP1Ms = -1;
    qint64 m_turnEpochP2Ms = -1;

    // USI表記用の直近文字列（MainWindow側はラベル更新のみ）
    QString m_bTimeStr, m_wTimeStr;

    // 時間ルール（byoyomi / increment / timeout）
    TimeControl m_tc;
    // === ここから MainWindow から移した状態 ===
    // ターン計測（HvH）
    QElapsedTimer m_turnTimer;
    bool          m_turnTimerArmed  = false;

    // 人間側の計測（HvE）
    QElapsedTimer m_humanTurnTimer;
    bool          m_humanTimerArmed = false;

public:
    // 既存 Deps に clock が入ってこない場合に備えて、後から差し替え可能に
    void setClock(ShogiClock* clock);

private:
    void wireClock_();           // ★追加：時計と onClockTick_ の connect を一元化
    void unwireClock_();         // ★追加：既存接続の解除
    QMetaObject::Connection m_clockConn; // ★追加：接続ハンドル保持

public:
    // ---- [GameOver 統合API] ----
    const GameOverState& gameOverState() const { return m_gameOver; }
    void clearGameOverState();  // 対局開始/局面編集開始などで呼ぶ
    void setGameOver(const GameEndInfo& info, bool loserIsP1, bool appendMoveOnce = true);
    void markGameOverMoveAppended(); // MainWindow が棋譜に一意追記後に通知

signals:
    // 既存: gameEnded(const GameEndInfo& info) はそのまま活用
    void gameOverStateChanged(const GameOverState& st);      // 参照側UI向け
    void requestAppendGameOverMove(const GameEndInfo& info); // 必要なら司令塔から一意追記をリクエスト

private:
    // ...（既存）
    GameOverState m_gameOver;

    void startTsumeSearch(const QString& sfen, int timeMs, bool infinite);
    void stopTsumeSearch();

public:
    // ==== 追加：検討の強制終了（quit送信→エンジン破棄） ====
    void handleBreakOffConsidaration();

private slots:
    void onCheckmateSolved_(const QStringList& pv);
    void onCheckmateNoMate_();
    void onCheckmateNotImplemented_();
    void onCheckmateUnknown_();

public:
    StartOptions buildStartOptions(PlayMode mode,
                                   const QString& startSfenStr,
                                   const QStringList* sfenRecord,
                                   const StartGameDialog* dlg) const;

    void ensureHumanAtBottomIfApplicable(const StartGameDialog* dlg, bool bottomIsP1);

    // ★新規：準備→開始→必要なら初手 go までを一括実行
    void prepareAndStartGame(PlayMode mode,
                             const QString& startSfenStr,
                             const QStringList* sfenRecord,
                             const StartGameDialog* dlg,
                             bool bottomIsP1);

    // ★ 今回追加：時間/手番・終局の処理（MainWindowから移管）
    void handleTimeUpdated();
    void handlePlayerTimeOut(int player); // 1 or 2
    void handleResignationRequest();
    void handleGameEnded();
    void handleGameOverStateChanged();

    // ★ 開始直後のタイマー起動や初手 go 判定を1本化
    void startMatchTimingAndMaybeInitialGo();

signals:
    // UIへは最小限の“文字列/色”等だけ通知（Presenterで受ける前提でもOK）
    void uiUpdateTurnAndClock(const QString& turnText,
                              const QString& p1Text,
                              const QString& p2Text);
    void uiNotifyTimeout(int player);
    void uiNotifyResign();
    void uiNotifyGameEnded();

    // 司令塔内のタイムティックが進んだ際（MainWindowはこの1本でUI更新に反応）
    void timeTick();

private:
    // 内部の計算ヘルパ（UI非依存）
    void recomputeClockSnapshot(QString& turnText, QString& p1, QString& p2) const;

public:
    // 現在のプレイモードを外部に公開
    PlayMode playMode() const;

    // 終局1回だけの棋譜追記（投了/時間切れ）と重複防止を司令塔で一括処理
    void appendGameOverLineAndMark(Cause cause, Player loser);

    // HvH：人間が指した直後の後処理（時計の消費設定／次手番開始など）を司令塔で一括実行
    void onHumanMove_HvH(ShogiGameController::Player moverBefore);

public:
    // 現在の状況に応じて適切なエンジンへ stop を送り、即時bestmoveを促す
    void forceImmediateMove();

private:
    void sendGoToCurrentEngine_(const GoTimes& t);
    void sendStopAllEngines_();
    void sendRawTo_(Usi* which, const QString& cmd);

    // USI "position ... moves" の履歴（UNDO等で使う）。SFENとは混ぜないこと！
    QStringList m_positionStrHistory;

public:
    // ・・・既存の public API の末尾あたりに追記・・・
    void sendGoTo(Usi* engine, const GoTimes& t);
    void sendStopTo(Usi* engine);
    void sendRawTo(Usi* engine, const QString& cmd);

    // --- USI 送受の実体（UI 依存なし） ---
    void sendGoToEngine(Usi* which, const GoTimes& t);
    void sendStopToEngine(Usi* which);
    void sendRawToEngine(Usi* which, const QString& cmd);

    // BreakOff（中断）時の棋譜1行追記＋二重追記ブロック確定
    void appendBreakOffLineAndMark();

    // ShogiClock 取得アクセサ
    ShogiClock*       clock();       // 非const版
    const ShogiClock* clock() const; // const版
};

#endif // MATCHCOORDINATOR_H
#ifndef MOVEVALIDATOR_H
#define MOVEVALIDATOR_H

#include <bitset>
#include <QVector>
#include <QStringList>
#include "shogimove.h"
#include "legalmovestatus.h"
#include <QMap>
#include <QObject>

// 指した手が合法手であるかどうかを判定するクラス
class MoveValidator : public QObject
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit MoveValidator(QObject* parent = nullptr);

    // 駒番号を表す列挙型
    enum PieceType {
        PAWN,
        LANCE,
        KNIGHT,
        SILVER,
        GOLD,
        BISHOP,
        ROOK,
        KING,
        PROMOTED_PAWN,
        PROMOTED_LANCE,
        PROMOTED_KNIGHT,
        PROMOTED_SILVER,
        HORSE,
        DRAGON,
        PIECE_TYPE_SIZE
    };

    // 先手番、後手番を示す列挙型
    enum Turn { BLACK, WHITE, TURN_SIZE };

    // 駒の種類数
    static constexpr int NUM_PIECE_TYPES = PIECE_TYPE_SIZE;

    // 対局者数（先手と後手）
    static constexpr int NUM_PLAYERS = TURN_SIZE;

    // 盤面の1辺のマス数（列数と段数）
    static constexpr int BOARD_SIZE = 9;

    // 将棋盤のマス数
    static constexpr int NUM_BOARD_SQUARES = BOARD_SIZE * BOARD_SIZE;

    // 指し手が合法手かどうかを判定する。
    LegalMoveStatus isLegalMove(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand, ShogiMove& currentMove);

    // 指定局面での合法手を生成する。
    int generateLegalMoves(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand);

signals:
    // エラーを報告するためのシグナル
    void errorOccurred(const QString& errorMessage);

private:
    // 全ての駒の種類を1文字のアルファベットで表す。
    QVector<QChar> m_allPieces;

    // 先手と後手の駒台の順序番号
    QMap<QChar, int> m_pieceOrderBlack;
    QMap<QChar, int> m_pieceOrderWhite;

    // 二歩のチェック
    // 先手あるいは後手の歩が同じ筋に複数存在する場合、二歩が存在すると判定する。
    void checkDoublePawn(const QVector<QChar>& boardData);

    // 各駒の数が最大数を超えていないかチェックする。
    void checkPieceCount(const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand);

    // 玉が一方の対局者につき一つ存在していることをチェックする。
    void checkKingPresence(const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand);

    // この関数は、将棋の盤面上の各駒が適切な位置にあるかどうかをチェックする。
    void checkCorrectPosition(const QVector<QChar>& boardData);

    // 先手および後手、各駒の種類ごとのbitboardを表す型を略称化
    using BoardStateArray = std::array<std::array<std::bitset<NUM_BOARD_SQUARES>, NUM_PIECE_TYPES>, NUM_PLAYERS>;

    // 先手、後手の2種類
    // 歩、香車、桂馬、銀、金、角、飛車、玉、と金、成香、成桂、成銀、馬、龍の14種類
    // の合計28種類の駒が存在するマスを表すbitboardを作成する。
    void generateBitboard(const QVector<QChar>& boardData, BoardStateArray& piecePlacedBitboard) const;

    // piecePlacedBitboardの標準出力する。
    void printBitboards(const BoardStateArray& piecePlacedBitboard) const;

    // 味方の各駒が存在するbitBoard中でindexで指定されたマスに味方の駒が存在するかどうかを判定する。
    bool isPieceOnSquare(int& index, const std::array<std::bitset<NUM_BOARD_SQUARES>, NUM_PIECE_TYPES>& turnBitboards) const;

    // 盤面データboardDataからtargetPieceに該当する駒が存在するマスを表すbitboardを各駒ごとに作成し、そのリストを返す。
    QVector<std::bitset<NUM_BOARD_SQUARES>> generateIndividualPieceBitboards(const QVector<QChar>& boardData, const QChar& targetPiece) const;

    // 先手の歩、先手の香車、先手の桂馬〜先手の龍、
    // 後手の歩、後手の香車、後手の桂馬〜後手の龍の28種類に分けて
    // 各駒ごとに駒が存在するマスを表すbitboardを作成する。
    // 例．平手で各40個の駒それぞれが存在するマスを示すbitboard
    // 先手の1七歩の場合
    // Piece: P
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 1
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    void generateAllPieceBitboards(QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards, const QVector<QChar>& boardData) const;

    // allPieceBitboardsの出力
    // 例．平手で各40個の駒それぞれが存在するマスを示すbitboard
    // 先手の1七歩の場合
    // Piece: P
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 1
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    void printAllPieceBitboards(const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards) const;

    // 各個々の駒が移動できるマスを表すbitboardを作成する。
    // 例．平手で各40個の駒の移動可能なマスを示すbitboard
    // 先手の1七歩の場合、1六に移動できる。
    // Piece: P
    // 先手:
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 1
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    void generateAllIndividualPieceAttackBitboards(const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards, const BoardStateArray& piecePlacedBitboard,
                                                   QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceAttackBitboards) const;

    // allPieceAttackBitboardsの出力
    // 例．平手で各40個の駒の移動可能なマスを示すbitboard
    // 先手の1七歩の場合、1六に移動できる。
    // Piece: P
    // 先手:
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 1
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    void printIndividualPieceAttackBitboards(const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards,
                                             const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceAttackBitboards) const;

    // 盤上の駒を動かした場合の全指し手リスト生成
    void generateShogiMoveFromBitboards(const Turn& turn, const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards,
                                        const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceAttackBitboards,
                                        QVector<ShogiMove>& allMovesList, const QVector<QChar>& boardData) const;

    // bitboardリストから各bitboardを取り出し、そのbitboardの内容を標準出力する。
    void printBitboardContent(const QVector<std::bitset<NUM_BOARD_SQUARES>>& bitboards) const;

    // 各駒が存在するマスの位置を示すsinglePieceBitboardから移動可能なマスの位置を示すattackBitboardを生成する。
    void generateSinglePieceAttackBitboard(std::bitset<MoveValidator::NUM_BOARD_SQUARES>& attackBitboard, const std::bitset<NUM_BOARD_SQUARES>& singlePieceBitboard,
                                           const Turn& turn, QChar pieceType, const BoardStateArray& piecePlacedBitboard) const;

    // 特定の種類の駒が攻撃可能なマスを表すビットボードを生成する。
    // continuousは、駒が連続して移動できるか（飛車、角、馬、龍など）を指定する。
    // enemyOccupiedStopは、敵の駒が存在するマスに到達した時点で駒の進行を止めるかを指定する（飛車、角、馬、龍など）。
    void generateAttackBitboard(std::bitset<NUM_BOARD_SQUARES>& attackBitboard, const Turn& turn,
                                const BoardStateArray& piecePlacedBitboard, const std::bitset<NUM_BOARD_SQUARES>& pieceBitboard,
                                const QList<QPoint>& directions, bool continuous, bool enemyOccupiedStop) const;

    // 駒のインデックスを定義
    enum PieceIndex {
        P_IDX = 0, L_IDX, N_IDX, S_IDX, G_IDX, B_IDX, R_IDX, K_IDX, Q_IDX, M_IDX, O_IDX, T_IDX, C_IDX, U_IDX,
        p_IDX, l_IDX, n_IDX, s_IDX, g_IDX, b_IDX, r_IDX, k_IDX, q_IDX, m_IDX, o_IDX, t_IDX, c_IDX, u_IDX
    };

    // 手番の玉が王手されているかどうかを調べる。
    int isKingInCheck(const Turn& turn, const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards,
                       const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceAttackBitboards,
                       std::bitset<NUM_BOARD_SQUARES>& necessaryMovesBitboard,
                      std::bitset<NUM_BOARD_SQUARES>& tmpBitboard);

    // bitboardの内容を標準出力する。
    void printSingleBitboard(const std::bitset<NUM_BOARD_SQUARES>& bitboard) const;

    // 王手されているときに王手を避ける指し手リスト候補を生成する。
    // 例.先手8八玉が後手2二角から王手を受けている場合、2二、3三、4四、5五、6六、7七に
    // 玉以外の先手の駒をそのマスに指すことができれば後手の王手を回避できる手を生成。
    // また、玉を移動させる手も生成するが王手が回避できていない手も含まれている。
    // 王手が回避できない手は、後の処理で除去している。
    // 1 Shogi move: From: (6, 7) To: (6, 6) Moving Piece: P Captured Piece:   Promotion: false
    // 2 Shogi move: From: (8, 9) To: (7, 7) Moving Piece: N Captured Piece:   Promotion: false
    // 3 Shogi move: From: (8, 8) To: (9, 8) Moving Piece: K Captured Piece:   Promotion: false
    // 4 Shogi move: From: (8, 8) To: (7, 8) Moving Piece: K Captured Piece:   Promotion: false
    void filterMovesThatBlockThreat(const Turn& turn, const QVector<ShogiMove>& allMovesList, const std::bitset<NUM_BOARD_SQUARES> &necessaryMovesBitboard,
                                    QVector<ShogiMove> &nonKingBlockingMoves) const;

    // 指し手リストから各指し手を標準出力する。
    void printShogiMoveList(const QVector<ShogiMove>& moveList) const;

    // 指し手リストmoveListの各指し手moveに対して指した直後の盤面データboardDataAfterMoveを作成し、
    // その局面で相手が盤上の駒を動かした際の手を生成して、その中に自玉に王手が掛かっていない手だけを
    // 合法手リストlegalMovesListに加える。
    void filterLegalMovesList(const Turn& turn, const QVector<ShogiMove>& moveList, const QVector<QChar>& boardData, QVector<ShogiMove>& legalMovesList);

    // 駒が置かれていないマスを表すbitboardを作成する。
    void generateEmptySquareBitboard(const QVector<QChar>& boardData, std::bitset<MoveValidator::NUM_BOARD_SQUARES>& emptySquareBitboard) const;

    // 歩以外の駒を駒台から打つ場合の指し手を生成する。
    void generateDropNonPawnMoves(QVector<ShogiMove>& dropMovesList, const QMap<QChar, int>& pieceStand, const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard, const Turn& turn) const;

    // 歩を駒台から打つ場合の指し手を生成する。
    void generateDropPawnMoves(QVector<ShogiMove>& dropMovesList, const QMap<QChar, int>& pieceStand, const std::bitset<NUM_BOARD_SQUARES>& emptySquaresNoPawnsFilesBitboard, const Turn& turn) const;

    // 盤面データを9x9のマスに表示する。
    void printShogiBoard(const QVector<QChar>& boardData);

    // 歩が無い筋を1で表すbitboardを作成する。
    void generateBitboardForEmptyFiles(const Turn& turn, const QVector<QChar>& boardData, std::bitset<NUM_BOARD_SQUARES>& bitboard) const;

    // 駒が置かれていないマスを表すemptySquareBitboardと歩が無い筋を1で表すemptyFilePawnBitboardをAND演算した
    // emptySquaresNoPawnsFilesBitboardを作成する。
    void performAndOperation(const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard, const std::bitset<NUM_BOARD_SQUARES>& emptyFilePawnBitboard,
                             std::bitset<NUM_BOARD_SQUARES>& emptySquaresNoPawnsFilesBitboard) const;

    // 盤上の駒を動かした場合の全指し手リストを生成する。
    void generateShogiMoveFromBitboard(const QChar piece, const std::bitset<NUM_BOARD_SQUARES>& bitboard,
                                       const std::bitset<NUM_BOARD_SQUARES>& attackBitboard,
                                       QVector<ShogiMove>& allMovesList, const QVector<QChar>& boardData) const;

    // 指し手が合法手の中にあるかどうかをチェックする。
    // 合法手に一致すればtrueを返し、無ければfalseを返す。
    bool isMoveInList(const ShogiMove& currentMove, const QVector<ShogiMove>& movesList) const;

    // 指し手が合法手の中にあるかどうかをチェックする。
    // 合法手に一致すればtrueを返し、無ければfalseを返す。
    LegalMoveStatus checkLegalMoveStatus(const ShogiMove& currentMove, const QVector<ShogiMove>& movesList) const;

    // 盤面と持ち駒を引数として、局面を漢字で出力する。
    void printBoardAndPieces(const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand) const;

    // 将棋盤内の駒を動かした場合の合法手がどうかを判定する。
    LegalMoveStatus isBoardMoveValid(const Turn& turn, const QVector<QChar>& boardData, const ShogiMove& currentMove,
                                     const int& numChecks, const QChar& piece, const std::bitset<NUM_BOARD_SQUARES>& attackBitboard,
                                     const std::bitset<NUM_BOARD_SQUARES>& pieceBitboard, const std::bitset<NUM_BOARD_SQUARES>& necessaryMovesBitboard,
                                     QVector<ShogiMove>& legalMovesList);

    // 駒台の駒を打った手が合法手かどうかを判定する。
    bool isHandPieceMoveValid(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand, const ShogiMove& currentMove,
                              const int& numChecks, const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard, QVector<ShogiMove>& legalMovesList);

    // 打った駒が歩かそれ以外の駒かを判別して合法手を生成する。
    bool generateLegalMovesForPiece(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand, const ShogiMove& currentMove,
                                    const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard, QVector<ShogiMove>& legalMovesList);

    // 歩を打った場合の指し手を生成する。
    void generateDropMoveForPawn(QVector<ShogiMove>& legalMovesList, const QMap<QChar, int>& pieceStand, const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard,
                                 const Turn& turn, const QVector<QChar>& boardData) const;

    void generateDropMoveForPiece(QVector<ShogiMove>& allMovesList, const QMap<QChar, int>& pieceStand, const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard,
                                  const Turn& turn, const QChar& piece) const;

    // 成って指した手を生成する。
    void generateAllPromotions(ShogiMove& move, QVector<ShogiMove>& promotions) const;

    // 1手指した後の局面データを作成する。
    void applyMovesToBoard(const ShogiMove& move, const QVector<QChar>& boardData, QVector<QChar>& boardDataAfterMove) const;

    // 駒を成って指した直後の盤面データを作成する。
    void applyPromotionMovesToBoard(const ShogiMove& move, int& toIndex, QVector<QChar>& boardDataAfterMove) const;

    // 駒を不成で指した直後の盤面データを作成する。
    void applyStandardMovesToBoard(const ShogiMove& move, int& toIndex, QVector<QChar>& boardDataAfterMove) const;

    // 駒を持ち駒から打った後の持ち駒数を更新する。
    void decreasePieceCount(const ShogiMove& move, const QMap<QChar, int>& pieceStand, QMap<QChar, int>& pieceStandAfterMove);

    // 指し手が合法手かどうか判定する。
    LegalMoveStatus validateMove(const int& numChecks, const QVector<QChar>& boardData, const ShogiMove& currentMove, const Turn& turn, BoardStateArray& piecePlacedBitboards,
                                 const QMap<QChar, int>& pieceStand, std::bitset<NUM_BOARD_SQUARES>& necessaryMovesBitboard, QVector<ShogiMove>& legalMovesList,
                                 const Turn& opponentTurn, const std::bitset<NUM_BOARD_SQUARES>& attackWithoutKingBitboard);

    // 将棋盤内の駒を動かした場合の指し手のマスの位置を示すbitboardとそのマスの駒の移動可能なマスの位置を示すbitboardを作成し、
    // 指し手が合法手かどうか判定する。
    LegalMoveStatus generateBitboardAndValidateMove(const int& numChecks, const QVector<QChar>& boardData, BoardStateArray& piecePlacedBitboards, const ShogiMove& currentMove,
                                         const Turn& turn, std::bitset<NUM_BOARD_SQUARES>& necessaryMovesBitboard, QVector<ShogiMove>& legalMovesList);

    // 自玉が王手されている場合、駒台の駒を打った場合の合法手かどうかを判定する。
    bool validateMoveWithChecks(const ShogiMove& currentMove, const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand,
                                const int& numChecks, const std::bitset<NUM_BOARD_SQUARES>& attackWithoutKingBitboard, QVector<ShogiMove>& legalMovesList);

    // 自玉が王手されていない場合、駒台の駒を打った場合の合法手かどうかを判定する。
    bool validateMoveWithoutChecks(const ShogiMove& currentMove, const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand,
                                   const int& numChecks, QVector<ShogiMove>& legalMovesList, const Turn& opponentTurn);

    // 相手玉の前のマスに駒台の歩を打ったかどうかを判定する。
    bool isPawnInFrontOfKing(const ShogiMove& currentMove, const Turn& turn, const QVector<QChar>& boardData) const;

    // 盤面データと持ち駒のチェックを行う。
    // 盤面データと持ち駒が有効でない場合、エラーメッセージをログに出力し、エラーメッセージボックスを表示する。
    // 有効な場合はtrueを返し、無効な場合はfalseを返す。
    void validateBoardAndPieces(const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand);

    // 指し手の筋の値を検証する。
    // 筋の値が有効でない場合、エラーメッセージをログに出力し、エラーメッセージボックスを表示する。
    void validateMoveFileValue(int fromSquareX);

    // 指し手の駒が盤面の駒と一致するかを検証する。
    // 指し手の駒が盤面の駒と一致しない場合、エラーメッセージをログに出力し、エラーメッセージボックスを表示する。
    // 一致する場合はtrueを返し、一致しない場合はfalseを返す。
    void validateMovingPiece(const ShogiMove& currentMove, const QVector<QChar>& boardData);

    // 駒台の駒が有効かどうかを検証する。
    // 指し手が駒台から駒を打つ場合、その駒の数が正の数かをチェックする。
    // 無効な場合はエラーメッセージをログに出力し、エラーメッセージボックスを表示する。
    void validatePieceStand(Turn turn, const ShogiMove& currentMove, const QMap<QChar, int>& pieceStand);

    // 駒台のエラー情報をログに出力し、エラーメッセージボックスを表示する。
    void logAndShowPieceStandError(const QString& errorMessage, QChar piece, const QMap<QChar, int>& pieceStand);

    // 取った駒が盤面の駒と一致するかを検証する。
    // 取った駒が盤面の移動先の駒と一致しない場合、エラーメッセージをログに出力し、エラーメッセージボックスを表示する。
    void validateCapturedPiece(const ShogiMove& currentMove, const QVector<QChar>& boardData);

    // 複数の検証を一括して行う。
    // 盤面データと持ち駒、指し手の筋、指し手の駒、駒台の駒、取った駒が有効であるかを検証する。
    // 無効な場合はエラーメッセージをログに出力し、エラーメッセージボックスを表示する。
    void validateMoveComponents(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand, const ShogiMove& currentMove);
};

#endif // MOVEVALIDATOR_H
#ifndef NAVIGATIONCONTEXT_H
#define NAVIGATIONCONTEXT_H

#include <QtGlobal>

class INavigationContext {
public:
    virtual ~INavigationContext() = default;

    // 状態取得
    virtual bool hasResolvedRows() const = 0;
    virtual int  resolvedRowCount() const = 0;
    virtual int  activeResolvedRow() const = 0;
    virtual int  maxPlyAtRow(int row) const = 0; // その行の最終手数 (= r.disp.size())

    // 現在手数（m_activePly 優先、なければ棋譜ビューの選択など）
    virtual int  currentPly() const = 0;

    // 反映（盤面・棋譜欄・分岐・矢印まで一括同期）
    virtual void applySelect(int row, int ply) = 0;
};

#endif // NAVIGATIONCONTEXT_H
#ifndef NAVIGATIONCONTROLLER_H
#define NAVIGATIONCONTROLLER_H

#include <QObject>
#include <QPointer>
class QPushButton;
class INavigationContext;

class NavigationController : public QObject {
    Q_OBJECT
public:
    struct Buttons {
        QPushButton* first{};
        QPushButton* back10{};
        QPushButton* prev{};
        QPushButton* next{};
        QPushButton* fwd10{};
        QPushButton* last{};
    };

    NavigationController(const Buttons& btns,
                         INavigationContext* ctx,
                         QObject* parent = nullptr);

public slots:
    void toFirst();
    void back10();
    void prev();
    void next();
    void fwd10();
    void toLast();

private:
    INavigationContext* m_ctx; // MainWindow の寿命 > Controller を前提（親子関係で担保）
    int clampRow(int row) const;
};

#endif // NAVIGATIONCONTROLLER_H
#ifndef NAVIGATIONPRESENTER_H
#define NAVIGATIONPRESENTER_H

#include <QObject>
#include <QPointer>

class KifuLoadCoordinator;
class EngineAnalysisTab;

// 分岐候補 UI の更新とツリーハイライトに専念する Presenter。
// - 候補の“再構築”は Coordinator に依頼する
// - Coordinator が内部で候補モデルを更新し終えたら、Presenter の「事後通知API」を呼ぶ
class NavigationPresenter : public QObject
{
    Q_OBJECT
public:
    struct Deps {
        KifuLoadCoordinator* coordinator = nullptr;   // 候補生成の実体
        EngineAnalysisTab*   analysisTab = nullptr;   // 分岐ツリーハイライト先（任意）
    };

    explicit NavigationPresenter(const Deps& d, QObject* parent = nullptr);

    // row/ply を軸に「候補再構築 → ハイライト」を一括実行（Coordinator を呼ぶ）
    void refreshAll(int row, int ply);

    // 分岐候補だけを再構築したいとき（refreshAll と同じで OK）
    void refreshBranchCandidates(int row, int ply);

    // ★ 再帰対策用：Coordinator が「候補モデル更新を完了」した直後に呼ぶ“事後通知”
    //    （Coordinator 内から呼び出すのはコレだけ。refresh* は呼ばない。）
    void updateAfterBranchListChanged(int row, int ply);

    // 依存オブジェクトの差し替え
    void setDeps(const Deps& d);

signals:
    // UI が更新されたことを通知（必要に応じて受ける）
    void branchUiUpdated(int row, int ply);

private:
    void highlightBranchTree_(int row, int ply);

    QPointer<KifuLoadCoordinator> m_coordinator;
    QPointer<EngineAnalysisTab>   m_analysisTab;
};

#endif // NAVIGATIONPRESENTER_H
#ifndef NUMERIC_RIGHT_ALIGN_COMMA_DELEGATE_H
#define NUMERIC_RIGHT_ALIGN_COMMA_DELEGATE_H

#include <QStyledItemDelegate>
#include <QLocale>

class NumericRightAlignCommaDelegate : public QStyledItemDelegate
{
    Q_OBJECT
public:
    using QStyledItemDelegate::QStyledItemDelegate;

    // 数値は 3桁区切り（,）に整形。非数値はそのまま。
    QString displayText(const QVariant& value, const QLocale& locale) const override
    {
        Q_UNUSED(locale);
        if (!value.isValid()) return {};

        // まず整数を優先
        bool ok = false;
        qlonglong iv = value.toLongLong(&ok);
        if (ok) {
            static const QLocale enUS(QLocale::English, QLocale::UnitedStates);
            return enUS.toString(iv); // 3桁区切りに , を使う
        }

        // 次に符号なし整数
        qulonglong uiv = value.toULongLong(&ok);
        if (ok) {
            static const QLocale enUS(QLocale::English, QLocale::UnitedStates);
            return enUS.toString(uiv);
        }

        // 必要なら double も（整数に丸められてしまうのを避ける）
        double dv = value.toDouble(&ok);
        if (ok) {
            static const QLocale enUS(QLocale::English, QLocale::UnitedStates);
            // 桁区切り＋既定精度。必要なら 'f' と桁数を指定してもOK
            return enUS.toString(dv);
        }

        // 数値以外（例: "mate 1"）はそのまま
        return QStyledItemDelegate::displayText(value, QLocale::c());
    }

    void initStyleOption(QStyleOptionViewItem* option, const QModelIndex& index) const override
    {
        QStyledItemDelegate::initStyleOption(option, index);
        option->displayAlignment = Qt::AlignRight | Qt::AlignVCenter; // 常に右寄せ
    }
};

#endif // NUMERIC_RIGHT_ALIGN_COMMA_DELEGATE_H
#ifndef PLAYERNAMESERVICE_H
#define PLAYERNAMESERVICE_H

#include <QString>
#include "playmode.h"

struct PlayerNameMapping {
    QString p1;  // 先手（黒）
    QString p2;  // 後手（白）
};

struct EngineNameMapping {
    QString model1; // m_lineEditModel1 に表示するエンジン名
    QString model2; // m_lineEditModel2 に表示するエンジン名
};

class PlayerNameService {
public:
    // 先手/後手の表示名を決定（人間名/エンジン名のどちらを出すか）
    static PlayerNameMapping computePlayers(PlayMode mode,
                                            const QString& human1,
                                            const QString& human2,
                                            const QString& engine1,
                                            const QString& engine2);

    // ログ用モデル（model1/model2）のエンジン名割り当てを決定
    static EngineNameMapping computeEngineModels(PlayMode mode,
                                                 const QString& engine1,
                                                 const QString& engine2);
};

#endif // PLAYERNAMESERVICE_H
#ifndef PLAYMODE_H
#define PLAYMODE_H

enum PlayMode {
    NotStarted,        // ソフトウェアを起動した直後、まだ対局を開始していない状態
    HumanVsHuman,      // 平手、駒落ち Player1: Human, Player2: Human
    EvenHumanVsEngine,     // 平手 Player1: Human, Player2: USI Engine
    EvenEngineVsHuman,     // 平手 Player1: USI Engine, Player2: Human
    EvenEngineVsEngine,    // 平手、駒落ち Player1: USI Engine, Player2: USI Engine
    HandicapEngineVsHuman, // 駒落ち Player1: USI Engine（下手）, Player2: Human（上手）
    HandicapHumanVsEngine,  // 駒落ち Player1: Human（下手）, Player2: USI Engine（上手）
    HandicapEngineVsEngine, // 駒落ち Player1: USI Engine（下手）, Player2: USI Engine（上手）
    AnalysisMode,      // 棋譜解析モード
    ConsidarationMode, // 検討モード
    TsumiSearchMode,   // 詰将棋探索モード
    PlayModeError  // エラーコード
};

#endif // PLAYMODE_H
#ifndef POSITIONEDITCONTROLLER_H
#define POSITIONEDITCONTROLLER_H

#include <QObject>
#include <QString>
#include <QStringList>
#include <functional>
#include <QPointer>

class ShogiView;
class ShogiBoard;
class ShogiGameController;
class BoardInteractionController;

class PositionEditController final : public QObject {
    Q_OBJECT
public:
    explicit PositionEditController(QObject* parent = nullptr) : QObject(parent) {}

    // 局面編集開始に必要な情報
    struct BeginEditContext {
        ShogiView*                 view = nullptr;          // 必須
        ShogiGameController*       gc   = nullptr;          // 必須
        BoardInteractionController* bic = nullptr;          // 任意（ハイライト等）

        // SFEN 蓄積（0手局面～）の実体ポインタ
        QStringList* sfenRecord = nullptr;                  // 任意

        // 選択状態
        int  selectedPly = -1;                              // 任意
        int  activePly   = -1;                              // 任意
        bool gameOver    = false;                           // 任意

        // 文字列側の状態（存在すれば採用）
        QString* startSfenStr   = nullptr;                  // 任意
        QString* currentSfenStr = nullptr;                  // 任意
        QString* resumeSfenStr  = nullptr;                  // 任意

        // UI: 盤面右の「編集終了」ボタン表示
        std::function<void()> onShowEditExitButton;         // 任意
        std::function<void()> onEnterEditMenu;               // 追加: 編集開始時に呼ぶ
    };

    // 局面編集終了に必要な情報
    struct FinishEditContext {
        ShogiView*                 view = nullptr;          // 必須
        ShogiGameController*       gc   = nullptr;          // 必須
        BoardInteractionController* bic = nullptr;          // 任意

        QStringList* sfenRecord = nullptr;                  // 任意（0手局面として再保存）
        QString*     startSfenStr = nullptr;                // 任意（startSfen更新）
        bool*        isResumeFromCurrent = nullptr;         // 任意（falseに落とす）

        // UI: 「編集終了」ボタンの後片付け
        std::function<void()> onHideEditExitButton;         // 任意
        std::function<void()> onLeaveEditMenu;               // 追加: 編集終了時に呼ぶ
    };

    void beginPositionEditing(const BeginEditContext& c);
    void finishPositionEditing(const FinishEditContext& c);

    // ★ 追加: 盤操作と「編集終了」ボタン制御（アクション/開始時に直接呼ぶ）
    void resetPiecesToStand(ShogiView* view, BoardInteractionController* bic);
    void setStandardStartPosition(ShogiView* view, BoardInteractionController* bic);
    void setTsumeShogiStartPosition(ShogiView* view, BoardInteractionController* bic);

    void showEditExitButtonOnBoard(ShogiView* view, QObject* receiver, const char* finishSlot);
    void hideEditExitButtonOnBoard(ShogiView* view);

    // 局面編集中の「from→to」着手要求を適用する。
    // - 成功/失敗に関わらず view のドラッグ終了と bic.onMoveApplied(...) までを含めて処理します。
    // - 成功時のみ view->update() を呼びます。
    // 返り値: 成功すれば true、失敗すれば false。
    bool applyEditMove(const QPoint& from,
                       const QPoint& to,
                       ShogiView* view,
                       ShogiGameController* gc,
                       BoardInteractionController* bic);

    // class PositionEditController 内に追記（publicの下に）
public slots:
    void onReturnAllPiecesOnStandTriggered();
    void onFlatHandInitialPositionTriggered();
    void onShogiProblemInitialPositionTriggered();
    void onToggleSideToMoveTriggered();

private:
    QPointer<ShogiView>                 m_view;
    QPointer<ShogiGameController>       m_gc;
    QPointer<BoardInteractionController> m_bic;
};

#endif // POSITIONEDITCONTROLLER_H
#ifndef PROMOTEDIALOG_H
#define PROMOTEDIALOG_H

#include <QDialog>

namespace Ui {
class PromoteDialog;
}

// 成る・不成の選択ダイアログを表示するクラス
class PromoteDialog : public QDialog
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit PromoteDialog(QWidget* parent = nullptr);

    // デストラクタ
    ~PromoteDialog();

private:
    Ui::PromoteDialog* ui;
};

#endif // PROMOTEDIALOG_H
#ifndef PROMOTIONFLOW_H
#define PROMOTIONFLOW_H

class QWidget;

class PromotionFlow final {
public:
    // 成る: true / 不成: false を返す
    static bool askPromote(QWidget* parent);
};

#endif // PROMOTIONFLOW_H
#ifndef RECORDPANE_H
#define RECORDPANE_H

#include <QWidget>
#include <QTextBrowser>

class QTableView; class QPushButton; class QTextBrowser; class QSplitter; class QScrollArea;
class KifuRecordListModel; class KifuBranchListModel;
class EvaluationChartWidget;

// ★ 追加: コメント表示用のラッパ（setText を提供）
class CommentTextAdapter {
public:
    explicit CommentTextAdapter(QTextBrowser* tb = nullptr) : m_tb(tb) {}
    void setText(const QString& text) { if (m_tb) m_tb->setPlainText(text); }
    void setHtml(const QString& html) { if (m_tb) m_tb->setHtml(html); }
    QTextBrowser* widget() const { return m_tb; }
    void reset(QTextBrowser* tb) { m_tb = tb; }
private:
    QTextBrowser* m_tb = nullptr;
};

class RecordPane : public QWidget {
    Q_OBJECT
public:
    explicit RecordPane(QWidget* parent=nullptr);
    void setModels(KifuRecordListModel* recModel, KifuBranchListModel* brModel);

    QTableView* kifuView() const;
    QTableView* branchView() const;
    EvaluationChartWidget* evalChart() const;

    void setArrowButtonsEnabled(bool on);

    QPushButton* firstButton()  const { return m_btn1; }
    QPushButton* back10Button() const { return m_btn2; }
    QPushButton* prevButton()   const { return m_btn3; }
    QPushButton* nextButton()   const { return m_btn4; }
    QPushButton* fwd10Button()  const { return m_btn5; }
    QPushButton* lastButton()   const { return m_btn6; }

    CommentTextAdapter* commentLabel();

    QPushButton* backToMainButton();

    void setupKifuSelectionAppearance();
    void setupBranchViewSelectionAppearance();

signals:
    void mainRowChanged(int row);
    void branchActivated(const QModelIndex&);

private:
    void buildUi();
    void wireSignals();

    QTableView *m_kifu=nullptr, *m_branch=nullptr;
    QWidget *m_arrows=nullptr;
    QPushButton *m_btn1=nullptr,*m_btn2=nullptr,*m_btn3=nullptr,*m_btn4=nullptr,*m_btn5=nullptr,*m_btn6=nullptr;
    QTextBrowser* m_branchText=nullptr;
    QSplitter *m_lr=nullptr, *m_right=nullptr;
    QScrollArea* m_scroll=nullptr;
    EvaluationChartWidget* m_eval=nullptr;
    QMetaObject::Connection m_connKifuCurrentRow;

private slots:
    void onKifuRowsInserted(const QModelIndex& parent, int first, int last);
    void onKifuCurrentRowChanged(const QModelIndex& cur, const QModelIndex& prev);

private:
    QMetaObject::Connection m_connRowChanged;
    QMetaObject::Connection m_connRowsInserted;

    // ★ 追加: コメント用アダプタの実体
    CommentTextAdapter m_commentAdapter{nullptr};

public slots:
    // プレーンテキストで分岐コメント欄に反映
    void setBranchCommentText(const QString& text);

    // HTMLで分岐コメント欄に反映（将来HTML対応したくなった時用）
    void setBranchCommentHtml(const QString& html);
};

#endif // RECORDPANE_H
#ifndef RECORDPANEWIRING_H
#define RECORDPANEWIRING_H

#include <QObject>

class QWidget;
class RecordPane;
class KifuRecordListModel;
class KifuBranchListModel;

// ★ 追加: 前方宣言（ヘッダ内でポインタ型として使うだけならこれでOK）
class NavigationController;
class INavigationContext;

class RecordPaneWiring : public QObject {
    Q_OBJECT
public:
    struct Deps {
        QWidget*             parent = nullptr;         // 親（通常は MainWindow の central）
        QObject*             ctx = nullptr;            // RecordPane::mainRowChanged などを受ける QObject（MainWindow*）
        INavigationContext*  navCtx = nullptr;         // NavigationController 用の INavigationContext*
        KifuRecordListModel* recordModel = nullptr;    // 棋譜モデル
        KifuBranchListModel* branchModel = nullptr;    // 分岐候補モデル
    };

    explicit RecordPaneWiring(const Deps& d, QObject* parent=nullptr);

    // RecordPane の生成と配線を行う
    void buildUiAndWire();

    // 生成物の取得
    RecordPane*           pane() const { return m_pane; }
    NavigationController* nav()  const { return m_nav;  }

private:
    Deps                  m_d;
    RecordPane*           m_pane = nullptr;
    NavigationController* m_nav  = nullptr;
};

#endif // RECORDPANEWIRING_H
#ifndef RECORDPRESENTER_H
#define RECORDPRESENTER_H

#include <QObject>
#include <QStringList>
#include <QList>
#include <QPointer>

class KifuRecordListModel;
class RecordPane;
class KifDisplayItem;
class QTableView;
class QItemSelectionModel;

class GameRecordPresenter : public QObject {
    Q_OBJECT
public:
    struct Deps {
        KifuRecordListModel* model {nullptr};
        RecordPane*          recordPane {nullptr}; // 任意（スクロール初期位置合わせ等に使用）
    };

    explicit GameRecordPresenter(const Deps& d, QObject* parent = nullptr);

    // 依存先が後から揃う場合に備えて更新可能に
    void updateDeps(const Deps& d);

    // モデル初期化
    void clear();

    // 棋譜全体をまとめて描画（ヘッダ＋各手を追加）
    void presentGameRecord(const QList<KifDisplayItem>& disp);

    // 1手分を末尾に追記（対局中のライブ更新でも使用）
    void appendMoveLine(const QString& prettyMove, const QString& elapsedTime);

    int  currentMoveIndex() const { return m_currentMoveIndex; }

signals:
    void modelReset(); // 必要なら MainWindow 側でハンドリング

private:
    Deps        m_d;
    int         m_currentMoveIndex {0};
    QStringList m_kifuDataList; // KIF文字列出力用の蓄積（必要なければ未使用でOK）

public:
    // 追加：コメントを Presenter 側で管理
    void setCommentsByRow(const QStringList& commentsByRow);
    // 追加：disp からコメント配列を構築（rowCount = sfenRecord->size() or disp.size()+1）
    void setCommentsFromDisplayItems(const QList<KifDisplayItem>& disp, int rowCount);

    // 追加：KifuView の選択変更を Presenter が直接受け取り、MainWindow へ signal を転送
    void bindKifuSelection(QTableView* kifuView);

    // 補助：行に対応するコメント取得
    QString commentForRow(int row) const;

    // disp をモデルに反映し、コメントと行数を整えて、選択変更の配線までを一括実行
    void displayAndWire(const QList<KifDisplayItem>& disp,
                        int rowCount,
                        RecordPane* recordPane);

    // 現在選択されている行インデックス（選択無しは -1）
    int currentRow() const;

signals:
    // Presenter 経由で MainWindow に「現在行＋コメント」を通知
    void currentRowChanged(int row, const QString& comment);

private:
    QPointer<QTableView> m_kifuView;
    QMetaObject::Connection m_connRowChanged;
    QStringList m_commentsByRow;

private slots:
    void onKifuCurrentRowChanged_(const QModelIndex& current, const QModelIndex& previous);

public:
    // ライブ記録用アイテムを追加（保存）
    void addLiveKifItem(const QString& prettyMove, const QString& elapsedTime);

    // 現在のライブ記録を取得
    const QList<KifDisplayItem>& liveDisp() const { return m_liveDisp; }

    // ライブ記録をクリア
    void clearLiveDisp() { m_liveDisp.clear(); }

private:
    QList<KifDisplayItem> m_liveDisp;
};

#endif // RECORDPRESENTER_H
#ifndef SETTINGSSERVICE_H
#define SETTINGSSERVICE_H

class QWidget;
class ShogiView;

namespace SettingsService {

// INI (ShogiBoardQ.ini) からメインウィンドウのサイズを読み込んで適用します。
// - mainWindow: 対象となる QMainWindow（や QWidget）
// 失敗時は何もしません（デフォルトサイズのまま）。
void loadWindowSize(QWidget* mainWindow);

// メインウィンドウのサイズと盤マスサイズ（ShogiView::squareSize）を INI に保存します。
// - mainWindow: 対象となる QMainWindow（や QWidget）
// - view      : 盤ビュー（nullptr の場合は何もしません）
void saveWindowAndBoard(QWidget* mainWindow, ShogiView* view);

} // namespace SettingsService

#endif // SETTINGSSERVICE_H
#ifndef SFENPOSITIONTRACER_H
#define SFENPOSITIONTRACER_H

#include <QString>
#include <QStringList>
#include <array>
#include <QPoint>
#include <QVector>
#include "shogimove.h"

/**
 * @brief USI手列を順に適用し、各手後のSFENを生成する簡易トレーサ。
 * - 平手初期局面から開始
 * - 盤上は SFEN と同じ文字（先手=大文字, 後手=小文字, 成駒は頭に'+'）
 * - 持ち駒は種類別に枚数管理（先手/後手）
 * - 合法手チェックはしない（与えられたUSI手を素直に適用）
 */
class SfenPositionTracer {
public:
    SfenPositionTracer();

    void resetToStartpos();
    /// USI一手（例: "7g7f", "P*5e", "2b3c+"）を適用
    bool applyUsiMove(const QString& usi);

    /// 現在局面の SFEN 文字列を返す（例: "lnsgkgsnl/... b - 1"）
    QString toSfenString() const;

    /// 手列を順に適用し、各手の直後局面の SFEN を配列で返す
    QStringList generateSfensForMoves(const QStringList& usiMoves);

    // 初期SFENから現在局面をセットする（4フィールド形式を想定: board stm hands ply）
    bool setFromSfen(const QString& sfen);

    bool blackToMove() const { return m_blackToMove; }
    // file: 1..9, rank: 'a'..'i'。空なら空文字列を返す
    QString tokenAtFileRank(int file, QChar rankLetter) const;

private:
    // 盤: [rank 0..8][file 0..8]  rank0='a'(最上段) ～ rank8='i'(最下段), file0='1' ～ file8='9'
    QString m_board[9][9];

    // 手番（true=先手b, false=後手w）
    bool m_blackToMove = true;

    // 次の手数（初期=1）。SFENの第4フィールドに入れる
    int m_plyNext = 1;

    // 持ち駒 [種別] の枚数
    enum Kind { P, L, N, S, G, B, R, KIND_N };
    std::array<int, KIND_N> m_handB{}; // 先手
    std::array<int, KIND_N> m_handW{}; // 後手

    // --- ユーティリティ ---
    static int fileToCol(int file);            // '1'..'9' → 0..8
    static int rankLetterToRow(QChar r);       // 'a'..'i' → 0..8
    static QChar kindToLetter(Kind k);         // 種別 → 'P','L',...（大文字）
    static Kind letterToKind(QChar upper);     // 'P','L',... → 種別
    static QChar toSideCase(QChar upper, bool black); // sideで大/小文字付与
    static QString makeToken(QChar upper, bool black, bool promoted); // 盤上トークン
    static bool isPromotedToken(const QString& t);      // "+p" 等
    static QChar baseUpperFromToken(const QString& t);  // "+p"→'P', 's'→'S' 等

    void clearBoard();
    void setStartposBoard();
    void addHand(bool black, Kind k, int n=1);
    bool subHand(bool black, Kind k, int n=1);

    // 盤→SFEN第1フィールド
    QString boardToSfenField() const;
    // 持ち駒→SFEN第3フィールド（なければ "-"）
    QString handsToSfenField() const;

public:
    // ---- ユーティリティ（今回新設） ----
    // 初期SFENとUSI手列から 0..N(+1) の局面列を構築（hasTerminal==true のとき終局用にもう1つ末尾に同一局面を追加）
    static QStringList buildSfenRecord(const QString& initialSfen,
                                       const QStringList& usiMoves,
                                       bool hasTerminal);

    // 初期SFENとUSI手列から可視化用の ShogiMove 列（1..N）を構築
    static QVector<ShogiMove> buildGameMoves(const QString& initialSfen,
                                             const QStringList& usiMoves);

    // USI座標ヘルパ（既存の MainWindow/KifuLoadCoordinator から移したい補助関数）
    static int    rankLetterToNum(QChar r);                          // 'a'..'i' -> 1..9（無効時は -1）
    static QPoint dropFromSquare(QChar dropUpper, bool black);       // 駒打ち時の「駒台」座標（UI内部表現）
    static QChar  dropLetterWithSide(QChar upper, bool black);       // 先手なら大文字/後手なら小文字
    static QChar  tokenToOneChar(const QString& tok);                // "+p" 等を一文字へマップ（成駒対応）
};

#endif // SFENPOSITIONTRACER_H
#ifndef SFENUTILS_H
#define SFENUTILS_H

#include <QString>

namespace SfenUtils {

// "startpos" を完全SFENへ正規化。既に完全SFENならそのまま返す。
inline QString normalizeStart(const QString& startPositionStr)
{
    if (startPositionStr == QStringLiteral("startpos")) {
        return QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1");
    }
    return startPositionStr;
}

} // namespace SfenUtils

#endif // SFENUTILS_H
#ifndef SHOGIBOARD_H
#define SHOGIBOARD_H

#include <QObject>
#include <QVector>
#include <QMap>

// 将棋盤に関するクラス
class ShogiBoard : public QObject
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit ShogiBoard(int ranks = 9, int files = 9, QObject *parent = 0);

    // 持ち駒の駒文字と枚数を格納するマップ
    QMap<QChar, int> m_pieceStand;

    // 将棋盤内の駒m_boardDataと駒台の駒m_standPieceの駒文字を返す。
    // 例．先手の歩 P、後手の銀 g char型の1文字を返す。
    QChar getPieceCharacter(const int file, const int rank);

    // 将棋盤と駒台を含むSFEN文字列で将棋盤全体を更新する場合、この関数を使う。
    // 将棋盤に入力で渡されるsfen形式の文字列に文法的に誤りが無いかチェックする。
    // 将棋盤と駒台のSFEN文字列を指定して将棋盤と駒台の駒の更新を行い、再描画する。
    // 入力は、将棋盤と駒台を含むSFEN文字列
    void setSfen(const QString& sfenStr);

    // 駒を指定したマスへ移動する。配置データのみを更新する。
    void movePieceToSquare(QChar selectedPiece, const int fileFrom, const int rankFrom,
                           const int fileTo, const int rankTo, const bool promote);

    // 持ち駒を出力する。
    void printPieceStand();

    // 局面編集中に使用される。将棋盤と駒台の駒を更新する。
    void updateBoardAndPieceStand(const QChar source, const QChar dest, const int fileFrom, const int rankFrom, const int fileTo, const int rankTo, const bool promote);

    // 駒台の駒数が0以下の時は、駒台の駒は無いので指せない。
    bool isPieceAvailableOnStand(const QChar source, const int fileFrom) const;

    // 将棋盤内のデータ（81マスの駒文字情報）を返す。
    const QVector<QChar>& boardData() const;

    // 駒台のデータ（駒台の各駒の枚数情報）を返す。
    const QMap<QChar, int>& getPieceStand() const;

    // 局面編集中に右クリックで成駒、不成駒に変換する。
    void promoteOrDemotePiece(const int fileFrom, const int rankFrom);

    // 将棋盤の段の数すなわち9を返す。
    int ranks() const { return m_ranks; }

    // 将棋盤の筋の数すなわち9を返す。
    int files() const { return m_files; }

    // 「全ての駒を駒台へ」をクリックした時に実行される。
    // 先手と後手の駒を同じ枚数にして全ての駒を駒台に載せる。
    void resetGameBoard();

    // 駒台の各駒の数を全て0にする。
    void initStand();

    // 「先後反転」をクリックした時に実行される。
    // 先手の配置を後手の配置に変更し、後手の配置を先手の配置に変更する。
    void flipSides();

    // SFEN文字列への変換してリストに追加する。
    void addSfenRecord(const QString& nextTurn, const int moveNumber, QStringList* m_sfenRecord);

    // 持ち駒を出力する。
    void printPieceCount() const;

    // 自分の駒台に駒を置いた場合、自分の駒台の枚数に1加える。
    void incrementPieceOnStand(const QChar dest);

    QString currentPlayer() const;

    // 盤面をSFEN形式へ変換する。
    QString convertBoardToSfen();

    // 駒台のSFEN形式への変換
    QString convertStandToSfen() const;

signals:
    // エラーを報告するためのシグナル
    void errorOccurred(const QString& errorMessage);

    // ShogiView::setBoardのconnectで使用されているシグナル
    // スロットのrepaint関数が実行される。（将棋盤、駒台の再描画）
    void boardReset();

    // ShogiView::setBoardのconnectで使用されているシグナル
    // スロットのrepaint関数が実行される。（将棋盤、駒台の再描画）
    void dataChanged(int c, int r);

private:
    // 将棋盤の段の数すなわち9
    int m_ranks;

    // 将棋盤の筋の数すなわち9
    int m_files;

    // 将棋盤内81マスの駒文字データを格納
    QVector<QChar> m_boardData;

    // SFEN文字列の次の手が何手目になるかを示す数
    int m_currentMoveNumber;

    // 先手か後手かのどちらか（bあるいはw）
    QString m_currentPlayer;

    // 将棋盤のマスに駒を配置する。
    // file 筋、rank 段で指定されたマスに駒文字valueをセットする。
    void setData(const int file, const int rank, const QChar value);

    // 将棋盤の81マスに空白を代入する。
    void initBoard();

    // 将棋盤のマスに駒を配置する。
    bool setDataInternal(const int file, const int rank, const QChar value);

    // SFEN文字列の持ち駒部分の文字列を入力して、持ち駒を表す配列に各駒の枚数をセットする。
    void setPieceStandFromSfen(const QString& str);

    // 将棋盤内のみのSFEN文字列を入力し、エラーチェックを行い、成り駒を1文字に変換したSFEN文字列を返す。
    QString validateAndConvertSfenBoardStr(QString sfenStr);

    // SFEN文字列から将棋盤内に駒を配置する。
    void setPiecePlacementFromSfen(QString& initialSfenStr);

    // 指したマスが将棋盤内で相手の駒があった場合、自分の駒台の枚数に1加える。
    void addPieceToStand(QChar dest);

    // 駒台から指した場合、駒台の駒の枚数を1減らす。
    void decrementPieceOnStand(QChar source);

    // SFEN文字列を入力し、エラーチェックを行い、次の手番、次の手が何手目かを取得する。
    void validateSfenString(const QString& sfenStr, QString& sfenBoardStr, QString& sfenStandStr);

    // 手番の持ち駒を出力する。
    void printPlayerPieces(const QString& player, const QString& pieceSet) const;

    // 駒の文字を変換する。成駒は相手の駒になるように、大文字を小文字に、小文字を大文字に変換する。
    QChar convertPieceChar(const QChar c) const;

    // 成駒を元の駒に変換する。
    QChar convertPromotedPieceToOriginal(const QChar dest) const;

    // 駒の初期値を設定する。
    void setInitialPieceStandValues();

    // 成り駒の文字をSFEN形式の駒文字列に変換する。
    QString convertPieceToSfen(const QChar piece) const;
};

#endif // SHOGIBOARD_H
#ifndef SHOGICLOCK_H
#define SHOGICLOCK_H

#include <QObject>
#include <QTimer>
#include <QStack>
#include <QElapsedTimer>
#include <QLoggingCategory>

Q_DECLARE_LOGGING_CATEGORY(lcShogiClock)

// 将棋クロック：持ち時間/秒読み/インクリメント/考慮時間の管理
class ShogiClock : public QObject
{
    Q_OBJECT
public:
    static constexpr int kTickMs = 50;

    explicit ShogiClock(QObject *parent = nullptr);

    // 設定
    void setLoseOnTimeout(bool v);
    void setPlayerTimes(int player1Seconds, int player2Seconds,
                        int byoyomi1Seconds, int byoyomi2Seconds,
                        int bincSeconds, int wincSeconds,
                        bool isLimitedTime);
    void setCurrentPlayer(int player);

    // クロック制御
    void startClock();
    void stopClock();          // 進行中の手番側の残時間/考慮msに経過分を反映し停止
    void updateClock();        // QTimer から kTickMs ごとに呼ばれる

    // 着手確定時（その手を指した側だけ呼ぶ）
    void applyByoyomiAndResetConsideration1();  // 先手が指した直後
    void applyByoyomiAndResetConsideration2();  // 後手が指した直後

    // 「待った」
    void undo();

    // ---- GUI表示API（仕様固定） ----
    // 残り時間（実残りms→秒は切り上げ）
    QString getPlayer1TimeString() const;
    QString getPlayer2TimeString() const;

    // 直近考慮（MM:SS）＝ 総考慮(秒)の差分
    QString getPlayer1ConsiderationTime() const;
    QString getPlayer2ConsiderationTime() const;

    // 総考慮（HH:MM:SS）＝ 実測総考慮ms → 秒は切り捨て
    QString getPlayer1TotalConsiderationTime() const;
    QString getPlayer2TotalConsiderationTime() const;

    // 棋譜欄用 "MM:SS/HH:MM:SS"
    QString getPlayer1ConsiderationAndTotalTime() const;
    QString getPlayer2ConsiderationAndTotalTime() const;

    // 残り時間（ms）
    qint64 getPlayer1TimeIntMs() const { return m_player1TimeMs; }
    qint64 getPlayer2TimeIntMs() const { return m_player2TimeMs; }

    // 現在の手番（1=先手, 2=後手）
    int currentPlayer() const { return m_currentPlayer; }

    // 考慮時間（ms）を外部から直接セット（HvE でエンジン手のelapsedを反映など）
    void setPlayer1ConsiderationTime(int ms);
    void setPlayer2ConsiderationTime(int ms);

    // byoyomi が設定されているか／適用中か
    bool hasByoyomi1() const { return m_byoyomi1TimeMs > 0; }
    bool hasByoyomi2() const { return m_byoyomi2TimeMs > 0; }
    bool byoyomi1Applied() const { return m_byoyomi1Applied; }
    bool byoyomi2Applied() const { return m_byoyomi2Applied; }

    // 終局管理
    bool isGameOver() const { return m_gameOver; }
    void markGameOver() { m_gameOver = true; }

    // デバッグ/ログ用
    qint64 player1ConsiderationMs() const { return m_player1ConsiderationTimeMs; }
    qint64 player2ConsiderationMs() const { return m_player2ConsiderationTimeMs; }
    int getPlayer1ConsiderationTimeMs() const;
    int getPlayer2ConsiderationTimeMs() const;

    // --- USI パラメータ用 Getter（最小限） ---
    qint64 getBincMs() const { return m_bincMs; }
    qint64 getWincMs() const { return m_wincMs; }

    // 両者同値の byoyomi だけ返す（不一致なら 0 を返す＝USIの byoyomi は使わない）
    qint64 getCommonByoyomiMs() const {
        return (m_byoyomi1TimeMs > 0 && m_byoyomi2TimeMs > 0 && m_byoyomi1TimeMs == m_byoyomi2TimeMs)
        ? m_byoyomi1TimeMs : 0;
    }

signals:
    void timeUpdated();
    void player1TimeOut();
    void player2TimeOut();
    void resignationTriggered();

private:
    // ---- 内部ヘルパ ----
    void saveState();                // undo 用に状態を積む（startClockで呼ぶ）
    void debugCheckInvariants() const;

    // 残り秒（切り上げ）計算
    int remainingDisplaySecP1() const;
    int remainingDisplaySecP2() const;

    // 直近考慮(秒)を更新（着手確定時）※総考慮ms→秒切り捨ての差分
    void updateShownConsiderationForPlayer(int player);

    // タイマ
    QTimer*       m_timer = nullptr;
    QElapsedTimer m_elapsedTimer;
    bool          m_clockRunning = false;
    qint64        m_lastTickMs   = 0;

    // 設定・状態
    bool   m_timeLimitSet  = false;
    bool   m_loseOnTimeout = true;
    int    m_currentPlayer = 1;   // 1=先手, 2=後手

    // 残り時間（ms）
    qint64 m_player1TimeMs = 0;
    qint64 m_player2TimeMs = 0;

    // 秒読み/インクリメント（ms）
    qint64 m_byoyomi1TimeMs = 0;
    qint64 m_byoyomi2TimeMs = 0;
    qint64 m_bincMs = 0;  // 先手の increment
    qint64 m_wincMs = 0;  // 後手の increment

    // 考慮時間（直近手の実測ms）と総計（実測msの合計）
    qint64 m_player1ConsiderationTimeMs = 0;
    qint64 m_player2ConsiderationTimeMs = 0;
    qint64 m_player1TotalConsiderationTimeMs = 0;
    qint64 m_player2TotalConsiderationTimeMs = 0;

    // GUI表示用：直近考慮(秒) と「前回指した時点の総考慮(秒)」
    int m_p1LastMoveShownSec = 0;
    int m_p2LastMoveShownSec = 0;
    int m_p1PrevShownTotalSec = 0;
    int m_p2PrevShownTotalSec = 0;

    // 秒表示キャッシュ（残り時間の秒が変わったときだけ通知）
    int m_prevShownSecP1 = -1;
    int m_prevShownSecP2 = -1;

    // 秒読みの適用状態
    bool m_byoyomi1Applied = false;
    bool m_byoyomi2Applied = false;

    // undo 用の履歴
    QStack<qint64> m_player1TimeHistory;
    QStack<qint64> m_player2TimeHistory;
    QStack<qint64> m_player1ConsiderationHistory;
    QStack<qint64> m_player2ConsiderationHistory;
    QStack<qint64> m_player1TotalConsiderationHistory;
    QStack<qint64> m_player2TotalConsiderationHistory;
    QStack<bool>   m_byoyomi1AppliedHistory;
    QStack<bool>   m_byoyomi2AppliedHistory;
    QStack<int>    m_p1LastMoveShownSecHistory;
    QStack<int>    m_p2LastMoveShownSecHistory;
    QStack<int>    m_p1PrevShownTotalSecHistory;
    QStack<int>    m_p2PrevShownTotalSecHistory;

    bool m_gameOver = false;  // 終局フラグ（時間切れ/投了後など）
};

#endif // SHOGICLOCK_H
#ifndef SHOGIENGINEINFOPARSER_H
#define SHOGIENGINEINFOPARSER_H

#include <QString>
#include <QObject>
#include "shogigamecontroller.h"

// エンジンは、infoコマンドによって思考中の情報を返す。
// info行を解析するクラス
class ShogiEngineInfoParser : public QObject
{
    Q_OBJECT

public:
    // コンストラクタ
    ShogiEngineInfoParser();

    // 評価値の境界を表す列挙型
    enum class EvaluationBound {
        None,       // どちらの境界もない
        LowerBound, // 下限値（実際にはその値を上回る可能性がある）
        UpperBound  // 上限値（実際にはその値を下回る可能性がある）
    };

    // 評価値の境界を取得する。
    EvaluationBound evaluationBound() const;

    // 評価値の境界を設定する。
    void setEvaluationBound(EvaluationBound newEvaluationBound);

    // 盤面の1辺のマス数（列数と段数）
    static constexpr int BOARD_SIZE = 9;

    // 将棋盤のマス数
    static constexpr int NUM_BOARD_SQUARES = BOARD_SIZE * BOARD_SIZE;

    // 駒台を示す筋番号
    static constexpr int STAND_FILE = 99;

    // "info multipv 1 score cp 0 depth 32 pv 3c3d 6g6f 2b3c 7i6h 8b2b 6h6g 3a4b 8h7g (57.54%)"
    // の"(57.54%)"のような文字列が入力された場合が該当する。
    static constexpr int INFO_STRING_SPECIAL_CASE = -2;

    // 直前の指し手の筋を返す。
    int previousFileTo() const;

    // 直前の指し手の筋を設定する。
    void setPreviousFileTo(int newPreviousFileTo);

    // 直前の指し手の段を返す。
    int previousRankTo() const;

    // 直前の指し手の段を設定する。
    void setPreviousRankTo(int newPreviousRankTo);

    // 将棋エンジンから受信したinfo行の読み筋を日本語に変換する。
    // 例．
    // 「7g7h 2f2e 8e8f 2e2d 2c2d 8i7g 8f8g+」
    // 「△７八馬(77)▲２五歩(26)△８六歩(85)▲２四歩(25)△同歩(23)▲７七桂(89)△８七歩成(86)」
    void parseEngineOutputAndUpdateState(QString& line, const ShogiGameController* algorithm,  QVector<QChar>& clonedBoardData,
                                         const bool isPondering);

    // 現在思考中の手の探索深さを取得する。
    QString depth() const;

    // 現在選択的に読んでいる手の探索深さを取得する。
    QString seldepth() const;

    // pvで初手の異なる複数の読み筋を返す時、それがn通りあれば、最も良い（評価値の高い）ものを返す。
    QString multipv() const;

    // 思考開始から探索したノード数を取得する。
    QString nodes() const;

    // 1秒あたりの探索局面数を取得する。
    QString nps() const;

    // 思考を開始してから経過した時間（単位はミリ秒）を取得する。
    QString time() const;

    // エンジンによる現在の評価値を取得する。
    QString scoreCp() const;

    // エンジンが詰みを発見した場合の詰み手数を取得する。
    QString scoreMate() const;

    // 現在の読み筋を漢字表示で表した文字列を取得する。
    QString pvKanjiStr() const;

    // 現在思考中の手（思考開始局面から最初に指す手）を取得する。
    QString currmove() const;

    // エンジンが現在使用しているハッシュの使用率を取得する。
    QString hashfull() const;

    // GUIの「探索手」の欄に表示する読み筋の最初の文字列を取得する。
    QString searchedHand() const;

    // エンジンが詰みを発見した場合の詰み手数を設定する。
    void setScoreMate(const QString& newScoremate);

    QString convertPredictedMoveToKanjiString(const ShogiGameController* algorithm, QString& predictedOpponentMove, QVector<QChar>& clonedBoardData);

    // 指し手を解析し、その指し手に基づいてコピーした盤面データを更新する。
    void parseAndApplyMoveToClonedBoard(const QString& str, QVector<QChar>& clonedBoardData);

    // 盤面データを9x9のマスに表示する。
    void printShogiBoard(const QVector<QChar>& boardData) const;

    // 評価値の文字列を設定する。
    void setScore(const QString& newScore);

    // 評価値の文字列を取得する。
    QString score() const;

signals:
    // エラーを報告するためのシグナル
    void errorOccurred(const QString& errorMessage);

private:
    // 現在思考中の手の探索深さ
    QString m_depth;

    // 現在選択的に読んでいる手の探索深さ
    QString m_seldepth;

    // pv: 現在の読み筋を返す。（pvというのは、principal variationの略）
    // pvで初手の異なる複数の読み筋を返す時、それがn通りあれば、最も良い（評価値の高い）ものを返す。
    QString m_multipv;

    // 思考開始から探索したノード数
    QString m_nodes;

    // 1秒あたりの探索局面数
    QString m_nps;

    // 思考を開始してから経過した時間（単位はミリ秒）
    QString m_time;

    // 評価値
    QString m_score;

    // info行のGUIに表示させたい任意の文字列
    QString m_string;

    // エンジンによる現在の評価値
    QString m_scoreCp;

    // エンジンが詰みを発見した場合の詰み手数
    QString m_scoreMate;

    // 現在の読み筋を漢字表示で表した文字列
    QString m_pvKanjiStr;

    // エンジンが現在使用しているハッシュの使用率
    QString m_hashfull;

    // GUIの「探索手」の欄に表示する読み筋の最初の文字列
    QString m_searchedHand;

    // 直前の指し手のマスの筋
    int m_previousFileTo;

    // 直前の指し手のマスの段
    int m_previousRankTo;

    // 駒台の段と駒の対応マップ
    QMap<int, QChar> m_pieceMap;

    // 駒とその成駒の対応マップ
    QMap<QChar, QChar> m_promoteMap;

    // 駒台の駒と段の対応マップ
    QMap<QChar, int> m_pieceCharToIntMap;

    // 駒文字と漢字の駒の対応マップ
    QMap<QChar, QString> m_pieceMapping;

    // フラグの変数名
    EvaluationBound m_evaluationBound;

    // 指し手文字列の三角マークを返す。
    // 例．「△７八馬(77)▲２五歩(26)△８六歩(85)▲２四歩(25)△同歩(23)▲７七桂(89)△８七歩成(86)」
    QString getMoveSymbol(const int moveIndex, const ShogiGameController* algorithm, const bool isPondering) const;

    // 直前の指し手と同じマスに指す場合、「同」を付ける。（同歩、同銀など）
    QString getFormattedMove(int fileTo, int rankTo, const QString& kanji) const;

    // 将棋エンジンから受信した読み筋を将棋の指し手の文字列に変換する。
    // 例．
    // 「7g7h 2f2e 8e8f 2e2d 2c2d 8i7g 8f8g+」
    // 「△７八馬(77)▲２五歩(26)△８六歩(85)▲２四歩(25)△同歩(23)▲７七桂(89)△８七歩成(86)」
    QString convertMoveToShogiString(const QString& kanji, const int fileFrom, const int rankFrom, const int fileTo, const int rankTo,
                                     const bool promote, const ShogiGameController* algorithm, const int moveIndex, const bool isPondering);

    // 段を示す文字を整数に変換する関数
    // 文字'a'から'i'までを1から9に変換する。
    int convertRankCharToInt(const QChar rankChar);

    // 駒文字を駒台の段番号に変換する。
    int convertPieceToStandRank(const QChar pieceChar);

    // 引数で与えられた文字が将棋盤のランクを表す文字（'a'から'i'）であるかどうかをチェックする。
    bool isBoardRankChar(const QChar rankChar) const;

    // 指し手を表す文字列から指し手のマスの座標と成るかどうかのフラグを取得する。
    int parseMoveString(const QString& moveStr, int& fileFrom, int& rankFrom, int& fileTo, int& rankTo, bool& promote);

    // 駒文字から漢字の駒を返す。
    QString getPieceKanjiName(QChar symbol);

    // 指定した位置の駒を表す文字を返す。
    QChar getPieceCharacter(const QVector<QChar>& boardData, const int file, const int rank);

    // 将棋盤のマスに駒を配置する。
    bool setData(QVector<QChar>& boardData, const int file, const int rank, const QChar piece) const;

    // 駒を指定したマスへ移動する。配置データのみを更新する。
    void movePieceToSquare(QVector<QChar>& boardData, QChar movingPiece, int fileFrom, int rankFrom, int fileTo, int rankTo, bool promote) const;

    // 将棋エンジンから受信したinfo行を解析し、depthなどのサブコマンドの値を取得する。
    void parseEngineInfoTokens(const QStringList& tokens, const ShogiGameController* algorithm, QVector<QChar>& clonedBoardData,
                               const bool isPondering);

    // pvの情報を解析し、それに基づいて盤面を更新する。
    int parsePvAndSimulateMoves(const QStringList& pvstr, const ShogiGameController* m_algorithm, QVector<QChar> copyBoardData,
                                const bool isPondering);

    // scoreサブコマンドの解析を行う。
    // score cp、score mate、およびそれらに関連する lowerbound、upperboundの処理を行う。
    void parseScore(const QStringList& tokens, int index);

    // 将棋エンジンからinfo currmove <move>が返された場合、その漢字の指し手に変換する。
    QString convertCurrMoveToKanjiNotation(const QString& str, const ShogiGameController* algorithm, QVector<QChar>& clonedBoardData,
                                           const bool isPondering);
};

#endif // SHOGIENGINEINFOPARSER_H
#ifndef SHOGIENGINETHINKINGMODEL_H
#define SHOGIENGINETHINKINGMODEL_H

#include <QVariant>
#include "abstractlistmodel.h"
#include "shogiinforecord.h"

// 将棋エンジンの思考結果をGUI上で表示するためのクラス
class ShogiEngineThinkingModel : public AbstractListModel<ShogiInfoRecord>
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit ShogiEngineThinkingModel(QObject *parent = nullptr);

    // 列数を返す。
    int columnCount(const QModelIndex &parent = QModelIndex()) const override;

    // データを返す。
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;

    // ヘッダーを返す。
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
};

#endif // SHOGIENGINETHINKINGMODEL_H
#ifndef SHOGIGAMECONTROLLER_H
#define SHOGIGAMECONTROLLER_H

#include <QObject>
#include "movevalidator.h"
#include "playmode.h"

// 将棋盤を表すクラス
class ShogiBoard;

// 将棋の対局全体を管理し、盤面の初期化、指し手の処理、合法手の検証、対局状態の管理を行うクラス
class ShogiGameController : public QObject
{
    Q_OBJECT

    Q_PROPERTY(Player currentPlayer READ currentPlayer NOTIFY currentPlayerChanged)

public:
    // 対局結果を表す列挙型
    enum Result { NoResult, Player1Wins, Draw, Player2Wins };

    Q_ENUM(Result)

    // 対局者を表す列挙型
    enum Player { NoPlayer, Player1, Player2 };

    Q_ENUM(Player)

    // コンストラクタ
    explicit ShogiGameController(QObject* parent = nullptr);

    // 将棋盤のポインタを返す。
    ShogiBoard* board() const;

    // 対局結果を返す。
    inline Result result() const { return m_result; }

    // 現在の手番を返す。
    inline Player currentPlayer() const { return m_currentPlayer; }

    // 現在の対局者を設定する。
    void setCurrentPlayer(const Player);

    // 将棋の指し手を検証し、合法手であれば盤面を更新する。
    // 将棋の指し手を検証し、合法手であれば盤面を更新する。
    bool validateAndMove(QPoint& outFrom, QPoint& outTo, QString& record, PlayMode& playMode, int& moveNumber,
                         QStringList* m_sfenRecord, QVector<ShogiMove>& gameMoves);

    // 局面編集で駒移動を行い、局面を更新する。
    bool editPosition(const QPoint& outFrom, const QPoint& outTo);

    // 指し手を漢字の文字列に変換する。
    QString convertMoveToKanjiStr(const QString piece, const int fileFrom, const int rankFrom, const int fileTo, const int rankTo);

    // 対局結果を設定する。
    void gameResult();

    // 歩、桂馬、香車を指した場合に成りが必須になる時のフラグを設定する。
    void setMandatoryPromotionFlag(const int fileTo, const int rankTo, const QChar source);

    // 編集局面モードの際、右クリックで駒を成・不成に変換する。
    void switchPiecePromotionStatusOnRightClick(const int fileFrom, const int rankFrom) const;

    // 二歩になるかどうかをチェックする。
    bool checkTwoPawn(const QChar source, const int fileFrom, const int fileTo) const;

    // 指そうとした場所に味方の駒があるかどうかチェックする。
    bool checkWhetherAllyPiece(const QChar source, const QChar dest, const int fileFrom, const int fileTo) const;

    // 駒台から指そうとした場合、駒台の駒数が0以下の時は、駒台の駒は無いので指せない。
    bool checkNumberStandPiece(const QChar source, const int fileFrom) const;

    // 駒台から駒台に駒を移動することが可能かどうかをチェックする。
    // 先手の駒台の駒から後手の駒台の異種駒には、駒は移せない。
    // また、後手の駒台の駒から先手の駒台の異種駒には、駒は移せない。
    bool checkFromPieceStandToPieceStand(const QChar source, const QChar dest, const int fileFrom, const int fileTo) const;

    // 王、玉は、相手の駒で取ることはできないので、取れない場合はfalseを返す。
    bool checkGetKingOpponentPiece(const QChar source, const QChar dest) const;

    // 禁じ手をチェックする。
    bool checkMovePiece(const QChar source, const QChar dest, const int fileFrom, const int fileTo) const;

    // 局面編集後の局面をSFEN形式に変換し、リストに追加する。
    void updateSfenRecordAfterEdit(QStringList* m_sfenRecord);

    // 手番を変える。
    void changeCurrentPlayer();

    // 成り・不成のフラグを設定する。
    void setPromote(bool newPromote);

    // 成り・不成のフラグを返す。
    bool promote() const;

    QPoint lastMoveTo() const;  // 直前着手の移動先（筋, 段）を返す

    // 既存の public: メソッド群のどこか（validateAndMove などの近く）に追記
    void applyTimeoutLossFor(int clockPlayer);     // player==1 なら先手の時間切れ→後手勝ち／player==2 なら先手勝ち
    void applyResignationOfCurrentSide();          // 現在手番側が投了 → 相手の勝ち
    void finalizeGameResult();                     // 結果未確定なら最終決定（未決のときは currentPlayer に基づいて勝敗をセット）

public slots:
    // 新規対局の準備
    // 将棋盤、駒台を初期化（何も駒がない）し、入力のSFEN文字列の配置に将棋盤、駒台の駒を
    // 配置し、対局結果を結果なし、現在の手番がどちらでもない状態に設定する。
    void newGame(QString& startsfenstr);

signals:
    // 盤面が変更されたことを通知する。
    void boardChanged(ShogiBoard *);

    // 対局結果が変更されたことを通知する。
    void gameOver(ShogiGameController::Result);

    // 対局者に成るかどうかを選択させるダイアログを表示する。
    void showPromotionDialog();

    // 現在の手番が変更されたことを通知する。
    void currentPlayerChanged(ShogiGameController::Player);

    // 駒のドラッグを終了したことを通知する。
    void endDragSignal();

    void moveCommitted(ShogiGameController::Player mover, int ply);

    // エラーを報告するためのシグナル
    void errorOccurred(const QString& errorMessage);

private:
    // 将棋盤のポインタ
    ShogiBoard* m_board;

    // 対局結果
    Result m_result;

    // 現在の手番
    Player m_currentPlayer;

    // 成るかどうかのフラグ
    bool m_promote;

    // 1手前に指した手の移動先の筋
    int previousFileTo;

    // 1手前に指した手の移動先の段
    int previousRankTo;

    // 将棋盤のポインタを設定する。
    void setupBoard();

    // 将棋盤の81マスに空白を代入し、駒台の駒を0にする。
    // 将棋盤を示すポインタm_boardを作成する。
    void setBoard(ShogiBoard* board);

    // 対局結果を設定する。
    void setResult(Result);

    // アルファベットの駒文字を漢字表記にする。
    QString getPieceKanji(const QChar& piece);

    // 指定された駒が成ることが可能な駒であるかを判定する。
    bool isPromotablePiece(QChar& piece);

    // ダイアログを表示してユーザーに成るかどうかを選択させる。
    void decidePromotionByDialog(QChar &piece, int &rankFrom, int &rankTo);

    // 人間が対局者に含まれているかどうかを判定する。
    bool isCurrentPlayerHumanControlled(PlayMode& playMode);

    // 人間が指した場合に指し手で成る手と不成の手が合法手であるかを判定し、GUIのダイアログで対局者に
    // 成るか成らないかを選択させて、その結果をcurrentMove.isPromotionに保存する。
    // 指し手が合法であればtrue、不合法であればfalseを返す。
    bool decidePromotion(PlayMode& playMode, MoveValidator& validator, const MoveValidator::Turn& turnMove,
                         int& fileFrom, int& rankFrom, int& fileTo, int& rankTo, QChar& piece,  ShogiMove& currentMove);

    // 相手の手番をSFEN形式の手番bまたはwで取得する。
    QString getNextPlayerSfen();

    // 合法手生成に関するクラスで利用するための手番を設定する。
    MoveValidator::Turn getCurrentTurnForValidator(MoveValidator& validator);
};

#endif // SHOGIGAMECONTROLLER_H
#ifndef SHOGIINFORECORD_H
#define SHOGIINFORECORD_H

#include <QObject>
#include <QString>

// GUIの思考タブの表に「時間」「深さ」「ノード数」「評価値」「読み筋」をセットするためのクラス
class ShogiInfoRecord : public QObject
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit ShogiInfoRecord(QObject *parent = nullptr);

    // コンストラクタ
    ShogiInfoRecord(const QString &time, const QString &depth, const QString &nodes,
               const QString &score, const QString &pv, QObject *parent = nullptr);


    // 思考時間を取得する。
    QString time() const;

    // 現在思考中の手の探索深さを取得する。
    QString depth() const;

    // 思考開始から探索したノード数を取得する。
    QString nodes() const;

    // 現在の評価値を取得する。
    QString score() const;

    // 現在の読み筋を取得する。
    QString pv() const;

private:
    // 思考時間
    QString m_time;

    // 現在思考中の手の探索深さ
    QString m_depth;

    // 思考開始から探索したノード数
    QString m_nodes;

    // エンジンによる現在の評価値
    QString m_score;

    // 現在の読み筋
    QString m_pv;
};

#endif // SHOGIINFORECORD_H
#ifndef SHOGIMOVE_H
#define SHOGIMOVE_H

#include <QPoint>
#include <iostream>
#include <QVector>
#include <QDebug>

struct ShogiMove {
    // 駒の移動元のマス
    QPoint fromSquare;

    // 駒の移動先のマス
    QPoint toSquare;

    // 指した自分の駒情報
    QChar movingPiece;

    // 捕獲した駒情報（駒が無ければ、空文字（' '）で初期化）
    QChar capturedPiece;

    // 駒が成るかどうかを示す情報（成る: true、不成: false）
    bool isPromotion;

    // デフォルトコンストラクタ
    ShogiMove();

    // コンストラクタ
    ShogiMove(const QPoint &from, const QPoint &to, QChar moving, QChar captured, bool promotion);

    // 構造体ShogiMoveの比較演算子定義
    bool operator==(const ShogiMove& other) const;

    // 構造体ShogiMoveのデバッグプリント用演算子"<<"の定義
    friend std::ostream& operator<<(std::ostream& os, const ShogiMove& move);
};

QDebug operator<<(QDebug dbg, const ShogiMove& move);

#endif // SHOGIMOVE_H
#ifndef SHOGIUTILS_H
#define SHOGIUTILS_H

#include <QString>
#include <QElapsedTimer>

// ShogibanQで使用する共通関数
namespace ShogiUtils {
    // 指した先のマスの段を漢字表記で出力する。
    QString transRankTo(const int rankTo);

    // 指した先のマスの筋を漢字表記で出力する。
    QString transFileTo(const int fileTo);

    // エラーメッセージをログ出力し、例外をスローする。
    void logAndThrowError(const QString& errorMessage);
}

namespace ShogiUtils {
    void startGameEpoch();      // 新規対局の開始時に呼ぶ
    qint64 nowMs();             // 対局開始からの経過ms（モノトニック）
}

#endif // SHOGIUTILS_H
#ifndef SHOGIVIEW_H
#define SHOGIVIEW_H

// ─────────────────────────────────────────────────────────────────────────────
// ShogiView
// 盤（9x9）と駒台を描画・操作する Qt ウィジェット。
// - 反転表示、局面編集モード、ドラッグ＆ドロップ、ハイライト表示、時計/名前ラベル表示などを提供
// - ShogiBoard（局面モデル）と接続して動作
// 設計メモ：
//  * QPainter の state 汚染を最小化するため、描画ヘルパは極力ローカルで save/restore する方針
//  * 駒台の疑似座標として file=10/11 を使用（左/右のスタンド列）
//  * ラベル（時計/名前）はウィジェット子として配置し、レイアウトは本クラスで制御
// ─────────────────────────────────────────────────────────────────────────────

#include "elidelabel.h"
#include "shogigamecontroller.h"

#include <QIcon>
#include <QMap>
#include <QPointer>
#include <QWidget>
#include <QLoggingCategory>
#include <QPushButton>

Q_DECLARE_LOGGING_CATEGORY(ClockLog)

// 前方宣言（ヘッダ依存を軽減）
class ShogiBoard;
class GlobalToolTip;
class QLabel;
class QPainter;
class QEvent;
class QMouseEvent;
class QResizeEvent;
class QColor;
class QPoint;
class QRect;
class QSize;
class QString;

class ShogiView : public QWidget
{
    Q_OBJECT
    // Q_PROPERTY: QML/Qt Designer 等からマスサイズ（正方）をバインド可能にする
    Q_PROPERTY(QSize fieldSize READ fieldSize WRITE setFieldSize NOTIFY fieldSizeChanged)

public:
    // ──────────────────────────── ハイライト種別 ─────────────────────────────
    // 視覚強調を表す基底クラス。必要に応じて派生種別を追加可能。
    class Highlight
    {
    public:
        Highlight() {}
        virtual ~Highlight() {}
        virtual int type() const { return 0; }  // 型識別子
    };

    // 1 マス単位の矩形ハイライト（色つき）
    class FieldHighlight : public Highlight
    {
    public:
        enum { Type = 1 };
        FieldHighlight(int file, int rank, QColor color) : m_field(file, rank), m_color(color) {}
        inline int file()        const { return m_field.x(); }
        inline int rank()        const { return m_field.y(); }
        inline QColor color()    const { return m_color; }
        int type() const override { return Type; }
    private:
        QPoint m_field;  // (file, rank)
        QColor m_color;
    };

    // ───────────────────────────── コンストラクタ ─────────────────────────────
    explicit ShogiView(QWidget *parent = nullptr);

    // ───────────────────────────── ボード接続 ────────────────────────────────
    void setBoard(ShogiBoard* board);   // モデル（局面）を差し替え
    ShogiBoard* board() const;          // 現在のモデル

    // ───────────────────────────── 盤サイズ系 ────────────────────────────────
    QSize fieldSize() const;            // 1マスの QSize（正方形推奨）
    QSize sizeHint() const override;    // レイアウト用の推奨サイズ
    void updateBoardSize();             // m_squareSize を反映して再配置（ユーティリティ）

    // 盤/ラベル座標計算（反転考慮）
    QRect calculateSquareRectangleBasedOnBoardState(int file, int rank) const;
    QRect calculateRectangleForRankOrFileLabel(int file, int rank) const;

    // ───────────────────────────── 駒画像管理 ────────────────────────────────
    void  setPiece(char type, const QIcon &icon); // 駒文字 → アイコン登録
    QIcon piece(QChar type) const;                // 駒文字 → アイコン取得
    void  setPieces();                            // 通常向きの画像一括登録
    void  setPiecesFlip();                        // 反転向きの画像一括登録

    // ───────────────────────────── 入力座標変換 ──────────────────────────────
    QPoint getClickedSquare(const QPoint& clickPosition) const;            // エントリ
    QPoint getClickedSquareInDefaultState(const QPoint& clickPosition) const; // 非反転
    QPoint getClickedSquareInFlippedState(const QPoint& clickPosition) const; // 反転

    // ───────────────────────────── ハイライト管理 ───────────────────────────
    void addHighlight(Highlight *hl);            // 追加（所有権ポリシーは呼び出し側設計に依存）
    void removeHighlight(Highlight *hl);         // 1件削除
    void removeHighlightAllData();               // 全削除
    inline Highlight *highlight(int index) const { return m_highlights.at(index); }
    inline int highlightCount() const { return m_highlights.size(); }

    // ───────────────────────────── 操作/状態切替 ────────────────────────────
    void setMouseClickMode(bool mouseClickMode); // クリック操作フラグ
    int  squareSize() const;                     // m_squareSize（px）
    void setPositionEditMode(bool positionEditMode); // 局面編集モードON/OFF
    bool positionEditMode() const;

    void resetAndEqualizePiecesOnStands();       // 初期化（平手/駒台均し等は ShogiBoard 実装に依存）
    void initializeToFlatStartingPosition();     // 平手初期局面を適用
    void shogiProblemInitialPosition();          // 問題用初期局面を適用
    void flipBoardSides();                       // 先後入替（モデル側で処理）

    bool getFlipMode() const;                    // 反転表示か
    void setFlipMode(bool newFlipMode);          // 反転表示の切替

    void setErrorOccurred(bool newErrorOccurred);// エラーフラグ

    // ドラッグ操作
    void startDrag(const QPoint &from);
    void endDrag();

    // 時計テキスト
    void setBlackClockText(const QString& text);
    void setWhiteClockText(const QString& text);
    QLabel *blackClockLabel() const;
    QLabel *whiteClockLabel() const;

    // プレイヤー名
    void setBlackPlayerName(const QString& name);
    void setWhitePlayerName(const QString& name);
    ElideLabel *blackNameLabel() const;
    ElideLabel *whiteNameLabel() const;

    // レイアウト調整パラメータ
    void setStandGapCols(double cols);      // 盤‐駒台の横ギャップ（列数 0.0〜2.0）
    void setNameFontScale(double scale);    // 0.2〜1.0 程度
    void setRankFontScale(double scale);    // 0.5〜1.2 程度

    // 手番表示（true=先手手番, false=後手手番）
    void setActiveSide(bool blackTurn);

    // 手番ハイライト配色（任意）
    void setHighlightStyle(const QColor& bgOn, const QColor& fgOn, const QColor& fgOff);

    // 追加: 残時間(ミリ秒)を受け取るセッター
    void setBlackTimeMs(qint64 ms);
    void setWhiteTimeMs(qint64 ms);

    QImage toImage(qreal scale = 1.0);

    // board を適用して即再描画する（ピース読み込みも面倒見ます）
    void applyBoardAndRender(ShogiBoard* board);

    // レイアウト都合の固定サイズ指定は外側の責務にするのが基本ですが、
    // まとめたいならこちらも用意可（任意）
    void configureFixedSizing(int squarePx = -1);

    void clearTurnHighlight();

    void setUiMuted(bool on);
    bool uiMuted() const { return m_uiMuted; }

    void setActiveIsBlack(bool activeIsBlack);

    // ── 状態管理
    // 既存 enum に 0秒用の状態を追加
    enum class Urgency { Normal, Warn10, Warn5 };
    Urgency m_urgency = Urgency::Normal;

    // しきい値（ミリ秒）
    static constexpr qint64 kWarn10Ms = 10'000;
    static constexpr qint64 kWarn5Ms  = 5'000;

    void setUrgencyVisuals(Urgency u);

    void updateTurnIndicator(ShogiGameController::Player now);

    void relayoutEditExitButton();

public slots:
    // Q_PROPERTY 用 setter（レイアウト更新・ラベル再配置を含む）
    void setFieldSize(QSize fieldSize);
    // 盤拡大/縮小（m_squareSize を ±1）
    void enlargeBoard();
    void reduceBoard();

    // 手番側の残り時間に応じて“名前/時計”の配色を切り替える
    void applyClockUrgency(qint64 activeRemainMs);

signals:
    void fieldSizeChanged(QSize fieldSize);  // setFieldSize 内で発火
    void clicked(const QPoint&);             // 左クリック
    void rightClicked(const QPoint&);        // 右クリック
    void errorOccurred(const QString& errorMessage);

protected:
    // ───────────────────────────── QWidget オーバライド ─────────────────────
    void paintEvent(QPaintEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void resizeEvent(QResizeEvent* e) override;
    bool eventFilter(QObject* obj, QEvent* ev) override;

private:
    // ───────────────────────────── 描画ヘルパ（盤/駒/ラベル） ────────────────
    void drawFiles(QPainter* painter);                         // 全筋ラベル
    void drawFile(QPainter* painter, int file) const;          // 筋ラベル 1 本
    void drawRanks(QPainter* painter);                         // 全段ラベル
    void drawRank(QPainter* painter, int rank) const;          // 段ラベル 1 本

    void drawBoardFields(QPainter* painter);                   // 盤の全マス
    void drawField(QPainter* painter, int file, int rank) const;

    void drawPieces(QPainter* painter);                        // 盤の全駒
    void drawPiece(QPainter* painter, int file, int rank);

    void drawFourStars(QPainter* painter);                     // 4隅の星（装飾）
    void drawHighlights(QPainter* painter);                    // ハイライト（含む駒台疑似座標）

    // 駒台（マス背景）
    void drawBlackStandField(QPainter* painter, int file, int rank) const;
    void drawWhiteStandField(QPainter* painter, int file, int rank) const;

    // 駒台（駒・枚数：通常モード）
    void drawBlackStandPiece(QPainter* painter, int file, int rank) const;
    void drawWhiteStandPiece(QPainter* painter, int file, int rank) const;

    // 表示モード別の駒台領域/駒描画
    void drawBlackNormalModeStand(QPainter* painter);
    void drawWhiteNormalModeStand(QPainter* painter);
    void drawNormalModeStand(QPainter* painter);
    void drawPiecesBlackStandInNormalMode(QPainter* painter);
    void drawPiecesWhiteStandInNormalMode(QPainter* painter);
    void drawPiecesStandFeatures(QPainter* painter);

    // ドラッグ中の駒（カーソル追従）
    void drawDraggingPiece(QPainter* painter);

    // 駒台の駒・枚数描画の共通ロジック
    void drawStandPieceIcon(QPainter* painter, const QRect& adjustedRect, QChar value) const;

    // 駒台の段→駒文字マッピング
    QChar rankToBlackShogiPiece(const int file, const int rank) const;
    QChar rankToWhiteShogiPiece(const int file, const int rank) const;

    // ───────────────────────────── ラベルとレイアウト ──────────────────────
    void updateBlackClockLabelGeometry();   // 黒側ラベルのジオメトリ更新
    void updateWhiteClockLabelGeometry();   // 白側ラベルのジオメトリ更新
    QRect blackStandBoundingRect() const;   // 黒側駒台の外接矩形
    QRect whiteStandBoundingRect() const;   // 白側駒台の外接矩形
    void  recalcLayoutParams();             // 内部レイアウト定数の再計算

    // フォントを矩形にフィットさせる（時計用）
    void fitLabelFontToRect(QLabel* label, const QString& text,
                            const QRect& rect, int paddingPx = 2);

    // 盤・駒台境界のユーティリティ
    int  boardLeftPx()  const;
    int  boardRightPx() const;
    int  standInnerEdgePx(bool rightSide) const;
    int  minGapForRankLabelsPx() const;

    // 名前ラベル/ツールチップ
    void    refreshNameLabels();                 // 向きマーク付与の表示更新
    static QString stripMarks(const QString&);   // ▲▼▽△ の除去

    // 手番ハイライト
    void   applyTurnHighlight(bool blackActive);

private:
    // ───────────────────────────── 内部状態（モデル/描画/入力） ────────────────
    // モデル
    QPointer<ShogiBoard> m_board;       // 局面。寿命は外部管理（QPointerで安全）

    // 描画寸法・配置
    int   m_squareSize { 50 };          // 1マスの基準ピクセル（正方）
    QSize m_fieldSize;                  // 1マスの QSize（正方前提だが将来拡張可）

    int   m_param1 { 0 };               // 先手側スタンドの水平寄せ量（px）
    int   m_param2 { 0 };               // 後手側スタンドの水平寄せ量（px）
    int   m_offsetX{ 0 };               // 盤の左端 X（boardLeftPx 相当）
    int   m_offsetY{ 20 };              // 盤の上端 Y のオフセット
    bool  m_flipMode{ false };          // 反転表示

    // ラベル帯とフォント
    int    m_labelGapPx  { 8 };         // 盤とラベルのすき間
    int    m_labelBandPx { 36 };        // ラベル帯の厚み
    double m_labelFontPt { 12.0 };      // ラベル用の基準フォントサイズ（pt）
    double m_nameFontScale { 0.36 };    // 名前ラベルのスケール
    double m_rankFontScale { 0.8 };     // 段ラベルのスケール

    // 盤‐駒台ギャップ
    double m_standGapCols { 0.6 };      // 列数換算（0.0〜2.0）
    int    m_standGapPx   { 0 };        // 実効ギャップ（px）

    // リソース（駒アイコン・ハイライト）
    QMap<QChar, QIcon>  m_pieces;       // 駒文字 → QIcon
    QList<Highlight*>   m_highlights;   // ハイライト（所有権は呼び出し側設計に依存）

    // ラベル（子ウィジェット）
    QLabel*     m_blackClockLabel { nullptr };
    QLabel*     m_whiteClockLabel { nullptr };
    ElideLabel* m_blackNameLabel  { nullptr };
    ElideLabel* m_whiteNameLabel  { nullptr };

    // プレイヤー名（装飾抜きの素の文字列）
    QString m_blackNameBase;
    QString m_whiteNameBase;

    // 入力/ドラッグ
    bool   m_mouseClickMode   { true };   // クリック操作モード
    bool   m_positionEditMode { false };  // 局面編集モード
    bool   m_dragging         { false };  // ドラッグ中
    QPoint m_dragFrom;                    // つまみ上げ元のマス
    QChar  m_dragPiece { ' ' };           // ドラッグ中の駒文字
    QPoint m_dragPos;                     // カーソル座標（ウィジェット系）
    bool   m_dragFromStand { false };     // 駒台からのドラッグか
    QMap<QChar,int> m_tempPieceStandCounts; // ドラッグ中の一時在庫

    // 手番ハイライト
    QColor m_highlightBg    = QColor(255, 255, 0);
    QColor m_highlightFgOn  = QColor(0, 0, 255);
    QColor m_highlightFgOff = QColor(51, 51, 51);
    bool   m_blackActive    = true;

    // 既存の「手番ハイライト色」を Normal として利用
    // 追加：10秒/5秒で使う配色
    QColor m_urgencyBgWarn10 = QColor(255, 193, 7);// 濃いめの黄橙
    QColor m_urgencyFgWarn10 = QColor(32, 32, 32); // 黒系
    QColor m_urgencyBgWarn5  = QColor(229, 57, 53); // 赤
    QColor m_urgencyFgWarn5  = QColor(255, 255, 255); // 白

    // ── 色（数値指定で clazy 回避）
    const QColor kTurnBg   = QColor(255, 249, 196); // 通常背景（黄系）
    const QColor kTurnFg   = QColor(  0,  64, 255);  // 通常文字（青）

    const QColor kWarn10Bg = QColor(255, 255,   0); // 10秒 背景（黄）
    const QColor kWarn10Fg = QColor(  0,   0, 255); // 10秒 文字（青）

    const QColor kWarn5Bg  = QColor(255, 255,   0); // 5秒 背景（黄）
    const QColor kWarn5Fg  = QColor(255,   0,   0); // 5秒 文字（赤）

    const QColor kWarn10Border = QColor(  0,  0, 255); // 10秒 枠色（青）
    const QColor kWarn5Border  = QColor(255,   0,   0); // 5秒 枠色（赤）

    // ── ヘルパ
    void setLabelStyle(QLabel* lbl,
                       const QColor& fg, const QColor& bg,
                       int borderPx, const QColor& borderColor,
                       bool bold);
    static QString toRgb(const QColor& c);              // "rgb(r,g,b)" 生成

    // エラー状態
    bool   m_errorOccurred { false };

    // 自前ツールチップ
    GlobalToolTip* m_tooltip = nullptr;

    // 起動直後や対局前に、両側を同じ基準タイポグラフィに整える
    void applyStartupTypography();

    // 追加: ログ用に保持
    qint64 m_blackTimeMs = -1;
    qint64 m_whiteTimeMs = -1;

    // ログスパム防止（前回値と同じなら出力しない）
    qint64 m_lastLoggedBlackMs = -2;
    qint64 m_lastLoggedWhiteMs = -2;

    bool m_uiMuted = false;

    void ensureTurnLabels_();
    void relayoutTurnLabels_();

    void ensureAndPlaceEditExitButton_();

    void styleEditExitButton_(QPushButton* btn);
    void fitEditExitButtonFont_(QPushButton* btn, int maxWidth);
};

#endif // SHOGIVIEW_H
#ifndef STARTGAMEDIALOG_H
#define STARTGAMEDIALOG_H

#include <QDialog>
#include <QComboBox>
#include <QRadioButton>

namespace Ui {
class StartGameDialog;
}

class StartGameDialog : public QDialog
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit StartGameDialog(QWidget *parent = nullptr);

    // デストラクタ
    ~StartGameDialog();

    // 先手／下手が人間であるかを示すフラグを取得する。
    bool isHuman1() const;

    // 後手／上手が人間であるかを示すフラグを取得する。
    bool isHuman2() const;

    // 先手／下手がエンジンであるかを示すフラグを取得する。
    bool isEngine1() const;

    // 後手／上手がエンジンであるかを示すフラグを取得する。
    bool isEngine2() const;

    // 先手／下手のエンジン名を取得する。
    const QString& engineName1() const;

    // 後手／上手のエンジン名を取得する。
    const QString& engineName2() const;

    // 先手／下手の人間名を取得する。
    const QString& humanName1() const;

    // 後手／上手の人間名を取得する。
    const QString& humanName2() const;

    // 先手／下手のエンジン番号を取得する。
    int engineNumber1() const;

    // 後手／上手のエンジン番号を取得する。
    int engineNumber2() const;

    // 対局者1の持ち時間の時間を取得する。
    int basicTimeHour1() const;

    // 対局者1の持ち時間の分を取得する。
    int basicTimeMinutes1() const;

    // 対局者1の秒読みの時間（秒）を取得する。
    int byoyomiSec1() const;

    // 対局者1の1手ごとの加算（秒）を取得する。
    int addEachMoveSec1() const;

    // 対局者2の持ち時間の時間を取得する。
    int basicTimeHour2() const;

    // 対局者2の持ち時間の分を取得する。
    int basicTimeMinutes2() const;

    // 対局者2の秒読みの時間（秒）を取得する。
    int byoyomiSec2() const;

    // 対局者2の1手ごとの加算（秒）を取得する。
    int addEachMoveSec2() const;

    // 対局の初期局面名を取得する。
    const QString& startingPositionName() const;

    // 対局の初期局面番号を取得する。
    int startingPositionNumber() const;

    // エンジンの名前とディレクトリを格納する構造体
    struct Engine
    {
        QString name;
        QString path;
    };

    // エンジンの名前とディレクトリを格納するリストを取得する。
    const QList<StartGameDialog::Engine>& getEngineList() const;

    // 最大手数を取得する。
    int maxMoves() const;

    // 連続対局数を取得する。
    int consecutiveGames() const;

    // 人を手前に表示するかどうかのフラグを取得する。
    bool isShowHumanInFront() const;

    // 棋譜の自動保存フラグを取得する。
    bool isAutoSaveKifu() const;

    // 時間切れを負けにするかどうかのフラグを取得する。
    bool isLoseOnTimeout() const;

    // 1局ごとに手番を入れ替えるかどうかのフラグを取得する。
    bool isSwitchTurnEachGame() const;

private:
    // UI
    Ui::StartGameDialog* ui;

    // 先手／下手が人間であるかを示すフラグ
    bool m_isHuman1;

    // 後手／上手が人間であるかを示すフラグ
    bool m_isHuman2;

    // 先手／下手がエンジンであるかを示すフラグ
    bool m_isEngine1;

    // 後手／上手がエンジンであるかを示すフラグ
    bool m_isEngine2;

    // 先手／下手のエンジン名
    QString m_engineName1;

    // 後手／上手のエンジン名
    QString m_engineName2;

    // 先手／下手の人間名
    QString m_humanName1;

    // 後手／上手の人間名
    QString m_humanName2;

    // 先手／下手のエンジン番号
    int m_engineNumber1;

    // 後手／上手のエンジン番号
    int m_engineNumber2;

    // 対局者1の持ち時間の時間
    int m_basicTimeHour1;

    // 対局者1の持ち時間の分
    int m_basicTimeMinutes1;

    // 対局者1の1手ごとの加算（秒）
    int m_addEachMoveSec1;

    // 対局者1の秒読みの時間（秒）
    int m_byoyomiSec1;

    // 対局者2の持ち時間の時間
    int m_basicTimeHour2;

    // 対局者2の持ち時間の分
    int m_basicTimeMinutes2;

    // 対局者2の1手ごとの加算（秒）
    int m_addEachMoveSec2;

    // 対局者2の秒読みの時間（秒）
    int m_byoyomiSec2;

    // 対局の初期局面
    QString m_startingPositionName;

    // 対局の初期局面番号
    int m_startingPositionNumber;

    // エンジン名とディレクトリを格納するリスト
    QList<Engine> engineList;

    // 最大手数
    int m_maxMoves;

    // 連続対局数
    int m_consecutiveGames;

    // 人を手前に表示するかどうかのフラグ
    bool m_isShowHumanInFront;

    // 棋譜の自動保存フラグ
    bool m_isAutoSaveKifu;

    // 時間切れを負けにするかどうかのフラグ
    bool m_isLoseOnTimeout;

    // 1局ごとに手番を入れ替えるかどうかのフラグ
    bool m_isSwitchTurnEachGame;

    // 設定ファイルからエンジンの名前とディレクトリを読み込む。
    void loadEngineConfigurations();

    // UIにエンジン設定を反映する。
    void populateUIWithEngines() const;

    // エンジン設定ダイアログの共通処理を行う。
    void showEngineSettingsDialog(QComboBox* comboBox);

    // シグナルとスロットを接続する。
    void connectSignalsAndSlots() const;

    // 設定ファイルから対局設定を読み込みGUIに反映する。
    void loadGameSettings();

private slots:
    // OKボタンが押された場合、対局ダイアログ内の各パラメータを取得する。
    void updateGameSettingsFromDialog();

    // 先手／下手のエンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
    void onFirstPlayerSettingsClicked();

    // 後手／上手のエンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
    void onSecondPlayerSettingsClicked();

    // 先後入れ替えボタンが押された場合、先後を入れ替える。
    void swapSides();

    // 設定ファイルに対局設定を保存する。
    void saveGameSettings();

    // 設定を初期値にリセットする。
    void resetSettingsToDefault();

    // 秒読みの値が変更された場合、1手ごとの加算時間を0に設定する。
    void handleByoyomiSecChanged(int value);

    // 1手ごとの加算時間の値が変更された場合、秒読みを0に設定する。
    void handleAddEachMoveSecChanged(int value);
};

#endif // STARTGAMEDIALOG_H
#ifndef TIMECONTROLUTIL_H
#define TIMECONTROLUTIL_H

#include "gamestartcoordinator.h"
#include <QString>

class ShogiClock;
class GameStartCoordinator;

namespace TimeControlUtil {

// GameStartCoordinator::TimeControl を ShogiClock へ適用。
// startSfenStr / currentSfenStr は「現在手番の推定」にのみ利用。
void applyToClock(ShogiClock* clock,
                  const GameStartCoordinator::TimeControl& tc,
                  const QString& startSfenStr,
                  const QString& currentSfenStr);

} // namespace TimeControlUtil

#endif // TIMECONTROLUTIL_H
#ifndef TIMEDISPLAYPRESENTER_H
#define TIMEDISPLAYPRESENTER_H

#include <QObject>
#include <QString>

class ShogiView;

class TimeDisplayPresenter : public QObject
{
    Q_OBJECT
public:
    explicit TimeDisplayPresenter(ShogiView* view, QObject* parent = nullptr);

public slots:
    // MatchCoordinator::timeUpdated から接続
    void onMatchTimeUpdated(qint64 p1ms, qint64 p2ms, bool p1turn, qint64 urgencyMs);

private:
    void applyTurnHighlights_(bool p1turn);
    void updateUrgencyStyles_(bool p1turn);

    static inline QString fmt_hhmmss(qint64 ms);

private:
    ShogiView* m_view = nullptr;
    qint64     m_lastP1Ms = 0;
    qint64     m_lastP2Ms = 0;
};

#endif // TIMEDISPLAYPRESENTER_H
#ifndef TIMEKEEPINGSERVICE_H
#define TIMEKEEPINGSERVICE_H

#include <QString>

class ShogiClock;
class ShogiGameController;
class MatchCoordinator;

class TimekeepingService {
public:
    // 「これから指す側」が P1 かどうかを引数で渡す。
    // 返り値は「直前に指した側の 1手の消費/累計」を "mm:ss/HH:MM:SS" で返す（未取得時は空）。
    static QString applyByoyomiAndCollectElapsed(ShogiClock* clock, bool nextIsP1);

    // 時計の停止/再開、司令塔の poke/arm/disarm など、時間面の後処理をまとめて実行。
    static void finalizeTurnPresentation(ShogiClock* clock,
                                         MatchCoordinator* match,
                                         ShogiGameController* gc,
                                         bool nextIsP1,
                                         bool isReplayMode);

    // 時計・司令塔・UI更新まで一括で実行する統合関数
    static void updateTurnAndTimekeepingDisplay(
        ShogiClock* clock,
        MatchCoordinator* match,
        ShogiGameController* gc,
        bool isReplayMode,
        const std::function<void(const QString&)>& appendElapsedLine, // 棋譜欄追記
        const std::function<void(int)>& updateTurnStatus               // UI 手番表示 (1:先手 / 2:後手)
        );
};

#endif // TIMEKEEPINGSERVICE_H
#ifndef TSUMEPOSITIONUTIL_H
#define TSUMEPOSITIONUTIL_H

#include <QString>
#include <QStringList>

// 詰み探索用に SFEN を「手番を明示」へ正規化し、"position sfen <...>" を返すユーティリティ。
class TsumePositionUtil {
public:
    static QString buildPositionForMate(const QStringList* sfenRecord,
                                        const QString& startSfenStr,
                                        const QStringList& positionStrList,
                                        int selectedIndex)
    {
        const int sel = qMax(0, selectedIndex);
        QString baseSfen;

        if (sfenRecord && !sfenRecord->isEmpty()) {
            const int safe = qBound(0, sel, sfenRecord->size() - 1);
            baseSfen = sfenRecord->at(safe);
        } else if (!startSfenStr.isEmpty()) {
            baseSfen = startSfenStr;
        } else if (!positionStrList.isEmpty()) {
            const int safe = qBound(0, sel, positionStrList.size() - 1);
            const QString pos = positionStrList.at(safe).trimmed();
            if (pos.startsWith(QStringLiteral("position sfen"))) {
                QString t = pos.mid(14).trimmed(); // "position sfen" を剥がす
                const int m = t.indexOf(QStringLiteral(" moves "));
                baseSfen = (m >= 0) ? t.left(m).trimmed() : t;
            }
        }
        if (baseSfen.isEmpty()) return QString();

        // 玉の有無から攻方を推定 → b/w を強制
        auto decideTurnFromSfen = [](const QString& sfen)->QChar {
            const QStringList toks = sfen.split(QLatin1Char(' '), Qt::SkipEmptyParts);
            if (toks.isEmpty()) return QLatin1Char('b');
            const QString& board = toks.at(0);
            int cntK = 0, cntk = 0;
            for (const QChar ch : board) {
                if (ch == QLatin1Char('K')) ++cntK;
                else if (ch == QLatin1Char('k')) ++cntk;
            }
            if ((cntK > 0) ^ (cntk > 0)) return (cntk > 0) ? QLatin1Char('b') : QLatin1Char('w');
            if (toks.size() >= 2) {
                if (toks[1] == QLatin1String("b")) return QLatin1Char('b');
                if (toks[1] == QLatin1String("w")) return QLatin1Char('w');
            }
            return QLatin1Char('b');
        };

        auto forceTurnInSfen = [](const QString& sfen, QChar turn)->QString {
            QStringList toks = sfen.split(QLatin1Char(' '), Qt::SkipEmptyParts);
            if (toks.size() >= 2) {
                toks[1] = QString(turn);
                if (toks.size() >= 4) toks[3] = QStringLiteral("1");
                return toks.join(QLatin1Char(' '));
            }
            return sfen + QLatin1Char(' ') + QString(turn) + QLatin1String(" - 1");
        };

        const QChar desiredTurn = decideTurnFromSfen(baseSfen);
        const QString forced    = forceTurnInSfen(baseSfen, desiredTurn);
        return QStringLiteral("position sfen %1").arg(forced);
    }
};

#endif // TSUMEPOSITIONUTIL_H
#ifndef TSUMESEARCHFLOWCONTROLLER_H
#define TSUMESEARCHFLOWCONTROLLER_H

#include <QObject>
#include <functional>

class QWidget;
class TsumeShogiSearchDialog;
class MatchCoordinator;

class TsumeSearchFlowController : public QObject
{
    Q_OBJECT
public:
    struct Deps {
        MatchCoordinator* match = nullptr;     // 司令塔
        // 局面生成に必要な素材（MainWindow から供給）
        const QStringList* sfenRecord = nullptr;  // 棋譜の SFEN 列
        QString            startSfenStr;          // 開始 SFEN（空可）
        QStringList        positionStrList;       // 既存 "position ..." の列
        int                currentMoveIndex = 0;  // 現在の行
        std::function<void(const QString&)> onError; // 任意: エラー表示
    };

    explicit TsumeSearchFlowController(QObject* parent=nullptr);
    void runWithDialog(const Deps& d, QWidget* parent);

private:
    QString buildPositionForMate_(const Deps& d) const;
    void startAnalysis_(MatchCoordinator* match,
                        const QString& enginePath,
                        const QString& engineName,
                        const QString& positionStr,
                        int byoyomiMs);
};

#endif // TSUMESEARCHFLOWCONTROLLER_H
#ifndef TSUMESHOGISEARCHDIALOG_H
#define TSUMESHOGISEARCHDIALOG_H

#include "considerationdialog.h"

namespace Ui {
class TsumeShogiSearchDialog;
}

// 詰み探索ダイアログを表示する。
class TsumeShogiSearchDialog : public ConsiderationDialog
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit TsumeShogiSearchDialog(QWidget *parent = nullptr);

    // デストラクタ
    ~TsumeShogiSearchDialog();
};

#endif // TSUMESHOGISEARCHDIALOG_H
#ifndef TURNMANAGER_H
#define TURNMANAGER_H

#include <QObject>
#include "shogigamecontroller.h"

// 薄い手番マネージャ：手番の単一ソース＋表現変換＋シグナル配信
class TurnManager : public QObject
{
    Q_OBJECT
public:
    using Side = ShogiGameController::Player; // Player1 / Player2 / NoPlayer

    explicit TurnManager(QObject* parent=nullptr);

    Side side() const;
    void set(Side s);
    void toggle();

    // ---- 変換：SFEN "b"/"w"
    QString toSfenToken() const;
    void setFromSfenToken(const QString& bw);

    // ---- 変換：Clock 1/2
    int  toClockPlayer() const;
    void setFromClockPlayer(int p);

    // ---- 変換：GC
    ShogiGameController::Player toGc() const;
    void setFromGc(ShogiGameController::Player p);

signals:
    void changed(ShogiGameController::Player now);

private:
    Side m_side;
};

#endif // TURNMANAGER_H
#ifndef TURNSYNCBRIDGE_H
#define TURNSYNCBRIDGE_H

#include <QObject>

class ShogiGameController;
class TurnManager;

/**
 * GC ↔ TurnManager ↔ UI(MainWindow) の配線を一箇所に集約。
 */
class TurnSyncBridge : public QObject
{
    Q_OBJECT
public:
    explicit TurnSyncBridge(QObject* parent=nullptr);

    /**
     * 重複接続は Qt::UniqueConnection により抑止。
     * uiReceiver は onTurnManagerChanged(ShogiGameController::Player) スロットを持つ想定。
     */
    static void wire(ShogiGameController* gc, TurnManager* tm, QObject* uiReceiver);
};

#endif // TURNSYNCBRIDGE_H
#ifndef UIACTIONSWIRING_H
#define UIACTIONSWIRING_H

#include <QObject>

class ShogiView;
namespace Ui { class MainWindow; }

class UiActionsWiring : public QObject {
    Q_OBJECT
public:
    struct Deps {
        Ui::MainWindow* ui = nullptr; // ui_*
        ShogiView*      shogiView = nullptr; // 盤の拡大/縮小を直結
        QObject*        ctx = nullptr; // 受け側(MainWindow*)。そのスロットへ接続する
    };

    explicit UiActionsWiring(const Deps& d, QObject* parent=nullptr)
        : QObject(parent), m_d(d) {}

    void wire(); // 多重接続を避けたい場合は呼び出し側で1回だけ呼べばOK

private:
    Deps m_d;
};

#endif // UIACTIONSWIRING_H
#ifndef USI_H
#define USI_H

#include <QPlainTextEdit>
#include <QProcess>
#include <QTableView>
#include <QtCharts/QChartView>
#include <QtCharts/QLineSeries>
#include <QThread>
#include <QElapsedTimer>
#include <QPointer>

#include "shogienginethinkingmodel.h"
#include "shogiengineinfoparser.h"
#include "shogigamecontroller.h"
#include "usicommlogmodel.h"
#include "playmode.h"

// UsiThreadクラスを前方宣言する。
class UsiThread;

class Usi : public QObject
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit Usi(UsiCommLogModel* model,  ShogiEngineThinkingModel* modelThinking, ShogiGameController* algorithm, PlayMode& playMode, QObject* parent = 0);

    // デストラクタ
    ~Usi();

    // 評価値の文字列を返す。
    QString scoreStr() const;

    // GUIがbestmove resignを受信したかどうかのフラグを返す。
    bool isResignMove() const;

    // 一番最後に受信した指し手の評価値を返す。
    int lastScoreCp() const;

    // 漢字の指し手に変換したpv文字列を返す。
    QString pvKanjiStr() const;

    // 漢字の指し手に変換したpv文字列を設定する。
    void setPvKanjiStr(const QString& newPvKanjiStr);

    // 先手が持ち駒を打つときの駒を文字列に変換する。
    QString convertFirstPlayerPieceNumberToSymbol(const int rankFrom) const;

    // 後手が持ち駒を打つときの駒を文字列に変換する。
    QString convertSecondPlayerPieceNumberToSymbol(const int rankFrom) const;

    // 将棋エンジンがbestmove文字列で返した最善手から移動元の筋と段、移動先の筋と段を取得する。
    void parseMoveCoordinates(int& fileFrom, int& rankFrom, int& fileTo, int& rankTo);

    // 将棋エンジンプロセスを起動し、対局を開始するUSIコマンドを送受信する。
    void initializeAndStartEngineCommunication(QString& engineFile, QString& enginename);

    // 人間対将棋エンジンの対局で将棋エンジンとUSIプロトコル通信を行う。
    void handleHumanVsEngineCommunication(QString& positionStr, QString& positionPonderStr, QPoint& outFrom, QPoint& outTo,
                                          int byoyomiMilliSec, const QString& btime, const QString& wtime, QStringList& positionStrList,
                                          int addEachMoveMiliSec1, int addEachMoveMiliSec2, bool useByoyomi);

    // 将棋エンジン対人間および将棋エンジン同士の対局で将棋エンジンとUSIプロトコル通信を行う。
    void handleEngineVsHumanOrEngineMatchCommunication(QString& positionStr, QString& positionPonderStr, QPoint& outFrom, QPoint& outTo,
                                                       int byoyomiMilliSec, const QString& btime, const QString& wtime,
                                                       int addEachMoveMiliSec1, int addEachMoveMiliSec2, bool useByoyomi);

    // gameoverコマンドを将棋エンジンに送信する。
    void sendGameOverCommand(const QString& result);

    // quitコマンドを将棋エンジンに送信する。
    void sendQuitCommand();

    // 将棋の段（1～9）をアルファベット表記（a～i）に変換する。
    QChar rankToAlphabet(const int rank) const;

    // GUIで「投了」をクリックした場合の処理を行う。
    void sendGameOverWinAndQuitCommands();

    // stopコマンドを将棋エンジンに送信する。
    void sendStopCommand();

    // GUIが将棋エンジンにstopまたはponderhitコマンドを送信するまで待つ。
    void waitForStopOrPonderhitCommand();

    void executeAnalysisCommunication(QString& positionStr, int byoyomiMilliSec);

    // 1手前に指した移動先の筋を設定する。
    void setPreviousFileTo(int newPreviousFileTo);

    // 1手前に指した移動先の段を設定する。
    void setPreviousRankTo(int newPreviousRankTo);

    qint64 lastBestmoveElapsedMs() const { return m_lastGoToBestmoveMs; }

    // エンジンにgameover loseコマンドとquitコマンドを送信し、手番を変更する。
    void sendGameOverLoseAndQuitCommands();

    // ログ識別子の設定（GUI 生成側で E1/E2, P1/P2, Engine名 を渡す）
    void setLogIdentity(const QString& engineTag, const QString& sideTag, const QString& engineName = QString());

    // タイムアウト確定後に、当該エンジンが出す "bestmove resign" を黙殺する
    void setSquelchResignLogging(bool on);

    void resetResignNotified() { m_resignNotified = false; }
    void markHardTimeout()     { m_timeoutDeclared = true; }
    void clearHardTimeout()    { m_timeoutDeclared = false; }
    bool isIgnoring() const    { return m_shutdownState != ShutdownState::Running; }

    // goコマンドを将棋エンジンに送信する。
    void sendGoCommand(int byoyomiMilliSec, const QString& btime, const QString& wtime,
                       int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi);

    // 任意の USI コマンドをそのまま送る（ログ出力は sendCommand 側で実施）
    void sendRaw(const QString& command) const;

public:
    // ★ 追加：後からThinking/Logモデルを挿し直すためのsetter
    void setThinkingModel(ShogiEngineThinkingModel* m) { m_modelThinking = m; }
    void setLogModel(UsiCommLogModel* m) { m_model = m; }

    // 将棋エンジンのプロセスを終了し、プロセスとスレッドを削除する。
    void cleanupEngineProcessAndThread();

    void sendPositionAndGoMate(const QString& sfen, int timeMs, bool infinite);
    void sendStopForMate();

    // 将棋エンジンを起動し、対局開始に関するコマンドを送信する。
    void startAndInitializeEngine(const QString& engineFile, const QString& enginename);

    // --- 詰み結果 ---
    struct TsumeResult {
        enum Kind { Solved, NoMate, NotImplemented, Unknown } kind = Unknown;
        QStringList pvMoves;
    };

    void executeTsumeCommunication(QString& positionStr, int mateLimitMilliSec);
    void sendPositionAndGoMateCommands(int mateLimitMilliSec, QString& positionStr);
    void cancelCurrentOperation();

#ifdef QT_DEBUG
    // ★ 追加：デバッグ用ダンプ
    ShogiEngineThinkingModel* debugThinkingModel() const { return m_modelThinking; }
    UsiCommLogModel*          debugLogModel()      const { return m_model; }
#endif

signals:
    // stopあるいはponderhitコマンドが送信されたことを通知するシグナル
    void stopOrPonderhitCommandSent();

    // bestmove resignを受信したことを通知するシグナル
    void bestMoveResignReceived();

    void sigTsumeCheckmate(const Usi::TsumeResult& result);

    // 追加: 詰将棋の最終結果
    void checkmateSolved(const QStringList& pvMoves);
    void checkmateNoMate();
    void checkmateNotImplemented();
    void checkmateUnknown();

    // ★未宣言で Q_EMIT errorOccurred(...) がエラーになっているので追加
    void errorOccurred(const QString& message);

private:
    // 盤面の1辺のマス数（列数と段数）
    static constexpr int BOARD_SIZE = 9;

    // 将棋盤のマス数
    static constexpr int NUM_BOARD_SQUARES = BOARD_SIZE * BOARD_SIZE;

    // 一番最後に受信した指し手の評価値
    int m_lastScoreCp;

    // 漢字の指し手に変換したpv文字列
    QString m_pvKanjiStr;

    // 評価値の文字列
    QString m_scoreStr;

    // 棋譜解析モードかどうかのフラグ
    bool m_analysisMode;

    // 1手前の移動先の段
    int m_previousFileTo;

    // 1手前の移動先の筋
    int m_previousRankTo;

    // 将棋エンジンの指し手
    QString m_bestMove;

    // 将棋エンジンが予想した相手の指し手
    QString m_predictedOpponentMove;

    // 盤面のコピーデータ
    QVector<QChar> m_clonedBoardData;

    // 将棋エンジンのプロセス
    QProcess* m_process;

    // 将棋エンジンからの受信データを1行ずつ保存するリスト
    QStringList m_lines;

    // 3桁ごとのカンマ区切り表示に使用するロケール
    QLocale m_locale;

    // GUIの「USIプロトコル通信ログ」タブのテキスト欄
    QPlainTextEdit* m_txt;

    // usiokを受信したかどうかのフラグ
    bool m_usiOkSignalReceived;

    // readyokを受信したかどうかのフラグ
    bool m_readyOkSignalReceived;

    // infoを受信したかどうかのフラグ
    bool m_infoSignalReceived;

    // bestmoveを受信したかどうかのフラグ
    bool m_bestMoveSignalReceived;

    // 設定ファイルから読み込んだ将棋エンジンオプションのリスト
    QStringList m_setOptionCommandList;

    // エンジン名、予想手、探索手、深さ、ノード数、局面探索数、ハッシュ使用率の更新に関するクラス
    UsiCommLogModel* m_model;

    // 将棋エンジンの思考結果をGUI上で表示するためのクラス
    ShogiEngineThinkingModel* m_modelThinking;

    // 将棋の対局全体を管理し、盤面の初期化、指し手の処理、合法手の検証、対局状態の管理を行うクラス
    ShogiGameController* m_gameController;

    // 対局モード
    PlayMode& m_playMode;

    // USIプロトコルに基づく通信を処理するための別スレッド
    // GUIのメインスレッドとは別のスレッドでgo ponderコマンド受信後の将棋エンジンの処理を行う。
    // GUIが将棋エンジンにstopまたはponderhitコマンドを送信するまで待ち、GUIの思考欄に読み筋を出力する。
    UsiThread* m_usiThread;

    // ponderモードが有効かどうかのフラグ
    bool m_isPonderEnabled;

    // GUIがbestmove resignを受信したかどうかのフラグ
    bool m_isResignMove;

    // GUIがbestmove winを受信したかどうかのフラグ
    bool m_isWinMove;

    // 将棋エンジンからデータを受信して保管した行リストをクリアする。
    void clearResponseData();

    // 将棋エンジンにコマンドを送信する。
    void sendCommand(const QString& command) const;

    // 将棋エンジンを起動する。
    void startEngine(const QString& engineFile);

    // usinewgameコマンドを将棋エンジンに送信する。
    void sendUsiNewGameCommand();

    // positionコマンドを将棋エンジンに送信する。
    void sendPositionCommand(QString& positionStr);

    // 設定ファイルShogibanQ.iniから将棋エンジンオプションを読み込み、
    // setoptionコマンドの文字列を生成する。
    void generateSetOptionCommands(const QString& engineName);

    // setoptionコマンドを将棋エンジンに送信する。
    void sendSetOptionCommands();

    // info行を全て削除する。
    void infoRecordClear();

    // go ponderコマンドを将棋エンジンに送信する。
    void sendGoPonderCommand();

    // 将棋のアルファベット表記（a～i）を段（1～9）に変換する。
    int alphabetToRank(QChar c);

    // 白（後手）の駒を表すアルファベットから持ち駒の段に変換する。
    int pieceToRankWhite(QChar c);

    // 黒（先手）の駒を表すアルファベットから持ち駒の段に変換する。
    int pieceToRankBlack(QChar c);

    // ponderhitコマンドを将棋エンジンに送信する。
    void sendPonderHitCommand();

    // info行を解析する。
    int parseEngineOutputAndUpdateInfo(QString& line, ShogiEngineInfoParser& info);

    // GUIの「探索手」欄を更新する。
    void updateSearchedHand(const ShogiEngineInfoParser* info);

    // GUIの「深さ」欄を更新する。
    void updateDepth(const ShogiEngineInfoParser* info);

    // GUIの「ノード数」欄を更新する。
    void updateNodes(const ShogiEngineInfoParser* info);

    // GUIの「ノード数」欄を更新する。
    void updateNps(const ShogiEngineInfoParser* info);

    // GUIの「ハッシュ使用率」欄を更新する。
    void updateHashfull(const ShogiEngineInfoParser* info);

    // 評価値を計算する。
    int calculateScoreInt(const ShogiEngineInfoParser* info) const;

    // 詰み手数（scoremate）と最終評価値（lastScore）の更新を行う。
    void updateScoreMateAndLastScore(ShogiEngineInfoParser* info, int& scoreint);

    // 棋譜解析モードにより、評価値の処理を行う。
    void updateAnalysisModeAndScore(const ShogiEngineInfoParser* info, int& scoreint);

    // 入力された評価値（scoreint）を範囲内（-2000〜2000）に制限して、その値をm_lastScorecpに設定する。
    void updateLastScore(const int scoreInt);

    // 現在の評価値（scorecp）が存在するかどうかに基づき、詰み手数（scoremate）と最終評価値（lastScore）を更新する。
    // scorecpが存在する場合は、棋譜解析モードに基づいた評価値の処理を行い、その他の情報（時間、深さ、ノード数、評価値、読み筋）をセットする。
    // さらに、評価値を範囲内（-2000〜2000）に制限した上で、最終評価値を更新する。
    void updateEvaluationInfo(ShogiEngineInfoParser* info, int& scoreint);

    // usiコマンドを将棋エンジンに送信する。
    void sendUsiCommand();

    // 将棋エンジンからusiokを受信するまで待つ。
    bool waitForUsiOK(const int timeoutMilliseconds);

    // isreadyコマンドを将棋エンジンに送信する。
    void sendIsReadyCommand();

    // 将棋エンジンからreadyokを受信するまで待つ。
    bool waitForReadyOk(const int timeoutMilliseconds);

    // 将棋エンジンからbestmoveを受信するまで待つ。
    bool waitForBestMove(const int timeoutMilliseconds);

     // 将棋エンジンからbestmoveを受信するまで待ち続ける。
    bool keepWaitingForBestMove();

    // 新しいスレッドを生成し、GUIが将棋エンジンにstopまたはponderhitコマンドを送信するまで待つ。
    // start関数が実行されることでrun関数が実行され、その中でwaitForStopOrPonderhitCommand関数が実行される。
    void startUsiThread();

    // 現在の局面（盤内のみ）をコピーする。
    void cloneCurrentBoardData();

    // 将棋エンジンから返された「bestmove A ponder B」の情報をもとに、将棋盤内の駒配置を更新する。
    void applyMovesToBoardFromBestMoveAndPonder();

    // bestmoveを指定した時間内に受信するまで待機する。
    // 指定した時間内に受信できなかった場合、エラーメッセージを表示して例外をスローする。
    // @param byoyomiMilliSec bestmoveを待機する時間（ミリ秒単位）
    // @return true: bestmoveを受信した場合, false: タイムアウトした場合
    void waitAndCheckForBestMove(const int byoyomiMilliSec);

    // 将棋エンジンからの「bestmove」受信後に予想手を考慮した以下の処理を開始する。
    // 1. 「bestmove」と「ponder」の情報をもとに駒配置を更新。
    // 2. 予想される相手の指し手をposition文字列に追加。
    // 3. 更新したpositionコマンドをエンジンに送信。
    // 4. ponderモードをセット。
    // 5. エンジンに「go ponder」コマンドを送信。
    // 6. "stop"または"ponderhit"コマンドの待機のため新しいスレッドを生成。
    void startPonderingAfterBestMove(QString& positionStr, QString& positionPonderStr);

    // 将棋エンジンからの最善手をposition文字列に追加し、予想手を考慮した処理を開始する。
    // @param positionStr position文字列
    // @param positionPonderStr position文字列に予想手を追加したもの
    void appendBestMoveAndStartPondering(QString& positionStr, QString& positionPonderStr);

    // positionコマンドを送信し、ponderモードをオフにして、goコマンドを送信し、
    // bestmoveを受信して予想手を考慮した処理を開始する。
    // @param positionStr positionコマンドの文字列
    // @param byoyomiMilliSec bestmoveを待機する時間（ミリ秒単位）
    // @param btime 黒の残り時間
    // @param wtime 白の残り時間
    // @param positionPonderStr position文字列に予想手を追加したもの
    void sendCommandsAndProcess(int byoyomiMilliSec, QString& positionStr, const QString& btime, const QString& wtime,
                                QString& positionPonderStr, int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi);

    // 将棋エンジンからのレスポンスに基づいて、適切なコマンドを送信し、必要に応じて処理を行う。
    void processEngineResponse(QString& positionStr, QString& positionPonderStr, int byoyomiMilliSec, const QString& btime, const QString& wtime,
                               int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi);

    // 将棋エンジンとのUSIプロトコルに基づく通信を処理するための共通関数
    // 人間対エンジン、エンジン対人間、およびエンジン同士の対局で共通して使用される。
    void executeEngineCommunication(QString& positionStr, QString& positionPonderStr, QPoint& outFrom,
                                    QPoint& outTo, int byoyomiMilliSec, const QString& btime, const QString& wtime,
                                    int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi);

    // 盤上の駒を動かす場合の指し手をUSI形式に変換する。
    QString convertBoardMoveToUsi(int fileFrom, int rankFrom, int fileTo, int rankTo, bool promote) const;

    // 持ち駒を打つ場合の指し手をUSI形式に変換する。
    QString convertDropMoveToUsi(int fileFrom, int rankFrom, int fileTo, int rankTo) const;

    // 人間の指し手をUSI形式の指し手に直す。
    QString convertHumanMoveToUsiFormat(const QPoint& outFrom, const QPoint& outTo, bool promote);

    // カレントディレクトリをエンジンファイルのあるディレクトリに移動する。
    void changeDirectoryToEnginePath(const QString& engineFile);

    // usiコマンドを将棋エンジンに送り、usiokを待機する。
    void sendUsiCommandAndWaitForUsiOk();

    // isreadyコマンドを将棋エンジンに送り、readyokを待機する。
    void sendIsReadyCommandAndWaitForReadyOk();

    // 将棋エンジンに対局開始に関するコマンドを送信する。
    void sendInitialCommands(const QString& enginename);

    // bestmove文字列（例: "7g7f", "P*5e"など）から移動元の座標（盤上の駒の場合）または持ち駒の種類（持ち駒を打つ場合）を解析する。
    void parseMoveFrom(const QString& move, int& fileFrom, int& rankFrom);

    // bestmove文字列（例: "7g7f", "P*5e"など）から移動先の座標を解析する。
    void parseMoveTo(const QString& move, int& fileTo, int& rankTo);

    // positionコマンドとgoコマンドを送信し、bestmoveを受信するまで待機する。
    void sendPositionAndGoCommands(int byoyomiMilliSec, QString& positionStr);

    // 棋譜解析モードでgoコマンドを将棋エンジンに送信する。
    void sendGoCommandByAnalysys(int byoyomiMilliSec);

    // 将棋エンジンから受信したデータを1行ごとにm_linesに貯え、GUIに受信データをログ出力する。
    void readFromEngine();

    // 将棋エンジンからbestmoveを受信した時に最善手を取得する。
    void bestMoveReceived(const QString& line);

    // 将棋エンジンからinfoを受信した時にinfo行を解析し、GUIの「思考」タブに表示する。
    void infoReceived(QString& line);

    // QProcessのエラーが発生したときに呼び出されるスロット
    void onProcessError(QProcess::ProcessError error);

    // 盤面データを9x9のマスに表示する。
    void printShogiBoard(const QVector<QChar>& boardData) const;

    // 残り時間になるまでbestmoveを待機する。
    void waitAndCheckForBestMoveRemainingTime(int byoyomiMilliSec, const QString& btime, const QString& wtime, bool useByoyomi);

    QElapsedTimer m_goTimer;               // go or ponderhit を送った時刻
    qint64        m_lastGoToBestmoveMs=0;  // 直近の go/ponderhit → bestmove 経過ms

    // === 追記: ヘッダ（privateセクション）======================================
    // ★ 追加(2)(3): 予算内待機 + 小さな猶予で再度待つヘルパ
    bool waitForBestMoveWithGrace(int budgetMs, int graceMs);

    // ★ 追加(2): “小さな猶予”の既定値（OSスケジューリング/パイプ遅延用）
    static constexpr int kBestmoveGraceMs = 250; // 200〜300ms がおすすめ

    // 思考フェーズ
    enum class SearchPhase { Idle, Main, Ponder };

    // ログ識別用
    QString m_logEngineTag;   // 例: "[E1]" / "[E2]"
    QString m_logSideTag;     // 例: "P1" / "P2"
    QString m_logEngineName;  // 例: "YaneuraOu"
    SearchPhase m_phase = SearchPhase::Idle;
    int m_ponderSession = 0;  // ぽんだーセッション番号

    // ログ用プレフィックス生成
    QString phaseTag() const;            // 例: "" / "[MAIN]" / "[PONDER#3]"
    QString logPrefix() const;           // 例: "[E1/P1 YaneuraOu] [PONDER#3]"

    // ★ 標準エラーの受信ログ（なければ新規で宣言）
    void readFromEngineStderr();

    // quit後に "info string ..." を何行までログに残すか（0で許可なし）
    int m_postQuitInfoStringLinesLeft = 0; // NEW

    // "info string ..." を許可するか判定する（quit後専用）
    bool shouldLogAfterQuit(const QString& line) const; // NEW

    bool m_gameoverSent = false; // このインスタンスに gameover を送ったか
    bool m_quitSent     = false; // このインスタンスに quit を送ったか

    bool m_squelchResignLogs = false; // NEW: true なら "bestmove resign" をログ/処理ともに捨てる  

    enum class ShutdownState { Running, IgnoreAll, IgnoreAllExceptInfoString };

    ShutdownState m_shutdownState = ShutdownState::Running;
    bool m_resignNotified  = false;  // resign の多重 emit 防止
    bool m_timeoutDeclared = false;  // ★ GUIにより旗落ち確定（この局の bestmove は受け付けない）

    bool shouldAbortWait() const;  // タイムアウト/終了状態なら true

    // usi.h の private: あたりに追加
    QPointer<QObject> m_opCtx { nullptr };  // オペ単位の一時コンテキスト
    quint64           m_seq   { 0 };        // リクエストID（切替で++）

    // public または private にメソッド宣言
    quint64 beginOperationContext(); // 新規

private:
    bool m_modeTsume = false; // 詰み探索中フラグ
    void handleCheckmateLine(const QString& line);

private slots:
    void onProcessFinished(int exitCode, QProcess::ExitStatus status);
};

// GUIのメインスレッドとは別のスレッドでgo ponderコマンド受信後の将棋エンジンの処理を行う。
// GUIが将棋エンジンにstopまたはponderhitコマンドを送信するまで待ち、GUIの思考欄に読み筋を出力する。
class UsiThread : public QThread
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit UsiThread(Usi* usi, QObject* parent = nullptr)
        : QThread(parent), m_usi(usi) {}

protected:
    // スレッドを実行する。
    void run() override {
        qDebug() << "Running in a separate thread...";

        // GUIが将棋エンジンにstopまたはponderhitコマンドを送信するまで待つ。
        m_usi->waitForStopOrPonderhitCommand();
    }

private:
    // Usiクラスのポインタ
    Usi* m_usi;
};

#endif // USI_H
#ifndef USICOMMLOGMODEL_H
#define USICOMMLOGMODEL_H

#include <QObject>

// エンジン名、予想手、探索手、深さ、ノード数、局面探索数、ハッシュ使用率の更新に関するクラス
class UsiCommLogModel : public QObject
{
    // Qtのメタオブジェクトシステムを使用するためのマクロ
    Q_OBJECT

    // エンジン名のプロパティを定義。エンジン名を読み取る関数と設定する関数、および変更時のシグナルを指定。
    Q_PROPERTY(QString engineName READ engineName WRITE setEngineName NOTIFY engineNameChanged)

    // 予想手のプロパティを定義。予想手を読み取る関数と設定する関数、および変更時のシグナルを指定。
    Q_PROPERTY(QString predictiveMove READ predictiveMove WRITE setPredictiveMove NOTIFY predictiveMoveChanged)

    // 探索手のプロパティを定義。探索手を読み取る関数と設定する関数、および変更時のシグナルを指定。
    Q_PROPERTY(QString searchedMove READ searchedMove WRITE setSearchedMove NOTIFY searchedMoveChanged)

    // 探索深さのプロパティを定義。探索深さを読み取る関数と設定する関数、および変更時のシグナルを指定。
    Q_PROPERTY(QString searchDepth READ searchDepth WRITE setSearchDepth NOTIFY searchDepthChanged)

    // ノード数のプロパティを定義。ノード数を読み取る関数と設定する関数、および変更時のシグナルを指定。
    Q_PROPERTY(QString nodeCount READ nodeCount WRITE setNodeCount NOTIFY nodeCountChanged)

    // 探索局面数（NPS: Nodes Per Second）のプロパティを定義。NPSを読み取る関数と設定する関数、および変更時のシグナルを指定。
    Q_PROPERTY(QString nodesPerSecond READ nodesPerSecond WRITE setNodesPerSecond NOTIFY nodesPerSecondChanged)

    // ハッシュ使用率のプロパティを定義。ハッシュ使用率を読み取る関数と設定する関数、および変更時のシグナルを指定。
    Q_PROPERTY(QString hashUsage READ hashUsage WRITE setHashUsage NOTIFY hashUsageChanged)

    // USIプロトコル通信コマンド行のプロパティを定義。読み取り専用で、変更時のシグナルを指定。
    Q_PROPERTY(QString usiCommLog READ usiCommLog NOTIFY usiCommLogChanged)

public:
    // コンストラクタ
    explicit UsiCommLogModel(QObject *parent = nullptr);

    // 将棋エンジン名を取得する。
    QString engineName() const;

    // 予想手を取得する。
    QString predictiveMove() const;

    // 探索手を取得する。
    QString searchedMove() const;

    // 深さを取得する。
    QString searchDepth() const;

    // ノード数を取得する。
    QString nodeCount() const;

    // 探索局面数を取得する。
    QString nodesPerSecond() const;

    // ハッシュ使用率を取得する。
    QString hashUsage() const;

    QString usiCommLog() const;

    // 将棋GUIと将棋エンジン間のUSIプロトコル通信コマンド行をセットし、GUIに追記する。
    void appendUsiCommLog(const QString& usiCommLog);

    void clear();

public slots:
    // 将棋エンジン名をセットし、GUIの表示を更新する。
    void setEngineName(const QString& engineName);

    // 予想手をセットし、GUIの表示を更新する。
    void setPredictiveMove(const QString& predictiveMove);

    // 探索手をセットし、GUIの表示を更新する。
    void setSearchedMove(const QString& searchedMove);

    // 深さをセットし、GUIの表示を更新する。
    void setSearchDepth(const QString& searchDepth);

    // ノード数をセットし、GUIの表示を更新する。
    void setNodeCount(const QString& nodeCount);

    // 探索局面数をセットし、GUIの表示を更新する。
    void setNodesPerSecond(const QString& nodesPerSecond);

    // ハッシュ使用率をセットし、GUIの表示を更新する。
    void setHashUsage(const QString& hashUsage);

signals:
    // 将棋エンジン名が変更されたときに発生するシグナル
    void engineNameChanged();

    // 予想手が変更されたときに発生するシグナル
    void predictiveMoveChanged();

    // 探索手が変更されたときに発生するシグナル
    void searchedMoveChanged();

    // 深さが変更されたときに発生するシグナル
    void searchDepthChanged();

    // ノード数が変更されたときに発生するシグナル
    void nodeCountChanged();

    // 探索局面数が変更されたときに発生するシグナル
    void nodesPerSecondChanged();

    // ハッシュ使用率が変更されたときに発生するシグナル
    void hashUsageChanged();

    // 将棋GUIと将棋エンジン間のUSIプロトコル通信コマンド行を追加したときに発生するシグナル
    void usiCommLogChanged();

private:
    // 将棋エンジン名
    QString m_engineName;

    // 予想手
    QString m_predictiveMove;

    // 探索手
    QString m_searchedMove;

    // 深さ
    QString m_searchDepth;

    // ノード数
    QString m_nodeCount;

    // 探索局面数
    QString m_nodesPerSecond;

    // ハッシュ使用率
    QString m_hashUsage;

    // 将棋GUIと将棋エンジン間のUSIプロトコル通信コマンド行
    QString m_usiCommLog;
};

#endif // USICOMMLOGMODEL_H
#ifndef VERSIONDIALOG_H
#define VERSIONDIALOG_H

#include <QDialog>

namespace Ui {
class VersionDialog;
}

// バージョンを表示するダイアログ
class VersionDialog : public QDialog
{
    Q_OBJECT

public:
    // コンストラクタ
    explicit VersionDialog(QWidget *parent = nullptr);

    // デストラクタ
    ~VersionDialog();

private:
    Ui::VersionDialog *ui;
};

#endif // VERSIONDIALOG_H
#include <QDesktopServices>
#include <QUrl>
#include "versiondialog.h"

namespace AboutCoordinator {

void showVersionDialog(QWidget* parent)
{
    VersionDialog dlg(parent);
    dlg.exec();
}

void openProjectWebsite()
{
    QDesktopServices::openUrl(QUrl("https://github.com/hnakada123/ShogiBoardQ"));
}

} // namespace AboutCoordinator
#include "analysiscoordinator.h"
#include "engineanalysistab.h"

#include <QDebug>
#include <QRegularExpression>
#include <limits>

AnalysisCoordinator::AnalysisCoordinator(const Deps& d, QObject* parent)
    : QObject(parent)
    , m_deps(d)
{
}

void AnalysisCoordinator::setDeps(const Deps& d)
{
    m_deps = d;
}

void AnalysisCoordinator::setAnalysisTab(EngineAnalysisTab* tab)
{
    m_analysisTab = tab;
}

void AnalysisCoordinator::setOptions(const Options& opt)
{
    m_opt = opt;
}

void AnalysisCoordinator::startAnalyzeRange()
{
    if (!m_deps.sfenRecord || m_deps.sfenRecord->isEmpty()) {
        qWarning() << "[ANA] startAnalyzeRange: sfenRecord not ready";
        return;
    }
    if (m_running) stop();

    m_mode = RangePositions;
    m_running = true;

    // endPly 未指定なら末尾まで
    const int last = m_deps.sfenRecord->size() - 1;
    if (m_opt.endPly < 0 || m_opt.endPly > last) {
        m_opt.endPly = last;
    }
    if (m_opt.startPly < 0) m_opt.startPly = 0;
    if (m_opt.startPly > m_opt.endPly) m_opt.startPly = m_opt.endPly;

    emit analysisStarted(m_opt.startPly, m_opt.endPly, m_mode);

    // MultiPV は setoption で設定（対応エンジンのみ有効）
    if (m_opt.multiPV > 1) {
        send_(QStringLiteral("setoption name MultiPV value %1").arg(m_opt.multiPV));
    }
    // 念のため isready → readyok を待ちたければ、呼び出し側で同期を取ること
    // ここでは簡易化して直ちに開始
    startRange_();
}

void AnalysisCoordinator::startAnalyzeSingle(int ply)
{
    if (!m_deps.sfenRecord || m_deps.sfenRecord->isEmpty()) {
        qWarning() << "[ANA] startAnalyzeSingle: sfenRecord not ready";
        return;
    }
    if (m_running) stop();

    m_mode = SinglePosition;
    m_running = true;

    m_opt.startPly = qMax(0, ply);
    m_opt.endPly   = m_opt.startPly;

    emit analysisStarted(m_opt.startPly, m_opt.endPly, m_mode);

    if (m_opt.multiPV > 1) {
        send_(QStringLiteral("setoption name MultiPV value %1").arg(m_opt.multiPV));
    }
    startSingle_(m_opt.startPly);
}

void AnalysisCoordinator::stop()
{
    if (!m_running) return;
    // USI の明示停止
    send_(QStringLiteral("stop"));

    m_running = false;
    m_mode = Idle;
    m_currentPly = -1;

    emit analysisFinished(Idle);
}

void AnalysisCoordinator::startRange_()
{
    m_currentPly = m_opt.startPly;
    sendAnalyzeForPly_(m_currentPly);
}

void AnalysisCoordinator::startSingle_(int ply)
{
    m_currentPly = ply;
    sendAnalyzeForPly_(m_currentPly);
}

void AnalysisCoordinator::nextPlyOrFinish_()
{
    if (m_mode != RangePositions) {
        // SinglePosition の場合はここで終わる
        m_running = false;
        m_mode = Idle;
        m_currentPly = -1;
        emit analysisFinished(Idle);
        return;
    }

    if (m_currentPly < 0) m_currentPly = m_opt.startPly;

    if (m_currentPly >= m_opt.endPly) {
        // すべて完了
        m_running = false;
        m_mode = Idle;
        m_currentPly = -1;
        emit analysisFinished(RangePositions);
        return;
    }

    // 次の局面へ
    m_currentPly += 1;
    sendAnalyzeForPly_(m_currentPly);
}

void AnalysisCoordinator::sendAnalyzeForPly_(int ply)
{
    if (!m_running) return;
    if (!m_deps.sfenRecord) return;
    if (ply < 0 || ply >= m_deps.sfenRecord->size()) {
        qWarning() << "[ANA] sendAnalyzeForPly_: index out of range" << ply;
        nextPlyOrFinish_();
        return;
    }

    const QString pos = m_deps.sfenRecord->at(ply);
    emit positionPrepared(ply, pos);

    // 1) position
    send_(pos);

    // 2) go movetime X
    //    （byoyomi / btime/wtime 等でも可。ここでは単純に movetime を採用）
    send_(QStringLiteral("go movetime %1").arg(m_opt.movetimeMs));

    // 分析進行に応じたツリーハイライトなどが必要ならここで
    if (m_analysisTab && m_opt.centerTree) {
        // “row” の概念がある場合は呼び出し側で解決してください。
        // ここでは ply のセンタリングだけ例示（必要なら setRow まで渡す）
        m_analysisTab->highlightBranchTreeAt(/*row=*/0, ply, /*centerOn=*/true);
    }
}

void AnalysisCoordinator::onEngineInfoLine(const QString& line)
{
    if (!m_running) return;
    if (m_currentPly < 0) return;

    // "info ..." 以外は無視
    if (!line.startsWith(QStringLiteral("info"))) return;

    ParsedInfo p;
    if (!parseInfoUSI_(line, &p)) {
        // パース不能でも raw を進捗として流しておくと UI 側で全文表示に使える
        emit analysisProgress(m_currentPly, -1, -1,
                              std::numeric_limits<int>::min(), 0,
                              QString(), line);
        return;
    }

    emit analysisProgress(m_currentPly, p.depth, p.seldepth,
                          p.scoreCp, p.mate, p.pv, line);
}

void AnalysisCoordinator::onEngineBestmoveReceived(const QString& line)
{
    if (!m_running) return;

    // "bestmove ..." を受けたら次へ
    nextPlyOrFinish_();
}

bool AnalysisCoordinator::parseInfoUSI_(const QString& line, ParsedInfo* out)
{
    // ざっくりとした USI info 行のパース：
    // 例）info depth 20 seldepth 34 score cp 23 pv 7g7f 3c3d ...
    //     info depth 25 score mate 3 pv ...
    // 必要十分ではないが実用的な範囲で抽出
    if (!out) return false;

    int depth = -1, seldepth = -1, scoreCp = std::numeric_limits<int>::min(), mate = 0;
    QString pv;

    // depth
    {
        static const QRegularExpression reDepth(QStringLiteral(R"(?:^|\s)depth\s+(\d+))"));
        auto m = reDepth.match(line);
        if (m.hasMatch()) depth = m.captured(1).toInt();
    }
    // seldepth
    {
        static const QRegularExpression reSel(QStringLiteral(R"(?:^|\s)seldepth\s+(\d+))"));
        auto m = reSel.match(line);
        if (m.hasMatch()) seldepth = m.captured(1).toInt();
    }
    // score
    {
        static const QRegularExpression reScoreCp(QStringLiteral(R"(?:^|\s)score\s+cp\s+(-?\d+))"));
        static const QRegularExpression reScoreMate(QStringLiteral(R"(?:^|\s)score\s+mate\s+(-?\d+))"));
        auto mCp   = reScoreCp.match(line);
        auto mMate = reScoreMate.match(line);
        if (mCp.hasMatch()) {
            scoreCp = mCp.captured(1).toInt();
        } else if (mMate.hasMatch()) {
            mate = mMate.captured(1).toInt(); // 詰みまでの手数（正負で先後）
        }
    }
    // pv
    {
        static const QRegularExpression rePv(QStringLiteral(R"(?:^|\s)pv\s+(.+)$)"));
        auto m = rePv.match(line);
        if (m.hasMatch()) pv = m.captured(1).trimmed();
    }

    if (depth < 0 && seldepth < 0 && scoreCp == std::numeric_limits<int>::min() && mate == 0 && pv.isEmpty()) {
        return false;
    }
    out->depth    = depth;
    out->seldepth = seldepth;
    out->scoreCp  = scoreCp;
    out->mate     = mate;
    out->pv       = pv;
    return true;
}

void AnalysisCoordinator::send_(const QString& line)
{
    emit requestSendUsiCommand(line);
}
#include "analysisflowcontroller.h"

#include "analysiscoordinator.h"
#include "analysisresultspresenter.h"
#include "kifuanalysisdialog.h"
#include "kifuanalysislistmodel.h"
#include "engineanalysistab.h"
#include "kifudisplay.h"
#include "usi.h"
#include "usicommlogmodel.h"
#include "kifuanalysisresultsdisplay.h"

#include <limits>
#include <QString>
#include <QObject>
#include <QtGlobal>

AnalysisFlowController::AnalysisFlowController(QObject* parent)
    : QObject(parent)
{
}

void AnalysisFlowController::start(const Deps& d, KifuAnalysisDialog* dlg)
{
    if (!d.sfenRecord || d.sfenRecord->isEmpty()) {
        if (d.displayError) d.displayError(QStringLiteral("内部エラー: sfenRecord が未準備です。棋譜読み込み後に実行してください。"));
        return;
    }
    if (!d.analysisModel) {
        if (d.displayError) d.displayError(QStringLiteral("内部エラー: 解析モデルが未準備です。"));
        return;
    }
    if (!d.usi) {
        if (d.displayError) d.displayError(QStringLiteral("内部エラー: Usi インスタンスが未初期化です。"));
        return;
    }
    if (!dlg) return;

    // Cache deps
    m_sfenRecord    = d.sfenRecord;
    m_moveRecords   = d.moveRecords;
    m_analysisModel = d.analysisModel;
    m_analysisTab   = d.analysisTab;
    m_usi           = d.usi;
    m_logModel      = d.logModel;
    m_activePly     = d.activePly;
    m_err           = d.displayError;
    m_prevEvalCp    = 0; // 差分用の前回値をリセット

    // Coordinator（初回のみ）
    if (!m_coord) {
        AnalysisCoordinator::Deps cd;
        cd.sfenRecord = m_sfenRecord;       // ★ 解析対象のSFEN列
        m_coord = new AnalysisCoordinator(cd, this);

        // (A) AC → エンジンへ USI 文字列を橋渡し
        QObject::connect(
            m_coord, &AnalysisCoordinator::requestSendUsiCommand,
            m_usi,   &Usi::sendRaw,
            Qt::UniqueConnection
            );

        // (B) エンジン標準出力（info/bestmove）→ AC へ橋渡し（既存のログモデル経由）
        if (m_logModel) {
            QObject::connect(
                m_logModel, &UsiCommLogModel::usiCommLogChanged,
                this,       &AnalysisFlowController::onUsiCommLogChanged_,
                Qt::UniqueConnection
                );
        }

        // (C) 進捗を結果モデルへ投入（差分は直前値から算出）
        QObject::connect(
            m_coord, &AnalysisCoordinator::analysisProgress,
            this,    &AnalysisFlowController::onAnalysisProgress_,
            Qt::UniqueConnection
            );
    }

    // 結果ビュー（Presenter）— 既存APIは showWithModel(...)
    if (!m_presenter) {
        m_presenter = new AnalysisResultsPresenter(this);
    }
    m_presenter->showWithModel(m_analysisModel);

    // ダイアログ設定を AC オプションへ反映
    applyDialogOptions_(dlg);

    // エンジン起動
    const int  engineIdx = dlg->engineNumber();
    const auto engines   = dlg->engineList();
    if (engineIdx < 0 || engineIdx >= engines.size()) {
        if (m_err) m_err(QStringLiteral("エンジン選択が不正です。"));
        return;
    }
    const QString enginePath = engines.at(engineIdx).path;
    const QString engineName = dlg->engineName();
    m_usi->startAndInitializeEngine(enginePath, engineName); // usi→usiok/setoption/isready→readyok

    // 解析開始
    m_coord->startAnalyzeRange();
}

void AnalysisFlowController::applyDialogOptions_(KifuAnalysisDialog* dlg)
{
    AnalysisCoordinator::Options opt;
    opt.movetimeMs = dlg->byoyomiSec() * 1000;

    const int startRaw = dlg->initPosition() ? 0 : qMax(0, m_activePly);
    opt.startPly = qBound(0, startRaw, m_sfenRecord->size() - 1);
    opt.endPly   = m_sfenRecord->size() - 1;

    opt.multiPV    = 1;    // ダイアログ未対応なら 1 固定
    opt.centerTree = true;

    m_coord->setOptions(opt);
}

// ======================
//  スロット実装（非ラムダ）
// ======================

void AnalysisFlowController::onUsiCommLogChanged_()
{
    if (!m_coord || !m_logModel) return;

    const QString line = m_logModel->usiCommLog().trimmed();
    if (line.startsWith(QStringLiteral("info "))) {
        m_coord->onEngineInfoLine(line);
    } else if (line.startsWith(QStringLiteral("bestmove "))) {
        m_coord->onEngineBestmoveReceived(line);
    }
}

void AnalysisFlowController::onAnalysisProgress_(int ply, int /*depth*/, int /*seldepth*/,
                                                 int scoreCp, int mate,
                                                 const QString& pv, const QString& /*raw*/)
{
    if (!m_analysisModel) return;

    // 指し手ラベル
    QString moveLabel;
    if (m_moveRecords && ply >= 0 && m_moveRecords->size() > ply && m_moveRecords->at(ply)) {
        moveLabel = m_moveRecords->at(ply)->currentMove();
    } else {
        moveLabel = QStringLiteral("ply %1").arg(ply);
    }

    // 評価値 / 差分
    QString evalStr;
    int curVal = 0;
    if (mate != 0) {
        evalStr = QStringLiteral("mate %1").arg(mate);
        curVal  = m_prevEvalCp; // 詰みは差分0扱い（前回値維持）
    } else if (scoreCp != std::numeric_limits<int>::min()) {
        evalStr = QString::number(scoreCp);
        curVal  = scoreCp;
    } else {
        evalStr = QStringLiteral("0");
        curVal  = 0;
    }
    const QString diff = QString::number(curVal - m_prevEvalCp);
    m_prevEvalCp = curVal;

    // ★ KifuAnalysisResultsDisplay は (Move, Eval, Diff, PV) の4引数
    m_analysisModel->appendItem(new KifuAnalysisResultsDisplay(
        moveLabel,
        evalStr,
        diff,
        pv
        ));
}

void AnalysisFlowController::runWithDialog(const Deps& d, QWidget* parent)
{
    // 依存の必須チェック（start(...) 側でも行いますが、早めに弾きます）
    if (!d.sfenRecord || d.sfenRecord->isEmpty()) {
        if (d.displayError) d.displayError(QStringLiteral("内部エラー: sfenRecord が未準備です。棋譜読み込み後に実行してください。"));
        return;
    }
    if (!d.analysisModel) {
        if (d.displayError) d.displayError(QStringLiteral("内部エラー: 解析モデルが未準備です。"));
        return;
    }
    if (!d.usi) {
        if (d.displayError) d.displayError(QStringLiteral("内部エラー: Usi インスタンスが未初期化です。"));
        return;
    }

    // ダイアログを生成してユーザに選択してもらう
    KifuAnalysisDialog dlg(parent);
    const int result = dlg.exec();
    if (result != QDialog::Accepted) return;

    // 以降は既存の start(...) に委譲（Presenter への表示や接続も start 側で実施）
    start(d, &dlg);
}
#include "analysisresultspresenter.h"
#include <QDialog>
#include <QTableView>
#include <QHeaderView>
#include <QVBoxLayout>
#include <QTimer>
#include <QScrollBar>
#include "numeric_right_align_comma_delegate.h"
#include "kifuanalysislistmodel.h"

AnalysisResultsPresenter::AnalysisResultsPresenter(QObject* parent)
    : QObject(parent)
    , m_reflowTimer(new QTimer(this))
{
    m_reflowTimer->setSingleShot(true);
    m_reflowTimer->setInterval(0);
    connect(m_reflowTimer, &QTimer::timeout, this, &AnalysisResultsPresenter::reflowNow);
}

void AnalysisResultsPresenter::showWithModel(KifuAnalysisListModel* model)
{
    buildUi(model);
    connectModelSignals(model);

    if (m_dlg) {
        m_dlg->resize(1000, 600);
        m_dlg->setModal(false);
        m_dlg->setWindowModality(Qt::NonModal);
        m_dlg->show();
    }

    // 初回レイアウト
    m_reflowTimer->start();
}

void AnalysisResultsPresenter::buildUi(KifuAnalysisListModel* model)
{
    if (m_dlg) {
        m_dlg->deleteLater();
        m_dlg = nullptr;
    }

    m_dlg = new QDialog;
    m_dlg->setAttribute(Qt::WA_DeleteOnClose, true);
    m_dlg->setWindowTitle(tr("棋譜解析結果"));

    m_view = new QTableView(m_dlg);
    m_view->setModel(model);
    m_view->setAlternatingRowColors(true);
    m_view->setWordWrap(false);
    m_view->verticalHeader()->setVisible(false);
    m_view->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_view->setSelectionMode(QAbstractItemView::SingleSelection);
    m_view->setTextElideMode(Qt::ElideRight);

    auto* numDelegate = new NumericRightAlignCommaDelegate(m_view);
    m_view->setItemDelegateForColumn(1, numDelegate); // Evaluation Value
    m_view->setItemDelegateForColumn(2, numDelegate); // Difference

    m_header = m_view->horizontalHeader();
    m_header->setMinimumSectionSize(60);
    m_header->setSectionResizeMode(0, QHeaderView::ResizeToContents); // Move
    m_header->setSectionResizeMode(1, QHeaderView::ResizeToContents); // Evaluation
    m_header->setSectionResizeMode(2, QHeaderView::ResizeToContents); // Difference
    m_header->setSectionResizeMode(3, QHeaderView::Stretch);          // PV
    m_header->setStretchLastSection(true);

    QVBoxLayout* lay = new QVBoxLayout(m_dlg);
    lay->setContentsMargins(8,8,8,8);
    lay->addWidget(m_view);

    // スクロールバーの出現/消失でも幅が変わる
    connect(m_view->verticalScrollBar(), &QAbstractSlider::rangeChanged,
            this, &AnalysisResultsPresenter::onScrollRangeChanged);
}

void AnalysisResultsPresenter::connectModelSignals(KifuAnalysisListModel* model)
{
    if (!model) return;
    connect(model, &QAbstractItemModel::modelReset,   this, &AnalysisResultsPresenter::onModelReset);
    connect(model, &QAbstractItemModel::rowsInserted, this, &AnalysisResultsPresenter::onRowsInserted);
    connect(model, &QAbstractItemModel::dataChanged,  this, &AnalysisResultsPresenter::onDataChanged);
    connect(model, &QAbstractItemModel::layoutChanged,this, &AnalysisResultsPresenter::onLayoutChanged);
}

void AnalysisResultsPresenter::reflowNow()
{
    if (!m_view || !m_header) return;

    // 0..2 を内容幅に
    m_header->setSectionResizeMode(0, QHeaderView::ResizeToContents);
    m_header->setSectionResizeMode(1, QHeaderView::ResizeToContents);
    m_header->setSectionResizeMode(2, QHeaderView::ResizeToContents);

    m_view->resizeColumnsToContents();

    // PV を一時的に Interactive に変更して幅を与える
    m_header->setSectionResizeMode(3, QHeaderView::Interactive);

    const int w0 = m_header->sectionSize(0);
    const int w1 = m_header->sectionSize(1);
    const int w2 = m_header->sectionSize(2);

    const int viewportW = m_view->viewport()->width();
    const int vScrollW  = m_view->verticalScrollBar()->isVisible()
                             ? m_view->verticalScrollBar()->width() : 0;
    const int margins   = 4;
    const int remain    = viewportW - (w0 + w1 + w2) - vScrollW - margins;
    const int pvWidth   = qMax(160, remain);

    m_header->resizeSection(3, pvWidth);

    // Stretch に戻す（ウィンドウ幅追従）
    m_header->setSectionResizeMode(3, QHeaderView::Stretch);
    m_header->setStretchLastSection(true);
}

void AnalysisResultsPresenter::onModelReset() { m_reflowTimer->start(); }
void AnalysisResultsPresenter::onRowsInserted(const QModelIndex&, int, int) { m_reflowTimer->start(); }
void AnalysisResultsPresenter::onDataChanged(const QModelIndex&, const QModelIndex&, const QList<int>&) { m_reflowTimer->start(); }
void AnalysisResultsPresenter::onLayoutChanged() { m_reflowTimer->start(); }
void AnalysisResultsPresenter::onScrollRangeChanged(int, int) { m_reflowTimer->start(); }
#include "analysistabwiring.h"

#include "engineanalysistab.h"
#include "shogienginethinkingmodel.h"
#include "usicommlogmodel.h"

#include <QTabWidget>
#include <QDebug>

AnalysisTabWiring::AnalysisTabWiring(const Deps& d, QObject* parent)
    : QObject(parent), m_d(d)
{
}

EngineAnalysisTab* AnalysisTabWiring::buildUiAndWire()
{
    // すでに構築済みならそのまま返す
    if (m_analysisTab) return m_analysisTab;

    // 1) タブ本体の生成と UI 構築
    m_analysisTab = new EngineAnalysisTab(m_d.centralParent);
    m_analysisTab->buildUi();

    // 2) 思考モデル（先後）を生成（親=this で寿命管理）
    m_think1 = new ShogiEngineThinkingModel(this);
    m_think2 = new ShogiEngineThinkingModel(this);

    // 3) モデルをタブにセット（EngineAnalysisTab の API 仕様に合わせる）
    m_analysisTab->setModels(m_think1, m_think2, m_d.log1, m_d.log2);

    // 4) 既定は単機表示（EvE で必要になれば MainWindow 側で切替）
    m_analysisTab->setDualEngineVisible(false);

    // 5) QTabWidget を拾っておく
    m_tab = m_analysisTab->tab();

    // 6) signal → signal の中継（ラムダ不使用）
    QObject::connect(
        m_analysisTab, &EngineAnalysisTab::branchNodeActivated,
        this,          &AnalysisTabWiring::branchNodeActivated,
        Qt::UniqueConnection);

    return m_analysisTab;
}
#include "boardsyncpresenter.h"
#include "shogigamecontroller.h"
#include "shogiview.h"
#include "boardinteractioncontroller.h"
#include "shogiboard.h"
#include "shogimove.h"
#include <QDebug>

BoardSyncPresenter::BoardSyncPresenter(const Deps& d, QObject* parent)
    : QObject(parent)
    , m_gc(d.gc)
    , m_view(d.view)
    , m_bic(d.bic)
    , m_sfenRecord(d.sfenRecord)
    , m_gameMoves(d.gameMoves)
{
}

// デバッグ用：SFENリストのダンプ（必要なら使う）
// ※ std::min(int, qsizetype) の型衝突を避けるため、自前で件数を算出
static inline void DBG_DUMP_SFEN_LIST(const QStringList* rec, const char* tag, int maxItems = 8) {
    if (!rec) { qDebug().noquote() << tag << " (rec=null)"; return; }

    const qsizetype sz = rec->size();
    qDebug().noquote() << tag << " size=" << sz << " ptr=" << static_cast<const void*>(rec);

    const int n = (sz > static_cast<qsizetype>(maxItems))
                      ? maxItems
                      : static_cast<int>(sz);

    for (int i = 0; i < n; ++i) {
        qDebug().noquote() << "  [" << i << "] " << rec->at(i);
    }
    if (sz > n) {
        qDebug().noquote() << "  ... (+" << static_cast<int>(sz - n) << " more)";
    }
}

void BoardSyncPresenter::applySfenAtPly(int ply) const
{
    // 文字列プレビュー用
    auto preview = [](const QString& s) -> QString {
        return (s.size() > 200) ? (s.left(200) + QStringLiteral(" ...")) : s;
    };

    qInfo() << "[PRESENTER] applySfenAtPly enter"
            << "reqPly=" << ply
            << "rec*=" << static_cast<const void*>(m_sfenRecord)
            << "gc=" << m_gc
            << "board=" << (m_gc ? m_gc->board() : nullptr)
            << "view=" << m_view;

    // ガード＆早期リターン
    if (!m_sfenRecord || m_sfenRecord->isEmpty() || !m_gc || !m_gc->board()) {
        qWarning() << "[PRESENTER] applySfenAtPly guard failed:"
                   << "rec*=" << static_cast<const void*>(m_sfenRecord)
                   << "isEmpty?=" << (m_sfenRecord ? m_sfenRecord->isEmpty() : true)
                   << "gc=" << m_gc << "board?=" << (m_gc ? m_gc->board() : nullptr);
        return;
    }

    const int size   = static_cast<int>(m_sfenRecord->size());
    const int maxIdx = size - 1;

    // ★ 終局（投了など）行の判定：SFEN は増えないため reqPly > maxIdx になる
    const bool isTerminalRow = (ply > maxIdx);

    // ★ 実際に適用するインデックスはクランプ（終局行なら常に末尾の SFEN を使う）
    const int idx = qBound(0, ply, maxIdx);

    qInfo().noquote()
        << QString("[PRESENTER] applySfenAtPly params reqPly=%1 size=%2 maxIdx=%3 idx=%4 terminalRow=%5")
               .arg(ply).arg(size).arg(maxIdx).arg(idx).arg(isTerminalRow);

    if (isTerminalRow) {
        // 例：開始局面 + 4手 + 投了 → size=5, reqPly=5, idx=4
        qInfo().noquote()
            << QString("[PRESENTER] TERMINAL-ROW: non-move row (e.g. resignation). Using last SFEN at idx=%1 (size-1).")
                   .arg(idx);
        if (ply == size) {
            qInfo() << "[PRESENTER] TERMINAL-ROW detail: reqPly == size (expected for resignation right after last move).";
        } else if (ply > size) {
            qWarning().noquote()
            << QString("[PRESENTER] TERMINAL-ROW anomaly: reqPly(%1) > size(%2). Upstream should not overshoot too much.")
                    .arg(ply).arg(size);
        }
    }

    const QString sfen = m_sfenRecord->at(idx);

    qInfo().noquote() << QString("[PRESENTER] applySfenAtPly reqPly=%1 idx=%2 size=%3 rec*=%4")
                             .arg(ply).arg(idx).arg(size)
                             .arg(reinterpret_cast<quintptr>(m_sfenRecord), 0, 16);

    if (size > 0) {
        qInfo().noquote() << "[PRESENTER] head[0]= "   << preview(m_sfenRecord->first());
        qInfo().noquote() << "[PRESENTER] tail[last]= "<< preview(m_sfenRecord->last());
    }
    qInfo().noquote() << "[PRESENTER] pick[" << idx << "]= " << preview(sfen);

    // --- 追加: リスト全体に "position " 混入がないか軽くスキャン（最初の1件だけ報告） ---
    {
        int bad = -1;
        for (int i = 0; i < size; ++i) {
            if (m_sfenRecord->at(i).startsWith(QLatin1String("position "))) { bad = i; break; }
        }
        if (bad >= 0) {
            qWarning().noquote() << "[PRESENTER] *** NON-SFEN DETECTED in m_sfenRecord at index "
                                 << bad << ": " << preview(m_sfenRecord->at(bad));
        }
    }

    // --- 追加: 周辺ダンプ（idx±3 だけ） ---
    {
        const int from = qMax(0, idx - 3);
        const int to   = qMin(size - 1, idx + 3);
        for (int i = from; i <= to; ++i) {
            const QString p = m_sfenRecord->at(i);
            qInfo().noquote() << QString("[PRESENTER] win[%1]= %2").arg(i).arg(preview(p));
        }
    }

    // --- 追加: pick文字列の基本妥当性チェック ---
    if (sfen.startsWith(QLatin1String("position "))) {
        qWarning() << "[PRESENTER] *** NON-SFEN passed to presenter (starts with 'position ') at idx=" << idx;
    }

    const QStringList parts = sfen.split(QLatin1Char(' '), Qt::KeepEmptyParts);
    if (parts.size() == 4) {
        const QString& boardField = parts[0];
        const QString& turnField  = parts[1];
        const QString& standField = parts[2];
        const QString& moveField  = parts[3];

        qInfo().noquote() << "[PRESENTER] fields"
                          << " board=" << boardField
                          << " turn=" << turnField
                          << " stand=" << standField
                          << " move=" << moveField;

        // 9段の盤 → スラッシュは8本のはず
        const int slashCount = boardField.count(QLatin1Char('/'));
        if (slashCount != 8) {
            qWarning() << "[PRESENTER] suspicious board field: slashCount=" << slashCount << "(expected 8)";
        }

        if (turnField != QLatin1String("b") && turnField != QLatin1String("w")) {
            qWarning() << "[PRESENTER] suspicious turn field:" << turnField;
        }

        bool moveOk = false;
        const int moveNum = moveField.toInt(&moveOk);
        if (!moveOk || moveNum <= 0) {
            qWarning() << "[PRESENTER] suspicious move field:" << moveField;
        }

        if (idx == 0) {
            if (moveField != QLatin1String("1")) {
                qWarning() << "[PRESENTER] head move number is not 1:" << moveField;
            }
        }

        // ★ 終局行の場合、最後の SFEN の move 番号と reqPly の関係をメモ
        if (isTerminalRow) {
            qInfo().noquote()
            << QString("[PRESENTER] terminal note: last SFEN's move=%1, reqPly=%2 (no new SFEN for resignation)")
                    .arg(moveField).arg(ply);
        }

    } else {
        qWarning().noquote() << "[PRESENTER] fields malformed (need 4 parts) size="
                             << parts.size() << " sfen=" << preview(sfen);
    }

    // --- 実適用（前後でログ） ---
    qInfo().noquote() << "[PRESENTER] setSfen() <= " << preview(sfen);
    m_gc->board()->setSfen(sfen);
    qInfo() << "[PRESENTER] setSfen() applied";

    if (m_view) {
        m_view->applyBoardAndRender(m_gc->board());
        qInfo() << "[PRESENTER] view->applyBoardAndRender() done";
    }

    // ★ トレーラ：この関数は「盤面適用」担当。
    // 投了など終局行のハイライト消去は syncBoardAndHighlightsAtRow() 側で行う想定。
    qInfo().noquote() << "[PRESENTER] applySfenAtPly leave"
                      << " reqPly=" << ply
                      << " idx=" << idx
                      << " terminalRow=" << isTerminalRow;
}

// 盤面・ハイライト同期（行 → 盤面）
void BoardSyncPresenter::syncBoardAndHighlightsAtRow(int ply) const
{
    // 依存チェック
    if (!m_sfenRecord || !m_gc || !m_gc->board()) {
        qDebug().noquote() << "[PRESENTER] syncBoardAndHighlightsAtRow ABORT:"
                           << "sfenRecord?" << (m_sfenRecord!=nullptr)
                           << "gc?"        << (m_gc!=nullptr)
                           << "board?"     << (m_gc? (m_gc->board()!=nullptr) : false)
                           << " ply="      << ply;
        return;
    }

    const int size   = static_cast<int>(m_sfenRecord->size());
    const int maxIdx = size - 1;
    if (maxIdx < 0) {
        qDebug().noquote() << "[PRESENTER] syncBoardAndHighlightsAtRow: empty sfenRecord ply=" << ply;
        return;
    }

    const bool isTerminalRow = (ply > maxIdx);
    const int  safePly       = qBound(0, ply, maxIdx);

    qDebug().noquote()
        << "[PRESENTER] syncBoardAndHighlightsAtRow enter"
        << " reqPly=" << ply
        << " safePly=" << safePly
        << " size=" << size
        << " maxIdx=" << maxIdx
        << " isTerminalRow=" << isTerminalRow;

    // ★重要：先に盤面を適用（元の実装と同じ順序を維持）
    // applySfenAtPly 内でクランプされる想定のため reqPly のまま渡す
    applySfenAtPly(ply);

    // ハイライト器（BIC）が無ければここで終了（盤面だけは更新済み）
    if (!m_bic) {
        qDebug().noquote() << "[PRESENTER] syncBoardAndHighlightsAtRow: no BIC; skip highlights";
        return;
    }

    // 開始局面（0手目）や終端行（投了等）の行はハイライト消去のみ
    if (safePly <= 0 || isTerminalRow) {
        qDebug().noquote() << "[PRESENTER] syncBoardAndHighlightsAtRow: clear highlights"
                           << " reason=" << (safePly<=0 ? "startpos" : "terminalRow");
        m_bic->clearAllHighlights();
        return;
    }

    // ======== ここからハイライト推定（SFEN差分） ========
    auto sfenAt = [&](int idx)->QString {
        if (!m_sfenRecord || idx < 0 || idx >= m_sfenRecord->size()) return QString();
        return m_sfenRecord->at(idx);
    };
    const QString prev = sfenAt(safePly - 1);
    const QString curr = sfenAt(safePly);

    // 1局面分の SFEN（盤面部）を 9x9 のトークングリッドへ展開
    // ★FIX：段(y)は「後手側=上」を原点(0)にする → y = r
    auto parseOneBoard = [](const QString& sfen, QString grid[9][9])->bool {
        for (int y=0; y<9; ++y) for (int x=0; x<9; ++x) grid[y][x].clear();

        if (sfen.isEmpty()) return false;
        const QString boardField = sfen.split(QLatin1Char(' '), Qt::KeepEmptyParts).value(0);
        const QStringList rows   = boardField.split(QLatin1Char('/'), Qt::KeepEmptyParts);
        if (rows.size() != 9) return false;

        for (int r = 0; r < 9; ++r) {
            const QString& row = rows.at(r);
            const int y = r;    // 上(後手側)=0, 下(先手側)=8
            int x = 8;          // 筋は右(9筋)=8 → 左(1筋)=0 へ詰める

            for (int i = 0; i < row.size(); ++i) {
                const QChar ch = row.at(i);
                if (ch.isDigit()) {
                    x -= (ch.toLatin1() - '0'); // 連続空白
                } else if (ch == QLatin1Char('+')) {
                    if (i + 1 >= row.size() || x < 0) return false;
                    grid[y][x] = QStringLiteral("+") + row.at(++i); // 成り駒
                    --x;
                } else {
                    if (x < 0) return false;
                    grid[y][x] = QString(ch); // 通常駒
                    --x;
                }
            }
            if (x != -1) return false; // 9マス分ちょうどで終わっていない
        }
        return true;
    };

    // prev/curr のグリッド差分から from/to を推定（駒打ちにも対応）
    auto deduceByDiff = [&](const QString& a, const QString& b, QPoint& from, QPoint& to)->bool {
        QString ga[9][9], gb[9][9];
        if (!parseOneBoard(a, ga) || !parseOneBoard(b, gb)) return false;

        bool foundFrom = false, foundTo = false;
        for (int y = 0; y < 9; ++y) {
            for (int x = 0; x < 9; ++x) {
                if (ga[y][x] == gb[y][x]) continue;
                if (!ga[y][x].isEmpty() && gb[y][x].isEmpty()) {
                    from = QPoint(x, y); foundFrom = true;   // 元が空いた
                } else {
                    to   = QPoint(x, y); foundTo = true;     // 先が変化（駒打ち含む）
                }
            }
        }
        // 駒打ちは from 不在でも OK（to があればハイライト可能）
        return foundTo;
    };

    QPoint from(-1,-1), to(-1,-1);
    bool ok = deduceByDiff(prev, curr, from, to);

    if (!ok) {
        // フォールバック：対局中に積んだ m_gameMoves（HvH等）を参照
        const int mvIdx = safePly - 1;
        if (!m_gameMoves || mvIdx < 0 || mvIdx >= m_gameMoves->size()) {
            m_bic->clearAllHighlights();
            return;
        }
        const ShogiMove& last = m_gameMoves->at(mvIdx);
        const bool hasFrom = (last.fromSquare.x() >= 0 && last.fromSquare.y() >= 0);

        qDebug().noquote() << "[PRESENTER] highlight(fallback:gameMoves)"
                           << " mvIdx=" << mvIdx
                           << " from=(" << last.fromSquare.x() << "," << last.fromSquare.y() << ")"
                           << " to=("   << last.toSquare.x()   << "," << last.toSquare.y()   << ")"
                           << " hasFrom=" << hasFrom;

        const QPoint to1 = toOne(last.toSquare);
        if (hasFrom) {
            const QPoint from1 = toOne(last.fromSquare);
            m_bic->showMoveHighlights(from1, to1);
        } else {
            m_bic->showMoveHighlights(QPoint(), to1);
        }
        return;
    }

    const QPoint to1   = toOne(to);
    const bool   hasFrom = (from.x() >= 0 && from.y() >= 0);
    qDebug().noquote() << "[PRESENTER] highlight(by sfen-diff)"
                       << " ply=" << safePly
                       << " from=(" << from.x() << "," << from.y() << ")"
                       << " to=("   << to.x()   << "," << to.y()   << ")"
                       << " hasFrom=" << hasFrom;

    if (hasFrom) {
        const QPoint from1 = toOne(from);
        m_bic->showMoveHighlights(from1, to1);
    } else {
        m_bic->showMoveHighlights(QPoint(), to1);
    }
}

void BoardSyncPresenter::clearHighlights() const
{
    if (m_bic) m_bic->clearAllHighlights();
}
#include "branchwiringcoordinator.h"

#include "recordpane.h"
#include "kifubranchlistmodel.h"
#include "branchcandidatescontroller.h"
#include "kifuloadcoordinator.h"

#include <QTableView>
#include <QDebug>

BranchWiringCoordinator::BranchWiringCoordinator(const Deps& d)
    : QObject(d.parent)
    , m_recordPane(d.recordPane)
    , m_branchModel(d.branchModel)
    , m_varEngine(d.variationEngine)
    , m_loader(d.kifuLoader)
{
}

void BranchWiringCoordinator::setupBranchView()
{
    if (!m_recordPane) return;

    if (!m_branchModel) {
        m_branchModel = new KifuBranchListModel(this);
        qDebug() << "[WIRE] created KifuBranchListModel =" << m_branchModel;
    }

    QTableView* view = m_recordPane->branchView();
    if (!view) return;

    if (view->model() != m_branchModel) {
        view->setModel(m_branchModel);
        qDebug() << "[WIRE] branchView.setModel done model=" << m_branchModel;
    }

    // ★初期から表示しておく：候補が空でもコメント欄の上に常に見せる
    view->setVisible(true);
    view->setEnabled(false);
}

void BranchWiringCoordinator::setupBranchCandidatesWiring()
{
    if (!m_recordPane) return;

    // モデル/ビューの配線は別関数 setupBranchView() で済ませ済み

    // Controller を用意（1回だけ）
    if (!m_branchCtl) {
        m_branchCtl = new BranchCandidatesController(m_varEngine, m_branchModel, this);
        qDebug() << "[WIRE] BranchCandidatesController created ve=" << static_cast<void*>(m_varEngine)
                 << " model=" << static_cast<void*>(m_branchModel);
    }

    // RecordPane 側と結線（クリック → activateCandidate）
    m_branchCtl->attachRecordPane(m_recordPane);

    // Plan クリック → 行/手ジャンプ
    const bool okA = connect(m_branchCtl, &BranchCandidatesController::planActivated,
                             this,         &BranchWiringCoordinator::onBranchPlanActivated,
                             Qt::UniqueConnection);
    qDebug() << "[WIRE] connect planActivated -> onBranchPlanActivated :" << okA;

    // RecordPane の行アクティベート → 候補の有効化
    const bool okB = connect(m_recordPane, &RecordPane::branchActivated,
                             this,         &BranchWiringCoordinator::onRecordPaneBranchActivated,
                             Qt::UniqueConnection);
    qDebug() << "[WIRE] connect RecordPane.branchActivated -> onRecordPaneBranchActivated :" << okB;

    // ★★ ここが肝：Loader に Controller を教える（以降、Loader が候補を流し込める）
    if (m_loader) {
        m_loader->setBranchCandidatesController(m_branchCtl);
    }
}

void BranchWiringCoordinator::onRecordPaneBranchActivated(const QModelIndex& index)
{
    if (!index.isValid() || !m_branchCtl) return;
    m_branchCtl->activateCandidate(index.row());
}

void BranchWiringCoordinator::onBranchPlanActivated(int row, int ply1)
{
    qDebug() << "[BRANCH] planActivated -> applyResolvedRowAndSelect row=" << row << " ply=" << ply1;
    applyResolvedRowAndSelect_(row, ply1);
}

void BranchWiringCoordinator::onBranchNodeActivated(int row, int ply)
{
    if (!m_branchModel) return;
    if (row < 0 || row >= m_branchModel->rowCount()) return;

    // その行の手数内にクランプ（0=開始局面, 1..N）
    const int maxPly = m_branchModel->data(m_branchModel->index(row, 0),
                                           KifuBranchListModel::DispCountRole).toInt();
    const int selPly = qBound(0, ply, maxPly);

    applyResolvedRowAndSelect_(row, selPly);
}

void BranchWiringCoordinator::applyResolvedRowAndSelect_(int row, int selPly)
{
    if (!m_loader) return;
    // KifuLoadCoordinator へ委譲（局面/棋譜/ビューの同期を一括で）
    m_loader->applyResolvedRowAndSelect(row, selPly);
}

void BranchWiringCoordinator::setKifuLoader(KifuLoadCoordinator* loader)
{
    m_loader = loader;
}
#include "considerationflowcontroller.h"

#include "considerationdialog.h"
#include "matchcoordinator.h"

#include <QObject>
#include <QDialog>

ConsiderationFlowController::ConsiderationFlowController(QObject* parent)
    : QObject(parent)
{
}

void ConsiderationFlowController::runWithDialog(const Deps& d, QWidget* parent, const QString& positionStr)
{
    if (!d.match) {
        if (d.onError) d.onError(QStringLiteral("内部エラー: MatchCoordinator が未初期化です。"));
        return;
    }
    if (positionStr.isEmpty()) {
        if (d.onError) d.onError(QStringLiteral("検討対象の局面（position）が空です。"));
        return;
    }

    ConsiderationDialog dlg(parent);
    if (dlg.exec() != QDialog::Accepted) return;

    const QList<ConsiderationDialog::Engine>& engines = dlg.getEngineList();
    const int idx = dlg.getEngineNumber();

    if (engines.isEmpty() || idx < 0 || idx >= engines.size()) {
        if (d.onError) d.onError(QStringLiteral("検討エンジンの選択が不正です。"));
        return;
    }

    const auto& engine = engines.at(idx);

    int byoyomiMs = 0;  // 0 は無制限
    if (!dlg.unlimitedTimeFlag()) {
        byoyomiMs = dlg.getByoyomiSec() * 1000;  // 秒 → ms
    }

    // 表示名は engine.name を使用
    startAnalysis_(d.match, engine.path, engine.name, positionStr, byoyomiMs);
}

void ConsiderationFlowController::startAnalysis_(MatchCoordinator* match,
                                                 const QString& enginePath,
                                                 const QString& engineName,
                                                 const QString& positionStr,
                                                 int byoyomiMs)
{
    MatchCoordinator::AnalysisOptions opt;
    opt.enginePath  = enginePath;
    opt.engineName  = engineName;
    opt.positionStr = positionStr;
    opt.byoyomiMs   = byoyomiMs;
    opt.mode        = ConsidarationMode;  // 既存の PlayMode

    match->startAnalysis(opt);
}
#include "engineregistrationdialog.h"

namespace EngineSettingsCoordinator {

void openDialog(QWidget* parent)
{
    EngineRegistrationDialog dlg(parent);
    dlg.exec();
}

} // namespace EngineSettingsCoordinator
#include "matchcoordinator.h"
#include "usi.h"
#include <QList>

namespace EvalGraphPresenter {

// 主エンジンのスコアを m_scoreCp へ追記
void appendPrimaryScore(QList<int>& scoreCp, MatchCoordinator* match)
{
    Usi* eng = match ? match->primaryEngine() : nullptr;
    const int cp = eng ? eng->lastScoreCp() : 0;
    scoreCp.append(cp);
}

// 2ndエンジンのスコアを m_scoreCp へ追記
void appendSecondaryScore(QList<int>& scoreCp, MatchCoordinator* match)
{
    Usi* eng2 = match ? match->secondaryEngine() : nullptr;
    const int cp = eng2 ? eng2->lastScoreCp() : 0;
    scoreCp.append(cp);
}

} // namespace EvalGraphPresenter
#include "gamelayoutbuilder.h"
#include <QSplitter>
#include <QVBoxLayout>
#include <QTabWidget>
#include <QWidget>
#include <QDebug>

GameLayoutBuilder::GameLayoutBuilder(const Deps& d, QObject* parent)
    : QObject(parent), m_d(d)
{}

QSplitter* GameLayoutBuilder::buildHorizontalSplit()
{
    if (!m_splitter) {
        m_splitter = new QSplitter(Qt::Horizontal);
        if (m_d.shogiView)           m_splitter->addWidget(m_d.shogiView);
        if (m_d.recordPaneOrWidget)  m_splitter->addWidget(m_d.recordPaneOrWidget);
    }
    return m_splitter;
}

void GameLayoutBuilder::attachToCentralLayout(QVBoxLayout* vbox)
{
    if (!vbox) return;
    // 既存中身クリアは MainWindow 側の責務のままでOK（clearLayout等）
    if (m_splitter) vbox->addWidget(m_splitter);
    if (m_d.analysisTabWidget) vbox->addWidget(m_d.analysisTabWidget);
}
#include "gamestartcoordinator.h"
#include "kifurecordlistmodel.h"
#include "shogiboard.h"
#include "shogiview.h"
#include "matchcoordinator.h"
#include "shogiclock.h"
#include "shogigamecontroller.h"
#include "sfenpositiontracer.h"
#include "startgamedialog.h"
#include "kifudisplay.h"
#include "playernameservice.h"
#include "timecontrolutil.h"

#include <QPointer>
#include <QDebug>
#include <QWidget>
#include <QObject>
#include <QVariant>
#include <QMetaType>
#include <QtGlobal>

GameStartCoordinator::GameStartCoordinator(const Deps& d, QObject* parent)
    : QObject(parent)
    , m_match(d.match)
    , m_clock(d.clock)
    , m_gc(d.gc)
    , m_view(d.view)
{
    // MainWindow との queued 接続でも安全に受け渡せるように登録
    qRegisterMetaType<GameStartCoordinator::TimeControl>("GameStartCoordinator::TimeControl");
    qRegisterMetaType<GameStartCoordinator::Request>("GameStartCoordinator::Request");
}

bool GameStartCoordinator::validate_(const StartParams& p, QString& whyNot) const
{
    if (!m_match) {
        whyNot = QStringLiteral("MatchCoordinator が未設定です。");
        return false;
    }
    // ★ StartOptions::mode は PlayMode。NotStarted を弾く
    if (p.opt.mode == PlayMode::NotStarted) {
        whyNot = QStringLiteral("対局モードが NotStarted のままです。");
        return false;
    }
    return true;
}

// ===================================================================
// メイン API: StartOptions を受け取り対局を開始
// ===================================================================
void GameStartCoordinator::start(const StartParams& params)
{
    QString reason;
    if (!validate_(params, reason)) {
        emit startFailed(reason);
        qWarning().noquote() << "[GameStartCoordinator] startFailed:" << reason;
        return;
    }

    // --- 1) 開始前フック（UI/状態初期化） ---
    emit requestPreStartCleanup();

    // --- 2) TimeControl を正規化して適用（enabled 補正 / byoyomi 優先で inc を落とす） ---
    TimeControl tc = params.tc; // コピーして正規化

    const bool hasAny =
        (tc.p1.baseMs > 0) || (tc.p2.baseMs > 0) ||
        (tc.p1.byoyomiMs > 0) || (tc.p2.byoyomiMs > 0) ||
        (tc.p1.incrementMs > 0) || (tc.p2.incrementMs > 0);

    const bool useByoyomi = (tc.p1.byoyomiMs > 0) || (tc.p2.byoyomiMs > 0);
    if (useByoyomi) {
        // 秒読み指定がある場合はフィッシャー増加は使わない（衝突回避）
        tc.p1.incrementMs = 0;
        tc.p2.incrementMs = 0;
    }

    // 値が一つでも入っているのに enabled=false だったケースを救済
    if (!tc.enabled && hasAny) {
        tc.enabled = true;
    }

    qDebug().noquote()
        << "[GameStartCoordinator] normalized TimeControl:"
        << " enabled=" << tc.enabled
        << " P1{base=" << tc.p1.baseMs << " byo=" << tc.p1.byoyomiMs << " inc=" << tc.p1.incrementMs << "}"
        << " P2{base=" << tc.p2.baseMs << " byo=" << tc.p2.byoyomiMs << " inc=" << tc.p2.incrementMs << "}";

    // UI（時計）へ適用依頼：enabled か、もしくは何か値がある場合は必ず投げる
    if (tc.enabled || hasAny) {
        emit requestApplyTimeControl(tc);
        // 互換シグナル（どちらか一方だけ接続想定）
        emit applyTimeControlRequested(tc);
    }

    // 司令塔にも直に反映しておく（UIシグナルの非同期順序に影響されないように）
    if (m_match) {
        const bool loseOnTimeout = tc.enabled; // 持ち時間系が有効ならタイムアウト負け扱い
        m_match->setTimeControlConfig(
            useByoyomi,
            tc.p1.byoyomiMs, tc.p2.byoyomiMs,
            tc.p1.incrementMs, tc.p2.incrementMs,
            loseOnTimeout
            );
        m_match->refreshGoTimes();
    }

    // --- 3) 対局をセットアップ & 開始 ---
    emit willStart(params.opt);
    m_match->configureAndStart(params.opt);

    // --- 4) 初手がエンジン手番なら go を起動 ---
    if (params.autoStartEngineMove) {
        m_match->startInitialEngineMoveIfNeeded();
    }

    // --- 5) 完了通知 ---
    emit started(params.opt);
    qDebug().noquote() << "[GameStartCoordinator] started: mode="
                       << static_cast<int>(params.opt.mode);
}

// ===================================================================
// 追加：開始前適用 API（軽量リクエスト）
// ===================================================================
void GameStartCoordinator::prepare(const Request& req)
{
    // --- 0) 前処理（UIのプレクリア） ---
    emit requestPreStartCleanup();

    // --- 1) ダイアログから時間設定を抽出 ---
    const TimeControl tc = extractTimeControlFromDialog(req.startDialog);

    // 互換のため従来のシグナルも両方飛ばす（他所で受けている場合がある）
    emit requestApplyTimeControl(tc);
    emit applyTimeControlRequested(tc);

    qInfo().noquote()
        << "[GameStartCoordinator] normalized TimeControl: "
        << " enabled=" << tc.enabled
        << " P1{base=" << tc.p1.baseMs << "  byo=" << tc.p1.byoyomiMs << "  inc=" << tc.p1.incrementMs << " }"
        << " P2{base=" << tc.p2.baseMs << "  byo=" << tc.p2.byoyomiMs << "  inc=" << tc.p2.incrementMs << " }";

    // --- 2) 時計の取得（req.clock が無ければ m_match->clock() を使用） ---
    ShogiClock* clock = req.clock;
    if (!clock && m_match) {
        clock = m_match->clock();
    }
    if (!clock) {
        qWarning() << "[GSC] prepare: no ShogiClock (req.clock is null and m_match has no clock)";
        return;
    }

    // --- 3) 時間制御を適用（applyToClock は初期手番を 1/2 で設定する修正版を想定） ---
    TimeControlUtil::applyToClock(clock, tc, req.startSfen, QString());

    // 念のため SFEN から初期手番を明示（修正版が未適用でも安全）
    const int initialPlayer = (req.startSfen.contains(QLatin1String(" w ")) ? 2 : 1);
    clock->setCurrentPlayer(initialPlayer);

    // --- 4) 司令塔へ配線 → 起動（順序が重要） ---
    if (m_match) {
        m_match->setClock(clock);  // 先に配線
    }
    clock->startClock();           // その後で起動
}

// ===================================================================
// 段階実行 API：MainWindow 側の関数差し替え先
// ===================================================================
void GameStartCoordinator::prepareDataCurrentPosition(const Ctx& c)
{
    // 依存の軽いバリデーション
    if (!c.view || !m_match) {
        qWarning().noquote() << "[GameStartCoordinator] prepareDataCurrentPosition: missing deps:"
                             << "view=" << (c.view != nullptr) << " match=" << (m_match != nullptr);
        return;
    }

    // --- 0) 開始前クリーンアップを UI 層へ依頼（ハイライト/選択/解析UI などの掃除） ---
    emit requestPreStartCleanup();

    // --- 1) ベースSFENの決定（★優先: 現在SFEN → 開始SFEN → 平手） ---
    QString baseSfen;
    if (c.currentSfenStr && !c.currentSfenStr->isEmpty()) {
        baseSfen = *(c.currentSfenStr);
    } else if (c.startSfenStr && !c.startSfenStr->isEmpty()) {
        baseSfen = *(c.startSfenStr);
    } else {
        baseSfen = QStringLiteral("startpos");
    }

    // --- 2) ベースSFENの適用 ---
    //    ・"startpos" なら既定初期配置に
    //    ・それ以外の SFEN 文字列ならその局面を盤へセット
    if (baseSfen == QLatin1String("startpos")) {
        c.view->initializeToFlatStartingPosition();
        if (c.startSfenStr && c.startSfenStr->isEmpty())
            *c.startSfenStr = QStringLiteral("startpos");
        if (c.currentSfenStr)
            *c.currentSfenStr = QStringLiteral("startpos");
    } else {
        // 既存の「SFENを盤へ反映する」系ユーティリティを使用
        // ※ applyResumePositionIfAny は空でなければ SFEN を即適用し描画も反映
        GameStartCoordinator::applyResumePositionIfAny(c.gc, c.view, baseSfen);

        // 共有文字列の同期（GUI側の補助）
        if (c.currentSfenStr) *c.currentSfenStr = baseSfen;
        if (c.startSfenStr   && c.startSfenStr->isEmpty())
            *c.startSfenStr = QString(); // 「現在局面」開始の意図を保つ
    }

    // --- 3) 直前の終局状態を必ずクリア ---
    m_match->clearGameOverState();

    // --- 4) ハイライトを確実に空へ ---
    c.view->removeHighlightAllData();

    qDebug().noquote() << "[GameStartCoordinator] prepareDataCurrentPosition: done.";
}

// 初期局面（平手／手合割）で開始する場合の準備を行う。
void GameStartCoordinator::prepareInitialPosition(const Ctx& c)
{
    // 1) 開始局面番号を取得（0=現在局面, 1..N=手合割）。0 の場合でも安全側で平手にフォールバック。
    int startingPosNumber = 1; // 1=平手を既定
    if (c.startDlg) {
        if (auto dlg = qobject_cast<StartGameDialog*>(c.startDlg)) {
            startingPosNumber = dlg->startingPositionNumber();
        } else {
            // 互換：property で持っていれば使う
            bool ok = false;
            const int v = c.startDlg->property("startingPositionNumber").toInt(&ok);
            if (ok) startingPosNumber = v;
        }
    }
    if (startingPosNumber <= 0) startingPosNumber = 1;

    // 2) 手合割 → 文字列テーブル（MainWindow 実装と同値を保持）
    static const QString kStartingPositionStr[14] = {
        //  1: 平手（元コードの配列は [0]=平手 でしたが、ここでは可読のため 1 起点の説明）
        QStringLiteral("startpos"),
        //  2: 香落ち
        QStringLiteral("sfen lnsgkgsn1/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        //  3: 右香落ち
        QStringLiteral("sfen 1nsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        //  4: 角落ち
        QStringLiteral("sfen lnsgkgsnl/1r7/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        //  5: 飛車落ち
        QStringLiteral("sfen lnsgkgsnl/7b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        //  6: 飛香落ち
        QStringLiteral("sfen lnsgkgsn1/7b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        //  7: 二枚落ち
        QStringLiteral("sfen lnsgkgsnl/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        //  8: 三枚落ち
        QStringLiteral("sfen lnsgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        //  9: 四枚落ち
        QStringLiteral("sfen 1nsgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        // 10: 五枚落ち
        QStringLiteral("sfen 2sgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        // 11: 左五枚落ち
        QStringLiteral("sfen 1nsgkgs2/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        // 12: 六枚落ち
        QStringLiteral("sfen 2sgkgs2/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        // 13: 八枚落ち
        QStringLiteral("sfen 3gkg3/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),
        // 14: 十枚落ち
        QStringLiteral("sfen 4k4/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1")
    };

    // 範囲ガード（1..14 を想定）
    const int idx = qBound(1, startingPosNumber, 14) - 1;
    const QString startPositionStr = kStartingPositionStr[idx];

    // 3) "startpos" / "sfen ..." → 純 SFEN へ正規化
    auto toPureSfen = [](QString s) -> QString {
        if (s == QLatin1String("startpos")) {
            // 平手の完全 SFEN へ正規化
            return QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1");
        }
        if (s.startsWith(QLatin1String("sfen "))) {
            s.remove(0, 5); // "sfen " を除去
            return s;
        }
        // それ以外（既に純 SFEN など）の場合は、そのまま返す
        return s;
    };

    const QString sfen = toPureSfen(startPositionStr);

    qDebug().noquote()
        << "[GSC][prepareInitial] startingPosNumber=" << startingPosNumber
        << " sfen=" << sfen
        << " sfenRecord*=" << static_cast<const void*>(c.sfenRecord);

    // 4) 参照を通して MainWindow 側の文字列を更新
    if (c.startSfenStr)   *c.startSfenStr   = sfen;
    if (c.currentSfenStr) *c.currentSfenStr = sfen; // 同期しておくと後段の利用が楽

    // 5) 棋譜欄に「=== 開始局面 ===」ヘッダを追加（必要時のみ・重複防止）
    if (c.kifuModel) {
        const int rows = c.kifuModel->rowCount();
        bool need = true;
        if (rows > 0) {
            const QModelIndex idx0 = c.kifuModel->index(0, 0);
            const QString head = c.kifuModel->data(idx0, Qt::DisplayRole).toString();
            if (head == QStringLiteral("=== 開始局面 ==="))
                need = false;
        }
        if (need) {
            if (rows == 0) {
                c.kifuModel->appendItem(
                    new KifuDisplay(QStringLiteral("=== 開始局面 ==="),
                                    QStringLiteral("（１手 / 合計）")));
            } else {
                c.kifuModel->prependItem(
                    new KifuDisplay(QStringLiteral("=== 開始局面 ==="),
                                    QStringLiteral("（１手 / 合計）")));
            }
        }
    }

    // 6) SFEN履歴に開始SFEN（0手目）を積む
    if (c.sfenRecord) {
        const int before = c.sfenRecord->size();
        qDebug().noquote() << "[GSC][prepareInitial] sfenRecord BEFORE size=" << before;

        c.sfenRecord->clear();
        c.sfenRecord->append(sfen);

        qDebug().noquote() << "[GSC][prepareInitial] sfenRecord AFTER  size=" << c.sfenRecord->size();
        if (!c.sfenRecord->isEmpty()) {
            qDebug().noquote() << "[GSC][prepareInitial] head[0]=" << c.sfenRecord->first();
        }
    } else {
        qDebug().noquote() << "[GSC][prepareInitial] sfenRecord is null";
    }

    // 7) 見た目のノイズを避けるため、開幕時のハイライトはクリアしておく（存在時のみ）
    if (c.view) {
        c.view->removeHighlightAllData();
    }

    // 末尾ログ（既存ログに加筆）
    qDebug().noquote() << "[GameStartCoordinator] prepareInitialPosition: sfen=" << sfen
                       << " sfenRecord*=" << static_cast<const void*>(c.sfenRecord);
}

void GameStartCoordinator::setTimerAndStart(const Ctx& c)
{
    // 依存チェック
    if (!c.clock) {
        qWarning().noquote() << "[GameStartCoordinator] setTimerAndStart: clock is null.";
        return;
    }

    // --- 1) ダイアログから各種設定値を取得 ---
    int basicTimeHour1 = 0, basicTimeMinutes1 = 0;
    int basicTimeHour2 = 0, basicTimeMinutes2 = 0;
    int byoyomi1 = 0, byoyomi2 = 0;
    int binc = 0, winc = 0;
    bool isLoseOnTimeout = true;

    if (c.startDlg) {
        if (auto dlg = qobject_cast<StartGameDialog*>(c.startDlg)) {
            basicTimeHour1    = dlg->basicTimeHour1();
            basicTimeMinutes1 = dlg->basicTimeMinutes1();
            basicTimeHour2    = dlg->basicTimeHour2();
            basicTimeMinutes2 = dlg->basicTimeMinutes2();
            byoyomi1          = dlg->byoyomiSec1();
            byoyomi2          = dlg->byoyomiSec2();
            binc              = dlg->addEachMoveSec1();
            winc              = dlg->addEachMoveSec2();
            isLoseOnTimeout   = dlg->isLoseOnTimeout();
        } else {
            auto getPropInt = [&](const char* name)->int {
                bool ok=false; int v = c.startDlg->property(name).toInt(&ok); return ok ? v : 0;
            };
            auto getPropBool = [&](const char* name)->bool {
                if (!c.startDlg->property(name).isValid()) return true;
                return c.startDlg->property(name).toBool();
            };
            basicTimeHour1    = getPropInt("basicTimeHour1");
            basicTimeMinutes1 = getPropInt("basicTimeMinutes1");
            basicTimeHour2    = getPropInt("basicTimeHour2");
            basicTimeMinutes2 = getPropInt("basicTimeMinutes2");
            byoyomi1          = getPropInt("byoyomiSec1");
            byoyomi2          = getPropInt("byoyomiSec2");
            binc              = getPropInt("addEachMoveSec1");
            winc              = getPropInt("addEachMoveSec2");
            isLoseOnTimeout   = getPropBool("isLoseOnTimeout");
        }
    }

    // --- 2) 秒へ統一（内部は秒でセット、UI表示は Clock 側でms等に変換） ---
    const int remainingTime1 = basicTimeHour1 * 3600 + basicTimeMinutes1 * 60;
    const int remainingTime2 = basicTimeHour2 * 3600 + basicTimeMinutes2 * 60;

    const bool hasTimeLimit =
        (basicTimeHour1*3600 + basicTimeMinutes1*60) > 0 ||
        (basicTimeHour2*3600 + basicTimeMinutes2*60) > 0 ||
        byoyomi1 > 0 || byoyomi2 > 0 || binc > 0 || winc > 0;

    // --- 3) 時計へ反映 ---
    c.clock->setLoseOnTimeout(isLoseOnTimeout);
    c.clock->setPlayerTimes(remainingTime1, remainingTime2,
                            byoyomi1, byoyomi2,
                            binc, winc,
                            hasTimeLimit);

    // --- 4) 初期msを出力（必要な場合のみ） ---
    if (c.initialTimeP1MsOut) *c.initialTimeP1MsOut = c.clock->getPlayer1TimeIntMs();
    if (c.initialTimeP2MsOut) *c.initialTimeP2MsOut = c.clock->getPlayer2TimeIntMs();

    // --- 5) 表示更新＆起動制御 ---
    emit requestUpdateTurnDisplay();
    c.clock->updateClock();
    if (!c.isReplayMode) {
        c.clock->startClock();
    }

    // ★★ 追加：司令塔に TimeControl（秒読み/増加/負け扱い）を設定
    if (m_match) {
        const bool useByoyomi = (byoyomi1 > 0 || byoyomi2 > 0);
        m_match->setTimeControlConfig(
            useByoyomi,
            byoyomi1 * 1000, byoyomi2 * 1000,
            binc     * 1000, winc     * 1000,
            isLoseOnTimeout
            );
    }

    // --- 6) MatchCoordinator へ時計を配線（初期表示も即時反映） ---
    if (m_match && c.clock) {
        m_match->setClock(c.clock);
        m_match->pokeTimeUpdateNow();
    }

    qDebug().noquote() << "[GameStartCoordinator] setTimerAndStart: "
                       << "t1=" << remainingTime1 << "s"
                       << " t2=" << remainingTime2 << "s"
                       << " byo=" << byoyomi1 << "/" << byoyomi2
                       << " inc=" << binc << "/" << winc
                       << " loseOnTimeout=" << isLoseOnTimeout
                       << " replay=" << c.isReplayMode;
}

// ===================================================================
// ダイアログ抽出ヘルパ
// ===================================================================
int GameStartCoordinator::readIntProperty(const QObject* root,
                                          const char* objectName,
                                          const char* prop,
                                          int def)
{
    if (!root) return def;
    if (auto obj = root->findChild<const QObject*>(QLatin1String(objectName))) {
        bool ok = false;
        const int n = obj->property(prop).toInt(&ok);
        if (ok) return n;
    }
    return def;
}

bool GameStartCoordinator::readBoolProperty(const QObject* root,
                                            const char* objectName,
                                            const char* prop,
                                            bool def)
{
    if (!root) return def;
    if (auto obj = root->findChild<const QObject*>(QLatin1String(objectName))) {
        const QVariant v = obj->property(prop);
        if (v.isValid()) return v.toBool();
    }
    return def;
}

GameStartCoordinator::TimeControl
GameStartCoordinator::extractTimeControlFromDialog(const QWidget* dlg)
{
    TimeControl tc;

    // 既定の objectName（あなたのUIに合わせて必要ならここを調整）
    const int p1h  = readIntProperty (dlg, "p1HoursSpin");
    const int p1m  = readIntProperty (dlg, "p1MinutesSpin");
    const int p2h  = readIntProperty (dlg, "p2HoursSpin");
    const int p2m  = readIntProperty (dlg, "p2MinutesSpin");
    const int byo1 = readIntProperty (dlg, "byoyomiSec1");
    const int byo2 = readIntProperty (dlg, "byoyomiSec2");
    const int inc1 = readIntProperty (dlg, "addEachMoveSec1");
    const int inc2 = readIntProperty (dlg, "addEachMoveSec2");
    const bool limited = readBoolProperty(dlg, "limitedTimeCheck");

    auto toMs = [](int h, int m){ return (qMax(0,h)*3600 + qMax(0,m)*60) * 1000LL; };

    tc.p1.baseMs = toMs(p1h, p1m);
    tc.p2.baseMs = toMs(p2h, p2m);

    // byoyomi / increment は排他
    if (byo1 > 0 || byo2 > 0) {
        tc.p1.byoyomiMs   = qMax(0, byo1) * 1000LL;
        tc.p2.byoyomiMs   = qMax(0, byo2) * 1000LL;
        tc.p1.incrementMs = 0;
        tc.p2.incrementMs = 0;
    } else if (inc1 > 0 || inc2 > 0) {
        tc.p1.byoyomiMs = qMax(0, inc1) * 1000LL;
        tc.p2.byoyomiMs = qMax(0, inc2) * 1000LL;
        tc.p1.byoyomiMs = 0;
        tc.p2.byoyomiMs = 0;
    } else {
        tc.p1.byoyomiMs = 0;
        tc.p2.byoyomiMs = 0;
        tc.p1.incrementMs = 0;
        tc.p2.incrementMs = 0;
    }

    // 時計の有効/無制限フラグ
    if (dlg) {
        tc.enabled = limited;
    } else {
        tc.enabled = (tc.p1.baseMs > 0 || tc.p2.baseMs > 0);
    }

    return tc;
}

PlayMode GameStartCoordinator::determinePlayMode(const int initPositionNumber,
                                                 const bool isPlayer1Human,
                                                 const bool isPlayer2Human) const
{
    // 平手（=1）と駒落ち（!=1）で分岐は同じ構造。元コードを忠実移植。
    const bool isEven = (initPositionNumber == 1);

    if (isEven) {
        if (isPlayer1Human && isPlayer2Human)  return HumanVsHuman;
        if (isPlayer1Human && !isPlayer2Human) return EvenHumanVsEngine;
        if (!isPlayer1Human && isPlayer2Human) return EvenEngineVsHuman;
        if (!isPlayer1Human && !isPlayer2Human) return EvenEngineVsEngine;
    } else {
        if (isPlayer1Human && isPlayer2Human)  return HumanVsHuman;
        if (isPlayer1Human && !isPlayer2Human) return HandicapHumanVsEngine;
        if (!isPlayer1Human && isPlayer2Human) return HandicapEngineVsHuman;
        if (!isPlayer1Human && !isPlayer2Human) return HandicapEngineVsEngine;
    }

    return PlayModeError;
}

PlayMode GameStartCoordinator::setPlayMode(const Ctx& c) const
{
    // StartGameDialog から値を取得（MainWindow::setPlayMode の移管）
    int  initPositionNumber = 1;
    bool isHuman1 = false, isHuman2 = false;
    bool isEngine1 = false, isEngine2 = false;

    if (c.startDlg) {
        if (auto dlg = qobject_cast<StartGameDialog*>(c.startDlg)) {
            initPositionNumber = dlg->startingPositionNumber();
            isHuman1           = dlg->isHuman1();
            isHuman2           = dlg->isHuman2();
            isEngine1          = dlg->isEngine1();
            isEngine2          = dlg->isEngine2();
        } else {
            // 互換: property 経由のフェールセーフ
            bool ok=false;
            const QVariant pn = c.startDlg->property("startingPositionNumber");
            initPositionNumber = pn.isValid() ? pn.toInt(&ok) : 1;
            if (!ok) initPositionNumber = 1;

            isHuman1  = c.startDlg->property("isHuman1").toBool();
            isHuman2  = c.startDlg->property("isHuman2").toBool();
            isEngine1 = c.startDlg->property("isEngine1").toBool();
            isEngine2 = c.startDlg->property("isEngine2").toBool();
        }
    }

    // 「Human と Engine の排他」を元コードと同じくここで整形
    const bool p1Human = (isHuman1  && !isEngine1);
    const bool p2Human = (isHuman2  && !isEngine2);

    const PlayMode mode = determinePlayMode(initPositionNumber, p1Human, p2Human);

    if (mode == PlayModeError) {
        // 元のメッセージに近い文面で、UI へ委譲（MainWindow::displayErrorMessage 相当）
        emit requestDisplayError(tr("An error occurred in GameStartCoordinator::determinePlayMode. "
                                    "There is a mistake in the game options."));
        qWarning().noquote() << "[GameStartCoordinator] setPlayMode: PlayModeError"
                             << "initPos=" << initPositionNumber
                             << " p1Human=" << p1Human << " p2Human=" << p2Human
                             << " (raw human/engine: "
                             << isHuman1 << "/" << isEngine1 << ", "
                             << isHuman2 << "/" << isEngine2 << ")";
    }

    return mode;
}

QChar GameStartCoordinator::turnFromSfen_(const QString& sfen)
{
    const QString s = sfen.trimmed();
    if (s.isEmpty()) return QChar();

    // 典型: "<board> b - 1" / "<board> w - 1"
    const QStringList toks = s.split(QLatin1Char(' '), Qt::SkipEmptyParts);
    if (toks.size() >= 2) {
        const QString t = toks.at(1).toLower();
        if (t == QLatin1String("b")) return QLatin1Char('b');
        if (t == QLatin1String("w")) return QLatin1Char('w');
    }
    // "startpos b 1" 形式の保険
    if (s.contains(QLatin1String(" b "))) return QLatin1Char('b');
    if (s.contains(QLatin1String(" w "))) return QLatin1Char('w');
    return QChar();
}

PlayMode GameStartCoordinator::determinePlayModeAlignedWithTurn(
    int initPositionNumber, bool isPlayer1Human, bool isPlayer2Human, const QString& startSfen)
{
    const QChar turn = turnFromSfen_(startSfen); // 'b' / 'w' / null
    const bool isEven = (initPositionNumber == 1);
    const bool hvh = (isPlayer1Human && isPlayer2Human);
    const bool eve = (!isPlayer1Human && !isPlayer2Human);
    const bool oneVsEngine = !hvh && !eve;

    // 「turn はどちらの座席が指すか」を表すだけなので、
    // 実際にその座席(P1 or P2)が Human か Engine かで HvE/EvH を決定する。
    if (isEven) {
        if (hvh) return HumanVsHuman;
        if (eve) return EvenEngineVsEngine;
        if (oneVsEngine) {
            if (turn == QLatin1Char('b')) {
                // 先手＝P1 の座席
                return isPlayer1Human ? EvenHumanVsEngine : EvenEngineVsHuman;
            }
            if (turn == QLatin1Char('w')) {
                // 後手＝P2 の座席
                return isPlayer2Human ? EvenHumanVsEngine : EvenEngineVsHuman;
            }
            // turn が取れない場合は座席だけで決める
            return (isPlayer1Human && !isPlayer2Human) ? EvenHumanVsEngine : EvenEngineVsHuman;
        }
        return NotStarted;
    } else {
        if (hvh) return HumanVsHuman;
        if (eve) return HandicapEngineVsEngine;
        if (oneVsEngine) {
            if (turn == QLatin1Char('b')) {
                return isPlayer1Human ? HandicapHumanVsEngine : HandicapEngineVsHuman;
            }
            if (turn == QLatin1Char('w')) {
                return isPlayer2Human ? HandicapHumanVsEngine : HandicapEngineVsHuman;
            }
            return (isPlayer1Human && !isPlayer2Human) ? HandicapHumanVsEngine : HandicapEngineVsHuman;
        }
        return NotStarted;
    }
}

void GameStartCoordinator::initializeGame(const Ctx& c)
{
    // --- 1) ダイアログ生成＆受付 ---
    StartGameDialog* dlg = new StartGameDialog;
    if (!dlg) return;

    if (dlg->exec() != QDialog::Accepted) {
        delete dlg;
        return;
    }

    // --- 2) ダイアログから必要情報を先に取得（この後の準備で使う） ---
    const int  initPosNo = dlg->startingPositionNumber(); // 平手=1, 現局面=0 など
    const bool p1Human   = dlg->isHuman1();
    const bool p2Human   = dlg->isHuman2();

    // --- 3) 開始SFENの決定（既存ロジック踏襲） ---
    const int startingPosNumber = initPosNo;

    QString startSfen;
    if (c.startSfenStr && !c.startSfenStr->isEmpty()) {
        startSfen = *(c.startSfenStr);
    }
    if (startingPosNumber == 0) {
        // 現在局面から開始
        Ctx c2 = c;
        c2.startDlg = dlg;
        prepareDataCurrentPosition(c2);

        if (c.currentSfenStr && !c.currentSfenStr->isEmpty()) {
            startSfen = *(c.currentSfenStr);
        } else if (startSfen.isEmpty()) {
            startSfen = QStringLiteral("startpos");
        }
    } else if (startSfen.isEmpty()) {
        // 平手/駒落ちプリセット
        static const QVector<QString> presets = {
            QString(), // 0: 未使用（現在局面）
            QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1"), // 1: 平手
            QStringLiteral("lnsgkgsn1/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"), // 2: 香落ち
            QStringLiteral("1nsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"), // 3: 右香落ち
            QStringLiteral("lnsgkgsnl/1r7/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),   // 4: 角落ち
            QStringLiteral("lnsgkgsnl/7b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),   // 5: 飛車落ち
            QStringLiteral("lnsgkgsn1/7b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),   // 6: 飛香落ち
            QStringLiteral("lnsgkgsnl/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),     // 7: 二枚落ち
            QStringLiteral("lnsgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),     // 8: 三枚落ち
            QStringLiteral("1nsgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),     // 9: 四枚落ち
            QStringLiteral("2sgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),      // 10: 五枚落ち
            QStringLiteral("1nsgkgs2/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),      // 11: 左五枚落ち
            QStringLiteral("2sgkgs2/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),       // 12: 六枚落ち
            QStringLiteral("3gkg3/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"),         // 13: 八枚落ち
            QStringLiteral("4k4/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1")            // 14: 十枚落ち
        };
        int idx = startingPosNumber;
        if (idx < 1) idx = 1;
        if (idx >= presets.size()) idx = presets.size() - 1;
        startSfen = presets.at(idx);

        // 駒落ち開始の内部状態整備（既存メソッド）
        Ctx c2 = c; c2.startDlg = dlg;
        prepareInitialPosition(c2);
    }

    // --- 3.5) ★開始SFENを正規化して共有リストに seed ---
    auto canonicalizeStart = [](const QString& sfen)->QString {
        const QString t = sfen.trimmed();
        if (t.isEmpty() || t == QLatin1String("startpos")) {
            // 平手のフルSFENに正規化
            return QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1");
        }
        return t;
    };
    const QString seedSfen = canonicalizeStart(startSfen);

    if (c.sfenRecord) {
        // ★ 修正点：現在局面から開始（startingPosNumber==0）の場合は
        // 0..selectedPly を保全し、末尾（選択行）だけ seedSfen に置換してから入れ直す。
        if (startingPosNumber == 0 && !c.sfenRecord->isEmpty() && c.selectedPly >= 0) {
            const int keepIdx = qBound(0, c.selectedPly, c.sfenRecord->size() - 1);
            const int takeLen = keepIdx + 1;

            QStringList preserved;
            preserved.reserve(takeLen);
            // 0..keepIdx を手動コピー（detach回避のため明示ループは使わず、push_back等も避ける）
            for (int i = 0; i < takeLen; ++i) {
                preserved.append(c.sfenRecord->at(i));
            }
            if (!preserved.isEmpty()) {
                preserved[preserved.size() - 1] = seedSfen; // 末尾だけ正規化した現在局面で置換
            }

            c.sfenRecord->clear();
            c.sfenRecord->append(preserved);

            qInfo().noquote()
                << "[GSC][seed-resume] kept(0.." << keepIdx << ") size=" << c.sfenRecord->size()
                << " head=" << (c.sfenRecord->isEmpty() ? QString("<empty>") : c.sfenRecord->first());
        } else {
            // 新規開始や保全対象なし：従来どおり seed のみ
            c.sfenRecord->clear();
            c.sfenRecord->append(seedSfen);

            qInfo().noquote()
                << "[GSC][seed] sfenRecord*=" << static_cast<const void*>(c.sfenRecord)
                << " size=" << c.sfenRecord->size()
                << " head=" << (c.sfenRecord->isEmpty() ? QString("<empty>") : c.sfenRecord->first());
        }
    } else {
        qWarning() << "[GSC][seed] sfenRecord is null (cannot seed)";
    }

    // --- 4) PlayMode を SFEN手番と整合させて最終決定 ---
    PlayMode mode = determinePlayModeAlignedWithTurn(initPosNo, p1Human, p2Human, seedSfen);
    qInfo() << "[GameStart] Final PlayMode =" << mode << "  startSfen=" << seedSfen;

    // --- 5) StartOptions 構築（司令塔依存） ---
    if (!m_match) {
        delete dlg;
        return;
    }
    MatchCoordinator::StartOptions opt =
        m_match->buildStartOptions(mode, seedSfen, c.sfenRecord, dlg);

    // 人を手前に（必要時のみ反転）
    m_match->ensureHumanAtBottomIfApplicable(dlg, c.bottomIsP1);

    // --- 6) TimeControl を ms で構築（ダイアログ値 → ミリ秒） ---
    auto hms_to_ms = [](int h, int m)->qint64 {
        const qint64 hh = qMax(0, h);
        const qint64 mm = qMax(0, m);
        return (hh*3600 + mm*60) * 1000;
    };
    auto sec_to_ms = [](int s)->qint64 {
        return qMax(0, s) * 1000ll;
    };

    const int h1   = dlg->basicTimeHour1();
    const int m1   = dlg->basicTimeMinutes1();
    const int h2   = dlg->basicTimeHour2();
    const int m2   = dlg->basicTimeMinutes2();
    const int byo1 = dlg->byoyomiSec1();
    const int byo2 = dlg->byoyomiSec2();
    const int inc1 = dlg->addEachMoveSec1();
    const int inc2 = dlg->addEachMoveSec2();

    TimeControl tc;
    tc.p1.baseMs      = hms_to_ms(h1, m1);
    tc.p2.baseMs      = hms_to_ms(h2, m2);
    tc.p1.byoyomiMs   = sec_to_ms(byo1);
    tc.p2.byoyomiMs   = sec_to_ms(byo2);
    tc.p1.incrementMs = sec_to_ms(inc1);
    tc.p2.incrementMs = sec_to_ms(inc2);

    // byoyomi 優先（併用指定なら inc は 0 扱い）
    const bool useByoyomi = (tc.p1.byoyomiMs > 0) || (tc.p2.byoyomiMs > 0);
    if (useByoyomi) {
        tc.p1.incrementMs = 0;
        tc.p2.incrementMs = 0;
    }

    // どれか値が入っていれば enabled = true
    const bool hasAny =
        (tc.p1.baseMs > 0) || (tc.p2.baseMs > 0) ||
        (tc.p1.byoyomiMs > 0) || (tc.p2.byoyomiMs > 0) ||
        (tc.p1.incrementMs > 0) || (tc.p2.incrementMs > 0);
    tc.enabled = hasAny;

    qDebug().noquote()
        << "[GSC] initializeGame tc:"
        << " enabled=" << tc.enabled
        << " P1{base=" << tc.p1.baseMs << " byo=" << tc.p1.byoyomiMs << " inc=" << tc.p1.incrementMs << "}"
        << " P2{base=" << tc.p2.baseMs << " byo=" << tc.p2.byoyomiMs << " inc=" << tc.p2.incrementMs << "}";

    // --- 7) 時計の準備と配線・起動は prepare(...) に委譲 ---
    Request req;
    req.startDialog = dlg;
    req.startSfen   = seedSfen;                         // ★ 手番確定に使用（正規化済み）
    req.clock       = c.clock ? c.clock : m_match->clock();

    prepare(req); // requestPreStartCleanup / 時間適用シグナル / setClock→startClock など

    // --- 8) 対局開始（時計設定 + 初手 go 設定） ---
    StartParams params;
    params.opt  = opt;
    params.tc   = tc;                 // 司令塔側の go 計算にも使用
    params.autoStartEngineMove = true;

    start(params);

    // --- 9) 保険：時計起動/初手go の取りこぼし防止 ---
    if (m_match) {
        if (c.clock && m_match->clock() != c.clock) {
            m_match->setClock(c.clock);
        }
        m_match->startMatchTimingAndMaybeInitialGo();
    }

    delete dlg;
}

// ★追加：司令塔（MatchCoordinator）の生成と初期配線を一括で実施
MatchCoordinator* GameStartCoordinator::createAndWireMatch(const MatchCoordinator::Deps& deps,
                                                           QObject* parentForMatch)
{
    // 既存があれば破棄（親を MainWindow にぶら下げ直すため）
    if (m_match) {
        m_match->disconnect(this);
        if (m_match->parent() == parentForMatch) {
            delete m_match;
        } else {
            m_match->setParent(nullptr);
            delete m_match;
        }
        m_match = nullptr;
    }

    // 生成
    m_match = new MatchCoordinator(deps, parentForMatch);

    // --- 司令塔→Coordinator へ受け、Coordinator から re-emit ---
    // timeUpdated(p1ms, p2ms, p1turn, urgencyMs)
    QObject::connect(
        m_match,
        static_cast<void (MatchCoordinator::*)(qint64,qint64,bool,qint64)>(&MatchCoordinator::timeUpdated),
        this,
        static_cast<void (GameStartCoordinator::*)(qint64,qint64,bool,qint64)>(&GameStartCoordinator::timeUpdated),
        Qt::UniqueConnection
        );

    // requestAppendGameOverMove(const GameEndInfo&)
    QObject::connect(
        m_match, &MatchCoordinator::requestAppendGameOverMove,
        this,    &GameStartCoordinator::requestAppendGameOverMove,
        Qt::UniqueConnection
        );

    // boardFlipped(bool)
    QObject::connect(
        m_match, &MatchCoordinator::boardFlipped,
        this,    &GameStartCoordinator::boardFlipped,
        Qt::UniqueConnection
        );

    // gameOverStateChanged(const GameOverState&)
    QObject::connect(
        m_match, &MatchCoordinator::gameOverStateChanged,
        this,    &GameStartCoordinator::gameOverStateChanged,
        Qt::UniqueConnection
        );

    // gameEnded(const GameEndInfo&)
    QObject::connect(
        m_match,
        static_cast<void (MatchCoordinator::*)(const MatchCoordinator::GameEndInfo&)>(&MatchCoordinator::gameEnded),
        this,
        static_cast<void (GameStartCoordinator::*)(const MatchCoordinator::GameEndInfo&)>(&GameStartCoordinator::matchGameEnded),
        Qt::UniqueConnection
        );

    // USI ポインタの初期注入（nullptr 可）
    m_match->updateUsiPtrs(deps.usi1, deps.usi2);

    // デバッグ：シグナル存在確認（既存ログと同等）
    qDebug() << "[DBG] signal index:"
             << m_match->metaObject()->indexOfSignal("timeUpdated(long long,long long,bool,long long)");

    return m_match;
}

void GameStartCoordinator::applyResumePositionIfAny(ShogiGameController* gc,
                                                    ShogiView* view,
                                                    const QString& resumeSfen)
{
    if (!gc || resumeSfen.isEmpty()) return;

    if (auto* b = gc->board()) {
        b->setSfen(resumeSfen);
        if (view) view->applyBoardAndRender(b);
    }
}

void GameStartCoordinator::applyPlayersNamesForMode(ShogiView* view,
                                                    PlayMode mode,
                                                    const QString& human1,
                                                    const QString& human2,
                                                    const QString& engine1,
                                                    const QString& engine2) const
{
    if (!view) return;
    const PlayerNameMapping names =
        PlayerNameService::computePlayers(mode, human1, human2, engine1, engine2);
    view->setBlackPlayerName(names.p1);
    view->setWhitePlayerName(names.p2);
}

// src/app/gamestartcoordinator.cpp

// ダイアログから TimeControl を組み立てるユーティリティ。
// ※ StartGameDialog が無い場合でも QObject::property でフォールバックします。
GameStartCoordinator::TimeControl
GameStartCoordinator::buildTimeControlFromDialog_(QDialog* startDlg) const
{
    TimeControl tc; // すべて 0 で初期化される前提の構造体

    int h1=0, m1=0, h2=0, m2=0;
    int byo1=0, byo2=0;
    int inc1=0, inc2=0;

    auto propInt = [&](const char* name)->int {
        if (!startDlg) return 0;
        bool ok=false; const int v = startDlg->property(name).toInt(&ok);
        return ok ? v : 0;
    };

    // StartGameDialog の型が使えるなら直接 getter を呼ぶ
    if (auto dlg = qobject_cast<StartGameDialog*>(startDlg)) {
        h1   = dlg->basicTimeHour1();
        m1   = dlg->basicTimeMinutes1();
        h2   = dlg->basicTimeHour2();
        m2   = dlg->basicTimeMinutes2();
        byo1 = dlg->byoyomiSec1();
        byo2 = dlg->byoyomiSec2();
        inc1 = dlg->addEachMoveSec1();
        inc2 = dlg->addEachMoveSec2();
    } else {
        // フォールバック：プロパティ名で取得
        h1   = propInt("basicTimeHour1");
        m1   = propInt("basicTimeMinutes1");
        h2   = propInt("basicTimeHour2");
        m2   = propInt("basicTimeMinutes2");
        byo1 = propInt("byoyomiSec1");
        byo2 = propInt("byoyomiSec2");
        inc1 = propInt("addEachMoveSec1");
        inc2 = propInt("addEachMoveSec2");
    }

    // (時間, 分) → ms
    const qint64 base1Ms = qMax<qint64>(0, (static_cast<qint64>(h1)*3600 + m1*60) * 1000);
    const qint64 base2Ms = qMax<qint64>(0, (static_cast<qint64>(h2)*3600 + m2*60) * 1000);

    const qint64 byo1Ms  = qMax<qint64>(0, static_cast<qint64>(byo1) * 1000);
    const qint64 byo2Ms  = qMax<qint64>(0, static_cast<qint64>(byo2) * 1000);

    const qint64 inc1Ms  = qMax<qint64>(0, static_cast<qint64>(inc1) * 1000);
    const qint64 inc2Ms  = qMax<qint64>(0, static_cast<qint64>(inc2) * 1000);

    // byoyomi と increment は排他運用（byoyomi 優先）。両方入っていたら inc は無視。
    const bool useByoyomi = (byo1Ms > 0) || (byo2Ms > 0);

    tc.p1.baseMs      = base1Ms;
    tc.p2.baseMs      = base2Ms;
    tc.p1.byoyomiMs   = useByoyomi ? byo1Ms : 0;
    tc.p2.byoyomiMs   = useByoyomi ? byo2Ms : 0;
    tc.p1.incrementMs = useByoyomi ? 0      : inc1Ms;
    tc.p2.incrementMs = useByoyomi ? 0      : inc2Ms;

    // どれか一つでも値が入っていれば enabled = true
    tc.enabled = (tc.p1.baseMs > 0) || (tc.p2.baseMs > 0) ||
                 (tc.p1.byoyomiMs > 0) || (tc.p2.byoyomiMs > 0) ||
                 (tc.p1.incrementMs > 0) || (tc.p2.incrementMs > 0);

    qDebug().noquote()
        << "[GSC] buildTimeControlFromDialog_:"
        << " enabled=" << tc.enabled
        << " P1{base=" << tc.p1.baseMs << " byo=" << tc.p1.byoyomiMs << " inc=" << tc.p1.incrementMs << "}"
        << " P2{base=" << tc.p2.baseMs << " byo=" << tc.p2.byoyomiMs << " inc=" << tc.p2.incrementMs << "}";

    return tc;
}
#include "kifuloadcoordinator.h"
#include "kiftosfenconverter.h"
#include "sfenpositiontracer.h"
#include "recordpane.h"              // これまで通り（前方宣言側）
#include "kifurecordlistmodel.h"     // ← 実体定義（必須）
#include "kifubranchlistmodel.h"     // ← 実体定義（必須）
#include "branchdisplayplan.h"
#include "navigationpresenter.h"
#include "engineanalysistab.h"

#include <QDebug>
#include <QStyledItemDelegate>
#include <QAbstractItemView>         // view->model() を使うなら
#include <QFile>
#include <QTextStream>
#include <QDebug>
#include <QTableWidget>
#include <QPainter>
#include <QFileInfo>

// デバッグのオン/オフ（必要に応じて false に）
static bool kGM_VERBOSE = true;

static inline QString pickLabelForDisp(const KifDisplayItem& d)
{
    return d.prettyMove;
}

inline int rankLetterToNum(QChar r) { // 'a'..'i' -> 1..9
    ushort u = r.toLower().unicode();
    return (u < 'a' || u > 'i') ? -1 : int(u - 'a') + 1;
}

inline QChar dropLetterWithSide(QChar upper, bool black) {
    return black ? upper.toUpper() : upper.toLower();
}

// 成駒トークン("+P"等) -> 1文字表現。非成駒はトークンそのまま1文字。
inline QChar tokenToOneChar(const QString& tok) {
    if (tok.isEmpty()) return QLatin1Char(' ');
    if (tok.size() == 1) return tok.at(0);
    static const QHash<QString,QChar> map = {
                                              {"+P",'Q'},{"+L",'M'},{"+N",'O'},{"+S",'T'},{"+B",'C'},{"+R",'U'},
                                              {"+p",'q'},{"+l",'m'},{"+n",'o'},{"+s",'t'},{"+b",'c'},{"+r",'u'},
                                              };
    const auto it = map.find(tok);
    return it == map.end() ? QLatin1Char(' ') : *it;
}

// ★打ちの fromSquare を駒台座標にマップ
inline QPoint dropFromSquare(QChar dropUpper, bool black) {
    const int x = black ? 9 : 10; // 先手=9, 後手=10
    int y = -1;
    switch (dropUpper.toUpper().unicode()) {
    case 'P': y = black ? 0 : 8; break;
    case 'L': y = black ? 1 : 7; break;
    case 'N': y = black ? 2 : 6; break;
    case 'S': y = black ? 3 : 5; break;
    case 'G': y = 4;            break; // 共通
    case 'B': y = black ? 5 : 3; break;
    case 'R': y = black ? 6 : 2; break;
    default:  y = -1;           break;
    }
    return QPoint(x, y);
}

static inline QString lineNameForRow(int row) {
    return (row == 0) ? QStringLiteral("Main") : QStringLiteral("Var%1").arg(row - 1);
}

// 1セルを "file-rank" 表示（USI基準とL2R基準の両方を出す）
static inline QString idxHuman(int idx) {
    const int col = idx % 9;       // 0..8   左→右
    const int row = idx / 9;       // 0..8   上→下
    const int fileL2R = col + 1;   // 1..9   左→右
    const int rankTop = row + 1;   // 1..9   上→下
    const int fileUSI = 9 - col;   // 9..1   右→左（一般的なUSIの筋）
    const int rankUSI = 9 - row;   // 9..1   下→上（一般的なUSIの段）
    return QStringLiteral("[idx=%1 L2R(%2,%3) USI(%4,%5)]")
        .arg(idx).arg(fileL2R).arg(rankTop).arg(fileUSI).arg(rankUSI);
}

// 盤面(81マス)をトークン列に展開（空は ""。駒は "P","p","+P" のように '+' 付きも保持）
static QVector<QString> sfenBoardTo81Tokens(const QString& sfen)
{
    const QString board = sfen.section(QLatin1Char(' '), 0, 0); // 盤面部分
    QVector<QString> cells; cells.reserve(81);

    for (int i = 0; i < board.size() && cells.size() < 81; ++i) {
        const QChar ch = board.at(i);
        if (ch == QLatin1Char('/')) continue;
        if (ch.isDigit()) {
            const int n = ch.digitValue();
            for (int k = 0; k < n; ++k) cells.push_back(QString()); // 空マス
            continue;
        }
        if (ch == QLatin1Char('+')) {
            if (i + 1 < board.size()) {
                cells.push_back(QStringLiteral("+") + board.at(i + 1));
                ++i;
            }
            continue;
        }
        // 通常駒1文字
        cells.push_back(QString(ch));
    }
    while (cells.size() < 81) cells.push_back(QString());

    if (kGM_VERBOSE) {
        qDebug().noquote() << "[GM] sfenBoardTo81Tokens parsed"
                           << " len=" << cells.size()
                           << " board=\"" << board << "\"";
    }
    return cells;
}

static inline bool tokenEmpty(const QString& t) { return t.isEmpty(); }
static inline bool tokenPromoted(const QString& t) { return (!t.isEmpty() && t.at(0) == QLatin1Char('+')); }
static inline QChar tokenBasePiece(const QString& t) {
    if (t.isEmpty()) return QChar();
    return t.back(); // '+P' → 'P', 'p' → 'p'
}

// SFENペアから 1手分の ShogiMove を復元（差分なし=終局などは false）
static bool deriveMoveFromSfenPair(const QString& prevSfen,
                                   const QString& nextSfen,
                                   ShogiMove* out)
{
    const QVector<QString> A = sfenBoardTo81Tokens(prevSfen);
    const QVector<QString> B = sfenBoardTo81Tokens(nextSfen);

    int fromIdx = -1, toIdx = -1;
    QString fromTok, toTokPrev, toTokNew;

    // どのセルが変わったか（詳細ログ用）
    QVector<int> diffs; diffs.reserve(4);

    for (int i = 0; i < 81; ++i) {
        const QString& a = A.at(i);
        const QString& b = B.at(i);
        if (a == b) continue;

        diffs.push_back(i);

        // 移動元：a に駒があり b が空
        if (!tokenEmpty(a) && tokenEmpty(b)) {
            fromIdx = i;
            fromTok = a;
            continue;
        }
        // 移動先：b に駒があり a と異なる
        if (!tokenEmpty(b) && a != b) {
            toIdx     = i;
            toTokNew  = b;
            toTokPrev = a; // 取りがあった場合は a に相手駒がいた
        }
    }

    if (kGM_VERBOSE) {
        qDebug().noquote() << "[GM] deriveMoveFromSfenPair  diffs=" << diffs.size();
        for (int i = 0; i < diffs.size(); ++i) {
            const int d = diffs.at(i);
            qDebug().noquote()
                << "      diff[" << i << "] idx=" << d
                << "  A=\"" << A.at(d) << "\""
                << "  B=\"" << B.at(d) << "\""
                << "  " << idxHuman(d);
        }
        qDebug().noquote() << "      picked fromIdx=" << fromIdx
                           << (fromIdx>=0 ? (" tok=\""+fromTok+"\" "+idxHuman(fromIdx)) : QString())
                           << "  toIdx=" << toIdx
                           << (toIdx>=0 ? (" tokPrev=\""+toTokPrev+"\" tokNew=\""+toTokNew+"\" "+idxHuman(toIdx)) : QString());
    }

    if (fromIdx < 0 && toIdx < 0) {
        // 盤が全く同じ → 投了など「着手なし」
        if (kGM_VERBOSE) qDebug() << "[GM] no board delta (resign/terminal/comment only)";
        return false;
    }

    // 盤座標 ← idx
    auto idxToPointL2R     = [](int idx)->QPoint { return QPoint(idx % 9, idx / 9); };
    auto idxToPointFlipped = [](int idx)->QPoint { return QPoint(8 - (idx % 9), idx / 9); };

    // 出力フィールド（※最終的に out へ入れるのは FLIP 側）
    QPoint from(-1, -1), to(-1, -1);
    QChar moving, captured;
    bool isPromotion = false;

    if (fromIdx < 0 && toIdx >= 0) {
        // 打つ手（ドロップ）
        from = QPoint(-1, -1);
        // ★ 採用は FLIP 側
        to   = idxToPointFlipped(toIdx);
        moving    = tokenBasePiece(toTokNew);              // 駒台から打った駒
        captured  = QChar();                               // 取りは無い
        isPromotion = false;                               // 打ちは成りなし
    } else if (fromIdx >= 0 && toIdx >= 0) {
        // 通常移動（★ 採用は FLIP 側）
        from     = idxToPointFlipped(fromIdx);
        to       = idxToPointFlipped(toIdx);
        moving   = tokenBasePiece(fromTok);               // 元の升の駒（非成り形）
        captured = tokenEmpty(toTokPrev) ? QChar() : tokenBasePiece(toTokPrev);
        isPromotion = tokenPromoted(toTokNew);
    } else {
        if (kGM_VERBOSE) qDebug() << "[GM] inconsistent from/to detection";
        return false;
    }

    if (kGM_VERBOSE) {
        // 参考ログ：L2R と FLIP の両方を出す（採用は FLIP）
        QPoint l2rFrom(-1,-1), l2rTo(-1,-1);
        if (fromIdx >= 0) l2rFrom = idxToPointL2R(fromIdx);
        if (toIdx   >= 0) l2rTo   = idxToPointL2R(toIdx);

        QPoint flipFrom(-1,-1), flipTo(-1,-1);
        if (fromIdx >= 0) flipFrom = idxToPointFlipped(fromIdx);
        if (toIdx   >= 0) flipTo   = idxToPointFlipped(toIdx);

        qDebug().noquote()
            << "      L2R  from=" << l2rFrom << " to=" << l2rTo;
        qDebug().noquote()
            << "      FLIP from=" << flipFrom << " to=" << flipTo << "  <-- chosen";

        qDebug().noquote()
            << "      moving=" << moving
            << " captured=" << (captured.isNull() ? QChar(' ') : captured)
            << " promoted=" << (isPromotion ? "T" : "F");
    }

    if (out) *out = ShogiMove(from, to, moving, captured, isPromotion);
    return true;
}

using BCDI = ::BranchCandidateDisplayItem;

KifuLoadCoordinator::KifuLoadCoordinator(QVector<ShogiMove>& gameMoves,
                                         QVector<ResolvedRow>& resolvedRows,
                                         QStringList& positionStrList,
                                         int& activeResolvedRow,
                                         int& activePly,
                                         int& currentSelectedPly,
                                         int& currentMoveIndex,
                                         QStringList* sfenRecord,
                                         QTableWidget* gameInfoTable,
                                         QDockWidget* gameInfoDock,
                                         EngineAnalysisTab* analysisTab,
                                         QTabWidget* tab,
                                         ShogiView* shogiView,
                                         RecordPane* recordPane,
                                         KifuRecordListModel* kifuRecordModel,
                                         KifuBranchListModel* kifuBranchModel,
                                         BranchCandidatesController* branchCtl,
                                         QTableView* kifuBranchView,
                                         QHash<int, QMap<int, ::BranchCandidateDisplay>>& branchDisplayPlan,
                                         QObject* parent)
    : QObject(parent)
    , m_gameMoves(gameMoves)                // ← 参照メンバに束縛（同一実体を共有）
    , m_resolvedRows(resolvedRows)          // ← 同上
    , m_positionStrList(positionStrList)    // ← 同上
    , m_activeResolvedRow(activeResolvedRow)
    , m_activePly(activePly)
    , m_currentSelectedPly(currentSelectedPly)
    , m_currentMoveIndex(currentMoveIndex)
    , m_sfenRecord(sfenRecord)
    , m_gameInfoTable(gameInfoTable)
    , m_gameInfoDock(gameInfoDock)
    , m_analysisTab(analysisTab)
    , m_tab(tab)
    , m_shogiView(shogiView)
    , m_recordPane(recordPane)
    , m_kifuRecordModel(kifuRecordModel)
    , m_kifuBranchModel(kifuBranchModel)
    , m_branchCtl(branchCtl)
    , m_kifuBranchView(kifuBranchView)
    , m_branchDisplayPlan(branchDisplayPlan)
{
    // 必要ならデバッグ時にチェック
    // Q_ASSERT(m_sfenRecord && "sfenRecord must not be null");
    // ここで初期同期が必要ならシグナル発火や内部初期化を追加してください。
}

void KifuLoadCoordinator::loadKifuFromFile(const QString& filePath)
{
    // --- IN ログ ---
    qDebug().noquote() << "[MAIN] loadKifuFromFile IN file=" << filePath;

    // ★ ロード中フラグ（applyResolvedRowAndSelect 等の分岐更新を抑止）
    m_loadingKifu = true;

    // 1) 初期局面（手合割）を決定
    QString teaiLabel;
    const QString initialSfen = prepareInitialSfen(filePath, teaiLabel);

    // 2) 解析（本譜＋分岐＋コメント）を一括取得
    KifParseResult res;
    QString parseWarn;
    KifToSfenConverter::parseWithVariations(filePath, res, &parseWarn);

    // 先手/後手名などヘッダ反映
    {
        const QList<KifGameInfoItem> infoItems = KifToSfenConverter::extractGameInfo(filePath);
        populateGameInfo(infoItems);
        applyPlayersFromGameInfo(infoItems);
    }

    // 本譜（表示／USI）
    const QList<KifDisplayItem>& disp = res.mainline.disp;
    m_usiMoves = res.mainline.usiMoves;

    // 終局/中断判定（見た目文字列で簡易判定）
    static const QStringList kTerminalKeywords = {
        QStringLiteral("投了"), QStringLiteral("中断"), QStringLiteral("持将棋"),
        QStringLiteral("千日手"), QStringLiteral("切れ負け"),
        QStringLiteral("反則勝ち"), QStringLiteral("反則負け"),
        QStringLiteral("入玉勝ち"), QStringLiteral("不戦勝"),
        QStringLiteral("不戦敗"), QStringLiteral("詰み"), QStringLiteral("不詰"),
    };
    auto isTerminalPretty = [&](const QString& s)->bool {
        for (const auto& kw : kTerminalKeywords) if (s.contains(kw)) return true;
        return false;
    };
    const bool hasTerminal = (!disp.isEmpty() && isTerminalPretty(disp.back().prettyMove));

    if (m_usiMoves.isEmpty() && !hasTerminal && disp.isEmpty()) {
        const QString errorMessage = tr("読み込み失敗 %1 から指し手を取得できませんでした。").arg(filePath);
        emit errorOccurred(errorMessage);
        qDebug().noquote() << "[MAIN] loadKifuFromFile OUT (no moves)";
        m_loadingKifu = false; // 早期return時も必ず解除
        return;
    }

    // 3) 本譜の SFEN 列と m_gameMoves を再構築
    rebuildSfenRecord(initialSfen, m_usiMoves, hasTerminal);
    rebuildGameMoves(initialSfen, m_usiMoves);

    // 3.5) USI position コマンド列を構築（0..N）
    //     initialSfen は prepareInitialSfen() が返す手合い込みの SFEN
    //     m_usiMoves は 1..N の USI 文字列（"7g7f" 等）
    m_positionStrList.clear();
    m_positionStrList.reserve(m_usiMoves.size() + 1);

    const QString base = QStringLiteral("position sfen %1").arg(initialSfen);
    m_positionStrList.push_back(base);  // 0手目：moves なし

    QStringList acc; // 先頭からの累積
    acc.reserve(m_usiMoves.size());
    for (int i = 0; i < m_usiMoves.size(); ++i) {
        acc.push_back(m_usiMoves.at(i));
        // i+1 手目：先頭から i+1 個の moves を連結
        m_positionStrList.push_back(base + QStringLiteral(" moves ") + acc.join(' '));
    }

    // （任意）ログで確認
    qDebug().noquote() << "[USI] position list built. count=" << m_positionStrList.size();
    if (!m_positionStrList.isEmpty()) {
        qDebug().noquote() << "[USI] pos[0]=" << m_positionStrList.first();
        if (m_positionStrList.size() > 1)
            qDebug().noquote() << "[USI] pos[1]=" << m_positionStrList.at(1);
    }

    // 4) 棋譜表示へ反映（本譜）
    emit displayGameRecord(disp);

    // 5) 本譜スナップショットを保持（以降の解決・描画に使用）
    m_dispMain = disp;          // 表示列（1..N）
    m_sfenMain = *m_sfenRecord; // 0..N の局面列
    m_gmMain   = m_gameMoves;   // 1..N のUSIムーブ

    // 6) 変化を取りまとめ（必要に応じて保持：Plan生成やツリー表示では m_resolvedRows を主に使用）
    m_variationsByPly.clear();
    m_variationsSeq.clear();
    for (const KifVariation& kv : std::as_const(res.variations)) {
        KifLine L = kv.line;
        L.startPly = kv.startPly;         // “その変化が始まる絶対手数（1-origin）”
        if (L.disp.isEmpty()) continue;
        m_variationsByPly[L.startPly].push_back(L);
        m_variationsSeq.push_back(L);     // 入力順（KIF出現順）を保持
    }

    // 7) 棋譜テーブルの初期選択（開始局面を選択）
    if (m_recordPane && m_recordPane->kifuView()) {
        QTableView* view = m_recordPane->kifuView();
        if (view->model() && view->model()->rowCount() > 0) {
            const QModelIndex idx0 = view->model()->index(0, 0);
            if (view->selectionModel()) {
                view->selectionModel()->setCurrentIndex(
                    idx0, QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);
            }
            view->scrollTo(idx0, QAbstractItemView::PositionAtTop);
        }
    }

    // 8) 解決行を1本（本譜のみ）作成 → 0手適用
    m_resolvedRows.clear();

    ResolvedRow r;
    r.startPly = 1;
    r.parent   = -1;           // ★本譜
    r.disp     = disp;          // 1..N
    r.sfen     = *m_sfenRecord; // 0..N
    r.gm       = m_gameMoves;   // 1..N
    r.varIndex = -1;            // 本譜

    m_resolvedRows.push_back(r);
    m_activeResolvedRow = 0;
    m_activePly         = 0;

    // apply 内では m_loadingKifu を見て分岐候補の更新を抑止
    applyResolvedRowAndSelect(/*row=*/0, /*selPly=*/0);

    // 9) UIの整合
    emit enableArrowButtons();
    logImportSummary(filePath, m_usiMoves, disp, teaiLabel, parseWarn, QString());

    // 10) 解決済み行を構築（親探索規則で親子関係を決定）
    buildResolvedLinesAfterLoad();

    // 11) 分岐レポート → Plan 構築（Plan方式の基礎データ）
    dumpBranchSplitReport();
    buildBranchCandidateDisplayPlan();
    dumpBranchCandidateDisplayPlan();

    // ★ 追加：読み込み直後に “+付与 & 行着色” をまとめて反映（Main 行が表示中）
    applyBranchMarksForCurrentLine_();

    // 12) 分岐ツリーへ供給（黄色ハイライトは applyResolvedRowAndSelect 内で同期）
    if (m_analysisTab) {
        QVector<EngineAnalysisTab::ResolvedRowLite> rows;
        rows.reserve(m_resolvedRows.size());

        // ★ detach 回避：QList を const 化して range-for
        for (const auto& r : std::as_const(m_resolvedRows)) {
            EngineAnalysisTab::ResolvedRowLite x;
            x.startPly = r.startPly;
            x.disp     = r.disp;
            x.sfen     = r.sfen;
            rows.push_back(std::move(x));
        }

        m_analysisTab->setBranchTreeRows(rows);
        m_analysisTab->highlightBranchTreeAt(/*row=*/0, /*ply=*/0, /*centerOn=*/true);
    }

    // 13) VariationEngine への投入（他機能で必要な可能性があるため保持）
    if (!m_varEngine) m_varEngine = std::make_unique<KifuVariationEngine>();
    {
        QVector<UsiMove> usiMain;
        usiMain.reserve(m_usiMoves.size());
        for (const auto& u : std::as_const(m_usiMoves)) usiMain.push_back(UsiMove(u));
        m_varEngine->ingest(res, m_sfenMain, usiMain, m_dispMain);
    }

    // ←ここで SFEN を各行に流し込む
    ensureResolvedRowsHaveFullSfen();
    // ←そして表を出す
    dumpAllRowsSfenTable();

    ensureResolvedRowsHaveFullGameMoves();

    dumpAllLinesGameMoves();

    // 14) （Plan方式化に伴い）WL 構築や従来の候補再計算は廃止
    // 15) ブランチ候補ワイヤリング（planActivated -> applyResolvedRowAndSelect）
    if (!m_branchCtl) {
        emit setupBranchCandidatesWiring_(); // 内部で planActivated の connect を済ませる
    }

    if (m_kifuBranchModel) {
        // 起動直後は候補を出さない（0手目）：モデルクリア＆ビュー非表示
        m_kifuBranchModel->clearBranchCandidates();
        m_kifuBranchModel->setHasBackToMainRow(false);
        if (QTableView* view = m_recordPane ? m_recordPane->branchView() : m_kifuBranchView) {
            view->setVisible(true);
            view->setEnabled(false);
        }
    }

    // ★ ロード完了 → 抑止解除
    m_loadingKifu = false;

    // 16) ツリーは読み込み後ロック（ユーザ操作で枝を生やさない）
    m_branchTreeLocked = true;
    qDebug() << "[BRANCH] tree locked after load";

    qDebug().noquote() << "[MAIN] loadKifuFromFile OUT";
}

QString KifuLoadCoordinator::prepareInitialSfen(const QString& filePath, QString& teaiLabel) const
{
    const QString sfen = KifToSfenConverter::detectInitialSfenFromFile(filePath, &teaiLabel);
    return sfen.isEmpty()
               ? QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1")
               : sfen;
}

void KifuLoadCoordinator::populateGameInfo(const QList<KifGameInfoItem>& items)
{
    m_gameInfoTable->clearContents();
    m_gameInfoTable->setRowCount(items.size());

    for (int row = 0; row < items.size(); ++row) {
        const auto& it = items.at(row);
        auto *keyItem   = new QTableWidgetItem(it.key);
        auto *valueItem = new QTableWidgetItem(it.value);
        keyItem->setFlags(keyItem->flags() & ~Qt::ItemIsEditable);
        valueItem->setFlags(valueItem->flags() & ~Qt::ItemIsEditable);
        m_gameInfoTable->setItem(row, 0, keyItem);
        m_gameInfoTable->setItem(row, 1, valueItem);
    }

    m_gameInfoTable->resizeColumnToContents(0);

    // まだタブに載ってなければ、このタイミングで追加しておくと確実
    addGameInfoTabIfMissing();
}

void KifuLoadCoordinator::addGameInfoTabIfMissing()
{
    if (!m_tab) return;

    // Dock で表示していたら解除
    if (m_gameInfoDock && m_gameInfoDock->widget() == m_gameInfoTable) {
        m_gameInfoDock->setWidget(nullptr);
        m_gameInfoDock->deleteLater();
        m_gameInfoDock = nullptr;
    }

    // まだタブに無ければ追加
    if (m_tab->indexOf(m_gameInfoTable) == -1) {
        int anchorIdx = -1;

        // 1) EngineAnalysisTab（検討タブ）の直後に入れる
        if (m_analysisTab)
            anchorIdx = m_tab->indexOf(m_analysisTab);

        // 2) 念のため、タブタイトルで「コメント/Comments」を探してその直後に入れるフォールバック
        if (anchorIdx < 0) {
            for (int i = 0; i < m_tab->count(); ++i) {
                const QString t = m_tab->tabText(i);
                if (t.contains(tr("コメント")) || t.contains("Comments", Qt::CaseInsensitive)) {
                    anchorIdx = i;
                    break;
                }
            }
        }

        const int insertPos = (anchorIdx >= 0) ? anchorIdx + 1 : m_tab->count();
        m_tab->insertTab(insertPos, m_gameInfoTable, tr("対局情報"));
    }
}

QString KifuLoadCoordinator::findGameInfoValue(const QList<KifGameInfoItem>& items,
                                      const QStringList& keys) const
{
    for (const auto& it : items) {
        // KifGameInfoItem.key は「先手」「後手」等（末尾コロンは normalize 済み）
        if (keys.contains(it.key)) {
            const QString v = it.value.trimmed();
            if (!v.isEmpty()) return v;
        }
    }
    return QString();
}

void KifuLoadCoordinator::applyPlayersFromGameInfo(const QList<KifGameInfoItem>& items)
{
    // 優先度：
    // 1) 先手／後手
    // 2) 下手／上手（→ 下手=Black, 上手=White）
    // 3) 先手省略名／後手省略名
    QString black = findGameInfoValue(items, { QStringLiteral("先手") });
    QString white = findGameInfoValue(items, { QStringLiteral("後手") });

    // 下手/上手にも対応（必要な側だけ補完）
    const QString shitate = findGameInfoValue(items, { QStringLiteral("下手") });
    const QString uwate   = findGameInfoValue(items, { QStringLiteral("上手") });

    if (black.isEmpty() && !shitate.isEmpty())
        black = shitate;                   // 下手 → Black
    if (white.isEmpty() && !uwate.isEmpty())
        white = uwate;                     // 上手 → White

    // 省略名でのフォールバック
    if (black.isEmpty())
        black = findGameInfoValue(items, { QStringLiteral("先手省略名") });
    if (white.isEmpty())
        white = findGameInfoValue(items, { QStringLiteral("後手省略名") });

    // 取得できた方だけ反映（既存表示を尊重）
    if (!black.isEmpty() && m_shogiView)
        m_shogiView->setBlackPlayerName(black);
    if (!white.isEmpty() && m_shogiView)
        m_shogiView->setWhitePlayerName(white);
}

void KifuLoadCoordinator::rebuildSfenRecord(const QString& initialSfen,
                                            const QStringList& usiMoves,
                                            bool hasTerminal)
{
    const QStringList list = SfenPositionTracer::buildSfenRecord(initialSfen, usiMoves, hasTerminal);
    if (!m_sfenRecord) m_sfenRecord = new QStringList;
    *m_sfenRecord = list; // COW
}

void KifuLoadCoordinator::rebuildGameMoves(const QString& initialSfen,
                                           const QStringList& usiMoves)
{
    m_gameMoves = SfenPositionTracer::buildGameMoves(initialSfen, usiMoves);
}

// 現在表示用の棋譜列（disp）を使ってモデルを再構成し、selectPly 行を選択・同期する
void KifuLoadCoordinator::showRecordAtPly(const QList<KifDisplayItem>& disp, int selectPly)
{
    // いま表示中の棋譜列を保持（分岐⇄本譜の復帰で再利用）
    m_dispCurrent = disp;

    // （既存）モデルへ反映：ここで displayGameRecord(disp) が呼ばれ、
    // その過程で m_currentMoveIndex が 0 に戻る実装になっている
    displayGameRecord(disp);

    // ★ 追加：現在表示中の行に対する「分岐あり手」マーキングをモデルへ反映
    applyBranchMarksForCurrentLine_();

    // ★ RecordPane 内のビューを使う
    QTableView* view = (m_recordPane ? m_recordPane->kifuView() : nullptr);
    if (!view || !view->model()) return;

    // 行数（0 は「=== 開始局面 ===」、1..N が各手）
    const int rc  = view->model()->rowCount();
    const int row = qBound(0, selectPly, rc > 0 ? rc - 1 : 0);

    // 0列目インデックス（選択は行単位）
    const QModelIndex idx = view->model()->index(row, 0);
    if (auto* sel = view->selectionModel()) {
        sel->setCurrentIndex(idx, QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);
    } else {
        view->setCurrentIndex(idx);
    }
    view->scrollTo(idx, QAbstractItemView::PositionAtCenter);

    // displayGameRecord() が 0 に戻した “現在の手数” を、選択行へ復元
    m_currentSelectedPly = row;
    m_currentMoveIndex   = row;

    // 盤面・ハイライトも現在手に同期
    emit syncBoardAndHighlightsAtRow(row);
}

void KifuLoadCoordinator::showBranchCandidatesFromPlan(int row, int ply1)
{
    // モデル/ビュー参照
    QTableView* view = m_recordPane ? m_recordPane->branchView() : m_kifuBranchView;

    // 行・手の安全化（不正時はクリア＆ボタン非表示）
    if (ply1 <= 0 || row < 0 || row >= m_resolvedRows.size()) {
        if (m_kifuBranchModel) {
            m_kifuBranchModel->clearBranchCandidates();
            m_kifuBranchModel->setHasBackToMainRow(false);
        }
        if (view) { view->setVisible(true); view->setEnabled(false); }

        // 「本譜に戻る」ボタンは隠す
        if (m_recordPane) {
            if (auto* btn = m_recordPane->backToMainButton()) btn->setVisible(false);
        }

        // 文脈保存
        m_branchPlyContext  = qMax(0, ply1);
        m_activeResolvedRow = qBound(0, row, m_resolvedRows.size() - 1);
        return;
    }

    // 行→(手→計画) テーブルから該当プランを取得
    const auto rowIt = m_branchDisplayPlan.constFind(row);
    if (rowIt == m_branchDisplayPlan.constEnd()) {
        if (m_kifuBranchModel) {
            m_kifuBranchModel->clearBranchCandidates();
            m_kifuBranchModel->setHasBackToMainRow(false);
        }
        if (view) { view->setVisible(true); view->setEnabled(false); }

        // ボタン非表示
        if (m_recordPane) {
            if (auto* btn = m_recordPane->backToMainButton()) btn->setVisible(false);
        }

        m_branchPlyContext  = ply1;
        m_activeResolvedRow = row;
        return;
    }

    const auto& byPly = rowIt.value();
    const auto itP    = byPly.constFind(ply1);
    if (itP == byPly.constEnd()) {
        if (m_kifuBranchModel) {
            m_kifuBranchModel->clearBranchCandidates();
            m_kifuBranchModel->setHasBackToMainRow(false);
        }
        if (view) { view->setVisible(true); view->setEnabled(false); }

        // ボタン非表示
        if (m_recordPane) {
            if (auto* btn = m_recordPane->backToMainButton()) btn->setVisible(false);
        }

        m_branchPlyContext  = ply1;
        m_activeResolvedRow = row;
        return;
    }

    const BranchCandidateDisplay& plan = itP.value();

    // （必要なら）現在指し手のラベルを取得しておく（候補リスト選択合わせ用）
    QString currentLbl;
    {
        const int li = ply1 - 1;
        const auto& disp = m_resolvedRows[row].disp;
        if (li >= 0 && li < disp.size()) {
            currentLbl = pickLabelForDisp(disp.at(li));
        }
    }

    // --- BranchCandidatesController 経由で候補を更新（クリック→局面反映の経路を保持） ---
    if (m_branchCtl) {
        QVector<BranchCandidateDisplayItem> pubItems;
        pubItems.reserve(plan.items.size());
        for (const auto& it : plan.items) {
            BranchCandidateDisplayItem x;
            x.row      = it.row;
            x.varN     = it.varN;
            x.lineName = it.lineName;
            x.label    = it.label;
            pubItems.push_back(x);
        }
        m_branchCtl->refreshCandidatesFromPlan(ply1, pubItems, plan.baseLabel);
    } else if (m_kifuBranchModel) {
        // フォールバック：Controller 未注入でも最低限の表示だけは行う（クリック遷移は不可）
        QList<KifDisplayItem> rows;
        rows.reserve(plan.items.size());
        for (const auto& it : plan.items) {
            rows.push_back(KifDisplayItem(it.label, QString(), QString(), ply1));
        }
        m_kifuBranchModel->setHasBackToMainRow(false);
        m_kifuBranchModel->setBranchCandidatesFromKif(rows);
    }

    // --- ビューの可視/有効状態だけ先に反映（既定選択はここでは行わない） ---
    if (view && m_kifuBranchModel) {
        const int rows = m_kifuBranchModel->rowCount();
        view->setVisible(true);
        view->setEnabled(rows > 0);
    }

    // --- ここがポイント：描画後に「現在の手」と一致する候補行を探して選択し直す ---
    if (view && m_kifuBranchModel && view->model() && view->selectionModel()) {
        // 先頭の手数（"3 " 等）を剥がして比較する
        // （ラムダ禁止のため簡易に都度 remove で対応）
        QString wantKey = currentLbl;
        {
            // ^\s*\d+\s* を削除
            QRegularExpression re(QStringLiteral(R"(^\s*\d+\s*)"));
            wantKey.remove(re);
        }

        int foundRow = -1;
        const int rcount = m_kifuBranchModel->rowCount();
        int r = 0;
        while (r < rcount) {
            const QModelIndex idx = m_kifuBranchModel->index(r, 0);
            QString cell = m_kifuBranchModel->data(idx, Qt::DisplayRole).toString();
            // こちらも先頭の手数を剥がして比較
            {
                QRegularExpression re(QStringLiteral(R"(^\s*\d+\s*)"));
                cell.remove(re);
            }
            if (cell == wantKey && !wantKey.isEmpty()) {
                foundRow = r;
                break;
            }
            ++r;
        }

        QItemSelectionModel* sel = view->selectionModel();
        if (foundRow >= 0) {
            const QModelIndex pick = m_kifuBranchModel->index(foundRow, 0);
            sel->setCurrentIndex(pick, QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);
            view->scrollTo(pick, QAbstractItemView::PositionAtCenter);
        } else {
            // 見つからない場合は勝手に先頭を選ばず、選択をクリアしておく
            sel->clearSelection();
        }
    }

    // --- 「本譜に戻る」ボタンの表示制御とスロット接続（ラムダ無し） ---
    if (m_recordPane) {
        if (auto* btn = m_recordPane->backToMainButton()) {
            const bool hasRows = (m_kifuBranchModel && m_kifuBranchModel->rowCount() > 0);
            btn->setVisible(hasRows);
            if (hasRows) {
                QObject::connect(btn, &QPushButton::clicked,
                                 this, &KifuLoadCoordinator::onBackToMainButtonClicked_,
                                 Qt::UniqueConnection);
            }
        }
    }

    // UI 状態
    m_branchPlyContext  = ply1;
    m_activeResolvedRow = row;
}

void KifuLoadCoordinator::onBackToMainButtonClicked_()
{
    // varIndex == -1 の行が「本譜」
    int mainRow = 0;
    const int n = m_resolvedRows.size();
    for (int i = 0; i < n; ++i) {
        if (m_resolvedRows.at(i).varIndex < 0) { mainRow = i; break; }
    }

    const int safePly = (m_branchPlyContext < 0) ? 0 : m_branchPlyContext;

    // ★ Sticky の自動保持を一度だけ無効化するため、
    //   「直前の行」を本譜(=0行)として扱わせる
    m_activeResolvedRow = mainRow;

    applyResolvedRowAndSelect(mainRow, safePly);
}

// ====== アクティブ行に対する「分岐あり手」の再計算 → ビュー再描画 ======
void KifuLoadCoordinator::updateKifuBranchMarkersForActiveRow()
{
    m_branchablePlySet.clear();

    // まずビュー参照を取得（nullでも安全に抜ける）
    QTableView* view = (m_recordPane ? m_recordPane->kifuView() : nullptr);

    if (m_resolvedRows.isEmpty()) {
        if (view && view->viewport()) view->viewport()->update();
        return;
    }

    const int active = qBound(0, m_activeResolvedRow, m_resolvedRows.size() - 1);
    const auto& r = m_resolvedRows[active];

    // r.disp: 1..N の手表示, r.sfen: 0..N の局面列
    for (int ply = 1; ply <= r.disp.size(); ++ply) {
        const int idx = ply - 1;                 // sfen は ply-1 が基底
        if (idx < 0 || idx >= r.sfen.size()) continue;

        const auto itPly = m_branchIndex.constFind(ply);
        if (itPly == m_branchIndex.constEnd()) continue;

        const QString base = r.sfen.at(idx);
        const auto itBase = itPly->constFind(base);
        if (itBase == itPly->constEnd()) continue;

        // 同じ手目に候補が2つ以上 → 分岐点としてマーキング
        if (itBase->size() >= 2) {
            m_branchablePlySet.insert(ply);
        }
    }

    // デリゲート装着（未装着ならここで装着）
    ensureBranchRowDelegateInstalled();

    // 再描画
    if (view && view->viewport()) view->viewport()->update();
}

void KifuLoadCoordinator::ensureBranchRowDelegateInstalled()
{
    // RecordPane から棋譜ビューを取得
    QTableView* view = (m_recordPane ? m_recordPane->kifuView() : nullptr);
    if (!view) return;

    if (!m_branchRowDelegate) {
        // デリゲートをビューの子として作成し、ビューに適用
        m_branchRowDelegate = new BranchRowDelegate(view);
        view->setItemDelegate(m_branchRowDelegate);
    } else {
        // 念のため親が違う場合は付け替え
        if (m_branchRowDelegate->parent() != view) {
            m_branchRowDelegate->setParent(view);
            view->setItemDelegate(m_branchRowDelegate);
        }
    }

    // 「分岐あり」マーカーの集合をデリゲートへ渡す
    m_branchRowDelegate->setMarkers(&m_branchablePlySet);
}

KifuLoadCoordinator::BranchRowDelegate::BranchRowDelegate(QObject* parent)
    : QStyledItemDelegate(parent) {}

KifuLoadCoordinator::BranchRowDelegate::~BranchRowDelegate() = default;

void KifuLoadCoordinator::BranchRowDelegate::paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const
{
    QStyleOptionViewItem opt(option);
    QStyledItemDelegate::initStyleOption(&opt, index);

    const bool isBranchable = (m_marks && m_marks->contains(index.row()));

    // 選択時のハイライトと衝突しないように、未選択時のみオレンジ背景
    if (isBranchable && !(opt.state & QStyle::State_Selected)) {
        painter->save();
        painter->fillRect(opt.rect, QColor(255, 220, 160));
        painter->restore();
    }

    QStyledItemDelegate::paint(painter, opt, index);
}

void KifuLoadCoordinator::logImportSummary(const QString& filePath,
                                  const QStringList& usiMoves,
                                  const QList<KifDisplayItem>& disp,
                                  const QString& teaiLabel,
                                  const QString& warnParse,
                                  const QString& warnConvert) const
{
    if (!warnParse.isEmpty())
        qWarning().noquote() << "[KIF parse warnings]\n" << warnParse.trimmed();
    if (!warnConvert.isEmpty())
        qWarning().noquote() << "[KIF convert warnings]\n" << warnConvert.trimmed();

    qDebug().noquote() << QStringLiteral("KIF読込: %1手（%2）")
                              .arg(usiMoves.size())
                              .arg(QFileInfo(filePath).fileName());
    for (int i = 0; i < qMin(5, usiMoves.size()); ++i) {
        qDebug().noquote() << QStringLiteral("USI[%1]: %2")
        .arg(i + 1)
            .arg(usiMoves.at(i));
    }

    qDebug().noquote() << QStringLiteral("手合割: %1")
                              .arg(teaiLabel.isEmpty()
                                       ? QStringLiteral("平手(既定)")
                                       : teaiLabel);

    // 本譜（表示用）。コメントがあれば直後に出力。
    for (const auto& it : disp) {
        const QString time = it.timeText.isEmpty()
        ? QStringLiteral("00:00/00:00:00")
        : it.timeText;
        qDebug().noquote() << QStringLiteral("「%1」「%2」").arg(it.prettyMove, time);
        if (!it.comment.trimmed().isEmpty()) {
            qDebug().noquote() << QStringLiteral("  └ コメント: %1")
                                      .arg(it.comment.trimmed());
        }
    }

    // SFEN（抜粋）
    if (m_sfenRecord) {
        for (int i = 0; i < qMin(12, m_sfenRecord->size()); ++i) {
            qDebug().noquote() << QStringLiteral("%1) %2")
            .arg(i)
                .arg(m_sfenRecord->at(i));
        }
    }

    // m_gameMoves（従来通り）
    qDebug() << "m_gameMoves size:" << m_gameMoves.size();
    for (int i = 0; i < m_gameMoves.size(); ++i) {
        qDebug().noquote() << QString("%1) ").arg(i + 1) << m_gameMoves[i];
    }
}

void KifuLoadCoordinator::buildResolvedLinesAfterLoad()
{
    // 既存: Resolved行の構築や m_varEngine->ingest(), rebuildBranchWhitelist() の後
    m_branchTreeLocked = true;
    qDebug() << "[BRANCH] tree locked (after buildResolvedLinesAfterLoad)";

    // 本関数は「後勝ち」をやめ、各変化の“親”を
    // 直前→さらに前…と遡って「b(=この変化の startPly) > a(=先行変化の startPly)」
    // を満たす最初の変化行にする（無ければ本譜 row=0）という規則で構築する。

    m_resolvedRows.clear();

    // --- 行0 = 本譜 ---
    ResolvedRow mainRow;
    mainRow.startPly = 1;
    mainRow.parent   = -1;           // ★追加：本譜の親は -1 を明示
    mainRow.disp     = m_dispMain;   // 1..N（表示）
    mainRow.sfen     = m_sfenMain;   // 0..N（局面）
    mainRow.gm       = m_gmMain;     // 1..N（USIムーブ）
    mainRow.varIndex = -1;           // 本譜
    m_resolvedRows.push_back(mainRow);

    if (m_variationsSeq.isEmpty()) {
        qDebug().noquote() << "[RESOLVED] only mainline (no variations).";
        return;
    }

    // 変化 vi → 解決済み行 index の写像（empty の変化は -1）
    QVector<int> varToRowIndex(m_variationsSeq.size(), -1);

    // 親行を解決するローカルラムダ：
    // 直前→さらに前…へ遡り、startPly(prev) < startPly(cur) を満たす
    // 先行変化を見つけたら、その変化の“解決済み行 index”を返す。無ければ 0（本譜）。
    auto resolveParentRowIndex = [&](int vi)->int {
        const int b = qMax(1, m_variationsSeq.at(vi).startPly);
        for (int prev = vi - 1; prev >= 0; --prev) {
            const KifLine& p = m_variationsSeq.at(prev);
            if (p.disp.isEmpty()) continue;          // 空の変化は親候補にしない
            const int a = qMax(1, p.startPly);
            if (b > a && varToRowIndex.at(prev) >= 0) {
                return varToRowIndex.at(prev);        // その変化の“行 index”
            }
        }
        return 0; // 見つからなければ本譜
    };

    // --- 行1.. = 各変化 ---
    for (int vi = 0; vi < m_variationsSeq.size(); ++vi) {
        const KifLine& v = m_variationsSeq.at(vi);
        if (v.disp.isEmpty()) {
            varToRowIndex[vi] = -1;
            continue;
        }

        const int start = qMax(1, v.startPly);   // 1-origin
        const int parentRow = resolveParentRowIndex(vi);
        const ResolvedRow& base = m_resolvedRows.at(parentRow);

        // 1) プレフィクス（1..start-1）を“親行”から切り出し、足りない分は本譜で補完
        QList<KifDisplayItem> prefixDisp = base.disp;
        if (prefixDisp.size() > start - 1) prefixDisp.resize(start - 1);

        QVector<ShogiMove> prefixGm = base.gm;
        if (prefixGm.size() > start - 1) prefixGm.resize(start - 1);

        QStringList prefixSfen = base.sfen;
        if (prefixSfen.size() > start) prefixSfen.resize(start);

        // 親行が短い場合は本譜で延長（disp/gm/sfen を一致させる）
        while (prefixDisp.size() < start - 1 && prefixDisp.size() < m_dispMain.size()) {
            const int idx = prefixDisp.size(); // 0.. → 手数は idx+1
            prefixDisp.append(m_dispMain.at(idx));
        }
        while (prefixGm.size() < start - 1 && prefixGm.size() < m_gmMain.size()) {
            const int idx = prefixGm.size();
            prefixGm.append(m_gmMain.at(idx));
        }
        while (prefixSfen.size() < start && prefixSfen.size() < m_sfenMain.size()) {
            const int sidx = prefixSfen.size(); // 0.. → sfen は 0=初期,1=1手後...
            prefixSfen.append(m_sfenMain.at(sidx));
        }

        // 2) 変化本体を連結
        ResolvedRow row;
        row.startPly = start;
        row.parent   = parentRow;    // ★追加：親行 index を保存
        row.varIndex = vi;

        row.disp = prefixDisp;
        row.disp += v.disp;

        row.gm = prefixGm;
        row.gm += v.gameMoves;

        // v.sfenList は [0]=基底（start-1 手後）, [1..]=各手後 を想定
        row.sfen = prefixSfen;                  // 0..start-1 は既に parent→本譜で整合
        if (v.sfenList.size() >= 2) {
            row.sfen += v.sfenList.mid(1);      // start.. の各手後
        } else if (v.sfenList.size() == 1) {
            // 念のため：基底のみしか無い場合でも、prefix は揃っているので何もしない
        }

        // 追加
        m_resolvedRows.push_back(row);
        varToRowIndex[vi] = m_resolvedRows.size() - 1;
    }

    qDebug().noquote() << "[RESOLVED] lines=" << m_resolvedRows.size();

    auto varIdOf = [&](int varIndex)->int {
        if (varIndex < 0) return -1; // 本譜
        if (m_varEngine) {
            const int id = m_varEngine->varIdForSourceIndex(varIndex);
            return (id >= 0) ? id : (varIndex + 1); // フォールバック
        }
        return varIndex + 1; // 既存仕様に準拠（空行スキップ条件が一致している前提）
    };

    for (int i = 0; i < m_resolvedRows.size(); ++i) {
        const auto& r = m_resolvedRows[i];
        QStringList pm; pm.reserve(r.disp.size());
        for (const auto& d : r.disp) pm << d.prettyMove;

        const bool isMain = (i == 0);
        const QString label = isMain
                                  ? "Main"
                                  : QString("Var%1(id=%2)").arg(r.varIndex).arg(varIdOf(r.varIndex)); // ★ id 併記

        // ★修正：表示も保存済みの r.parent を使用（再計算しない）
        qDebug().noquote()
            << "  [" << label << "]"
            << " parent=" << r.parent
            << " start="  << r.startPly
            << " ndisp="  << r.disp.size()
            << " nsfen="  << r.sfen.size()
            << " seq=「 " << pm.join(" / ") << " 」";
    }
}

// 行番号から表示名を作る（Main / VarN）
QString KifuLoadCoordinator::rowNameFor_(int row) const
{
    if (row < 0 || row >= m_resolvedRows.size()) return QString("<?>");
    const auto& rr = m_resolvedRows[row];
    return (rr.varIndex < 0) ? QStringLiteral("Main")
                             : QStringLiteral("Var%1").arg(rr.varIndex);
}

// 1始まり hand-ply のラベル（無ければ ""）
QString KifuLoadCoordinator::labelAt_(const ResolvedRow& rr, int ply) const
{
    const int li = ply - 1;
    if (li < 0 || li >= rr.disp.size()) return QString();
    return pickLabelForDisp(rr.disp.at(li));
}

// 1..p までの完全一致（両方に手が存在し、かつ全ラベル一致）なら true
bool KifuLoadCoordinator::prefixEqualsUpTo_(int rowA, int rowB, int p) const
{
    if (rowA < 0 || rowA >= m_resolvedRows.size()) return false;
    if (rowB < 0 || rowB >= m_resolvedRows.size()) return false;
    const auto& A = m_resolvedRows[rowA];
    const auto& B = m_resolvedRows[rowB];
    for (int k = 1; k <= p; ++k) {
        const QString a = labelAt_(A, k);
        const QString b = labelAt_(B, k);
        if (a.isEmpty() || b.isEmpty() || a != b) return false;
    }
    return true;
}

void KifuLoadCoordinator::dumpBranchSplitReport() const
{
    if (m_resolvedRows.isEmpty()) return;

    // 行ごとに出力
    for (int r = 0; r < m_resolvedRows.size(); ++r) {
        const auto& rr = m_resolvedRows[r];
        const QString header = rowNameFor_(r);
        qDebug().noquote() << header;

        const int maxPly = rr.disp.size();
        for (int p = 1; p <= maxPly; ++p) {
            const QString curLbl = labelAt_(rr, p);
            // この行と「1..p まで完全一致」する仲間を抽出
            QList<int> group;
            for (int j = 0; j < m_resolvedRows.size(); ++j) {
                if (prefixEqualsUpTo_(r, j, p)) group << j;
            }

            // その仲間たちの「次手 (p+1)」を集計（存在するものだけ）
            struct NextMove { QString who; QString lbl; };
            QVector<NextMove> nexts; nexts.reserve(group.size());
            QSet<QString> uniq;

            // ★ detach 回避：QList を const 化して range-for
            for (int j : std::as_const(group)) {
                const QString lblNext = labelAt_(m_resolvedRows[j], p + 1);
                if (lblNext.isEmpty()) continue; // ここで終端は候補に出さない
                const QString who = rowNameFor_(j);
                nexts.push_back({who, lblNext});
                uniq.insert(lblNext);
            }

            const QString curOrEmpty = curLbl.isEmpty() ? QStringLiteral("<EMPTY>") : curLbl;

            if (uniq.size() > 1) {
                // 分岐あり：各ライン名と次手を「、」で列挙
                QStringList parts;
                parts.reserve(nexts.size());
                for (const auto& nm : nexts) {
                    parts << QStringLiteral("%1 %2").arg(nm.who, nm.lbl);
                }

                qDebug().noquote()
                    << QStringLiteral("%1 %2 分岐あり %3")
                           // ★ multi-arg を使用（p は number 化）
                           .arg(QString::number(p),
                                curOrEmpty,
                                parts.join(QStringLiteral("、")));
            } else {
                qDebug().noquote()
                << QStringLiteral("%1 %2 分岐なし")
                        // ★ multi-arg を使用
                        .arg(QString::number(p), curOrEmpty);
            }
        }

        // 行間の空行
        qDebug().noquote() << "";
    }
}

void KifuLoadCoordinator::dumpBranchCandidateDisplayPlan() const
{
    if (m_resolvedRows.isEmpty()) return;

    auto labelAt = [&](int row, int ply1)->QString {
        // ply1 は 1-based
        const int li = ply1 - 1;
        const auto& disp = m_resolvedRows[row].disp;
        return (li >= 0 && li < disp.size()) ? pickLabelForDisp(disp.at(li)) : QString();
    };

    // 行ごとに
    for (int r = 0; r < m_resolvedRows.size(); ++r) {
        qDebug().noquote() << (r == 0 ? "Main" : QString("Var%1").arg(r - 1));

        const int len = m_resolvedRows[r].disp.size();
        const auto itRow = m_branchDisplayPlan.constFind(r);

        for (int ply1 = 1; ply1 <= len; ++ply1) {
            const QString base = labelAt(r, ply1);
            bool has = false;
            QVector<BranchCandidateDisplayItem> items;

            if (itRow != m_branchDisplayPlan.constEnd()) {
                const auto& mp = itRow.value();
                auto itP = mp.constFind(ply1);
                if (itP != mp.constEnd()) {
                    has   = true;
                    items = itP.value().items;
                }
            }

            if (!has) {
                const QString baseOrEmpty = base.isEmpty() ? QStringLiteral("<EMPTY>") : base;
                qDebug().noquote()
                    << QStringLiteral("%1 %2 分岐候補表示なし")
                           .arg(QString::number(ply1), baseOrEmpty);
            } else {
                // "Main ▲…、Var0 ▲…、Var2 ▲…" の並びを構築
                QStringList parts;
                parts.reserve(items.size());
                for (const auto& it : std::as_const(items)) {  // ← detach 回避
                    parts << QStringLiteral("%1 %2").arg(it.lineName, it.label);
                }
                const QString baseOrEmpty = base.isEmpty() ? QStringLiteral("<EMPTY>") : base;
                qDebug().noquote()
                    << QStringLiteral("%1 %2 分岐候補表示あり %3")
                           .arg(QString::number(ply1),
                                baseOrEmpty,
                                parts.join(QStringLiteral("、")));  // ← multi-arg
            }
        }

        // 行間の空行
        qDebug().noquote() << "";
    }
}

void KifuLoadCoordinator::ensureResolvedRowsHaveFullSfen()
{
    if (m_resolvedRows.isEmpty()) return;

    qDebug() << "[SFEN] ensureResolvedRowsHaveFullSfen BEGIN";

    // Main の SFEN（VEが空なら既存の行0を使う）
    QStringList veMain = (m_varEngine ? m_varEngine->mainlineSfen() : QStringList());
    if (veMain.isEmpty() && !m_resolvedRows[0].sfen.isEmpty())
        veMain = m_resolvedRows[0].sfen;

    auto sfenFromVeForRow = [&](const ResolvedRow& rr)->QStringList {
        if (rr.varIndex < 0) {
            // 本譜
            return veMain;
        }
        if (!m_varEngine) return {};
        const int vid = m_varEngine->variationIdFromSourceIndex(rr.varIndex);
        return m_varEngine->sfenForVariationId(vid);
    };

    const int rowCount = m_resolvedRows.size();
    for (int r = 0; r < rowCount; ++r) {
        auto& rr = m_resolvedRows[r];

        const int need = rr.disp.size() + 1;     // 0..N
        const int s    = qMax(1, rr.startPly);   // 1-origin
        const int base = s - 1;                  // 直前局面の添字

        // 親行（無ければ Main=0）
        int parentRow = 0;
        if (rr.parent >= 0 && rr.parent < rowCount) {
            parentRow = rr.parent;
        }

        // 親のプレフィクス（親が空なら mainline を使う）
        const QStringList parentPrefix =
            (!m_resolvedRows[parentRow].sfen.isEmpty()
                 ? m_resolvedRows[parentRow].sfen
                 : veMain);

        // この行の VE 配列（base を先頭とする 0..M）
        const QStringList veRow = sfenFromVeForRow(rr);

        // 合成先。既存をベースにするが、0..base は必ず親で上書きする
        QStringList full = rr.sfen;

        // --- 1) 0..base を親の SFEN で「強制上書き」 -----------------------
        //     ※ ここが今回の肝：古い/別行の値が残らないようにする
        for (int i = 0; i <= base; ++i) {
            if (i >= parentPrefix.size()) break;   // 親に無ければ打ち切り
            const QString pv = parentPrefix.at(i);
            if (i < full.size()) {
                full[i] = pv;                      // 常に上書き
            } else if (!pv.isEmpty()) {
                full.append(pv);                   // 既知のものだけ追加
            } else {
                break;                             // 空は追加しない
            }
        }

        // デバッグ（境界確認）
        auto hashS = [](const QString& s){ return qHash(s); };
        auto safeAt = [&](const QStringList& a, int i)->QString{
            return (0<=i && i<a.size() ? a.at(i) : QString());
        };

        qDebug().noquote()
            << "[SFEN] row=" << r
            << " base=" << base
            << " pre(base-1)#=" << hashS(safeAt(full, base-1))
            << " pre(base)#="   << hashS(safeAt(full, base))
            << " pre(base+1)#=" << hashS(safeAt(full, base+1));


        // --- 2) VE の部分配列を base から重ねる（空は書かない／ギャップは埋めない） ---
        bool gap = false;
        if (!veRow.isEmpty()) {
            for (int j = 0; j < veRow.size(); ++j) {
                const int pos = base + j;
                const QString v = veRow.at(j);
                if (v.isEmpty()) continue;

                if (pos < full.size()) {
                    full[pos] = v;
                } else if (pos == full.size()) {
                    full.append(v);
                } else {
                    // 間の index が未充足（空で埋めない方針なので打ち切り）
                    gap = true;
                    break;
                }
            }
        } else {
            // veRow が空：壊さずスキップ（警告のみ）
            if (full.size() < need) {
                qWarning().noquote()
                << "[SFEN] SKIP(fill) row=" << r
                << " startPly=" << rr.startPly
                << " need=" << need
                << " prefix(sz=" << parentPrefix.size() << ")"
                << " veRow(sz=0)  -- keep r.sfen as-is";
            }
        }

        // --- 3) 検査＆警告 ---------------------------------------------------
        bool missing = (full.size() < need);
        if (!missing) {
            for (int i = 0; i < need; ++i) {
                if (full.at(i).isEmpty()) { missing = true; break; }
            }
        }
        if (missing || gap) {
            qWarning().noquote()
            << "[SFEN] WARN(fill) row=" << r
            << " startPly=" << rr.startPly
            << " need=" << need
            << " prefix(sz=" << parentPrefix.size() << ")"
            << " veRow(sz=" << veRow.size() << ")"
            << (gap ? " GAP" : "");
        }

        // デバッグ（境界確認：合成後）

        qDebug().noquote()
            << "[SFEN] row=" << r
            << " post(base-1)#=" << hashS(safeAt(full, base-1))
            << " post(base)#="   << hashS(safeAt(full, base))
            << " post(base+1)#=" << hashS(safeAt(full, base+1));


        rr.sfen = std::move(full);
    }

    qDebug() << "[SFEN] ensureResolvedRowsHaveFullSfen END";
}

void KifuLoadCoordinator::dumpAllRowsSfenTable() const
{
    if (m_resolvedRows.isEmpty()) return;

    auto labelAt = [&](int row, int ply1)->QString {
        const int li = ply1 - 1;
        const auto& disp = m_resolvedRows[row].disp;
        return (li >= 0 && li < disp.size()) ? pickLabelForDisp(disp.at(li)) : QString();
    };

    for (int r = 0; r < m_resolvedRows.size(); ++r) {
        const auto& rr = m_resolvedRows[r];
        qDebug().noquote() << (r == 0 ? "Main" : QString("Var%1").arg(r - 1));

        // 0: 開始局面
        const QString s0 = (!rr.sfen.isEmpty() ? rr.sfen.first() : QStringLiteral("<SFEN MISSING>"));
        qDebug().noquote() << QStringLiteral("0 開始局面 %1").arg(s0);

        // 1..N
        for (int ply1 = 1; ply1 <= rr.disp.size(); ++ply1) {
            const QString lbl  = labelAt(r, ply1);
            QString sfen = (ply1 >= 0 && ply1 < rr.sfen.size()) ? rr.sfen.at(ply1) : QString();
            if (sfen.isEmpty()) sfen = QStringLiteral("<SFEN MISSING>");

            qDebug().noquote()
                << QStringLiteral("%1 %2 %3")
                       .arg(QString::number(ply1),
                            lbl.isEmpty() ? QStringLiteral("<EMPTY>") : lbl,
                            sfen);
        }
        qDebug().noquote() << "";
    }
}

// 各 ResolvedRow の SFEN 列から gm（ShogiMove 列）を復元する（詳細ログ付き）
void KifuLoadCoordinator::ensureResolvedRowsHaveFullGameMoves()
{
    qDebug() << "[GM] ensureResolvedRowsHaveFullGameMoves BEGIN";
    for (int i = 0; i < m_resolvedRows.size(); ++i) {
        auto& r = m_resolvedRows[i];

        const int nsfen = r.sfen.size();     // 0..N
        const int ndisp = r.disp.size();     // 1..N
        // resign など「盤が変わらない終端」は 1 手として数えないので、基本は min(ndisp, nsfen-1)
        const int want  = qMax(0, qMin(ndisp, nsfen - 1));

        const QString label = (i == 0)
                                  ? QStringLiteral("Main")
                                  : QStringLiteral("Var%1(id=%2)")
                                        .arg(r.varIndex)
                                        .arg(m_varEngine ? m_varEngine->varIdForSourceIndex(r.varIndex)
                                                         : (r.varIndex + 1));

        qDebug().noquote()
            << QString("[GM] row=%1 \"%2\" start=%3 nsfen=%4 ndisp=%5 current_gm=%6 want=%7")
                   .arg(i).arg(label).arg(r.startPly).arg(nsfen).arg(ndisp).arg(r.gm.size()).arg(want);

        // サイズが一致していればスキップ（必要に応じて強制再構築したい場合はこの if を外す）
        if (r.gm.size() == want) {
            qDebug().noquote() << QString("[GM] row=%1 keep (size match)").arg(i);
            continue;
        }

        r.gm.clear();

        for (int ply1 = 1; ply1 <= want; ++ply1) {
            const QString prev = r.sfen.at(ply1 - 1);
            const QString next = r.sfen.at(ply1);
            const QString pretty = r.disp.at(ply1 - 1).prettyMove;

            ShogiMove mv;
            const bool ok = deriveMoveFromSfenPair(prev, next, &mv); // ★ 内部で FLIP（USI向き）を採用

            if (!ok) {
                // 盤が同一 → 投了やコメントのみなど（gm へは積まない）
                qDebug().noquote()
                    << QString("[GM] row=%1 ply=%2 \"%3\" : NO-DELTA (terminal/comment)")
                           .arg(i).arg(ply1).arg(pretty);
                continue;
            }

            r.gm.push_back(mv);

            auto qcharToStr = [](QChar c)->QString { return c.isNull() ? QString(" ") : QString(c); };
            qDebug().noquote()
                << QStringLiteral("[GM] row=%1 ply=%2 \"%3\"  From:(%4,%5) To:(%6,%7) Moving:%8 Captured:%9 Promotion:%10")
                       .arg(QString::number(i),
                            QString::number(ply1),
                            pretty)
                       .arg(QString::number(mv.fromSquare.x()),
                            QString::number(mv.fromSquare.y()),
                            QString::number(mv.toSquare.x()))
                       .arg(QString::number(mv.toSquare.y()),
                            qcharToStr(mv.movingPiece),
                            qcharToStr(mv.capturedPiece))
                       .arg(mv.isPromotion ? QStringLiteral("true") : QStringLiteral("false"));
        }

        qDebug().noquote()
            << QString("[GM] row=%1 built gm.size=%2 / want=%3").arg(i).arg(r.gm.size()).arg(want);
    }
    qDebug() << "[GM] ensureResolvedRowsHaveFullGameMoves END";
}

void KifuLoadCoordinator::dumpAllLinesGameMoves() const
{
    if (m_resolvedRows.isEmpty()) return;

    // 終局判定（見た目ベース）
    static const QStringList kTerminalKeywords = {
        QStringLiteral("投了"), QStringLiteral("中断"), QStringLiteral("持将棋"),
        QStringLiteral("千日手"), QStringLiteral("切れ負け"),
        QStringLiteral("反則勝ち"), QStringLiteral("反則負け"),
        QStringLiteral("入玉勝ち"), QStringLiteral("不戦勝"),
        QStringLiteral("不戦敗"), QStringLiteral("詰み"), QStringLiteral("不詰"),
    };
    auto isTerminalPretty = [&](const QString& s)->bool {
        for (const auto& kw : kTerminalKeywords) if (s.contains(kw)) return true;
        return false;
    };

    auto lineNameFor = [](int row)->QString {
        return (row == 0) ? QStringLiteral("Main")
                          : QStringLiteral("Var%1").arg(row - 1);
    };
    auto labelAt = [&](const ResolvedRow& rr, int li)->QString {
        return (li >= 0 && li < rr.disp.size())
                 ? pickLabelForDisp(rr.disp.at(li))
                 : QString();
    };
    auto fmtPt = [](const QPoint& p)->QString {
        return QStringLiteral("(%1,%2)").arg(p.x()).arg(p.y());
    };

    // QChar/char/整数 いずれでも文字列化できる汎用ヘルパ
    auto pieceToQString = [](auto v)->QString {
        using T = std::decay_t<decltype(v)>;
        if constexpr (std::is_same_v<T, QChar>) {
            return v.isNull() ? QString() : QString(v);
        } else if constexpr (std::is_same_v<T, char>) {
            return v ? QString(QChar(v)) : QString();
        } else if constexpr (std::is_integral_v<T>) {
            return v ? QString(QChar(static_cast<ushort>(v))) : QString();
        } else {
            return QString();
        }
    };

    for (int r = 0; r < m_resolvedRows.size(); ++r) {
        const auto& rr = m_resolvedRows[r];
        qDebug().noquote() << lineNameFor(r);

        // 0) 開始局面（From/To 等は出さない）
        qDebug().noquote() << "0 開始局面";

        const int M = rr.disp.size();
        for (int li = 0; li < M; ++li) {
            const QString pretty = labelAt(rr, li);
            const bool terminal  = isTerminalPretty(pretty);

            // ヘッダ（手数 + 見た目ラベル）
            const QString head = QStringLiteral("%1 %2").arg(li + 1).arg(pretty);

            if (terminal || li >= rr.gm.size()) {
                // 投了など or GM不足 → そのまま
                qDebug().noquote() << head;
                continue;
            }

            const ShogiMove& mv = rr.gm.at(li);

            // ドロップ（打つ手）は fromSquare が無効座標の可能性
            const bool hasFrom = (mv.fromSquare.x() >= 0 && mv.fromSquare.y() >= 0);
            const QString fromS = hasFrom ? fmtPt(mv.fromSquare) : QString();
            const QString toS   = fmtPt(mv.toSquare);

            const QString moving = pieceToQString(mv.movingPiece);
            const QString cap    = pieceToQString(mv.capturedPiece);
            const bool promoted  = mv.isPromotion;   // ← 正しいフィールド名

            qDebug().noquote()
                << head
                << " From:" << fromS
                << " To:" << toS
                << " Moving:" << moving
                << " Captured:" << cap
                << " Promotion:" << (promoted ? "true" : "false");
        }

        qDebug().noquote() << "";
    }
}

void KifuLoadCoordinator::buildBranchCandidateDisplayPlan()
{
    m_branchDisplayPlan.clear();

    const int R = m_resolvedRows.size();
    if (R == 0) return;

    auto labelAt = [&](int row, int li)->QString {
        const auto& disp = m_resolvedRows[row].disp;
        return (li >= 0 && li < disp.size()) ? pickLabelForDisp(disp.at(li)) : QString();
    };

    auto prefixEquals = [&](int r1, int r2, int uptoLi)->bool {
        // li=0 のときは「初手より前の共通部分」は空なので常に一致とみなす
        for (int i = 0; i < uptoLi; ++i) {
            if (labelAt(r1, i) != labelAt(r2, i)) return false;
        }
        return true;
    };

    // 各行 r の各ローカル添字 li（0-based）について、
    // 「初手から li-1 まで完全一致する行」をグループ化し、
    // その li 手目に 2 種類以上の指し手があれば分岐とみなす。
    // ★ 表示は “その手（li）” に出す（＝1手先に送らない）
    for (int r = 0; r < R; ++r) {
        const int len = m_resolvedRows[r].disp.size();
        if (len == 0) continue;

        for (int li = 0; li < len; ++li) {
            // この行 r と「初手から li-1 まで一致」する行
            QVector<int> group;
            group.reserve(R);
            for (int g = 0; g < R; ++g) {
                if (li < m_resolvedRows[g].disp.size() && prefixEquals(r, g, li)) {
                    group.push_back(g);
                }
            }
            if (group.size() <= 1) continue; // 比較相手がいない

            // グループの li 手目ラベルを集計
            QHash<QString, QVector<int>> labelToRows;
            for (int g : group) {
                const QString lbl = labelAt(g, li);
                labelToRows[lbl].push_back(g);
            }
            if (labelToRows.size() <= 1) continue; // 全員同じ指し手 → 分岐ではない

            // 表示先 ply（1-based）。li は 0-based
            const int targetPly = li + 1;
            if (targetPly > m_resolvedRows[r].disp.size()) continue;

            // 見出し（この行 r の li 手目）
            const QString baseForDisplay = labelAt(r, li);

            // ===== 重複整理（自分の行 > Main(=row0) > 若い VarN）=====
            struct TmpKeep { QString lbl; int keepRow; };
            QVector<TmpKeep> keeps; keeps.reserve(labelToRows.size());

            for (auto it = labelToRows.constBegin(); it != labelToRows.constEnd(); ++it) {
                const QString lbl = it.key();
                const QVector<int>& rowsWithLbl = it.value();

                int keep = -1;

                // 1) 自分の行 r を最優先
                bool hasSelf = false;
                for (int cand : rowsWithLbl) {
                    if (cand == r) { keep = cand; hasSelf = true; break; }
                }

                // 2) 自分が無ければ Main(row=0)
                if (!hasSelf) {
                    bool hasMain = false;
                    for (int cand : rowsWithLbl) {
                        if (cand == 0) { keep = 0; hasMain = true; break; }
                    }

                    // 3) それも無ければ最小 row（VarN の若い方）
                    if (!hasMain) {
                        keep = rowsWithLbl.first();
                        for (int cand : rowsWithLbl) {
                            if (cand < keep) keep = cand;
                        }
                    }
                }

                keeps.push_back({ lbl, keep });
            }

            // 表示順: Main が先、次に row 昇順
            std::sort(keeps.begin(), keeps.end(), [](const TmpKeep& a, const TmpKeep& b){
                if (a.keepRow == 0 && b.keepRow != 0) return true;
                if (a.keepRow != 0 && b.keepRow == 0) return false;
                return a.keepRow < b.keepRow;
            });

            QVector<::BranchCandidateDisplayItem> items;
            items.reserve(keeps.size());
            for (const auto& k : keeps) {
                ::BranchCandidateDisplayItem itx;
                itx.row      = k.keepRow;
                itx.varN     = (k.keepRow == 0 ? -1 : k.keepRow - 1);
                itx.lineName = lineNameForRow(k.keepRow); // "Main" / "VarN"
                itx.label    = k.lbl;
                items.push_back(itx);
            }

            // 保存
            ::BranchCandidateDisplay plan;
            plan.ply       = targetPly;
            plan.baseLabel = baseForDisplay;
            plan.items     = std::move(items);
            m_branchDisplayPlan[r].insert(targetPly, std::move(plan));
        }
    }
}

void KifuLoadCoordinator::setAnalysisTab(EngineAnalysisTab* tab)
{
    // 既存の接続を解除（重複接続/古いタブへのぶら下がり防止）
    if (m_analysisTab) {
        QObject::disconnect(
            m_analysisTab, &EngineAnalysisTab::branchNodeActivated,
            this,         &KifuLoadCoordinator::applyResolvedRowAndSelect
            );
    }

    m_analysisTab = tab;

    // 新しいタブに配線（「分岐ツリーのクリック → 行適用＆選択」）
    if (m_analysisTab) {
        QObject::connect(
            m_analysisTab, &EngineAnalysisTab::branchNodeActivated,
            this,          &KifuLoadCoordinator::applyResolvedRowAndSelect,
            Qt::UniqueConnection
            );
    }

    // 既存の Presenter 依存も更新（従来どおり）
    if (m_navPresenter) {
        NavigationPresenter::Deps d;
        d.coordinator = this;
        d.analysisTab = m_analysisTab;
        m_navPresenter->setDeps(d);
    }
}

void KifuLoadCoordinator::ensureNavigationPresenter_()
{
    if (m_navPresenter) return;

    NavigationPresenter::Deps d;
    d.coordinator = this;
    d.analysisTab = m_analysisTab;

    m_navPresenter = new NavigationPresenter(d, this);

    // 必要なら通知を拾ってログや別UIに伝播
    // connect(m_navPresenter, &NavigationPresenter::branchUiUpdated,
    //         this, &KifuLoadCoordinator::onBranchUiUpdated); // ※スロット用意時
}

void KifuLoadCoordinator::applyResolvedRowAndSelect(int row, int selPly)
{
    // デバッグ：入口
    qDebug().noquote()
        << "[KLC] applyResolvedRowAndSelect enter"
        << "row=" << row << "selPly=" << selPly
        << " resolvedRows.size=" << m_resolvedRows.size()
        << " recPtr=" << static_cast<const void*>(m_sfenRecord)
        << " recSize(before)=" << (m_sfenRecord ? m_sfenRecord->size() : -1);

    // ------- 安全化と早期リターン -------
    if (m_resolvedRows.isEmpty()) {
        // 解決行が未構築のケースでは、現在の disp を使って最低限の同期だけ行う
        const int pick = (selPly < 0) ? 0 : selPly;
        showRecordAtPly(m_dispCurrent, pick);
        ensureNavigationPresenter_();
        m_navPresenter->refreshAll(/*row=*/0, pick);
        qDebug() << "[KLC] applyResolvedRowAndSelect leave (no resolved rows)";
        return;
    }

    // 呼び出し引数の一旦安全化
    const int nRows   = m_resolvedRows.size();
    int       safeRow = (row < 0) ? 0 : ((row >= nRows) ? (nRows - 1) : row);
    int       safePly = (selPly < 0) ? 0 : selPly;

    // ======== Sticky 分岐ロジック ========
    // 直前に Var 行を表示していた場合、ツリーで「分岐前」のノードを押しても
    // その Var 行を維持する（= 本譜へ勝手に戻さない）
    // 条件:
    //   1) 今回要求 row が本譜(=0)
    //   2) 直前のアクティブ行が Var 行 (varIndex >= 0)
    //   3) 今回の手数 safePly が、その Var 行の startPly より前
    const int prevRow = (m_activeResolvedRow < 0)
                            ? 0
                            : ((m_activeResolvedRow >= nRows) ? (nRows - 1) : m_activeResolvedRow);

    if (safeRow == 0 && prevRow >= 0 && prevRow < nRows) {
        const ResolvedRow& prev = m_resolvedRows.at(prevRow);
        if (prev.varIndex >= 0) {
            const int varStart = (prev.startPly <= 0) ? 1 : prev.startPly;
            if (safePly < varStart) {
                qDebug() << "[KLC][sticky] keep variation row instead of main:"
                         << "prevRow=" << prevRow << "varStart=" << varStart
                         << "requested ply=" << safePly;
                safeRow = prevRow; // ← 本譜に戻さず Var 行を維持
            }
        }
    }
    // ======== Sticky 分岐ここまで ========

    // ★★★★★ 現在の解決行/手をまず更新（以降の処理はこの状態を前提） ★★★★★
    m_activeResolvedRow = safeRow;
    m_activePly         = safePly;

    // 以降：表示列/局面列/USIムーブ列を、この safeRow の行に切り替え
    const ResolvedRow& rr = m_resolvedRows.at(safeRow);

    // 1..N の表示列
    m_dispCurrent = rr.disp;

    // 0..N の SFEN 列（共有実体を書き換え/COW）
    if (m_sfenRecord) {
        if (!rr.sfen.isEmpty()) {
            *m_sfenRecord = rr.sfen;
            qDebug().noquote() << "[KLC] SFEN overwritten from resolvedRows  size="
                               << m_sfenRecord->size();
        } else {
            qDebug().noquote() << "[KLC] rr.sfen is EMPTY -> keep existing shared SFEN (size="
                               << m_sfenRecord->size() << ")";
        }
    }

    // 1..N の USI ムーブ列
    m_gameMoves = rr.gm;

    // ------- 棋譜テーブルへ反映 & 選択（safePly 行を選択） -------
    showRecordAtPly(m_dispCurrent, safePly);

    // 「分岐あり」マーカーの再計算と描画更新（本譜/変化の切替に追随）
    updateKifuBranchMarkersForActiveRow();

    m_loadingKifu = false;

    // ------- 分岐候補（Plan 方式）とツリーハイライトまで一括更新 -------
    ensureNavigationPresenter_();
    m_navPresenter->refreshAll(safeRow, safePly);

    // デバッグ：出口
    qDebug().noquote()
        << "[KLC] applyResolvedRowAndSelect leave"
        << " recSize(after)=" << (m_sfenRecord ? m_sfenRecord->size() : -1);
}

// 既存：分岐候補モデルの構築・表示更新を担う関数
void KifuLoadCoordinator::showBranchCandidates(int row, int ply)
{
    // Plan ベースの表示へ一本化
    showBranchCandidatesFromPlan(row, ply);

    // 表示更新後にツリーハイライトだけ通知（逆呼びになるため refreshAll は呼ばない）
    ensureNavigationPresenter_();
    m_navPresenter->updateAfterBranchListChanged(row, ply);
}

void KifuLoadCoordinator::onMainMoveRowChanged(int selPly)
{
    // selPly を安全化
    const int safePly = qMax(0, selPly);

    // 読み込み中はスキップ（再帰的な更新抑止）
    if (m_loadingKifu) return;

    // “いまアクティブな解決行” を安全化
    const int row = (m_resolvedRows.isEmpty()
                         ? 0
                         : qBound(0, m_activeResolvedRow, m_resolvedRows.size() - 1));

    // 盤/棋譜/ハイライトは Coordinator の既存ユーティリティに一任
    applyResolvedRowAndSelect(row, safePly);
}

void KifuLoadCoordinator::setBranchCandidatesController(BranchCandidatesController* ctl)
{
    m_branchCtl = ctl;
}

// ===== KifuLoadCoordinator.cpp: ライブ対局から分岐ツリーを更新 =====
QList<KifDisplayItem> KifuLoadCoordinator::collectDispFromRecordModel_() const
{
    QList<KifDisplayItem> disp;

    if (!m_kifuRecordModel) return disp;

    const int rows = m_kifuRecordModel->rowCount();
    if (rows <= 1) return disp; // 0 行目は「=== 開始局面 ===」

    // 「ASCII数字(1..,23..)+空白任意+ (▲|△)」の時だけ、その数字部分を剥がす。
    // 例: "1 ▲７六歩" / "1▲７六歩" / "23▲..." / "23 ▲..." は除去対象。
    // 例: "▲７六歩" / "△７六歩" / "７六歩"（先頭が全角数字）は対象外。
    static const QRegularExpression kDupMoveNoPattern(
        QStringLiteral("^\\s*([0-9]+)\\s*(?=[▲△])")
        );

    for (int r = 1; r < rows; ++r) {
        const QModelIndex idxMove = m_kifuRecordModel->index(r, 0);
        const QModelIndex idxTime = m_kifuRecordModel->index(r, 1);

        QString move = m_kifuRecordModel->data(idxMove, Qt::DisplayRole).toString();
        const QString time = m_kifuRecordModel->data(idxTime, Qt::DisplayRole).toString();

        // ★ 重複付与検知時のみ、先頭の ASCII 手数を除去
        move.remove(kDupMoveNoPattern);

        const int ply = r; // ヘッダを除いた 1 始まりの絶対手数
        disp.push_back(KifDisplayItem(move, time, QString(), ply));
    }

    return disp;
}

// ライブ（HvH/HvE）対局の 1手追加ごとに分岐ツリーを更新するエントリポイント
void KifuLoadCoordinator::updateBranchTreeFromLive(int currentPly)
{
    // 1) 現在の棋譜モデルから disp を再構成（「=== 開始局面 ===」行は含まない）
    const QList<KifDisplayItem> dispLive = collectDispFromRecordModel_();
    if (!m_analysisTab) return; // タブ未生成なら何もしない

    // 2) 本譜行（row=0 相当：parent==-1）を特定（なければ作成）
    int mainRow = -1;
    {
        const int n = m_resolvedRows.size();
        for (int i = 0; i < n; ++i) {
            if (m_resolvedRows.at(i).parent < 0) { mainRow = i; break; } // parent==-1 が本譜
        }
        if (mainRow < 0) {
            ResolvedRow main;
            main.startPly = 1;
            main.parent   = -1;
            main.disp     = dispLive;
            main.sfen     = QStringList();
            main.gm       = QVector<ShogiMove>();
            main.varIndex = -1; // 本譜識別
            m_resolvedRows.push_back(main);
            mainRow = m_resolvedRows.size() - 1;
            m_activeResolvedRow = mainRow;
        }
    }

    // 3) アンカー手（「現在の局面から開始」）の決定
    const int anchorPly = (m_branchPlyContext >= 0)
                              ? m_branchPlyContext
                              : qMax(0, m_currentSelectedPly);
    const bool startFromCurrentPos = (anchorPly > 0);

    // 4) 行の更新
    int highlightRow = mainRow;
    int highlightAbsPly = qBound(0, currentPly, dispLive.size());

    if (!startFromCurrentPos) {
        // 4-a) 通常の新規対局：本譜をそのまま置換（既存分岐は保持）
        m_resolvedRows[mainRow].disp = dispLive;

        highlightRow    = mainRow;
        highlightAbsPly = qBound(0, currentPly, m_resolvedRows.at(mainRow).disp.size());
    } else {
        // 4-b) 「現在の局面」からの 2局目：別ラインとして追加/更新
        //      親＝本譜行(mainRow)、分岐開始は (anchorPly) の直後
        const int startPly = anchorPly + 1;        // 分岐開始の絶対手
        const int suffixStart = qBound(0, anchorPly, dispLive.size()); // ここからが“新たに指した手”

        // 親（=本譜）の prefix（1..startPly-1）を切り出す
        QList<KifDisplayItem> merged = m_resolvedRows.at(mainRow).disp;
        if (merged.size() > startPly - 1) merged.resize(startPly - 1);

        // ★FIX: 2局目の全手を連結せず、anchorPly 以降の “新規手” だけを連結
        const auto& liveConst = std::as_const(dispLive);
        for (int i = suffixStart; i < liveConst.size(); ++i) {
            merged.push_back(liveConst.at(i));
        }

        // 既存の同一 startPly のライブ枝（varIndex <= -2）を探す
        int liveRowIdx = -1;
        {
            const int n = m_resolvedRows.size();
            for (int i = 0; i < n; ++i) {
                const ResolvedRow& r = m_resolvedRows.at(i);
                if (r.parent == mainRow && r.startPly == startPly && r.varIndex <= -2) {
                    liveRowIdx = i;
                    break;
                }
            }
        }

        if (liveRowIdx < 0) {
            ResolvedRow br;
            br.startPly = startPly;
            br.parent   = mainRow;
            br.disp     = merged;
            br.sfen     = QStringList();
            br.gm       = QVector<ShogiMove>();
            br.varIndex = -2; // ライブ分岐識別（本譜=-1、KIF由来>=0）
            m_resolvedRows.push_back(br);
            liveRowIdx = m_resolvedRows.size() - 1;
        } else {
            m_resolvedRows[liveRowIdx].disp = merged;
        }

        m_activeResolvedRow = liveRowIdx;

        // ★FIX: ハイライトは「分岐開始の直前」+「アンカー以降に実際に指した手数」
        // currentPly は“絶対手数”想定なので、アンカーからの相対手数を使う
        const int relPlayed = qMax(0, currentPly - anchorPly);
        highlightRow    = liveRowIdx;
        highlightAbsPly = (startPly - 1) + relPlayed;
        // 範囲ガード
        highlightAbsPly = qBound(startPly - 1,
                                 highlightAbsPly,
                                 startPly - 1 + (liveConst.size() - suffixStart));
    }

    // ★★★ 修正箇所：現在の行に対して、最新の SFEN と GameMoves を保存する ★★★
    // これを行わないと、別の分岐から戻ってきたときに盤面を復元できません。
    if (highlightRow >= 0 && highlightRow < m_resolvedRows.size()) {
        // 現在アクティブな行（＝今指している行）であれば、対局データを信頼してコピーする
        if (m_activeResolvedRow == highlightRow) {
            if (m_sfenRecord) {
                m_resolvedRows[highlightRow].sfen = *m_sfenRecord;
            }
            m_resolvedRows[highlightRow].gm = m_gameMoves;
        }
    }
    // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

    // 5) EngineAnalysisTab へ供給
    QVector<EngineAnalysisTab::ResolvedRowLite> rowsLite;
    rowsLite.reserve(m_resolvedRows.size());
    const auto& rowsConst = std::as_const(m_resolvedRows);
    for (const ResolvedRow& r : rowsConst) {
        EngineAnalysisTab::ResolvedRowLite x;
        x.startPly = r.startPly;
        x.disp     = r.disp;
        x.sfen     = r.sfen;
        rowsLite.push_back(std::move(x));
    }
    m_analysisTab->setBranchTreeRows(rowsLite);

    // 6) 該当ノードをハイライト（中心スクロールあり）
    m_analysisTab->highlightBranchTreeAt(highlightRow, highlightAbsPly, /*centerOn=*/true);
}

void KifuLoadCoordinator::applyBranchMarksForCurrentLine_()
{
    if (!m_kifuRecordModel) return;

    QSet<int> marks; // ply1=1..N（モデルの行番号と一致。0は開始局面なので除外）

    const auto itRow = m_branchDisplayPlan.constFind(m_activeResolvedRow);
    if (itRow != m_branchDisplayPlan.cend()) {
        // byPly: QMap<int (ply1), BranchCandidateDisplay>
        const QMap<int, BranchCandidateDisplay>& byPly = itRow.value();

        const QList<int> keys = byPly.keys(); // QMap → 安全に昇順
        for (int i = 0; i < keys.size(); ++i) {
            const int ply1 = keys.at(i);
            if (ply1 > 0) marks.insert(ply1);
        }
    }

    m_kifuRecordModel->setBranchPlyMarks(marks);
}
#include "mainwindow.h"

#include <QApplication>
#include <QLocale>
#include <QTranslator>
#include <QStyleFactory>
#include <QGuiApplication>
#include <QToolTip>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTranslator translator;

    const QStringList uiLanguages = QLocale::system().uiLanguages();

    for (const QString &locale : uiLanguages) {
        const QString baseName = "ShogiBoardQ_" + QLocale(locale).name();

        if (translator.load(":/i18n/" + baseName)) {
            a.installTranslator(&translator);
            break;
        }
    }

    // Creatorのような「Fusion」スタイルに統一する。
    a.setStyle(QStyleFactory::create("Fusion"));

    MainWindow w;

    w.show();

    return a.exec();
}
#include <QMessageBox>
#include <QDesktopServices>
#include <QHBoxLayout>
#include <QHeaderView>
#include <QFileDialog>
#include <QToolButton>
#include <QWidgetAction>
#include <QMetaType>
#include <QDebug>
#include <QScrollBar>
#include <QPushButton>
#include <functional>

#include "mainwindow.h"
#include "branchwiringcoordinator.h"
#include "considerationflowcontroller.h"
#include "gamelayoutbuilder.h"
#include "shogigamecontroller.h"
#include "shogiboard.h"
#include "shogiview.h"
#include "timedisplaypresenter.h"
#include "tsumesearchflowcontroller.h"
#include "ui_mainwindow.h"
#include "shogiclock.h"
#include "apptooltipfilter.h"
#include "navigationcontroller.h"
#include "boardimageexporter.h"
#include "engineinfowidget.h"
#include "engineanalysistab.h"
#include "matchcoordinator.h"
#include "kifuvariationengine.h"
#include "branchcandidatescontroller.h"
#include "turnmanager.h"
#include "errorbus.h"
#include "kifuloadcoordinator.h"
#include "evaluationchartwidget.h"
#include "timekeepingservice.h"
#include "kifuioservice.h"
#include "positioneditcontroller.h"
#include "playernameservice.h"
#include "analysisresultspresenter.h"
#include "boardsyncpresenter.h"
#include "gamestartcoordinator.h"
#include "navigationpresenter.h"
#include "analysiscoordinator.h"
#include "kifuanalysislistmodel.h"
#include "analysiscoordinator.h"
#include "recordpresenter.h"
#include "timecontrolutil.h"
#include "analysisflowcontroller.h"
#include "sfenutils.h"
#include "turnsyncbridge.h"
#include "promotionflow.h"
#include "kifusavecoordinator.h"
#include "evalgraphpresenter.h"
#include "settingsservice.h"
#include "aboutcoordinator.h"
#include "enginesettingscoordinator.h"
#include "analysistabwiring.h"
#include "recordpanewiring.h"
#include "navigationcontroller.h"
#include "uiactionswiring.h"
#include "kifucontentbuilder.h"

using KifuIoService::makeDefaultSaveFileName;
using KifuIoService::writeKifuFile;
using GameOverCause = MatchCoordinator::Cause;
using std::placeholders::_1;
using std::placeholders::_2;

static inline GameOverCause toUiCause(MatchCoordinator::Cause c) { return c; }

// ★ コメント整形ヘルパ：
//   1) '*' の直前で改行
//   2) URL( http(s)://... ) を <a href="...">...</a> にリンク化
//   3) 改行を <br/> に変換（安全のため非URL部は HTML エスケープ）
namespace {
static QString toRichHtmlWithStarBreaksAndLinks(const QString& raw)
{
    // 改行正規化
    QString s = raw;
    s.replace(QStringLiteral("\r\n"), QStringLiteral("\n"));
    s.replace(QChar('\r'), QChar('\n'));

    // '*' が行頭でない場合、その直前に改行を入れる（直前の余分な空白は削る）
    QString withBreaks;
    withBreaks.reserve(s.size() + 16);
    for (int i = 0; i < s.size(); ++i) {
        const QChar ch = s.at(i);
        if (ch == QLatin1Char('*') && i > 0 && s.at(i - 1) != QLatin1Char('\n')) {
            while (!withBreaks.isEmpty()) {
                const QChar tail = withBreaks.at(withBreaks.size() - 1);
                if (tail == QLatin1Char('\n')) break;
                if (!tail.isSpace()) break;
                withBreaks.chop(1);
            }
            withBreaks.append(QLatin1Char('\n'));
        }
        withBreaks.append(ch);
    }

    // URL をリンク化（非URL部分は都度エスケープ）
    static const QRegularExpression urlRe(
        QStringLiteral(R"((https?://[^\s<>"']+))"),
        QRegularExpression::CaseInsensitiveOption);

    QString html;
    html.reserve(withBreaks.size() + 64);

    int last = 0;
    QRegularExpressionMatchIterator it = urlRe.globalMatch(withBreaks);
    while (it.hasNext()) {
        const QRegularExpressionMatch m = it.next();
        const int start = m.capturedStart();
        const int end   = m.capturedEnd();

        // 非URL部分をエスケープして追加
        html += QString(withBreaks.mid(last, start - last)).toHtmlEscaped();

        // URL部分を <a href="...">...</a>
        const QString url   = m.captured(0);
        const QString href  = url.toHtmlEscaped();   // 属性用の最低限エスケープ
        const QString label = url.toHtmlEscaped();   // 表示用
        html += QStringLiteral("<a href=\"%1\">%2</a>").arg(href, label);

        last = end;
    }
    // 末尾の非URL部分
    html += QString(withBreaks.mid(last)).toHtmlEscaped();

    // 改行 → <br/>
    html.replace(QChar('\n'), QStringLiteral("<br/>"));
    return html;
}
} // anonymous namespace

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
    , m_startSfenStr(QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1"))
    , m_currentSfenStr(QStringLiteral("startpos"))
    , m_errorOccurred(false)
    , m_usi1(nullptr)
    , m_usi2(nullptr)
    , m_playMode(NotStarted)
    , m_lineEditModel1(new UsiCommLogModel(this))
    , m_lineEditModel2(new UsiCommLogModel(this))
    , m_gameController(nullptr)
    , m_analysisModel(nullptr)
{
    ui->setupUi(this);

    setupCentralWidgetContainer_();

    configureToolBarFromUi_();

    // コア部品（GC, View, 盤モデル etc.）は既存関数で初期化
    initializeComponents();

    if (!m_timePresenter) m_timePresenter = new TimeDisplayPresenter(m_shogiView, this);

    // 画面骨格（棋譜/分岐/レイアウト/タブ/中央表示）
    buildGamePanels_();

    // ウィンドウ設定の復元（位置/サイズなど）
    restoreWindowAndSync_();

    // メニュー/アクションのconnect（関数ポインタで統一）
    connectAllActions_();

    // コアシグナル（昇格ダイアログ・エラー・ドラッグ終了・指し手確定 等）
    connectCoreSignals_();

    // ツールチップをコンパクト表示へ
    installAppToolTips_();

    // 司令塔やUIフォント/位置編集コントローラの最終初期化
    finalizeCoordinators_();

    // 起動時用：編集メニューを“編集前（未編集）”の初期状態にする
    initializeEditMenuForStartup();
}

void MainWindow::setupCentralWidgetContainer_()
{
    m_central = ui->centralwidget;
    m_centralLayout = new QVBoxLayout(m_central);
    m_centralLayout->setContentsMargins(0, 0, 0, 0);
    m_centralLayout->setSpacing(0);
}

void MainWindow::configureToolBarFromUi_()
{
    if (QToolBar* tb = ui->toolBar) {
        tb->setIconSize(QSize(18, 18)); // お好みで 16/18/20/24
        tb->setToolButtonStyle(Qt::ToolButtonIconOnly);
        tb->setStyleSheet(
            "QToolBar{margin:0px; padding:0px; spacing:2px;}"
            "QToolButton{margin:0px; padding:2px;}"
            );
    }
}

void MainWindow::buildGamePanels_()
{
    // 1) 記録ペイン（RecordPane）など UI 部の初期化
    setupRecordPane();

    // 2) 分岐配線をコーディネータに集約（旧: setupBranchCandidatesWiring_()）
    //    既存があれば入れ替え（多重接続を防ぐ）
    if (m_branchWiring) {
        m_branchWiring->deleteLater();
        m_branchWiring = nullptr;
    }
    if (m_recordPane) {
        BranchWiringCoordinator::Deps bw;
        bw.recordPane      = m_recordPane;
        bw.branchModel     = m_kifuBranchModel;     // 既に保持していれば渡す（null可）
        bw.variationEngine = m_varEngine.get();     // unique_ptr想定
        bw.kifuLoader      = m_kifuLoadCoordinator; // 読み込み済みなら渡す（null可）
        bw.parent          = this;

        m_branchWiring = new BranchWiringCoordinator(bw);

        // ★ 冪等なのでこの1回で十分
        m_branchWiring->setupBranchView();
        m_branchWiring->setupBranchCandidatesWiring();
    } else {
        qWarning() << "[UI] buildGamePanels_: RecordPane is null; skip branch wiring.";
    }

    // 3) 将棋盤・駒台の初期化（従来順序を維持）
    startNewShogiGame(m_startSfenStr);

    // 4) 盤＋各パネルの横並びレイアウト構築
    setupHorizontalGameLayout();

    // 5) エンジン解析タブの構築
    setupEngineAnalysisTab();

    // 6) central へのタブ追加など表示側の初期化
    initializeCentralGameDisplay();
}

void MainWindow::restoreWindowAndSync_()
{
    loadWindowSettings();
}

void MainWindow::connectAllActions_()
{
    // 既存があれば使い回し
    if (!m_actionsWiring) {
        UiActionsWiring::Deps d;
        d.ui        = ui;
        d.shogiView = m_shogiView;
        d.ctx       = this; // MainWindow のスロットに繋ぐ
        m_actionsWiring = new UiActionsWiring(d, this);
    }
    m_actionsWiring->wire();
}

void MainWindow::connectCoreSignals_()
{
    // 将棋盤表示・昇格・ドラッグ終了・指し手確定
    if (m_gameController) {
        connect(m_gameController, &ShogiGameController::showPromotionDialog,
                this, &MainWindow::displayPromotionDialog, Qt::UniqueConnection);

        connect(m_gameController, &ShogiGameController::endDragSignal,
                m_shogiView,      &ShogiView::endDrag, Qt::UniqueConnection);

        connect(m_gameController, &ShogiGameController::moveCommitted,
                this, &MainWindow::onMoveCommitted, Qt::UniqueConnection);
    }
    if (m_shogiView) {
        connect(m_shogiView, &ShogiView::errorOccurred,
                this, &MainWindow::displayErrorMessage, Qt::UniqueConnection);
    }

    // ErrorBus はラムダを使わず専用スロットへ
    connect(&ErrorBus::instance(), &ErrorBus::errorOccurred,
            this, &MainWindow::onErrorBusOccurred, Qt::UniqueConnection);
}

void MainWindow::installAppToolTips_()
{
    auto* tipFilter = new AppToolTipFilter(this);
    tipFilter->setPointSizeF(12.0);
    tipFilter->setCompact(true);

    const auto toolbars = findChildren<QToolBar*>();
    for (QToolBar* tb : toolbars) {
        const auto buttons = tb->findChildren<QToolButton*>();
        for (QToolButton* b : buttons) {
            b->installEventFilter(tipFilter);
        }
    }
}

void MainWindow::finalizeCoordinators_()
{
    initMatchCoordinator();
    setupNameAndClockFonts_();
    ensurePositionEditController_();
    ensureBoardSyncPresenter_();
    ensureAnalysisPresenter_();
}

void MainWindow::onErrorBusOccurred(const QString& msg)
{
    displayErrorMessage(msg);
}

// GUIを構成するWidgetなどを生成する。（リファクタ後）
void MainWindow::initializeComponents()
{
    // ───────────────── Core models ─────────────────
    // ShogiGameController は QObject 親を付けてリーク防止
    if (!m_gameController) {
        m_gameController = new ShogiGameController(this);
    } else {
        // 再初期化に備えて、必要ならシグナル切断などをここで行う
        // m_gameController->disconnect(this);
    }

    // 局面履歴（SFEN列）を確保（起動直後の初期化なのでクリアもOK）
    if (!m_sfenRecord) m_sfenRecord = new QStringList;
    else               m_sfenRecord->clear();

    // 棋譜表示用のレコードリストを確保（ここでは容器だけ用意）
    if (!m_moveRecords) m_moveRecords = new QList<KifuDisplay *>;
    else                m_moveRecords->clear();

    // ───────────────── View ─────────────────
    if (!m_shogiView) {
        m_shogiView = new ShogiView(this);     // 親をMainWindowに
        m_shogiView->setNameFontScale(0.30);   // 好みの倍率（表示前に設定）
    } else {
        // 再初期化時も念のためパラメータを揃える
        m_shogiView->setParent(this);
        m_shogiView->setNameFontScale(0.30);
    }

    // 盤・駒台操作の配線（BoardInteractionController など）
    setupBoardInteractionController();

    // ───────────────── Board model 初期化 ─────────────────
    // m_startSfenStr が "startpos ..." の場合は必ず完全 SFEN に正規化してから newGame。
    QString start = m_startSfenStr;
    if (start.isEmpty()) {
        // 既定：平手初期局面の完全SFEN
        start = QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1");
    } else if (start.startsWith(QLatin1String("startpos"))) {
        start = SfenUtils::normalizeStart(start);
    }

    // 盤データを生成してビューへ接続（view->board() が常に有効になるように順序を固定）
    m_gameController->newGame(start);
    if (m_shogiView->board() != m_gameController->board()) {
        m_shogiView->setBoard(m_gameController->board());
    }

    // ───────────────── Turn 初期化 & 同期 ─────────────────
    // 1) TurnManager 側の初期手番（b→Player1）を立ち上げる
    setCurrentTurn();

    // 2) GC ↔ TurnManager のブリッジ確立＆初期同期（内部で gc->currentPlayer() を反映）
    ensureTurnSyncBridge_();

    // ───────────────── 表示名・ログモデル名の初期反映（任意だが初期表示を安定化） ─────────────────
    // setPlayersNamesForMode / setEngineNamesBasedOnMode がサービスへ移設済みでも呼び出し名は同じ
    setPlayersNamesForMode();
    setEngineNamesBasedOnMode();
}

// エラーメッセージを表示する。
void MainWindow::displayErrorMessage(const QString& errorMessage)
{
    // エラー状態を設定する。
    m_errorOccurred = true;

    // 将棋盤内をマウスでクリックできないようにフラグを変更する。
    m_shogiView->setErrorOccurred(m_errorOccurred);

    // エラーメッセージを表示する。
    QMessageBox::critical(this, tr("Error"), errorMessage);
}

// 「表示」の「思考」 思考タブの表示・非表示
void MainWindow::toggleEngineAnalysisVisibility()
{
    if (!m_analysisTab) return;
    m_analysisTab->setAnalysisVisible(ui->actionToggleEngineAnalysis->isChecked());
}

// 待ったボタンを押すと、2手戻る。
void MainWindow::undoLastTwoMoves()
{
    if (m_match) {
        m_match->undoTwoPlies();
    }
}

void MainWindow::initializeNewGame(QString& startSfenStr)
{
    if (m_gameController) {
        m_gameController->newGame(startSfenStr);
    }
    // ← ここは Coordinator に委譲
    GameStartCoordinator::applyResumePositionIfAny(m_gameController, m_shogiView, m_resumeSfenStr);
}

// 対局モードに応じて将棋盤上部に表示される対局者名をセットする。
void MainWindow::setPlayersNamesForMode()
{
    // ShogiView が未生成なら何もしない
    if (!m_shogiView) return;

    // GameStartCoordinator がある（= 対局開始後の通常経路）の場合は従来どおり適用
    if (m_gameStart) {
        m_gameStart->applyPlayersNamesForMode(
            m_shogiView,
            m_playMode,
            m_humanName1, m_humanName2,
            m_engineName1, m_engineName2
            );
        return;
    }

    // ★ 起動直後（m_gameStart が未設定）のデフォルト表示を補う
    //   「▲/▽」マークは ShogiView 側の refreshNameLabels() で自動付与されるため、
    //   ここでは素の名前（先手/後手）のみを渡します。
    m_shogiView->setBlackPlayerName(tr("先手"));
    m_shogiView->setWhitePlayerName(tr("後手"));
}

// 駒台を含む将棋盤全体の画像をクリップボードにコピーする。
void MainWindow::copyBoardToClipboard()
{
    BoardImageExporter::copyToClipboard(m_shogiView);
}

void MainWindow::saveShogiBoardImage()
{
    BoardImageExporter::saveImage(this, m_shogiView);
}

// 対局モードに応じて将棋盤下部に表示されるエンジン名をセットする。
void MainWindow::setEngineNamesBasedOnMode()
{
    const EngineNameMapping e =
        PlayerNameService::computeEngineModels(m_playMode, m_engineName1, m_engineName2);

    if (m_lineEditModel1) m_lineEditModel1->setEngineName(e.model1);
    if (m_lineEditModel2) m_lineEditModel2->setEngineName(e.model2);
}

// 対局者名と残り時間、将棋盤と棋譜、矢印ボタン、評価値グラフのグループを横に並べて表示する。
void MainWindow::setupHorizontalGameLayout()
{
    if (!m_layoutBuilder) {
        GameLayoutBuilder::Deps d;
        d.shogiView          = m_shogiView;
        d.recordPaneOrWidget = m_gameRecordLayoutWidget;
        d.analysisTabWidget  = m_tab; // 下段タブ
        m_layoutBuilder = new GameLayoutBuilder(d, this);
    }
    m_hsplit = m_layoutBuilder->buildHorizontalSplit();
}

// --- レイアウトの中身だけ入れ替えるヘルパ ---
static void clearLayout(QLayout* lay) {
    while (QLayoutItem* it = lay->takeAt(0)) {
        if (QWidget* w = it->widget()) w->setParent(nullptr);
        delete it;
    }
}

void MainWindow::initializeCentralGameDisplay()
{
    if (!m_centralLayout) return;

    // レイアウトを空にする（既存のウィジェットはレイアウトから外すだけ）
    clearLayout(m_centralLayout);

    // 必須部品の存在チェック（無ければ何もしない）
    if (!m_shogiView || !m_gameRecordLayoutWidget || !m_tab) {
        qWarning().noquote()
        << "[initializeCentralGameDisplay] missing widget(s)."
        << " shogiView=" << (m_shogiView!=nullptr)
        << " recordPaneOrWidget=" << (m_gameRecordLayoutWidget!=nullptr)
        << " tab=" << (m_tab!=nullptr);
        return;
    }

    // ★ 重要：
    // setupHorizontalGameLayout() は setupEngineAnalysisTab() より先に呼ばれるため、
    // 起動順によっては m_tab 未設定のまま m_layoutBuilder が生成されている。
    // ここで一度 Builder を作り直し、最新の依存を確実に反映させる。
    if (m_layoutBuilder) {
        m_layoutBuilder->deleteLater();
        m_layoutBuilder = nullptr;
    }
    {
        GameLayoutBuilder::Deps d;
        d.shogiView          = m_shogiView;
        d.recordPaneOrWidget = m_gameRecordLayoutWidget; // 右ペイン（RecordPane）
        d.analysisTabWidget  = m_tab;                    // 下段タブ（EngineAnalysisTab を内包）
        m_layoutBuilder = new GameLayoutBuilder(d, this);
    }

    // 左右スプリッタを生成して保持（以後も m_hsplit を参照する箇所があるため）
    m_hsplit = m_layoutBuilder->buildHorizontalSplit();
    Q_ASSERT(m_hsplit);
    Q_ASSERT(m_tab);

    // 中央レイアウトへ追加：上=スプリッタ、下=タブ
    m_centralLayout->addWidget(m_hsplit);
    m_centralLayout->addWidget(m_tab);

    // 見た目調整：上を広く、下のタブは控えめ
    m_centralLayout->setStretch(0, 1); // splitter
    m_centralLayout->setStretch(1, 0); // analysis tab
}

void MainWindow::startNewShogiGame(QString& startSfenStr)
{
    const bool resume = m_isResumeFromCurrent;

    // 評価値グラフ等の初期化
    if (auto ec = m_recordPane ? m_recordPane->evalChart() : nullptr) {
        if (!resume) ec->clearAll();
    }
    if (!resume) {
        m_scoreCp.clear();
        // ★ ライブ記録のクリアも Presenter に依頼
        if (m_recordPresenter) {
            m_recordPresenter->clearLiveDisp();
        }
    }

    // 司令塔が未用意なら作る
    if (!m_match) {
        initMatchCoordinator();
    }
    if (!m_match) return;

    // ★ ここで一括：開始に必要な前処理～初手goまでを司令塔に丸投げ
    m_match->prepareAndStartGame(
        m_playMode,
        startSfenStr,
        m_sfenRecord,
        m_startGameDialog,
        m_bottomIsP1
        );
}

// 棋譜欄の下の矢印ボタンを無効にする。
void MainWindow::disableArrowButtons()
{
    if (m_recordPane) m_recordPane->setArrowButtonsEnabled(false);
}

// 棋譜欄の下の矢印ボタンを有効にする。
void MainWindow::enableArrowButtons()
{
    if (m_recordPane) m_recordPane->setArrowButtonsEnabled(true);
}

// メニューで「投了」をクリックした場合の処理を行う。
void MainWindow::handleResignation()
{
    if (m_match) m_match->handleResign();
}

void MainWindow::redrawEngine1EvaluationGraph()
{
    EvalGraphPresenter::appendPrimaryScore(m_scoreCp, m_match);
}

void MainWindow::redrawEngine2EvaluationGraph()
{
    EvalGraphPresenter::appendSecondaryScore(m_scoreCp, m_match);
}

// 将棋クロックの手番を設定する。
void MainWindow::updateTurnStatus(int currentPlayer)
{
    if (!m_shogiView) return;

    if (!m_shogiClock) { // 保険
        qWarning() << "ShogiClock not ready yet";
        ensureClockReady_();
        if (!m_shogiClock) return;
    }

    m_shogiClock->setCurrentPlayer(currentPlayer);
    m_shogiView->setActiveSide(currentPlayer == 1);
}

void MainWindow::displayVersionInformation()
{
    AboutCoordinator::showVersionDialog(this);
}

void MainWindow::openWebsiteInExternalBrowser()
{
    AboutCoordinator::openProjectWebsite();
}

void MainWindow::displayEngineSettingsDialog()
{
    EngineSettingsCoordinator::openDialog(this);
}

// 成る・不成の選択ダイアログを起動する。
void MainWindow::displayPromotionDialog()
{
    if (!m_gameController) return;
    const bool promote = PromotionFlow::askPromote(this);
    m_gameController->setPromote(promote);
}

// 検討ダイアログを表示する。
void MainWindow::displayConsiderationDialog()
{
    // UI 側の状態保持（従来どおり）
    m_playMode = ConsidarationMode;

    // 手番表示（必要最小限）
    if (m_gameController && m_gameMoves.size() > 0 && m_currentMoveIndex >= 0 && m_currentMoveIndex < m_gameMoves.size()) {
        if (m_gameMoves.at(m_currentMoveIndex).movingPiece.isUpper())
            m_gameController->setCurrentPlayer(ShogiGameController::Player1);
        else
            m_gameController->setCurrentPlayer(ShogiGameController::Player2);
    }

    // 送信する position（既存の m_positionStrList を利用）
    const QString position = (m_currentMoveIndex >= 0 && m_currentMoveIndex < m_positionStrList.size())
                                 ? m_positionStrList.at(m_currentMoveIndex)
                                 : QString();

    // Flow に一任（onError はラムダではなく専用スロットへバインド）
    ConsiderationFlowController* flow = new ConsiderationFlowController(this);
    ConsiderationFlowController::Deps d;
    d.match   = m_match;
    d.onError = std::bind(&MainWindow::onFlowError_, this, std::placeholders::_1);

    flow->runWithDialog(d, this, position);
}

// 詰み探索ダイアログを表示する。
void MainWindow::displayTsumeShogiSearchDialog()
{
    // 解析モード切替
    m_playMode = TsumiSearchMode;

    // Flow に一任（ダイアログ生成～exec～司令塔連携）
    TsumeSearchFlowController* flow = new TsumeSearchFlowController(this);

    TsumeSearchFlowController::Deps d;
    d.match            = m_match;
    d.sfenRecord       = m_sfenRecord;
    d.startSfenStr     = m_startSfenStr;
    d.positionStrList  = m_positionStrList;
    d.currentMoveIndex = qMax(0, m_currentMoveIndex);
    d.onError          = std::bind(&MainWindow::onFlowError_, this, std::placeholders::_1);

    flow->runWithDialog(d, this);
}

// 棋譜解析ダイアログを表示する。
void MainWindow::displayKifuAnalysisDialog()
{
    // 解析モードに遷移
    m_playMode = AnalysisMode;

    // Flow の用意
    if (!m_analysisFlow) {
        m_analysisFlow = new AnalysisFlowController(this);
    }

    // 解析モデルが未生成ならここで作成
    if (!m_analysisModel) {
        m_analysisModel = new KifuAnalysisListModel(this);
    }

    // 依存を詰めて Flow へ一任（displayError はスロットにバインド）
    AnalysisFlowController::Deps d;
    d.sfenRecord    = m_sfenRecord;
    d.moveRecords   = m_moveRecords;
    d.analysisModel = m_analysisModel;
    d.analysisTab   = m_analysisTab;
    d.usi           = m_usi1;
    d.logModel      = m_lineEditModel1;  // info/bestmove の橋渡し用
    d.activePly     = m_activePly;
    d.displayError  = std::bind(&MainWindow::onFlowError_, this, std::placeholders::_1);

    m_analysisFlow->runWithDialog(d, this);
}

// TurnManager::changed を受けて UI/Clock を更新（＋手番を GameController に同期）
void MainWindow::onTurnManagerChanged(ShogiGameController::Player now)
{
    // 1) UI側（先手=1, 後手=2）に反映
    const int cur = (now == ShogiGameController::Player2) ? 2 : 1;
    updateTurnStatus(cur);

    // 2) 盤モデルの手番は GC に集約
    if (m_gameController) {
        m_gameController->setCurrentPlayer(now);
    }

    // ★ 3) 盤ビュー側の「次の手番」ラベル表示を更新（片側のみ表示）
    if (m_shogiView) {
        m_shogiView->updateTurnIndicator(now);
    }

    // （必要なら：ここでログやステータスバー更新などを追加）
}

// 現在の手番を設定する。
void MainWindow::setCurrentTurn()
{
    // TurnManager を確保
    TurnManager* tm = this->findChild<TurnManager*>(QStringLiteral("TurnManager"));
    if (!tm) {
        tm = new TurnManager(this);
        tm->setObjectName(QStringLiteral("TurnManager"));
        // ラムダを使わず、メンバ関数に接続
        connect(tm, &TurnManager::changed,
                this, &MainWindow::onTurnManagerChanged,
                Qt::UniqueConnection);
    }

    // 盤（SFEN）の "b"/"w" から TurnManager へ → UI/Clock は changed によって更新
    const QString bw = (m_shogiView && m_shogiView->board())
                       ? m_shogiView->board()->currentPlayer()
                       : QStringLiteral("b");
    tm->setFromSfenToken(bw);

    // GC 側も TurnManager に揃える（意味統一＝GC 方式）
    if (m_gameController) {
        m_gameController->setCurrentPlayer(tm->toGc());
    }
}

QString MainWindow::resolveCurrentSfenForGameStart_() const
{
    // 1) 棋譜SFENリストの「選択手」から取得（最優先）
    if (m_sfenRecord) {
        const int size = m_sfenRecord->size();
        // m_currentSelectedPly が [0..size-1] のインデックスである前提（本プロジェクトの慣習）
        // 1始まりの場合はプロジェクト実装に合わせて +0 / -1 調整してください。
        int idx = m_currentSelectedPly;
        if (idx < 0) {
            // 0手目（開始局面）などのとき
            idx = 0;
        }
        if (idx >= 0 && idx < size) {
            const QString s = m_sfenRecord->at(idx).trimmed();
            if (!s.isEmpty()) return s;
        }
    }

    // 2) フォールバックなし（司令塔側が安全に処理）
    return QString();
}

// 対局を開始する。
void MainWindow::initializeGame()
{
    ensureGameStartCoordinator_();

    // ★ 平手SFENが優先されてしまう問題の根本対策：
    //    ダイアログ確定直後に司令塔へ渡す前に、startSfen を明示クリアし、
    //    currentSfen を「選択中の手のSFEN（最優先）→それがなければ空」の順で決定しておく。
    m_startSfenStr.clear();

    // 現在の局面SFEN（棋譜レコードから最優先で取得）
    {
        const QString sfen = resolveCurrentSfenForGameStart_().trimmed();
        if (!sfen.isEmpty()) {
            m_currentSfenStr = sfen;
        } else {
            // 何も取れないケースは珍しいが、空のままでも司令塔側で安全にフォールバックされる。
            // ここでは何もしない（ログのみ）
            qDebug().noquote() << "[INIT] resolveCurrentSfenForGameStart_: empty. delegate to coordinator.";
        }
    }

    GameStartCoordinator::Ctx c;
    c.view            = m_shogiView;
    c.gc              = m_gameController;
    c.clock           = m_shogiClock;
    c.sfenRecord      = m_sfenRecord;          // QStringList*
    c.currentSfenStr  = &m_currentSfenStr;     // 現局面の SFEN（ここで事前決定済み）
    c.startSfenStr    = &m_startSfenStr;       // 開始SFENは明示的に空（優先度を逆転）
    c.selectedPly     = m_currentSelectedPly;  // 1始まり/0始まりはプロジェクト規約に準拠
    c.isReplayMode    = m_isReplayMode;
    c.bottomIsP1      = m_bottomIsP1;

    m_gameStart->initializeGame(c);
}

// 設定ファイルにGUI全体のウィンドウサイズを書き込む。
// また、将棋盤のマスサイズも書き込む。その後、GUIを終了する。
void MainWindow::saveSettingsAndClose()
{
    // 設定ファイルにGUIQ全体のウィンドウサイズを書き込む。
    // また、将棋盤のマスサイズも書き込む。
    saveWindowAndBoardSettings();

    // GUIを終了する。
    QCoreApplication::quit();
}

// GUIを初期画面表示に戻す。
void MainWindow::resetToInitialState()
{
    // 既存呼び出し互換のため残し、内部は司令塔フックへ集約
    onPreStartCleanupRequested_();
}

// 棋譜ファイルをダイアログから選択し、そのファイルを開く。
void MainWindow::chooseAndLoadKifuFile()
{
    // --- 1) ファイル選択（UI層に残す） ---
    const QString filePath =
        QFileDialog::getOpenFileName(this, tr("KIFファイルを開く"), QString(), tr("KIF Files (*.kif *.kifu)"));
    if (filePath.isEmpty()) return;

    setReplayMode(true);
    ensureGameInfoTable();

    // 既存があれば破棄予約（多重生成対策）
    if (m_kifuLoadCoordinator) {
        m_kifuLoadCoordinator->deleteLater();
        m_kifuLoadCoordinator = nullptr;
    }

    // --- 2) 読み込み系の配線と依存は Coordinator に集約 ---
    m_kifuLoadCoordinator = new KifuLoadCoordinator(
        /* gameMoves           */ m_gameMoves,
        /* resolvedRows        */ m_resolvedRows,
        /* positionStrList     */ m_positionStrList,
        /* activeResolvedRow   */ m_activeResolvedRow,
        /* activePly           */ m_activePly,
        /* currentSelectedPly  */ m_currentSelectedPly,
        /* currentMoveIndex    */ m_currentMoveIndex,
        /* sfenRecord          */ m_sfenRecord,
        /* gameInfoTable       */ m_gameInfoTable,
        /* gameInfoDock        */ m_gameInfoDock,
        /* analysisTab         */ m_analysisTab,
        /* tab                 */ m_tab,
        /* shogiView           */ m_shogiView,
        /* recordPane          */ m_recordPane,
        /* kifuRecordModel     */ m_kifuRecordModel,
        /* kifuBranchModel     */ m_kifuBranchModel,
        /* branchCtl           */ m_branchCtl,
        /* kifuBranchView      */ m_kifuBranchView,
        /* branchDisplayPlan   */ m_branchDisplayPlan,
        /* parent              */ this
        );

    // ★ 追加 (1): BranchWiring に loader を後から注入
    if (m_branchWiring) {
        m_branchWiring->setKifuLoader(m_kifuLoadCoordinator);
    }

    // ★ 追加 (2): KifuLoadCoordinator 側が必要時に再配線させるためのトリガ
    // （KifuLoadCoordinator::setupBranchCandidatesWiring_ シグナル → BranchWiring の配線処理）
    if (m_branchWiring) {
        connect(m_kifuLoadCoordinator, &KifuLoadCoordinator::setupBranchCandidatesWiring_,
                m_branchWiring,       &BranchWiringCoordinator::setupBranchCandidatesWiring,
                Qt::UniqueConnection);
    }

    // ★ MainWindow 側でやっていた branchNode 配線は setAnalysisTab() に委譲
    //   （内部で disconnect / connect を一貫管理）
    m_kifuLoadCoordinator->setAnalysisTab(m_analysisTab);

    // --- 3) Coordinator -> MainWindow の通知（UI更新）は従来どおり受ける ---
    connect(m_kifuLoadCoordinator, &KifuLoadCoordinator::displayGameRecord,
            this, &MainWindow::displayGameRecord, Qt::UniqueConnection);
    connect(m_kifuLoadCoordinator, &KifuLoadCoordinator::syncBoardAndHighlightsAtRow,
            this, &MainWindow::syncBoardAndHighlightsAtRow, Qt::UniqueConnection);
    connect(m_kifuLoadCoordinator, &KifuLoadCoordinator::enableArrowButtons,
            this, &MainWindow::enableArrowButtons, Qt::UniqueConnection);

    // --- 4) 読み込み実行（ロジックは Coordinator へ） ---
    m_kifuLoadCoordinator->loadKifuFromFile(filePath);
}

void MainWindow::displayGameRecord(const QList<KifDisplayItem> disp)
{
    if (!m_kifuRecordModel) return;

    ensureRecordPresenter_();
    if (!m_recordPresenter) return;

    const int moveCount = disp.size();
    const int rowCount  = (m_sfenRecord && !m_sfenRecord->isEmpty())
                             ? m_sfenRecord->size()
                             : (moveCount + 1);

    // ← まとめて Presenter 側に委譲
    m_recordPresenter->displayAndWire(disp, rowCount, m_recordPane);
}

void MainWindow::loadWindowSettings()
{
    SettingsService::loadWindowSize(this);
}

void MainWindow::saveWindowAndBoardSettings()
{
    SettingsService::saveWindowAndBoard(this, m_shogiView);
}

void MainWindow::closeEvent(QCloseEvent* e)
{
    saveWindowAndBoardSettings();
    QMainWindow::closeEvent(e);
}

void MainWindow::onReverseTriggered()
{
    if (m_match) m_match->flipBoard();
}

// 起動時用：編集メニューを“編集前（未編集）”の初期状態にする
void MainWindow::initializeEditMenuForStartup()
{
    // 未編集状態（＝編集モードではない）でメニューを整える
    applyEditMenuEditingState(false);
}

// 共通ユーティリティ：編集モードかどうかで可視/不可視を一括切り替え
// editing == true  : 編集モード中 → 「局面編集終了」などを表示／「編集局面開始」は隠す
// editing == false : 未編集（通常）→ 「編集局面開始」を表示／それ以外を隠す
void MainWindow::applyEditMenuEditingState(bool editing)
{
    if (!ui) {
        return;
    }

    // 未編集状態では「局面編集開始」を表示、それ以外は非表示
    ui->actionStartEditPosition->setVisible(!editing);

    // 編集モード関連アクションは editing のときのみ表示
    ui->actionEndEditPosition->setVisible(editing);
    ui->flatHandInitialPosition->setVisible(editing);
    ui->shogiProblemInitialPosition->setVisible(editing);
    ui->returnAllPiecesOnStand->setVisible(editing);
    ui->reversal->setVisible(editing);
    ui->turnaround->setVisible(editing);

    // ※ QMenu名は .ui 上で "Edit"（= ui->Edit）です。必要なら再描画。
    if (ui->Edit) {
        ui->Edit->update();
    }
}

void MainWindow::beginPositionEditing()
{
    ensurePositionEditController_();
    if (!m_posEdit || !m_shogiView || !m_gameController) return;

    PositionEditController::BeginEditContext ctx;
    ctx.view       = m_shogiView;
    ctx.gc         = m_gameController;
    ctx.bic        = m_boardController;
    ctx.sfenRecord = m_sfenRecord ? m_sfenRecord : nullptr;

    ctx.selectedPly = m_currentSelectedPly;
    ctx.activePly   = m_activePly;
    ctx.gameOver    = (m_match ? m_match->gameOverState().isOver : false);

    ctx.startSfenStr    = &m_startSfenStr;
    ctx.currentSfenStr  = &m_currentSfenStr;
    ctx.resumeSfenStr   = &m_resumeSfenStr;

    // ── メニュー表示（Controller → callback）: 共通ヘルパで編集メニューに遷移 ──
    ctx.onEnterEditMenu = [this]() {
        applyEditMenuEditingState(true);
    };

    // ── 「編集終了」ボタン表示（Controller API 経由） ──
    ctx.onShowEditExitButton = [this]() {
        if (m_posEdit && m_shogiView) {
            m_posEdit->showEditExitButtonOnBoard(m_shogiView, this, SLOT(finishPositionEditing()));
        }
    };

    // 実行（盤と文字列状態の同期等は Controller が担当）
    m_posEdit->beginPositionEditing(ctx);

    // ── 編集用アクション配線（ラムダ無し・重複防止） ─────────────
    if (ui) {
        // Controller のスロットへ直接接続
        connect(ui->returnAllPiecesOnStand,      &QAction::triggered,
                m_posEdit, &PositionEditController::onReturnAllPiecesOnStandTriggered,
                Qt::UniqueConnection);

        connect(ui->flatHandInitialPosition,     &QAction::triggered,
                m_posEdit, &PositionEditController::onFlatHandInitialPositionTriggered,
                Qt::UniqueConnection);

        connect(ui->shogiProblemInitialPosition, &QAction::triggered,
                m_posEdit, &PositionEditController::onShogiProblemInitialPositionTriggered,
                Qt::UniqueConnection);

        connect(ui->turnaround,                  &QAction::triggered,
                m_posEdit, &PositionEditController::onToggleSideToMoveTriggered,
                Qt::UniqueConnection);

        // 先後反転は司令塔の責務のまま（MatchCoordinator操作）
        connect(ui->reversal,                    &QAction::triggered,
                this,     &MainWindow::onReverseTriggered,
                Qt::UniqueConnection);
    }
}

void MainWindow::finishPositionEditing()
{
    // --- A) 自動同期を一時停止（ここが肝） ---
    const bool prevGuard = m_onMainRowGuard;
    m_onMainRowGuard = true;

    ensurePositionEditController_();
    if (!m_posEdit || !m_shogiView || !m_gameController) {
        m_onMainRowGuard = prevGuard;
        return;
    }

    // Controller に委譲して SFEN の確定・sfenRecord/開始SFEN 更新・UI 後片付けを実施
    PositionEditController::FinishEditContext ctx;
    ctx.view       = m_shogiView;
    ctx.gc         = m_gameController;
    ctx.bic        = m_boardController;
    ctx.sfenRecord = m_sfenRecord ? m_sfenRecord : nullptr;
    ctx.startSfenStr        = &m_startSfenStr;
    ctx.isResumeFromCurrent = &m_isResumeFromCurrent;

    // 「編集終了」ボタンの後片付け（Controller → callback）
    ctx.onHideEditExitButton = [this]() {
        if (m_posEdit && m_shogiView) {
            m_posEdit->hideEditExitButtonOnBoard(m_shogiView);
        }
    };

    // メニューを元に戻す（Controller → callback）: 共通ヘルパで通常メニューに復帰
    ctx.onLeaveEditMenu = [this]() {
        applyEditMenuEditingState(false);
    };

    // 実行
    m_posEdit->finishPositionEditing(ctx);

    // --- D) 自動同期を再開 ---
    m_onMainRowGuard = prevGuard;

    qDebug() << "[EDIT-END] flags: editMode="
             << (m_shogiView ? m_shogiView->positionEditMode() : false)
             << " guard=" << m_onMainRowGuard
             << " m_startSfenStr=" << m_startSfenStr;
}

// 「すぐ指させる」
void MainWindow::movePieceImmediately()
{
    if (m_match) {
        m_match->forceImmediateMove();
    }
}

void MainWindow::onPlayer1TimeOut()
{
    if (m_match) m_match->handlePlayerTimeOut(1); // 1 = 先手
}

void MainWindow::onPlayer2TimeOut()
{
    if (m_match) m_match->handlePlayerTimeOut(2); // 2 = 後手
}

void MainWindow::setGameOverMove(GameOverCause cause, bool loserIsPlayerOne)
{
    if (!m_match || !m_match->gameOverState().isOver) return;

    m_match->appendGameOverLineAndMark(
        (cause == GameOverCause::Resignation) ? MatchCoordinator::Cause::Resignation
                                              : MatchCoordinator::Cause::Timeout,
        loserIsPlayerOne ? MatchCoordinator::P1 : MatchCoordinator::P2);

    // UI 後処理は従来通り
    if (m_shogiView) m_shogiView->update();
    if (m_recordPane) {
        if (auto* view = m_recordPane->kifuView()) {
            view->setSelectionMode(QAbstractItemView::SingleSelection);
        }
    }
    setReplayMode(true);
    exitLiveAppendMode_();
}

void MainWindow::appendKifuLine(const QString& text, const QString& elapsedTime)
{
    // KIF 追記の既存フローに合わせて m_lastMove を経由し、updateGameRecord() を1回だけ呼ぶ
    m_lastMove = text;

    // ここで棋譜へ 1 行追加（手数インクリメントやモデル反映は updateGameRecord が面倒を見る）
    updateGameRecord(elapsedTime);

    // 二重追記防止のためクリア
    m_lastMove.clear();
}

void MainWindow::ensureGameInfoTable()
{
    if (m_gameInfoTable) return;

    m_gameInfoTable = new QTableWidget(m_central);
    m_gameInfoTable->setColumnCount(2);
    m_gameInfoTable->setHorizontalHeaderLabels({ tr("項目"), tr("内容") });
    m_gameInfoTable->horizontalHeader()->setStretchLastSection(true);
    m_gameInfoTable->verticalHeader()->setVisible(false);
    m_gameInfoTable->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_gameInfoTable->setSelectionMode(QAbstractItemView::NoSelection);
    m_gameInfoTable->setWordWrap(true);
    m_gameInfoTable->setShowGrid(false);
}

void MainWindow::syncBoardAndHighlightsAtRow(int ply)
{
    // 位置編集モード中は従来どおりスキップ
    if (m_shogiView && m_shogiView->positionEditMode()) {
        qDebug() << "[UI] syncBoardAndHighlightsAtRow skipped (edit-mode). ply=" << ply;
        return;
    }

    ensureBoardSyncPresenter_();
    if (m_boardSync) {
        m_boardSync->syncBoardAndHighlightsAtRow(ply);
    }

    // 旧コードが行っていた「矢印ボタンの活性化」等の軽いUIは残す
    enableArrowButtons();
}

void MainWindow::applyResolvedRowAndSelect(int row, int selPly)
{
    if (!m_kifuLoadCoordinator) return;

    // 状態の差し替え（disp/sfen/gm）と Presenter 更新は Coordinator 側の責務
    m_kifuLoadCoordinator->applyResolvedRowAndSelect(row, selPly);
}

void MainWindow::BranchRowDelegate::paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const
{
    QStyleOptionViewItem opt(option);
    QStyledItemDelegate::initStyleOption(&opt, index);

    const bool isBranchable = (m_marks && m_marks->contains(index.row()));

    // 選択時のハイライトと衝突しないように、未選択時のみオレンジ背景
    if (isBranchable && !(opt.state & QStyle::State_Selected)) {
        painter->save();
        painter->fillRect(opt.rect, QColor(255, 220, 160));
        painter->restore();
    }

    QStyledItemDelegate::paint(painter, opt, index);
}

// --- INavigationContext の実装 ---
bool MainWindow::hasResolvedRows() const
{
    return !m_resolvedRows.isEmpty();
}

int MainWindow::resolvedRowCount() const
{
    return m_resolvedRows.size();
}

int MainWindow::activeResolvedRow() const
{
    return m_activeResolvedRow;
}

int MainWindow::maxPlyAtRow(int row) const
{
    if (m_resolvedRows.isEmpty()) {
        // ライブ（解決済み行なし）のとき：
        // - SFEN: 「開始局面 + 実手数」なので終局行（投了/時間切れ）は含まれない → size()-1
        // - 棋譜欄: 「実手 + 終局行（あれば）」が入る → rowCount()-1
        // 末尾へ進める上限は「どちらか大きい方」を採用する。
        const int sfenMax = (m_sfenRecord && !m_sfenRecord->isEmpty())
                                ? (m_sfenRecord->size() - 1)
                                : 0;
        const int kifuMax = (m_kifuRecordModel && m_kifuRecordModel->rowCount() > 0)
                                ? (m_kifuRecordModel->rowCount() - 1)
                                : 0;
        return qMax(sfenMax, kifuMax);
    }

    // 既に解決済み行がある（棋譜ファイル読み込み後など）のとき：
    // その行に表示するエントリ数（disp.size()）が末尾。
    const int clamped = qBound(0, row, m_resolvedRows.size() - 1);
    return m_resolvedRows[clamped].disp.size();
}

int MainWindow::currentPly() const
{
    // ★ リプレイ／再開（ライブ追記）中は UI 側のトラッキング値を優先
    if (m_isLiveAppendMode) {
        if (m_currentSelectedPly >= 0) return m_currentSelectedPly;

        // 念のためビューの currentIndex もフォールバックに
        const QTableView* view = (m_recordPane ? m_recordPane->kifuView() : nullptr);
        if (view) {
            const QModelIndex cur = view->currentIndex();
            if (cur.isValid()) return qMax(0, cur.row());
        }
        return 0;
    }

    // 通常時は従来通り m_activePly を優先
    if (m_activePly >= 0) return m_activePly;

    const QTableView* view = (m_recordPane ? m_recordPane->kifuView() : nullptr);
    if (view) {
        const QModelIndex cur = view->currentIndex();
        if (cur.isValid()) return qMax(0, cur.row());
    }
    return 0;
}

void MainWindow::applySelect(int row, int ply)
{
    // ライブ append 中 or 解決済み行が未構築のときは
    // → 表の選択を直接動かして局面・ハイライトを同期
    if (m_isLiveAppendMode || m_resolvedRows.isEmpty()) {
        if (m_recordPane && m_kifuRecordModel) {
            if (QTableView* view = m_recordPane->kifuView()) {
                const int rows = m_kifuRecordModel->rowCount();
                const int safe = (rows > 0) ? qBound(0, ply, rows - 1) : 0;

                const QModelIndex idx = m_kifuRecordModel->index(safe, 0);
                if (idx.isValid()) {
                    if (auto* sel = view->selectionModel()) {
                        sel->setCurrentIndex(
                            idx, QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);
                    } else {
                        view->setCurrentIndex(idx);
                    }
                    view->scrollTo(idx, QAbstractItemView::PositionAtCenter);
                }

                // 盤・ハイライト即時同期（従来の onMainMoveRowChanged と同じ流れ）
                syncBoardAndHighlightsAtRow(safe);

                // ★ 修正点：currentPly() のベースになるトラッキングを更新
                m_activePly          = safe;   // ← 追加
                m_currentSelectedPly = safe;
                m_currentMoveIndex   = safe;
            }
        }
        return;
    }

    // 通常（KIF再生/分岐再生）ルート
    applyResolvedRowAndSelect(row, ply);
}

void MainWindow::setupRecordPane()
{
    // モデルの用意（従来どおり）
    if (!m_kifuRecordModel) m_kifuRecordModel = new KifuRecordListModel(this);
    if (!m_kifuBranchModel) m_kifuBranchModel = new KifuBranchListModel(this);

    // Wiring の生成
    if (!m_recordPaneWiring) {
        RecordPaneWiring::Deps d;
        d.parent      = m_central;                               // 親ウィジェット
        d.ctx         = this;                                    // RecordPane::mainRowChanged の受け先
        d.navCtx      = dynamic_cast<INavigationContext*>(this); // NavigationController 用
        d.recordModel = m_kifuRecordModel;
        d.branchModel = m_kifuBranchModel;

        m_recordPaneWiring = new RecordPaneWiring(d, this);
    }

    // RecordPane の構築と配線
    m_recordPaneWiring->buildUiAndWire();

    // 生成物の取得
    m_recordPane = m_recordPaneWiring->pane();
    m_nav        = m_recordPaneWiring->nav(); // 既存コードで m_nav を使う場合に備えて保持

    // レイアウト用（右側ペインとして使用）
    m_gameRecordLayoutWidget = m_recordPane;
}

void MainWindow::setupEngineAnalysisTab()
{
    // 既に配線クラスがあれば再利用し、タブ取得だけを行う
    if (!m_analysisWiring) {
        AnalysisTabWiring::Deps d;
        d.centralParent = m_central;         // 既存の central エリア
        d.log1          = m_lineEditModel1;  // USIログ(先手)
        d.log2          = m_lineEditModel2;  // USIログ(後手)

        m_analysisWiring = new AnalysisTabWiring(d, this);
        m_analysisWiring->buildUiAndWire();
    }

    // 配線クラスから出来上がった部品を受け取る（MainWindow の既存フィールドへ反映）
    m_analysisTab    = m_analysisWiring->analysisTab();
    m_tab            = m_analysisWiring->tab();
    m_modelThinking1 = m_analysisWiring->thinking1();
    m_modelThinking2 = m_analysisWiring->thinking2();

    Q_ASSERT(m_analysisTab && m_tab && m_modelThinking1 && m_modelThinking2);

    // 分岐ツリーのアクティベートを MainWindow スロットへ（ラムダ不使用）
    QObject::connect(
        m_analysisTab, &EngineAnalysisTab::branchNodeActivated,
        this,          &MainWindow::onBranchNodeActivated_,
        Qt::UniqueConnection);
}

// src/app/mainwindow.cpp
void MainWindow::initMatchCoordinator()
{
    // 依存が揃っていない場合は何もしない
    if (!m_gameController || !m_shogiView) return;

    // まず時計を用意（nullでも可だが、あれば渡す）
    ensureClockReady_();

    using std::placeholders::_1;
    using std::placeholders::_2;

    // --- MatchCoordinator::Deps を構築（UI hooks は従来どおりここで設定） ---
    MatchCoordinator::Deps d;
    d.gc    = m_gameController;
    d.clock = m_shogiClock;
    d.view  = m_shogiView;
    d.usi1  = m_usi1;
    d.usi2  = m_usi2;

    // （EvE 用）ログ／思考モデル
    d.comm1  = m_lineEditModel1;
    d.think1 = m_modelThinking1;
    d.comm2  = m_lineEditModel2;
    d.think2 = m_modelThinking2;

    // ★Presenterと同じリストを渡す（Single Source of Truth）
    d.sfenRecord = m_sfenRecord;

    // ---- ここは「コメントアウト」せず、関数バインドで割り当て ----
    d.hooks.appendEvalP1       = std::bind(&MainWindow::requestRedrawEngine1Eval_, this);
    d.hooks.appendEvalP2       = std::bind(&MainWindow::requestRedrawEngine2Eval_, this);
    d.hooks.sendGoToEngine     = std::bind(&MatchCoordinator::sendGoToEngine,   m_match, _1, _2);
    d.hooks.sendStopToEngine   = std::bind(&MatchCoordinator::sendStopToEngine, m_match, _1);
    d.hooks.sendRawToEngine    = std::bind(&MatchCoordinator::sendRawToEngine,  m_match, _1, _2);
    d.hooks.initializeNewGame  = std::bind(&MainWindow::initializeNewGame_, this, _1);
    d.hooks.showMoveHighlights = std::bind(&MainWindow::showMoveHighlights_, this, _1, _2);
    d.hooks.appendKifuLine     = std::bind(&MainWindow::appendKifuLineHook_, this, _1, _2);

    // ★ 追加（今回の肝）：結果ダイアログ表示フックを配線
    d.hooks.showGameOverDialog = std::bind(&MainWindow::showGameOverMessageBox_, this, _1, _2);

    // ★★ 追加：時計から「残り/増加/秒読み」を司令塔へ提供するフックを配線
    d.hooks.remainingMsFor = std::bind(&MainWindow::getRemainingMsFor_, this, _1);
    d.hooks.incrementMsFor = std::bind(&MainWindow::getIncrementMsFor_, this, _1);
    d.hooks.byoyomiMs      = std::bind(&MainWindow::getByoyomiMs_, this);

    // --- GameStartCoordinator の確保（1 回だけ） ---
    if (!m_gameStartCoordinator) {
        GameStartCoordinator::Deps gd;
        gd.match = nullptr;
        gd.clock = m_shogiClock;
        gd.gc    = m_gameController;
        gd.view  = m_shogiView;

        m_gameStartCoordinator = new GameStartCoordinator(gd, this);

        // ★ Coordinator の転送シグナルを MainWindow のスロットへ接続
        // timeUpdated
        if (m_timeConn) { QObject::disconnect(m_timeConn); m_timeConn = {}; }
        m_timeConn = connect(
            m_gameStartCoordinator,
            static_cast<void (GameStartCoordinator::*)(qint64,qint64,bool,qint64)>(&GameStartCoordinator::timeUpdated),
            m_timePresenter, &TimeDisplayPresenter::onMatchTimeUpdated,
            Qt::UniqueConnection);

        // requestAppendGameOverMove
        connect(m_gameStartCoordinator, &GameStartCoordinator::requestAppendGameOverMove,
                this,                   &MainWindow::onRequestAppendGameOverMove,
                Qt::UniqueConnection);

        // boardFlipped
        connect(m_gameStartCoordinator, &GameStartCoordinator::boardFlipped,
                this,                   &MainWindow::onBoardFlipped,
                Qt::UniqueConnection);

        // gameOverStateChanged
        connect(m_gameStartCoordinator, &GameStartCoordinator::gameOverStateChanged,
                this,                   &MainWindow::onGameOverStateChanged,
                Qt::UniqueConnection);

        // gameEnded → onMatchGameEnded
        connect(
            m_gameStartCoordinator,
            static_cast<void (GameStartCoordinator::*)(const MatchCoordinator::GameEndInfo&)>(&GameStartCoordinator::matchGameEnded),
            this,
            static_cast<void (MainWindow::*)(const MatchCoordinator::GameEndInfo&)>(&MainWindow::onMatchGameEnded),
            Qt::UniqueConnection);
    }

    // --- 司令塔の生成＆初期配線を Coordinator に委譲 ---
    m_match = m_gameStartCoordinator->createAndWireMatch(d, this);

    // PlayMode を司令塔へ伝達（従来どおり）
    if (m_match) {
        m_match->setPlayMode(m_playMode);
    }

    // ★★ UNDO 用バインディング（今回の修正点）★★
    if (m_match) {
        MatchCoordinator::UndoRefs u;
        u.recordModel      = m_kifuRecordModel;      // 棋譜テーブルのモデル
        u.gameMoves        = &m_gameMoves;           // 内部の着手配列
        u.positionStrList  = &m_positionStrList;     // "position ..." 履歴（あれば）
        u.sfenRecord       = m_sfenRecord;           // SFEN の履歴（Presenterと同一）
        u.currentMoveIndex = &m_currentMoveIndex;    // 現在手数（0起点）
        u.gc               = m_gameController;       // 盤ロジック
        u.boardCtl         = m_boardController;      // ハイライト消去など（null可）
        u.clock            = m_shogiClock;           // 時計（null可）
        u.view             = m_shogiView;            // クリック可否の切替

        MatchCoordinator::UndoHooks h;
        h.getMainRowGuard                 = std::bind(&MainWindow::getMainRowGuard_, this);
        h.setMainRowGuard                 = std::bind(&MainWindow::setMainRowGuard_, this, _1);
        h.updateHighlightsForPly          = std::bind(&MainWindow::syncBoardAndHighlightsAtRow, this, _1);
        h.updateTurnAndTimekeepingDisplay = std::bind(&MainWindow::updateTurnAndTimekeepingDisplay_, this);
        // 評価値などの巻戻しが必要なら将来ここに追加：
        // h.handleUndoMove               = std::bind(&MainWindow::onUndoMove_, this, _1);
        h.isHumanSide                     = std::bind(&MainWindow::isHumanSide_, this, _1);
        h.isHvH                           = std::bind(&MainWindow::isHvH_, this);

        m_match->setUndoBindings(u, h);
    }

    // Clock → MainWindow のタイムアウト系は従来どおり UI 側で受ける
    if (m_shogiClock) {
        connect(m_shogiClock, &ShogiClock::player1TimeOut,
                this, &MainWindow::onPlayer1TimeOut, Qt::UniqueConnection);
        connect(m_shogiClock, &ShogiClock::player2TimeOut,
                this, &MainWindow::onPlayer2TimeOut, Qt::UniqueConnection);
        connect(m_shogiClock, &ShogiClock::resignationTriggered,
                this, &MainWindow::onResignationTriggered, Qt::UniqueConnection);
    }

    // 盤クリックの配線
    connectBoardClicks_();

    // 人間操作 → 合法判定＆適用の配線
    connectMoveRequested_();

    // 既定モード（必要に応じて開始時に上書き）
    if (m_boardController)
        m_boardController->setMode(BoardInteractionController::Mode::HumanVsHuman);
}

void MainWindow::ensureClockReady_()
{
    if (m_shogiClock) return;

    m_shogiClock = new ShogiClock(this);

    // ★ ここでは timeUpdated を m_match に接続しない
    //    （接続は wireMatchSignals_() に一本化）

    connect(m_shogiClock, &ShogiClock::player1TimeOut,
            this, &MainWindow::onPlayer1TimeOut, Qt::UniqueConnection);
    connect(m_shogiClock, &ShogiClock::player2TimeOut,
            this, &MainWindow::onPlayer2TimeOut, Qt::UniqueConnection);
}

void MainWindow::onMatchGameEnded(const MatchCoordinator::GameEndInfo& info)
{
    qDebug().nospace()
    << "[UI] onMatchGameEnded ENTER cause="
    << ((info.cause==MatchCoordinator::Cause::Timeout)?"Timeout":"Resign")
    << " loser=" << ((info.loser==MatchCoordinator::P1)?"P1":"P2");

    // --- UI 後始末（UI層に残す） ---
    if (m_match)      m_match->disarmHumanTimerIfNeeded();
    if (m_shogiClock) m_shogiClock->stopClock();
    if (m_shogiView)  m_shogiView->setMouseClickMode(false);

    // --- 棋譜追記＋時間確定は司令塔へ一括委譲 ---
    const bool loserIsP1 = (info.loser == MatchCoordinator::P1);
    setGameOverMove(toUiCause(info.cause), /*loserIsPlayerOne=*/loserIsP1);

    // --- UIの後処理（矢印ボタン・選択モード整え） ---
    enableArrowButtons();
    if (m_recordPane && m_recordPane->kifuView()) {
        m_recordPane->kifuView()->setSelectionMode(QAbstractItemView::SingleSelection);
    }

    qDebug() << "[UI] onMatchGameEnded LEAVE";
}

void MainWindow::onActionFlipBoardTriggered(bool /*checked*/)
{
    if (m_match) m_match->flipBoard();
}

void MainWindow::onRequestAppendGameOverMove(const MatchCoordinator::GameEndInfo& info)
{
    const bool loserIsP1 = (info.loser == MatchCoordinator::P1);
    setGameOverMove(toUiCause(info.cause), loserIsP1);
}

void MainWindow::setupBoardInteractionController()
{
    // 既存があれば入れ替え
    if (m_boardController) {
        m_boardController->deleteLater();
        m_boardController = nullptr;
    }

    // コントローラ生成
    m_boardController = new BoardInteractionController(m_shogiView, m_gameController, this);

    // 盤クリックの配線
    connectBoardClicks_();

    // 人間操作 → 合法判定＆適用の配線
    connectMoveRequested_();

    // 既定モード（必要に応じて開始時に上書き）
    m_boardController->setMode(BoardInteractionController::Mode::HumanVsHuman);
}

void MainWindow::connectBoardClicks_()
{
    Q_ASSERT(m_shogiView && m_boardController);

    QObject::connect(m_shogiView, &ShogiView::clicked,
                     m_boardController, &BoardInteractionController::onLeftClick,
                     Qt::UniqueConnection);

    QObject::connect(m_shogiView, &ShogiView::rightClicked,
                     m_boardController, &BoardInteractionController::onRightClick,
                     Qt::UniqueConnection);
}

void MainWindow::connectMoveRequested_()
{
    Q_ASSERT(m_boardController && m_gameController);

    QObject::connect(
        m_boardController, &BoardInteractionController::moveRequested,
        this,              &MainWindow::onMoveRequested_,
        Qt::UniqueConnection);
}

void MainWindow::onMoveRequested_(const QPoint& from, const QPoint& to)
{
    qInfo() << "[UI] onMoveRequested_ from=" << from << " to=" << to
            << " m_playMode=" << int(m_playMode);

    // --- 編集モードは Controller へ丸投げ ---
    if (m_boardController && m_boardController->mode() == BoardInteractionController::Mode::Edit) {
        ensurePositionEditController_();
        if (!m_posEdit || !m_shogiView || !m_gameController) return;

        const bool ok = m_posEdit->applyEditMove(from, to, m_shogiView, m_gameController, m_boardController);
        if (!ok) qInfo() << "[UI] editPosition failed (edit-mode move rejected)";
        return;
    }

    // ▼▼▼ 通常対局 ▼▼▼
    if (!m_gameController) {
        qWarning() << "[UI][WARN] m_gameController is null";
        return;
    }

    PlayMode matchMode = (m_match ? m_match->playMode() : NotStarted);
    PlayMode modeNow   = (m_playMode != NotStarted) ? m_playMode : matchMode;

    qInfo() << "[UI] effective modeNow=" << int(modeNow)
            << "(ui m_playMode=" << int(m_playMode) << ", matchMode=" << int(matchMode) << ")";

    // 着手前の手番（HvH/HvE 後処理で使用）
    const auto moverBefore = m_gameController->currentPlayer();

    // validateAndMove は参照引数なのでローカルに退避
    QPoint hFrom = from, hTo = to;

    // ★ 次の着手番号は「記録サイズ」を信頼する（既存ロジックのまま）
    const int recSizeBefore = (m_sfenRecord ? m_sfenRecord->size() : 0);
    const int nextIdx       = qMax(1, recSizeBefore);

    // ここで合法判定＆盤面反映。m_lastMove に「▲７六歩」のような整形済み文字列がセットされる
    const bool ok = m_gameController->validateAndMove(
        hFrom, hTo, m_lastMove, modeNow, const_cast<int&>(nextIdx), m_sfenRecord, m_gameMoves);

    if (m_boardController) m_boardController->onMoveApplied(hFrom, hTo, ok);
    if (!ok) {
        qInfo() << "[UI] validateAndMove failed (human move rejected)";
        return;
    }

    // UI 側の現在カーソルは、常に「記録サイズ」に同期させる
    if (m_sfenRecord) {
        m_currentMoveIndex = m_sfenRecord->size() - 1; // 末尾（直近の局面）
    }

    // --- 対局モードごとの後処理 ---
    switch (modeNow) {
    case HumanVsHuman: {
        qInfo() << "[UI] HvH: delegate post-human-move to MatchCoordinator";
        if (m_match) {
            // 直前手の考慮msを ShogiClock へ確定（MatchCoordinator 側で行う）
            m_match->onHumanMove_HvH(moverBefore);
        }

        // ★ 追加：HvH でも「指し手＋考慮時間」を棋譜欄に追記する
        // MatchCoordinator::onHumanMove_HvH() で直前手の考慮時間を ShogiClock に確定済み。
        QString elapsed;
        if (m_shogiClock) {
            elapsed = (moverBefore == ShogiGameController::Player1)
            ? m_shogiClock->getPlayer1ConsiderationAndTotalTime()
            : m_shogiClock->getPlayer2ConsiderationAndTotalTime();
        } else {
            ensureClockReady_();
            elapsed = QStringLiteral("00:00/00:00:00"); // フォールバック
        }

        // m_lastMove（validateAndMoveで得た表示用文字列）＋ elapsed を1行追記
        updateGameRecord(elapsed);
        break;
    }

    case EvenHumanVsEngine:
    case HandicapHumanVsEngine:
    case EvenEngineVsHuman:
    case HandicapEngineVsHuman:
        if (m_match) {
            qInfo() << "[UI] HvE: forwarding to MatchCoordinator::onHumanMove_HvE";
            m_match->onHumanMove_HvE(hFrom, hTo, m_lastMove);
        }
        break;

    default:
        qInfo() << "[UI] not a live play mode; skip post-handling";
        break;
    }
}

// 再生モードの切替を MainWindow 内で一元管理
void MainWindow::setReplayMode(bool on)
{
    m_isReplayMode = on;

    // 再生中は時計を止め、表示だけ整える
    if (m_shogiClock) {
        m_shogiClock->stopClock();
        m_shogiClock->updateClock(); // 表示だけは最新化
    }
    if (m_match) {
        m_match->pokeTimeUpdateNow(); // 残時間ラベル等の静的更新だけ反映
    }

    // ★ 再生モードの入/出でハイライト方針を切替
    if (m_shogiView) {
        m_shogiView->setUiMuted(on);
        if (on) {
            m_shogiView->clearTurnHighlight();   // 中立に
        } else {
            // 対局に戻る: 現手番・残時間から再適用
            const bool p1turn = (m_gameController &&
                                 m_gameController->currentPlayer() == ShogiGameController::Player1);
            // ★ enum ではなく bool を渡す（true = 先手手番）
            m_shogiView->setActiveSide(p1turn);  // or setBlackActive(p1turn); ※ヘッダに合わせて

            // ★ Urgency は時計側の更新イベントで再適用させる
            if (m_shogiClock) {
                m_shogiClock->updateClock();   // timeUpdated が飛び、既存の結線で applyClockUrgency が呼ばれる想定
            }
        }
    }
}

void MainWindow::broadcastComment(const QString& text, bool asHtml)
{
    if (asHtml) {
        // ★ 「*の手前で改行」＋「URLリンク化」付きのHTMLに整形して配信
        const QString html = toRichHtmlWithStarBreaksAndLinks(text);
        if (m_analysisTab) m_analysisTab->setCommentHtml(html);
        if (m_recordPane)  m_recordPane->setBranchCommentHtml(html);
    } else {
        // プレーンテキスト経路は従来通り
        if (m_analysisTab) m_analysisTab->setCommentText(text);
        if (m_recordPane)  m_recordPane->setBranchCommentText(text);
    }
}

std::pair<int,int> MainWindow::resolveBranchHighlightTarget(int row, int ply) const
{
    if (!m_varEngine) return {-1, -1};
    if (row < 0 || row >= m_resolvedRows.size() || ply < 0) return {-1, -1};

    const ResolvedRow& rr = m_resolvedRows[row];

    // Main 行（varIndex < 0）は常に vid=0（本譜）
    if (rr.varIndex < 0) {
        return { 0, ply };
    }

    // 親行（無ければ Main=0）
    const int parentRow =
        (rr.parent >= 0 && rr.parent < m_resolvedRows.size()) ? rr.parent : 0;

    // 分岐前の手は親行の vid でハイライト
    if (ply < rr.startPly) {
        return resolveBranchHighlightTarget(parentRow, ply);
    }

    // 分岐以降は当該分岐の vid（sourceIndex -> variationId）
    const int vid = m_varEngine->variationIdFromSourceIndex(rr.varIndex);
    if (vid < 0) {
        // 念のためフォールバック
        return resolveBranchHighlightTarget(parentRow, ply);
    }
    return { vid, ply };
}

void MainWindow::onBranchNodeActivated_(int row, int ply)
{
    if (row < 0 || row >= m_resolvedRows.size()) return;

    // その行の手数内にクランプ（0=開始局面, 1..N）
    const int maxPly = m_resolvedRows[row].disp.size();
    const int selPly = qBound(0, ply, maxPly);

    // これだけで：局面更新 / 棋譜欄差し替え＆選択 / 分岐候補欄更新 / ツリーハイライト同期
    applyResolvedRowAndSelect(row, selPly);
}

// 毎手の着手確定時：ライブ分岐ツリー更新をイベントループ後段に遅延
void MainWindow::onMoveCommitted(ShogiGameController::Player mover, int /*ply*/)
{
    // 1) いまは即時呼び出しを行わず、0ms 遅延で呼ぶ
    QTimer::singleShot(0, this, &MainWindow::refreshBranchTreeLive_);

    // 2) （従来通り）EvE の評価グラフだけは維持
    const bool isEvE =
        (m_playMode == EvenEngineVsEngine) ||
        (m_playMode == HandicapEngineVsEngine);

    if (isEvE) {
        if (mover == ShogiGameController::Player1) {
            redrawEngine1EvaluationGraph();
        } else if (mover == ShogiGameController::Player2) {
            redrawEngine2EvaluationGraph();
        }
    }
}

void MainWindow::flipBoardAndUpdatePlayerInfo()
{
    qDebug() << "[UI] flipBoardAndUpdatePlayerInfo ENTER";
    if (!m_shogiView) return;

    // 盤の表示向きをトグル
    const bool flipped = !m_shogiView->getFlipMode();
    m_shogiView->setFlipMode(flipped);
    if (flipped) m_shogiView->setPiecesFlip();
    else         m_shogiView->setPieces();

    // ★ 手番強調/緊急度は Presenter に再適用してもらう
    if (m_timePresenter) {
        m_timePresenter->onMatchTimeUpdated(
            m_lastP1Ms, m_lastP2Ms, m_lastP1Turn, /*urgencyMs(未使用)*/ 0);
    }

    m_shogiView->update();
    qDebug() << "[UI] flipBoardAndUpdatePlayerInfo LEAVE";
}

void MainWindow::setupNameAndClockFonts_()
{
    if (!m_shogiView) return;
    auto* n1 = m_shogiView->blackNameLabel();
    auto* n2 = m_shogiView->whiteNameLabel();
    auto* c1 = m_shogiView->blackClockLabel();
    auto* c2 = m_shogiView->whiteClockLabel();
    if (!n1 || !n2 || !c1 || !c2) return;

    // 例：等幅は環境依存のため FixedFont をベースに
    QFont nameFont = QFontDatabase::systemFont(QFontDatabase::GeneralFont);
    nameFont.setPointSize(12);         // お好みで
    nameFont.setWeight(QFont::DemiBold);

    QFont clockFont = QFontDatabase::systemFont(QFontDatabase::FixedFont);
    clockFont.setPointSize(16);        // お好みで
    clockFont.setWeight(QFont::DemiBold);

    n1->setFont(nameFont);
    n2->setFont(nameFont);
    c1->setFont(clockFont);
    c2->setFont(clockFont);
}

// 盤反転の通知を受けたら、手前が先手かどうかのフラグをトグル
void MainWindow::onBoardFlipped(bool /*flipped*/)
{
    m_bottomIsP1 = !m_bottomIsP1;

    // （必要なら）プレイヤー名や駒台ラベルの入れ替えなど既存処理をここに
    flipBoardAndUpdatePlayerInfo();
}

void MainWindow::onGameOverStateChanged(const MatchCoordinator::GameOverState& st)
{
    // 司令塔が isOver / Cause / KIF一行追記 まで面倒を見る前提
    if (!st.isOver) return;

    // UI 遷移（閲覧モードへ）
    enableArrowButtons();
    setReplayMode(true);

    // ハイライト消去
    if (m_shogiView) {
        m_shogiView->removeHighlightAllData();
    }
}

void MainWindow::handleBreakOffGame()
{
    if (!m_match || m_match->gameOverState().isOver) return;
    m_match->handleBreakOff();
}

void MainWindow::exitLiveAppendMode_()
{
    m_isLiveAppendMode = false;
    if (!m_recordPane) return;
    if (auto* view = m_recordPane->kifuView()) {
        view->setSelectionMode(QAbstractItemView::SingleSelection);
        view->setFocusPolicy(Qt::StrongFocus);
    }
}

// 「検討を終了」アクション用：エンジンに quit を送り検討セッションを終了
void MainWindow::handleBreakOffConsidaration()
{
    if (!m_match) return;

    // 司令塔に依頼（内部で quit 送信→プロセス/Usi 破棄→モード NotStarted）
    m_match->handleBreakOffConsidaration();

    // UI の後始末（任意）——検討のハイライトなどをクリアしておく
    if (m_shogiView) m_shogiView->removeHighlightAllData();

    // MainWindow 側のモードも念のため合わせる（UI 表示に依存がある場合）
    m_playMode = NotStarted;

    // 盤下のエンジン名表示などを通常状態へ（関数がある場合）
    setEngineNamesBasedOnMode();

    // ここでは UI の大規模リセットは行わず、検討終了の状態だけ示す
    if (statusBar()) {
        statusBar()->showMessage(tr("検討を中断しました（エンジンに quit を送信）。"), 3000);
    }
}

void MainWindow::ensureTurnSyncBridge_()
{
    auto* gc = m_gameController;
    auto* tm = findChild<TurnManager*>("TurnManager");
    if (!gc || !tm) return;

    TurnSyncBridge::wire(gc, tm, this);
}

static inline QString fwColonLine(const QString& key, const QString& val)
{
    // 全角コロン「：」で連結（読込側がこの形を期待）
    return QStringLiteral("%1：%2").arg(key, val);
}

void MainWindow::ensurePositionEditController_()
{
    if (m_posEdit) return;
    m_posEdit = new PositionEditController(this); // 親=MainWindow にして寿命管理
}

void MainWindow::ensureBoardSyncPresenter_()
{
    if (m_boardSync) return;

    BoardSyncPresenter::Deps d;
    d.gc         = m_gameController;
    d.view       = m_shogiView;
    d.bic        = m_boardController;
    d.sfenRecord = m_sfenRecord;
    d.gameMoves  = &m_gameMoves;

    m_boardSync = new BoardSyncPresenter(d, this);
}

void MainWindow::ensureAnalysisPresenter_()
{
    if (!m_analysisPresenter)
        m_analysisPresenter = new AnalysisResultsPresenter(this);
}

void MainWindow::ensureGameStartCoordinator_()
{
    if (m_gameStart) return;

    GameStartCoordinator::Deps d;
    d.match = m_match;
    d.clock = m_shogiClock;
    d.gc    = m_gameController;
    d.view  = m_shogiView;

    m_gameStart = new GameStartCoordinator(d, this);

    // 依頼シグナルを既存メソッドへ接続（ラムダ不使用）
    connect(m_gameStart, &GameStartCoordinator::requestPreStartCleanup,
            this, &MainWindow::onPreStartCleanupRequested_);

    connect(m_gameStart, &GameStartCoordinator::requestApplyTimeControl,
            this, &MainWindow::onApplyTimeControlRequested_);
}

void MainWindow::onPreStartCleanupRequested_()
{
    // --- 盤/ハイライト等のビジュアル初期化 ---
    if (m_boardController) {
        m_boardController->clearAllHighlights();
    }
    if (m_shogiView) {
        m_shogiView->blackClockLabel()->setText(QStringLiteral("00:00:00"));
        m_shogiView->whiteClockLabel()->setText(QStringLiteral("00:00:00"));
    }

    // --- 「現在の局面」から開始かどうかを判定 ---
    // 既存実装では 2局目開始直前に m_startSfenStr を明示クリア、
    // m_currentSfenStr に選択行の SFEN を入れているため、
    // これをトリガとして判定する。
    const bool startFromCurrentPos =
        m_startSfenStr.trimmed().isEmpty() && !m_currentSfenStr.trimmed().isEmpty();

    // 安全な keepRow（保持したい最終行＝選択中の行）を算出
    int keepRow = qMax(0, m_currentSelectedPly);

    // --- 棋譜モデルの扱い（ここが今回の修正ポイント） ---
    if (m_kifuRecordModel) {
        if (startFromCurrentPos) {
            // 1) 1局目の途中までを残して、末尾だけを削除
            const int rows = m_kifuRecordModel->rowCount();
            if (rows <= 0) {
                // 空なら見出しだけ用意
                m_kifuRecordModel->appendItem(
                    new KifuDisplay(QStringLiteral("=== 開始局面 ==="),
                                    QStringLiteral("（１手 / 合計）")));
                keepRow = 0;
            } else {
                // keepRow をモデル範囲にクランプし、末尾の余剰行を一括削除
                if (keepRow > rows - 1) keepRow = rows - 1;
                const int toRemove = rows - (keepRow + 1);
                if (toRemove > 0) {
                    // QList の detach を避けつつ末尾からまとめて削除できる既存APIを使用
                    m_kifuRecordModel->removeLastItems(toRemove);
                }
            }
        } else {
            // 2) 平手/手合割など「新規初期局面から開始」のときは従来通り全消去
            m_kifuRecordModel->clearAllItems();
            // 見出し行を重複なく先頭へ
            m_kifuRecordModel->appendItem(
                new KifuDisplay(QStringLiteral("=== 開始局面 ==="),
                                QStringLiteral("（１手 / 合計）")));
            keepRow = 0;
        }
    }

    // --- 手数トラッキングの更新 ---
    if (startFromCurrentPos) {
        m_activePly          = keepRow;
        m_currentSelectedPly = keepRow;
        m_currentMoveIndex   = keepRow;
    } else {
        m_activePly          = 0;
        m_currentSelectedPly = 0;
        m_currentMoveIndex   = 0;
    }

    // --- 分岐モデルは新規対局としてクリア ---
    if (m_kifuBranchModel) {
        m_kifuBranchModel->clear();
    }
    m_branchDisplayPlan.clear();

    // --- コメント欄は見た目リセット（Presenter管理でも表示は空に）
    broadcastComment(QString(), /*asHtml=*/true);

    // --- USI ログの初期化（既存内容を踏襲） ---
    auto resetInfo = [](UsiCommLogModel* m) {
        if (!m) return;
        m->clear();
        m->setEngineName(QString());
        m->setPredictiveMove(QString());
        m->setSearchedMove(QString());
        m->setSearchDepth(QString());
        m->setNodeCount(QString());
        m->setNodesPerSecond(QString());
        m->setHashUsage(QString());
    };
    resetInfo(m_lineEditModel1);
    resetInfo(m_lineEditModel2);

    // --- タブ選択は先頭へ戻す（棋譜タブへ） ---
    if (m_tab) {
        m_tab->setCurrentIndex(0);
    }

    // デバッグログ
    qDebug().noquote()
        << "[MW] onPreStartCleanupRequested_: startFromCurrentPos=" << startFromCurrentPos
        << " keepRow=" << keepRow
        << " rows(after)=" << (m_kifuRecordModel ? m_kifuRecordModel->rowCount() : -1);
}

void MainWindow::onApplyTimeControlRequested_(const GameStartCoordinator::TimeControl& tc)
{
    qDebug().noquote()
    << "[MW] onApplyTimeControlRequested_:"
    << " enabled=" << tc.enabled
    << " P1{base=" << tc.p1.baseMs << " byoyomi=" << tc.p1.byoyomiMs << " inc=" << tc.p1.incrementMs << "}"
    << " P2{base=" << tc.p2.baseMs << " byoyomi=" << tc.p2.byoyomiMs << " inc=" << tc.p2.incrementMs << "}";

    // 1) まず時計に適用
    TimeControlUtil::applyToClock(m_shogiClock, tc, m_startSfenStr, m_currentSfenStr);

    // 2) 司令塔へも必ず反映（これが無いと computeGoTimes_ が byoyomi を使いません）
    if (m_match) {
        const bool useByoyomi = (tc.p1.byoyomiMs > 0) || (tc.p2.byoyomiMs > 0);

        // byoyomi を使う場合は inc は無視されます（司令塔側ロジックに合わせる）
        const qint64 byo1 = tc.p1.byoyomiMs;
        const qint64 byo2 = tc.p2.byoyomiMs;
        const qint64 inc1 = tc.p1.incrementMs;
        const qint64 inc2 = tc.p2.incrementMs;

        // 負け扱い（秒読みのみ運用でも true 推奨）
        const bool loseOnTimeout = true;

        qDebug().noquote()
            << "[MW] setTimeControlConfig to MatchCoordinator:"
            << " useByoyomi=" << useByoyomi
            << " byo1=" << byo1 << " byo2=" << byo2
            << " inc1=" << inc1 << " inc2=" << inc2
            << " loseOnTimeout=" << loseOnTimeout;

        m_match->setTimeControlConfig(useByoyomi, byo1, byo2, inc1, inc2, loseOnTimeout);
        // 反映直後に現在の go 用数値を再計算しておくと安全
        m_match->refreshGoTimes();
    }

    // 3) 表示更新
    if (m_shogiClock) {
        qDebug() << "[MW] clock after apply:"
                 << "P1=" << m_shogiClock->getPlayer1TimeIntMs()
                 << "P2=" << m_shogiClock->getPlayer2TimeIntMs()
                 << "byo=" << m_shogiClock->getCommonByoyomiMs()
                 << "binc=" << m_shogiClock->getBincMs()
                 << "winc=" << m_shogiClock->getWincMs();
        m_shogiClock->updateClock();
    }
    if (m_shogiView) m_shogiView->update();
}

void MainWindow::ensureRecordPresenter_()
{
    if (m_recordPresenter) return;

    GameRecordPresenter::Deps d;
    d.model      = m_kifuRecordModel;
    d.recordPane = m_recordPane;

    m_recordPresenter = new GameRecordPresenter(d, this);

    // Presenter → MainWindow：「現在行＋コメント」通知（新方式）
    QObject::connect(
        m_recordPresenter,
        &GameRecordPresenter::currentRowChanged,          // シグナル
        this,
        &MainWindow::onRecordRowChangedByPresenter,       // スロット
        Qt::UniqueConnection
        );
}

// UIスレッド安全のため queued 呼び出しにしています
void MainWindow::requestRedrawEngine1Eval_()
{
    QMetaObject::invokeMethod(this, &MainWindow::redrawEngine1EvaluationGraph, Qt::QueuedConnection);
}

void MainWindow::requestRedrawEngine2Eval_()
{
    QMetaObject::invokeMethod(this, &MainWindow::redrawEngine2EvaluationGraph, Qt::QueuedConnection);
}

void MainWindow::initializeNewGame_(const QString& s)
{
    // --- 司令塔からのコールバック：UI側の初期化のみ行う ---
    QString startSfenStr = s;              // initializeNewGame(QString&) が参照で受けるため可変にコピー

    // 盤モデルの初期化（従来の UI 側初期化）
    initializeNewGame(startSfenStr);

    // 盤の再描画・サイズ調整
    if (m_shogiView && m_gameController && m_gameController->board()) {
        m_shogiView->applyBoardAndRender(m_gameController->board());
        m_shogiView->configureFixedSizing();
    }

    // 表示名の更新（必要に応じて）
    setPlayersNamesForMode();
    setEngineNamesBasedOnMode();
}

void MainWindow::showMoveHighlights_(const QPoint& from, const QPoint& to)
{
    if (m_boardController) m_boardController->showMoveHighlights(from, to);
}

// ===== MainWindow.cpp: appendKifuLineHook_（ライブ分岐ツリー更新を追加） =====
void MainWindow::appendKifuLineHook_(const QString& text, const QString& elapsed)
{
    // 既存：棋譜欄へ 1手追記（Presenter がモデルへ反映）
    appendKifuLine(text, elapsed);

    // ★追加：HvH/HvE の「1手指すごと」に分岐ツリーを更新
    refreshBranchTreeLive_();
}

void MainWindow::onRecordRowChangedByPresenter(int row, const QString& comment)
{
    const int modelRowsBefore =
        (m_kifuRecordModel ? m_kifuRecordModel->rowCount() : -1);
    const int presenterCurBefore =
        (m_recordPresenter ? m_recordPresenter->currentRow() : -1);

    qDebug().noquote()
        << "[MW] onRecordRowChangedByPresenter ENTER"
        << " row=" << row
        << " comment.len=" << comment.size()
        << " modelRows(before)=" << modelRowsBefore
        << " presenter.cur(before)=" << presenterCurBefore
        << " tracking.before{ activePly=" << m_activePly
        << ", currentSelectedPly=" << m_currentSelectedPly
        << ", currentMoveIndex=" << m_currentMoveIndex << " }";

    // 盤面・ハイライト同期
    if (row >= 0) {
        qDebug().noquote() << "[MW] syncBoardAndHighlightsAtRow CALL row=" << row;
        syncBoardAndHighlightsAtRow(row);
        qDebug().noquote() << "[MW] syncBoardAndHighlightsAtRow DONE row=" << row;

        // ▼ 現在手数トラッキングを更新（NavigationController::next/prev 用）
        m_activePly          = row;   // ← これが無いと currentPly() が 0 のまま
        m_currentSelectedPly = row;
        m_currentMoveIndex   = row;

        qDebug().noquote()
            << "[MW] tracking UPDATED"
            << " activePly=" << m_activePly
            << " currentSelectedPly=" << m_currentSelectedPly
            << " currentMoveIndex=" << m_currentMoveIndex;

        // ▼ 分岐候補欄の更新は Coordinator へ直接委譲
        if (m_kifuLoadCoordinator) {
            const int rows        = m_resolvedRows.size();
            const int resolvedRow = (rows <= 0) ? 0 : qBound(0, m_activeResolvedRow, rows - 1);
            const int safePly     = (row < 0) ? 0 : row;

            qDebug().noquote()
                << "[MW] showBranchCandidates CALL"
                << " resolvedRows.size=" << rows
                << " activeResolvedRow=" << m_activeResolvedRow
                << " resolvedRow=" << resolvedRow
                << " safePly=" << safePly;

            m_kifuLoadCoordinator->showBranchCandidates(resolvedRow, safePly);

            qDebug().noquote() << "[MW] showBranchCandidates DONE";
        } else {
            qWarning().noquote() << "[MW] m_kifuLoadCoordinator is nullptr; skip showBranchCandidates";
        }
    } else {
        qWarning().noquote() << "[MW] row < 0; skip sync/tracking";
    }

    // コメント表示は既存の一括関数に統一
    const QString cmt = comment.trimmed();
    qDebug().noquote()
        << "[MW] broadcastComment"
        << " empty?=" << cmt.isEmpty()
        << " len=" << cmt.size();
    broadcastComment(cmt.isEmpty() ? tr("コメントなし") : cmt, /*asHtml=*/true);

    // 矢印ボタンなどの活性化（直前の状態を可視化）
    const int modelRowsAfter =
        (m_kifuRecordModel ? m_kifuRecordModel->rowCount() : -1);
    const int presenterCurAfter =
        (m_recordPresenter ? m_recordPresenter->currentRow() : -1);
    const bool canPrevComputed = (presenterCurAfter > 0);
    const bool canNextComputed = (modelRowsAfter >= 0) ? (presenterCurAfter < modelRowsAfter - 1) : false;

    qDebug().noquote()
        << "[MW] enableArrowButtons BEFORE"
        << " presenter.cur(after)=" << presenterCurAfter
        << " modelRows(after)=" << modelRowsAfter
        << " canPrev(computed)=" << canPrevComputed
        << " canNext(computed)=" << canNextComputed
        << " atLastRow?=" << (presenterCurAfter >= 0 && modelRowsAfter >= 0 && presenterCurAfter == modelRowsAfter - 1);

    enableArrowButtons();

    // ここでは UI の有効/無効を直接読めないため、計算値を再掲
    qDebug().noquote()
        << "[MW] enableArrowButtons AFTER (restate)"
        << " presenter.cur=" << presenterCurAfter
        << " modelRows=" << modelRowsAfter
        << " canPrev(computed)=" << canPrevComputed
        << " canNext(computed)=" << canNextComputed;

    qDebug().noquote() << "[MW] onRecordRowChangedByPresenter LEAVE";
}

void MainWindow::onFlowError_(const QString& msg)
{
    // 既存のエラー表示に委譲（UI 専用）
    displayErrorMessage(msg);
}

void MainWindow::onResignationTriggered()
{
    // 既存の投了処理に委譲（m_matchの有無は中で判定）
    handleResignation();
}

qint64 MainWindow::getRemainingMsFor_(MatchCoordinator::Player p) const
{
    if (!m_shogiClock) {
        qDebug() << "[MW] getRemainingMsFor_: clock=null";
        return 0;
    }
    const qint64 p1 = m_shogiClock->getPlayer1TimeIntMs();
    const qint64 p2 = m_shogiClock->getPlayer2TimeIntMs();
    qDebug() << "[MW] getRemainingMsFor_: P1=" << p1 << " P2=" << p2
             << " req=" << (p==MatchCoordinator::P1?"P1":"P2");
    return (p == MatchCoordinator::P1) ? p1 : p2;
}

qint64 MainWindow::getIncrementMsFor_(MatchCoordinator::Player p) const
{
    if (!m_shogiClock) {
        qDebug() << "[MW] getIncrementMsFor_: clock=null";
        return 0;
    }
    const qint64 inc1 = m_shogiClock->getBincMs();
    const qint64 inc2 = m_shogiClock->getWincMs();
    qDebug() << "[MW] getIncrementMsFor_: binc=" << inc1 << " winc=" << inc2
             << " req=" << (p==MatchCoordinator::P1?"P1":"P2");
    return (p == MatchCoordinator::P1) ? inc1 : inc2;
}

qint64 MainWindow::getByoyomiMs_() const
{
    const qint64 byo = m_shogiClock ? m_shogiClock->getCommonByoyomiMs() : 0;
    qDebug() << "[MW] getByoyomiMs_: ms=" << byo;
    return byo;
}

// 対局終了時のタイトルと本文を受け取り、情報ダイアログを表示するだけのヘルパ
void MainWindow::showGameOverMessageBox_(const QString& title, const QString& message)
{
    QMessageBox::information(this, title, message);
}

void MainWindow::onRecordPaneMainRowChanged_(int row)
{
    // フォールバック：起動直後など Loader 未生成時でも UI が動くように最低限の同期を行う
    if (row >= 0) {
        syncBoardAndHighlightsAtRow(row);

        // ★ 修正点：currentPly() のベースになるトラッキングを更新
        m_activePly          = row;  // ← 追加
        m_currentSelectedPly = row;
        m_currentMoveIndex   = row;
    }
    enableArrowButtons();
}

// ===== MainWindow.cpp: ライブ用の KifuLoadCoordinator を確保 =====
void MainWindow::ensureKifuLoadCoordinatorForLive_()
{
    if (m_kifuLoadCoordinator) {
        return; // 既に用意済み
    }

    // KIF読込時と同等の依存で生成（ロード自体はしない）
    m_kifuLoadCoordinator = new KifuLoadCoordinator(
        /* gameMoves           */ m_gameMoves,
        /* resolvedRows        */ m_resolvedRows,
        /* positionStrList     */ m_positionStrList,
        /* activeResolvedRow   */ m_activeResolvedRow,
        /* activePly           */ m_activePly,
        /* currentSelectedPly  */ m_currentSelectedPly,
        /* currentMoveIndex    */ m_currentMoveIndex,
        /* sfenRecord          */ m_sfenRecord,
        /* gameInfoTable       */ m_gameInfoTable,
        /* gameInfoDock        */ m_gameInfoDock,
        /* analysisTab         */ m_analysisTab,
        /* tab                 */ m_tab,
        /* shogiView           */ m_shogiView,
        /* recordPane          */ m_recordPane,
        /* kifuRecordModel     */ m_kifuRecordModel,
        /* kifuBranchModel     */ m_kifuBranchModel,
        /* branchCtl           */ m_branchCtl,
        /* kifuBranchView      */ m_kifuBranchView,
        /* branchDisplayPlan   */ m_branchDisplayPlan,
        this);

    // 分岐配線（既存のやり方に合わせる）
    if (m_branchWiring) {
        m_branchWiring->setKifuLoader(m_kifuLoadCoordinator);
        connect(m_kifuLoadCoordinator, &KifuLoadCoordinator::setupBranchCandidatesWiring_,
                m_branchWiring,       &BranchWiringCoordinator::setupBranchCandidatesWiring,
                Qt::UniqueConnection);
    }

    // Analysisタブとの配線
    m_kifuLoadCoordinator->setAnalysisTab(m_analysisTab);

    // UI更新通知（既存と同じ）
    connect(m_kifuLoadCoordinator, &KifuLoadCoordinator::displayGameRecord,
            this, &MainWindow::displayGameRecord, Qt::UniqueConnection);
    connect(m_kifuLoadCoordinator, &KifuLoadCoordinator::syncBoardAndHighlightsAtRow,
            this, &MainWindow::syncBoardAndHighlightsAtRow, Qt::UniqueConnection);
    connect(m_kifuLoadCoordinator, &KifuLoadCoordinator::enableArrowButtons,
            this, &MainWindow::enableArrowButtons, Qt::UniqueConnection);
}

// ===== MainWindow.cpp: ライブ対局中に分岐ツリーを更新 =====
void MainWindow::refreshBranchTreeLive_()
{
    ensureKifuLoadCoordinatorForLive_();
    if (!m_kifuLoadCoordinator) return;

    // 現在の絶対手数（棋譜モデルは先頭にヘッダ1行を持つため -1）
    int ply = 0;
    if (m_kifuRecordModel) {
        ply = qMax(0, m_kifuRecordModel->rowCount() - 1);
    }

    // ライブ棋譜から分岐ツリーを再構成し、該当手をハイライト
    m_kifuLoadCoordinator->updateBranchTreeFromLive(ply);
}

// ========== UNDO用：MainWindow 補助関数 ==========

bool MainWindow::getMainRowGuard_() const
{
    return m_onMainRowGuard;
}

void MainWindow::setMainRowGuard_(bool on)
{
    m_onMainRowGuard = on;
}

bool MainWindow::isHvH_() const
{
    return (m_playMode == HumanVsHuman);
}

bool MainWindow::isHumanSide_(ShogiGameController::Player p) const
{
    // 「どちら側が人間か」を PlayMode から判定
    switch (m_playMode) {
    case HumanVsHuman:
        return true; // 両方人間
    case EvenHumanVsEngine:
    case HandicapHumanVsEngine:
        return (p == ShogiGameController::Player1); // 先手＝人
    case EvenEngineVsHuman:
    case HandicapEngineVsHuman:
        return (p == ShogiGameController::Player2); // 後手＝人
    case EvenEngineVsEngine:
    case HandicapEngineVsEngine:
        return false;
    default:
        // 未開始/検討系は人が操作主体という前提
        return true;
    }
}

void MainWindow::updateTurnAndTimekeepingDisplay_()
{
    // 手番ラベルなど
    setCurrentTurn();

    // 時計の再描画（Presenterに現在値を流し直し）
    if (m_timePresenter && m_shogiClock) {
        const qint64 p1 = m_shogiClock->getPlayer1TimeIntMs();
        const qint64 p2 = m_shogiClock->getPlayer2TimeIntMs();
        const bool p1turn =
            (m_gameController ? (m_gameController->currentPlayer() == ShogiGameController::Player1) : true);
        m_timePresenter->onMatchTimeUpdated(p1, p2, p1turn, /*urgencyMs*/ 0);
    }
}

void MainWindow::updateGameRecord(const QString& elapsedTime)
{
    const bool gameOverAppended =
        (m_match && m_match->gameOverState().isOver && m_match->gameOverState().moveAppended);
    if (gameOverAppended) return;

    ensureRecordPresenter_();
    if (m_recordPresenter) {
        m_recordPresenter->appendMoveLine(m_lastMove, elapsedTime);

        // ★ 変更: Presenter にライブ記録を蓄積させる
        if (!m_lastMove.isEmpty()) {
            m_recordPresenter->addLiveKifItem(m_lastMove, elapsedTime);
        }
    }

    m_lastMove.clear();
}

// 新しい保存関数
void MainWindow::saveKifuToFile()
{
    // ★ Context を作成して Builder に渡す
    KifuExportContext ctx;
    ctx.gameInfoTable = m_gameInfoTable;
    ctx.recordModel   = m_kifuRecordModel;
    ctx.resolvedRows  = &m_resolvedRows;
    if (m_recordPresenter) {
        ctx.liveDisp = &m_recordPresenter->liveDisp();
    }

    ctx.startSfen = m_startSfenStr;
    ctx.playMode  = m_playMode;
    ctx.human1    = m_humanName1;
    ctx.human2    = m_humanName2;
    ctx.engine1   = m_engineName1;
    ctx.engine2   = m_engineName2;

    // Builder でリスト生成
    m_kifuDataList = KifuContentBuilder::buildKifuDataList(ctx);

    const QString path = KifuSaveCoordinator::saveViaDialog(
        this,
        m_kifuDataList,
        m_playMode,
        m_humanName1, m_humanName2,
        m_engineName1, m_engineName2);

    if (!path.isEmpty()) {
        kifuSaveFileName = path;
    }
}

void MainWindow::overwriteKifuFile()
{
    if (kifuSaveFileName.isEmpty()) {
        saveKifuToFile();
        return;
    }

    // ★ Context を作成して Builder に渡す
    KifuExportContext ctx;
    ctx.gameInfoTable = m_gameInfoTable;
    ctx.recordModel   = m_kifuRecordModel;
    ctx.resolvedRows  = &m_resolvedRows;
    if (m_recordPresenter) {
        ctx.liveDisp = &m_recordPresenter->liveDisp();
    }

    ctx.startSfen = m_startSfenStr;
    ctx.playMode  = m_playMode;
    ctx.human1    = m_humanName1;
    ctx.human2    = m_humanName2;
    ctx.engine1   = m_engineName1;
    ctx.engine2   = m_engineName2;

    // Builder でリスト生成
    m_kifuDataList = KifuContentBuilder::buildKifuDataList(ctx);

    QString error;
    const bool ok = KifuSaveCoordinator::overwriteExisting(kifuSaveFileName, m_kifuDataList, &error);
    if (!ok) {
        QMessageBox::warning(this, tr("KIF Save Error"), error);
    }
}
#include "navigationpresenter.h"
#include "kifuloadcoordinator.h"
#include "engineanalysistab.h"
#include <QDebug>

NavigationPresenter::NavigationPresenter(const Deps& d, QObject* parent)
    : QObject(parent)
    , m_coordinator(d.coordinator)
    , m_analysisTab(d.analysisTab)
{
}

void NavigationPresenter::setDeps(const Deps& d)
{
    m_coordinator = d.coordinator;
    m_analysisTab = d.analysisTab;
}

void NavigationPresenter::highlightBranchTree_(int row, int ply)
{
    if (!m_analysisTab) return;
    // ツリー側に行/手のハイライトとセンタリングを依頼
    m_analysisTab->highlightBranchTreeAt(row, ply, /*centerOn=*/true);
}

void NavigationPresenter::refreshAll(int row, int ply)
{
    if (!m_coordinator) {
        qDebug() << "[NAV-PRES] refreshAll skipped (coordinator==null)";
        return;
    }

    const int safeRow = qMax(0, row);
    const int safePly = qMax(0, ply);

    // 1) 候補再構築は Coordinator に依頼
    m_coordinator->showBranchCandidates(safeRow, safePly);

    // 2) 再構築が終わった前提でツリーハイライト＆通知
    highlightBranchTree_(safeRow, safePly);
    emit branchUiUpdated(safeRow, safePly);
}

void NavigationPresenter::refreshBranchCandidates(int row, int ply)
{
    // 実質 refreshAll と同義（必要なら分離可能）
    refreshAll(row, ply);
}

void NavigationPresenter::updateAfterBranchListChanged(int row, int ply)
{
    // ★ Coordinator 側からのみ呼ばれる“事後通知API”
    //    （ここでは Coordinator には戻らず、ハイライトと通知だけ行う）
    const int safeRow = qMax(0, row);
    const int safePly = qMax(0, ply);

    highlightBranchTree_(safeRow, safePly);
    emit branchUiUpdated(safeRow, safePly);
}
#include "promotionflow.h"
#include "promotedialog.h"
#include <QDialog>

bool PromotionFlow::askPromote(QWidget* parent)
{
    PromoteDialog dlg(parent);
    return dlg.exec() == QDialog::Accepted; // 成る=OK
}
#include "recordpanewiring.h"
#include "recordpane.h"
#include "kifurecordlistmodel.h"
#include "kifudisplay.h"
#include "navigationcontroller.h"
#include "mainwindow.h"

#include <QModelIndex>
#include <QDebug>

RecordPaneWiring::RecordPaneWiring(const Deps& d, QObject* parent)
    : QObject(parent), m_d(d)
{}

void RecordPaneWiring::buildUiAndWire()
{
    if (!m_pane) {
        m_pane = new RecordPane(m_d.parent);

        // MainWindow へ「メイン行変更」を通知（こちらは MainWindow にスロットあり）
        if (auto* mw = qobject_cast<MainWindow*>(m_d.ctx)) {
            QObject::connect(m_pane, &RecordPane::mainRowChanged,
                             mw,     &MainWindow::onRecordPaneMainRowChanged_,
                             Qt::UniqueConnection);
        }

        // ★重要★
        // branchActivated は BranchCandidatesController 側で配線する設計なので、
        // ここ（RecordPaneWiring）では接続しません。
        // （以前の MainWindow::onRecordPaneBranchActivated への接続行は削除）
    }

    // RecordPane へのモデル割当て
    m_pane->setModels(m_d.recordModel, m_d.branchModel);

    // ナビゲーションボタン束
    NavigationController::Buttons btns{
        m_pane->firstButton(),
        m_pane->back10Button(),
        m_pane->prevButton(),
        m_pane->nextButton(),
        m_pane->fwd10Button(),
        m_pane->lastButton(),
    };

    // NavigationController 生成（INavigationContext* が必須）
    if (!m_nav) {
        INavigationContext* ctx = m_d.navCtx;
        if (!ctx) ctx = dynamic_cast<INavigationContext*>(m_d.ctx);
        if (!ctx) {
            qWarning() << "[RecordPaneWiring] navCtx is null. NavigationController will not be created.";
        } else {
            m_nav = new NavigationController(btns, ctx);
        }
    }

    // 起動直後の「=== 開始局面 ===」ヘッダを重複なく用意（任意）
    if (m_d.recordModel) {
        const int rows = m_d.recordModel->rowCount();
        bool need = true;
        if (rows > 0) {
            const QModelIndex idx0 = m_d.recordModel->index(0, 0);
            const QString head = m_d.recordModel->data(idx0, Qt::DisplayRole).toString();
            if (head == QStringLiteral("=== 開始局面 ===")) need = false;
        }
        if (need) {
            auto* item = new KifuDisplay(QStringLiteral("=== 開始局面 ==="),
                                         QStringLiteral("（１手 / 合計）"));
            if (rows == 0) {
                m_d.recordModel->appendItem(item);
            } else {
                m_d.recordModel->prependItem(item);
            }
        }
    }
}
#include "recordpresenter.h"
#include "kifdisplayitem.h"
#include "kifurecordlistmodel.h"
#include "kifudisplay.h"
#include "recordpane.h"

#include <QAbstractItemView>
#include <QDebug>
#include <QTableView>
#include <QItemSelectionModel>
#include <QDebug>

GameRecordPresenter::GameRecordPresenter(const Deps& d, QObject* parent)
    : QObject(parent), m_d(d) {}

void GameRecordPresenter::updateDeps(const Deps& d) {
    m_d = d;
}

void GameRecordPresenter::clear() {
    m_kifuDataList.clear();
    m_currentMoveIndex = 0;
    if (m_d.model) {
        m_d.model->clearAllItems();
        emit modelReset();
    }
}

void GameRecordPresenter::presentGameRecord(const QList<KifDisplayItem>& disp) {
    if (!m_d.model) return;

    clear();

    // ヘッダ（開始局面）
    m_d.model->appendItem(new KifuDisplay(
        QStringLiteral("=== 開始局面 ==="),
        QStringLiteral("（1手 / 合計）")
        ));

    // 各手を追加
    for (const auto& it : disp) {
        appendMoveLine(it.prettyMove, it.timeText);
    }

    // 初期選択位置は先頭に寄せる（任意）
    if (m_d.recordPane) {
        if (auto* view = m_d.recordPane->kifuView()) {
            const QModelIndex top = m_d.model->index(0, 0);
            view->setCurrentIndex(top);
            view->scrollTo(top, QAbstractItemView::PositionAtCenter);
        }
    }
}

void GameRecordPresenter::appendMoveLine(const QString& prettyMove, const QString& elapsedTime)
{
    const QString last = prettyMove.trimmed();
    if (last.isEmpty()) {
        qDebug() << "[RecordPresenter] skip empty move line";
        return;
    }

    // --- 手数の算出 ---
    // 基本は「モデルの現在行数」だが、先頭に「開始局面」「平手」「startpos」などの見出し行が
    // 1行入っている構成のため、これを手数計算から除外する。
    int moveRows = 0;
    if (m_d.model) {
        moveRows = m_d.model->rowCount();

        if (moveRows > 0) {
            const QModelIndex headIdx = m_d.model->index(0, 0);
            const QString headText = m_d.model->data(headIdx, Qt::DisplayRole).toString();

            // 見出し行の代表的な文言を検出して 1 行分を差し引く
            // （必要に応じて追加： "開始局面", "平手", "Handicap", "startpos" 等）
            if (headText.contains(QStringLiteral("開始局面"))
                || headText.contains(QStringLiteral("平手"))
                || headText.contains(QStringLiteral("startpos"), Qt::CaseInsensitive)) {
                moveRows -= 1;
                if (moveRows < 0) moveRows = 0;
            }
        }
    }

    // 次に付与すべき手数（1始まり）
    const int nextMoveNumber = moveRows + 1;

    // 内部の現在手数インデックスも同期（独自カウンタに依存しない）
    m_currentMoveIndex = nextMoveNumber;

    // 「   n ▲７六歩」形式（左寄せ4桁）
    const QString moveNumberStr = QString::number(m_currentMoveIndex);
    const QString spaces = QString(qMax(0, 4 - moveNumberStr.length()), QLatin1Char(' '));
    const QString recordLine = spaces + moveNumberStr + QLatin1Char(' ') + last;

    // KIF 出力用（先後記号は除去）
    QString kifuLine = recordLine + QStringLiteral(" ( ") + elapsedTime + QLatin1String(" )");
    kifuLine.remove(QStringLiteral("▲"));
    kifuLine.remove(QStringLiteral("△"));
    m_kifuDataList.append(kifuLine); // 必要なければそのままでOK

    if (m_d.model) {
        m_d.model->appendItem(new KifuDisplay(recordLine, elapsedTime));
    }
}

void GameRecordPresenter::setCommentsByRow(const QStringList& commentsByRow)
{
    m_commentsByRow = commentsByRow;
}

void GameRecordPresenter::setCommentsFromDisplayItems(const QList<KifDisplayItem>& disp,
                                                      int rowCount)
{
    // rowCount: 0手目(初期局面)を含む行数
    m_commentsByRow.clear();
    m_commentsByRow.resize(qMax(0, rowCount));

    const int moveCount = disp.size();
    if (m_commentsByRow.isEmpty()) {
        return;
    }

    // --- 行0（開始局面）のコメント ---
    // KifToSfenConverter は「先頭の * コメント」を disp[0].comment に入れる仕様。
    // よって開始局面には disp[0].comment をそのまま割り当てる。
    if (moveCount > 0) {
        m_commentsByRow[0] = disp[0].comment;
    } else {
        m_commentsByRow[0].clear();
    }

    // --- 行1..（各手のコメント）---
    // これまで「行(i+1) ← disp[i].comment」としていたため 1手前が表示されていた。
    // 「コメントは“次手にひも付け”」という抽出仕様に合わせ、
    // 行r(=1..)…には disp[r].comment を割り当てる（= 1つ先を見る）。
    // 末尾行などインデックス外は安全に空文字を入れる。
    const int rows = m_commentsByRow.size();
    for (int r = 1; r < rows; ++r) {
        const int idx = r; // 1つ先へシフト
        if (idx >= 0 && idx < moveCount) {
            m_commentsByRow[r] = disp[idx].comment;
        } else {
            m_commentsByRow[r].clear();
        }
    }
}

QString GameRecordPresenter::commentForRow(int row) const
{
    if (row >= 0 && row < m_commentsByRow.size())
        return m_commentsByRow[row];
    return QString();
}

void GameRecordPresenter::onKifuCurrentRowChanged_(const QModelIndex& current,
                                                   const QModelIndex& /*previous*/)
{
    const int row = current.isValid() ? current.row() : -1;
    const QString cmt = commentForRow(row);
    emit currentRowChanged(row, cmt);
}

void GameRecordPresenter::bindKifuSelection(QTableView* kifuView)
{
    if (!kifuView) {
        qWarning() << "[RecordPresenter] bindKifuSelection: view is null";
        return;
    }
    m_kifuView = kifuView;

    // 既存の接続を解除
    if (m_connRowChanged)
        QObject::disconnect(m_connRowChanged);

    auto* sel = m_kifuView->selectionModel();
    if (!sel) {
        qWarning() << "[RecordPresenter] selectionModel is null";
        return;
    }

    // KifuView の currentRowChanged を Presenter が受け、
    // 行とコメントを整形して currentRowChanged(row, cmt) を発火
    m_connRowChanged = connect(
        sel, &QItemSelectionModel::currentRowChanged,
        this, &GameRecordPresenter::onKifuCurrentRowChanged_,
        Qt::UniqueConnection
        );
}

void GameRecordPresenter::displayAndWire(const QList<KifDisplayItem>& disp,
                                         int rowCount,
                                         RecordPane* recordPane)
{
    // 1) モデルへ反映（既存のまとめ関数）
    presentGameRecord(disp);

    // 2) コメント配列を Presenter 側で構築（既存の補助関数）
    setCommentsFromDisplayItems(disp, rowCount);

    // 3) KifuView の currentRowChanged を Presenter が受けて MainWindow へ signal 転送
    if (recordPane && recordPane->kifuView()) {
        bindKifuSelection(recordPane->kifuView()); // ここで UniqueConnection 済み
    }
}

int GameRecordPresenter::currentRow() const
{
    // KifuView がバインド済みなら、その selectionModel の currentIndex を信頼
    if (m_kifuView) {
        if (auto* sel = m_kifuView->selectionModel()) {
            const QModelIndex idx = sel->currentIndex();
            if (idx.isValid()) return idx.row();
        }
    }
    return -1; // 選択がまだ無い／未バインド
}

void GameRecordPresenter::addLiveKifItem(const QString& prettyMove, const QString& elapsedTime)
{
    KifDisplayItem item;
    item.prettyMove = prettyMove;
    item.timeText   = elapsedTime.isEmpty() ? QStringLiteral("00:00/00:00:00") : elapsedTime;
    m_liveDisp.push_back(item);
}
#include "timedisplaypresenter.h"
#include "shogiview.h"
#include <QTime>

TimeDisplayPresenter::TimeDisplayPresenter(ShogiView* view, QObject* parent)
    : QObject(parent), m_view(view)
{
}

inline QString TimeDisplayPresenter::fmt_hhmmss(qint64 ms)
{
    if (ms < 0) ms = 0;
    QTime t(0,0); return t.addMSecs(static_cast<int>(ms)).toString("hh:mm:ss");
}

void TimeDisplayPresenter::onMatchTimeUpdated(qint64 p1ms, qint64 p2ms, bool p1turn, qint64 /*urgencyMs*/)
{
    m_lastP1Ms = p1ms;
    m_lastP2Ms = p2ms;

    if (m_view) {
        if (auto* b = m_view->blackClockLabel()) b->setText(fmt_hhmmss(p1ms));
        if (auto* w = m_view->whiteClockLabel()) w->setText(fmt_hhmmss(p2ms));
        m_view->setBlackTimeMs(p1ms);
        m_view->setWhiteTimeMs(p2ms);
    }
    applyTurnHighlights_(p1turn);
}

void TimeDisplayPresenter::applyTurnHighlights_(bool p1turn)
{
    updateUrgencyStyles_(p1turn);
}

void TimeDisplayPresenter::updateUrgencyStyles_(bool p1turn)
{
    if (!m_view) return;

    // アクティブ側（先手=黒か）をビューへ通知
    m_view->setActiveIsBlack(p1turn);

    // 残り時間から緊急度を決定（ShogiView の定数に合わせる）
    const qint64 ms = p1turn ? m_lastP1Ms : m_lastP2Ms;
    ShogiView::Urgency u;
    if (ms <= ShogiView::kWarn5Ms)       u = ShogiView::Urgency::Warn5;
    else if (ms <= ShogiView::kWarn10Ms) u = ShogiView::Urgency::Warn10;
    else                                 u = ShogiView::Urgency::Normal;

    // 見た目の適用は ShogiView に一元化
    m_view->setUrgencyVisuals(u);
}
#include "tsumesearchflowcontroller.h"

#include "tsumeshogisearchdialog.h"
#include "matchcoordinator.h"
#include "tsumepositionutil.h"

#include <QObject>
#include <QDialog>
#include <QtGlobal>

TsumeSearchFlowController::TsumeSearchFlowController(QObject* parent)
    : QObject(parent)
{
}

void TsumeSearchFlowController::runWithDialog(const Deps& d, QWidget* parent)
{
    if (!d.match) {
        if (d.onError) d.onError(QStringLiteral("内部エラー: MatchCoordinator が未初期化です。"));
        return;
    }
    const QString pos = buildPositionForMate_(d);
    if (pos.isEmpty()) {
        if (d.onError) d.onError(QStringLiteral("詰み探索用の局面（SFEN）が取得できません。棋譜を読み込むか局面を指定してください。"));
        return;
    }

    TsumeShogiSearchDialog dlg(parent);
    if (dlg.exec() != QDialog::Accepted) return;

    const QList<ConsiderationDialog::Engine>& engines = dlg.getEngineList();
    const int idx = dlg.getEngineNumber();

    if (engines.isEmpty() || idx < 0 || idx >= engines.size()) {
        if (d.onError) d.onError(QStringLiteral("詰み探索エンジンの選択が不正です。"));
        return;
    }

    const auto& engine = engines.at(idx);

    int byoyomiMs = 0;  // 0 は無制限
    if (!dlg.unlimitedTimeFlag()) {
        byoyomiMs = dlg.getByoyomiSec() * 1000;  // 秒 → ms
    }

    startAnalysis_(d.match, engine.path, engine.name, pos, byoyomiMs);
}

QString TsumeSearchFlowController::buildPositionForMate_(const Deps& d) const
{
    return TsumePositionUtil::buildPositionForMate(
        d.sfenRecord, d.startSfenStr, d.positionStrList, qMax(0, d.currentMoveIndex));
}

void TsumeSearchFlowController::startAnalysis_(MatchCoordinator* match,
                                               const QString& enginePath,
                                               const QString& engineName,
                                               const QString& positionStr,
                                               int byoyomiMs)
{
    MatchCoordinator::AnalysisOptions opt;
    opt.enginePath  = enginePath;
    opt.engineName  = engineName;
    opt.positionStr = positionStr;
    opt.byoyomiMs   = byoyomiMs;
    opt.mode        = TsumiSearchMode;

    match->startAnalysis(opt);
}
#include "uiactionswiring.h"
#include "ui_mainwindow.h"        // Ui::MainWindow
#include "shogiview.h"
#include "mainwindow.h"           // MainWindow のスロットを型安全に結ぶため

void UiActionsWiring::wire()
{
    auto* ui = m_d.ui;
    auto* mw = qobject_cast<MainWindow*>(m_d.ctx);
    Q_ASSERT(ui && mw);

    // ファイル/アプリ
    QObject::connect(ui->actionQuit,        &QAction::triggered, mw, &MainWindow::saveSettingsAndClose,      Qt::UniqueConnection);
    QObject::connect(ui->actionSaveAs,      &QAction::triggered, mw, &MainWindow::saveKifuToFile,            Qt::UniqueConnection);
    QObject::connect(ui->actionSave,        &QAction::triggered, mw, &MainWindow::overwriteKifuFile,         Qt::UniqueConnection);
    QObject::connect(ui->actionOpenKifuFile,&QAction::triggered, mw, &MainWindow::chooseAndLoadKifuFile,     Qt::UniqueConnection);
    QObject::connect(ui->actionVersionInfo, &QAction::triggered, mw, &MainWindow::displayVersionInformation, Qt::UniqueConnection);
    QObject::connect(ui->actionOpenWebsite, &QAction::triggered, mw, &MainWindow::openWebsiteInExternalBrowser, Qt::UniqueConnection);

    // 対局
    QObject::connect(ui->actionNewGame,     &QAction::triggered, mw, &MainWindow::resetToInitialState, Qt::UniqueConnection);
    QObject::connect(ui->actionStartGame,   &QAction::triggered, mw, &MainWindow::initializeGame,      Qt::UniqueConnection);
    QObject::connect(ui->actionResign,      &QAction::triggered, mw, &MainWindow::handleResignation,   Qt::UniqueConnection);
    QObject::connect(ui->breakOffGame,      &QAction::triggered, mw, &MainWindow::handleBreakOffGame,  Qt::UniqueConnection);

    // 盤操作・表示
    QObject::connect(ui->actionFlipBoard,            &QAction::triggered, mw,           &MainWindow::onActionFlipBoardTriggered, Qt::UniqueConnection);
    QObject::connect(ui->actionCopyBoardToClipboard, &QAction::triggered, mw,           &MainWindow::copyBoardToClipboard,       Qt::UniqueConnection);
    QObject::connect(ui->actionMakeImmediateMove,    &QAction::triggered, mw,           &MainWindow::movePieceImmediately,       Qt::UniqueConnection);
    if (m_d.shogiView) {
        QObject::connect(ui->actionEnlargeBoard,     &QAction::triggered, m_d.shogiView, &ShogiView::enlargeBoard, Qt::UniqueConnection);
        QObject::connect(ui->actionShrinkBoard,      &QAction::triggered, m_d.shogiView, &ShogiView::reduceBoard,  Qt::UniqueConnection);
    }
    QObject::connect(ui->actionUndoMove,             &QAction::triggered, mw, &MainWindow::undoLastTwoMoves,   Qt::UniqueConnection);
    QObject::connect(ui->actionSaveBoardImage,       &QAction::triggered, mw, &MainWindow::saveShogiBoardImage, Qt::UniqueConnection);

    // 解析/検討/詰み・エンジン設定
    QObject::connect(ui->actionToggleEngineAnalysis, &QAction::triggered, mw, &MainWindow::toggleEngineAnalysisVisibility, Qt::UniqueConnection);
    QObject::connect(ui->actionEngineSettings,       &QAction::triggered, mw, &MainWindow::displayEngineSettingsDialog,    Qt::UniqueConnection);
    QObject::connect(ui->actionConsideration,        &QAction::triggered, mw, &MainWindow::displayConsiderationDialog,     Qt::UniqueConnection);
    QObject::connect(ui->actionAnalyzeKifu,          &QAction::triggered, mw, &MainWindow::displayKifuAnalysisDialog,      Qt::UniqueConnection);
    QObject::connect(ui->actionStartEditPosition,    &QAction::triggered, mw, &MainWindow::beginPositionEditing,           Qt::UniqueConnection);
    QObject::connect(ui->actionEndEditPosition,      &QAction::triggered, mw, &MainWindow::finishPositionEditing,          Qt::UniqueConnection);
    QObject::connect(ui->actionTsumeShogiSearch,     &QAction::triggered, mw, &MainWindow::displayTsumeShogiSearchDialog,  Qt::UniqueConnection);
    QObject::connect(ui->actionQuitEngine,           &QAction::triggered, mw, &MainWindow::handleBreakOffConsidaration,    Qt::UniqueConnection);
}
#include "boardimageexporter.h"
#include <QClipboard>
#include <QApplication>
#include <QImageWriter>
#include <QFileDialog>
#include <QStandardPaths>
#include <QDateTime>
#include <QDir>
#include <QImage>
#include <QPixmap>
#include <QMessageBox>

static bool hasFormat(const QSet<QString>& fmts, const QString& key) {
    if (key == "jpeg") return fmts.contains("jpeg") || fmts.contains("jpg");
    return fmts.contains(key);
}

void BoardImageExporter::copyToClipboard(QWidget* boardWidget) {
    if (!boardWidget) return;
    QApplication::clipboard()->setPixmap(boardWidget->grab());
}

void BoardImageExporter::saveImage(QWidget* parent, QWidget* boardWidget) {
    if (!boardWidget) return;

    QSet<QString> fmts;
    for (const QByteArray& f : QImageWriter::supportedImageFormats())
        fmts.insert(QString::fromLatin1(f).toLower());
    if (fmts.isEmpty()) {
        QMessageBox::critical(parent, QObject::tr("Error"),
                              QObject::tr("No writable image formats are available."));
        return;
    }

    struct F { QString key; QString filter; QString ext; };
    const QVector<F> cands = {
                              {"png","PNG (*.png)","png"},{"tiff","TIFF (*.tiff *.tif)","tiff"},
                              {"jpeg","JPEG (*.jpg *.jpeg)","jpg"},{"webp","WebP (*.webp)","webp"},
                              {"bmp","BMP (*.bmp)","bmp"},{"ppm","PPM (*.ppm)","ppm"},
                              {"pgm","PGM (*.pgm)","pgm"},{"pbm","PBM (*.pbm)","pbm"},
                              {"xbm","XBM (*.xbm)","xbm"},{"xpm","XPM (*.xpm)","xpm"},
                              };
    QStringList filters; QMap<QString,F> map;
    for (auto& c : cands) if (hasFormat(fmts, c.key)) { filters<<c.filter; map[c.filter]=c; }

    const QString stamp = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
    const QString base = QStringLiteral("ShogiBoard_%1").arg(stamp);
    const QString dir  = QStandardPaths::writableLocation(QStandardPaths::PicturesLocation);
    const QString defExt = hasFormat(fmts, "png") ? "png" : map[filters.first()].ext;
    QString selFilter = filters.isEmpty() ? QString() : filters.first();

    QString path = QFileDialog::getSaveFileName(parent, QObject::tr("Output the image"),
                                                QDir(dir).filePath(base + "." + defExt), filters.join(";;"), &selFilter);
    if (path.isEmpty()) return;

    QString suffix = QFileInfo(path).suffix().toLower();
    QString fmt;
    if (suffix.isEmpty()) {
        const auto f = map.value(selFilter);
        path += "." + f.ext; fmt = f.key;
    } else { if (suffix=="jpg") suffix="jpeg"; fmt=suffix; if (!hasFormat(fmts, fmt)) {
            QMessageBox::critical(parent, QObject::tr("Error"),
                                  QObject::tr("This image format is not available: %1").arg(suffix));
            return; } }

    const QImage img = boardWidget->grab().toImage();
    QImageWriter w(path, fmt.toLatin1());
    if (fmt=="jpeg" || fmt=="webp") w.setQuality(95);
    if (!w.write(img)) {
        QMessageBox::critical(parent, QObject::tr("Error"),
                              QObject::tr("Failed to save the image: %1").arg(w.errorString()));
    }
}
#include "boardinteractioncontroller.h"

#include "shogiview.h"
#include "shogigamecontroller.h"
#include "shogiboard.h"          // board()->getPieceCharacter(), getPieceStand()
#include <QColor>
#include <QClipboard>
#include <QApplication>
#include <QDebug>

// ======================= ctor =======================
BoardInteractionController::BoardInteractionController(ShogiView* view,
                                                       ShogiGameController* gc,
                                                       QObject* parent)
    : QObject(parent), m_view(view), m_gc(gc)
{
    Q_ASSERT(m_view);
    Q_ASSERT(m_gc);
}

// ===================== public slots =====================

void BoardInteractionController::onLeftClick(const QPoint& pt)
{
    // --- 1) “ドラッグ開始/終了”の 2クリック制御（元 onShogiViewClicked） ---
    // 駒台クリック時：枚数0を弾く（1stクリックのときのみ）
    if (!m_waitingSecondClick && (pt.x() == kBlackStandFile || pt.x() == kWhiteStandFile)) {
        const QChar piece = m_view->board()->getPieceCharacter(pt.x(), pt.y());
        if (m_view->board()->getPieceStand().value(piece) <= 0) {
            return; // 何も持ってないマスはドラッグさせない
        }
    }

    if (!m_waitingSecondClick) {
        // 1st クリック：選択＆ドラッグ開始
        m_firstClick = pt;
        m_view->startDrag(pt);
        m_waitingSecondClick = true;

        // 選択ハイライトを更新
        selectPieceAndHighlight(pt);
        emit selectionChanged(pt);
        return;
    }

    // 2nd クリック：同一マスならキャンセル扱い
    m_waitingSecondClick = false;
    if (pt == m_clickPoint) {
        finalizeDrag(); // ← ここでは従来通りキャンセル時のみドラッグ終了
        return;
    }

    // --- 2) モードに関わらず「移動要求」を発火（適用は呼び元） ---
    const QPoint from = m_clickPoint;
    const QPoint to   = pt;

    // 直前の赤ハイライトは、適用が成功したタイミングで描くためここでは触らない
    // ★重要★ ここではドラッグを終了しない。
    //         理由：成/不成ダイアログ表示中も “相手駒に重なった状態” を維持したい。
    //         ドラッグの終了は ShogiGameController 側で昇格判定後に endDragSignal を emit し、
    //         MainWindow::endDrag() 経由で ShogiView::endDrag() が呼ばれて行われる。
    emit moveRequested(from, to);
}

void BoardInteractionController::onRightClick(const QPoint& pt)
{
    // 2nd クリック待ち中ならキャンセル（元 onShogiViewRightClicked）
    if (m_waitingSecondClick) {
        finalizeDrag();
        return;
    }

    // Edit モード時のみ成/不成トグル
    if (m_mode == Mode::Edit) {
        togglePiecePromotionOnClick(pt);
    }
}

void BoardInteractionController::onMoveApplied(const QPoint& from, const QPoint& to, bool success)
{
    // 呼び元（Main/Coordinator）が合法判定＆適用後に呼ぶ
    if (!success) {
        // 非合法：選択とドラッグ状態をクリア
        finalizeDrag();
        return;
    }

    // 合法：ハイライト更新（元 addMoveHighlights と同等の見た目に）
    // 「直前の移動元」を薄い赤、「移動先」を黄色
    // 既存の“前回移動先/移動元2”も整合のため更新/クリア
    if (m_selectedField2) deleteHighlight(m_selectedField2);
    addNewHighlight(m_selectedField2, from, QColor(255, 0, 0, 50)); // 赤

    updateHighlight(m_movedField, to, Qt::yellow);                  // 黄

    // クリック状態のリセット（次の手の入力へ）
    resetSelectionAndHighlight(); // ← 選択（オレンジ）は消すが、直前手の赤/黄は残す
}

void BoardInteractionController::showMoveHighlights(const QPoint& from, const QPoint& to)
{
    // 局面移動で「この手」を強調したいとき
    updateHighlight(m_selectedField2, from, QColor(255, 0, 0, 50));
    updateHighlight(m_movedField,     to,   Qt::yellow);
}

void BoardInteractionController::clearAllHighlights()
{
    deleteHighlight(m_selectedField);
    deleteHighlight(m_selectedField2);
    deleteHighlight(m_movedField);
}

void BoardInteractionController::clearSelectionHighlight()
{
    // resetSelectionAndHighlight() と同義だが公開メソッドとして提供
    m_clickPoint = QPoint();
    deleteHighlight(m_selectedField); // 選択（オレンジ）だけ消す
    // m_selectedField2（赤）と m_movedField（黄）は残す
}

// ===================== private helpers =====================

void BoardInteractionController::selectPieceAndHighlight(const QPoint& field)
{
    auto* board = m_view->board();
    const int file = field.x();
    const int rank = field.y();
    const QChar value = board->getPieceCharacter(file, rank);

    // 盤編集モードでないとき、相手の駒台は触らせない
    if (!m_view->positionEditMode()) {
        const bool p1Turn = (m_gc->currentPlayer() == ShogiGameController::Player1);
        const bool isMyStand = ( (p1Turn && file == kBlackStandFile) ||
                                (!p1Turn && file == kWhiteStandFile) );
        if ((file >= kBlackStandFile) && !isMyStand) {
            finalizeDrag();
            return; // 相手の駒台は無視
        }
    }

    // 駒台：枚数0は無視
    const bool isStand = (file == kBlackStandFile || file == kWhiteStandFile);
    if (isStand && board->getPieceStand().value(value) <= 0) return;

    // 盤上の空白は選択しない
    if (value == QChar(' ')) return;

    // 選択状態を保持＆ハイライト（オレンジ）
    m_clickPoint = field;

    if (m_selectedField) deleteHighlight(m_selectedField);
    m_selectedField = new ShogiView::FieldHighlight(file, rank, QColor(255, 128, 0, 70));
    m_view->addHighlight(m_selectedField);
}

void BoardInteractionController::updateHighlight(ShogiView::FieldHighlight*& hl,
                                                 const QPoint& field,
                                                 const QColor& color)
{
    if (hl) deleteHighlight(hl);
    addNewHighlight(hl, field, color);
}

void BoardInteractionController::deleteHighlight(ShogiView::FieldHighlight*& hl)
{
    if (!hl) return;
    m_view->removeHighlight(hl);
    delete hl;
    hl = nullptr;
}

void BoardInteractionController::addNewHighlight(ShogiView::FieldHighlight*& hl,
                                                 const QPoint& pos,
                                                 const QColor& color)
{
    hl = new ShogiView::FieldHighlight(pos.x(), pos.y(), color);
    m_view->addHighlight(hl);
}

void BoardInteractionController::resetSelectionAndHighlight()
{
    m_clickPoint = QPoint();
    deleteHighlight(m_selectedField); // 選択（オレンジ）は消す
    // m_selectedField2（赤）と m_movedField（黄）は残す
}

void BoardInteractionController::finalizeDrag()
{
    m_view->endDrag();
    m_waitingSecondClick = false;
    resetSelectionAndHighlight();
}

void BoardInteractionController::togglePiecePromotionOnClick(const QPoint& field)
{
    // 右クリック → 成/不成トグル（駒台の駒は成れない）
    auto* board = m_view->board();
    const int file = field.x();
    const int rank = field.y();

    // 盤外（駒台）や空白は何もしない
    if (file >= kBlackStandFile) return;
    if (board->getPieceCharacter(file, rank) == QChar(' ')) return;

    // 成/不成の切り替え
    m_gc->switchPiecePromotionStatusOnRightClick(file, rank);

    // 選択ハイライトをリセット
    resetSelectionAndHighlight();
}
#include "branchcandidatescontroller.h"
#include "kifuvariationengine.h"
#include "kifubranchlistmodel.h"
#include "recordpane.h"

#include <QMetaType>
#include <QModelIndex>
#include <QDebug>

//====================== コンストラクタ ======================
BranchCandidatesController::BranchCandidatesController(KifuVariationEngine* ve,
                                                       KifuBranchListModel* model,
                                                       QObject* parent)
    : QObject(parent)
    , m_ve(ve)
    , m_model(model)
{
    m_planMode = true;     // ★Plan方式を常時有効
    m_planMetas.clear();

    qDebug().nospace()
        << "[WIRE] BranchCandidatesController created ve=" << static_cast<void*>(ve)
        << " model=" << static_cast<void*>(model);
}

//====================== クリック処理 ======================
void BranchCandidatesController::activateCandidate(int rowIndex)
{
    // Plan 方式のみ
    if (rowIndex < 0 || rowIndex >= m_planMetas.size()) {
        qDebug() << "[BRANCH-CTL] activateCandidate: out of range idx=" << rowIndex
                 << " metas=" << m_planMetas.size();
        return;
    }
    const auto& m = m_planMetas[rowIndex];
    qDebug() << "[BRANCH-CTL] planActivated row=" << m.targetRow
             << " ply=" << m.targetPly
             << " label=" << m.label
             << " line=" << m.lineName;
    emit planActivated(m.targetRow, m.targetPly);
}

//====================== （互換）旧方式はノーオペ ======================
void BranchCandidatesController::refreshCandidatesForPly(int /*ply*/,
                                                         bool /*includeMainline*/,
                                                         const QString& /*prevSfen*/,
                                                         const QSet<int>& /*restrictVarIds*/)
{
    if (!m_model) return;
    m_planMode = true;            // 念のため Plan モードを維持
    m_planMetas.clear();

    m_model->clearBranchCandidates();
    m_model->setHasBackToMainRow(false);
    qDebug() << "[BRANCH-CTL] refreshCandidatesForPly: legacy API (no-op in Plan mode)";
}

//====================== Plan をそのまま表示 ======================
void BranchCandidatesController::refreshCandidatesFromPlan(
    int ply1,
    const QVector<BranchCandidateDisplayItem>& items,
    const QString& /*baseLabel*/)
{
    m_planMode = true;
    m_planMetas.clear();

    if (m_model) {
        m_model->clearBranchCandidates();
        m_model->setHasBackToMainRow(false); // Plan は「戻る」不要
    }

    // モデルに「指し手ラベル」だけ流す
    QList<KifDisplayItem> rows;
    rows.reserve(items.size());
    for (const auto& it : items) {
        rows.push_back(KifDisplayItem(it.label)); // 例: "▲２六歩(27)"
    }
    if (m_model) {
        m_model->setBranchCandidatesFromKif(rows);
    }

    // クリック時のジャンプ先（行/手）をメタに揃えて保持
    m_planMetas.reserve(items.size());
    for (const auto& it : items) {
        PlanMeta meta;
        meta.targetRow  = it.row;
        meta.targetPly  = ply1;       // 「その手」で切替える
        meta.label      = it.label;
        meta.lineName   = it.lineName;
        m_planMetas.push_back(meta);
    }

    qDebug() << "[BRANCH-CTL] set plan items =" << items.size()
             << " ply=" << ply1;
}

void BranchCandidatesController::attachRecordPane(RecordPane* pane)
{
    if (!pane) return;

    // ここで必要なメタタイプ登録を Controller 側に寄せる
    qRegisterMetaType<KifDisplayItem>("KifDisplayItem");
    qRegisterMetaType<QList<KifDisplayItem>>("QList<KifDisplayItem>");
    qRegisterMetaType<QStringList>("QStringList");

    QObject::connect(pane, &RecordPane::branchActivated,
                     this, &BranchCandidatesController::onRecordPaneBranchActivated,
                     Qt::UniqueConnection);
}

void BranchCandidatesController::onRecordPaneBranchActivated(const QModelIndex& index)
{
    if (!index.isValid()) return;
    activateCandidate(index.row());
}
#include "errorbus.h"
#include "kifreader.h"

#include <QByteArray>
#include <QDebug>
#include <QFile>
#include <QStringDecoder>

namespace KifReader {

// --- helpers ---------------------------------------------------------------

static inline void normalizeNewlines(QString& s)
{
    // CRLF -> LF、残った CR も LF へ
    s.replace(QStringLiteral("\r\n"), QStringLiteral("\n"));
    s.replace(QChar(u'\r'), QChar(u'\n'));
}

static inline void splitByNewlines(const QString& s, QStringList& out)
{
    QString t = s;
    // BOM を除去（行頭のみ対象）
    if (!t.isEmpty() && t.front() == QChar(0xFEFF)) {
        t.remove(0, 1);
    }
    normalizeNewlines(t);
    out = t.split(QChar(u'\n'), Qt::KeepEmptyParts);
}

// QByteArray を指定の codecName でデコードして戻す。
// 成功の目安として U+FFFD（置換文字）が存在しないことを条件に ok を立てます。
static inline QString decodeWith(const QByteArray& bytes, const char* codecName, bool& ok)
{
    QStringDecoder dec(codecName);
    QString s = dec.decode(bytes);
    ok = !s.contains(QChar(0xFFFD));
    return s;
}

// BOM 判定（UTF-8 / UTF-16LE / UTF-16BE / UTF-32LE / UTF-32BE）
// 見つかった場合は usedEncoding を設定し、適切にデコードします。
static bool decodeByBom(const QByteArray& bytes, QString& out, QString* usedEncoding)
{
    const auto sz = bytes.size();
    const auto data = bytes.constData();

    if (sz >= 3 &&
        (unsigned char)data[0] == 0xEF &&
        (unsigned char)data[1] == 0xBB &&
        (unsigned char)data[2] == 0xBF) {
        bool ok = true;
        out = decodeWith(bytes.mid(3), "UTF-8", ok);
        if (usedEncoding) *usedEncoding = QStringLiteral("utf-8(bom)");
        return true;
    }
    if (sz >= 2 &&
        (unsigned char)data[0] == 0xFF &&
        (unsigned char)data[1] == 0xFE) {
        // UTF-16LE
        QStringDecoder dec("UTF-16LE");
        out = dec.decode(bytes.mid(2));
        if (usedEncoding) *usedEncoding = QStringLiteral("utf-16le(bom)");
        return true;
    }
    if (sz >= 2 &&
        (unsigned char)data[0] == 0xFE &&
        (unsigned char)data[1] == 0xFF) {
        // UTF-16BE
        QStringDecoder dec("UTF-16BE");
        out = dec.decode(bytes.mid(2));
        if (usedEncoding) *usedEncoding = QStringLiteral("utf-16be(bom)");
        return true;
    }
    if (sz >= 4 &&
        (unsigned char)data[0] == 0xFF &&
        (unsigned char)data[1] == 0xFE &&
        (unsigned char)data[2] == 0x00 &&
        (unsigned char)data[3] == 0x00) {
        // UTF-32LE
        QStringDecoder dec("UTF-32LE");
        out = dec.decode(bytes.mid(4));
        if (usedEncoding) *usedEncoding = QStringLiteral("utf-32le(bom)");
        return true;
    }
    if (sz >= 4 &&
        (unsigned char)data[0] == 0x00 &&
        (unsigned char)data[1] == 0x00 &&
        (unsigned char)data[2] == 0xFE &&
        (unsigned char)data[3] == 0xFF) {
        // UTF-32BE
        QStringDecoder dec("UTF-32BE");
        out = dec.decode(bytes.mid(4));
        if (usedEncoding) *usedEncoding = QStringLiteral("utf-32be(bom)");
        return true;
    }
    return false;
}

// --- public API ------------------------------------------------------------

bool readAllLinesAuto(const QString& filePath,
                      QStringList& outLines,
                      QString* usedEncoding,
                      QString* warn)
{
    outLines.clear();

    QFile f(filePath);
    if (!f.open(QIODevice::ReadOnly)) {
        if (warn) *warn += QStringLiteral("open failed: %1\n").arg(filePath);
        return false;
    }
    const QByteArray bytes = f.readAll();

    QString text;
    // 1) BOM 優先
    if (!decodeByBom(bytes, text, usedEncoding)) {
        // 2) UTF-8 を試す（置換文字の有無で判定）
        bool okUtf8 = false;
        QString sUtf8 = decodeWith(bytes, "UTF-8", okUtf8);
        if (okUtf8) {
            text = std::move(sUtf8);
            if (usedEncoding) *usedEncoding = QStringLiteral("utf-8");
        } else {
            // 3) CP932 / Shift_JIS
            bool okSj = false;
            QString sSj = decodeWith(bytes, "Shift-JIS", okSj);
            if (okSj) {
                text = std::move(sSj);
                if (usedEncoding) *usedEncoding = QStringLiteral("cp932(iconv)");
            } else {
                // 4) EUC-JP（稀）
                bool okEuc = false;
                QString sEuc = decodeWith(bytes, "EUC-JP", okEuc);
                if (okEuc) {
                    text = std::move(sEuc);
                    if (usedEncoding) *usedEncoding = QStringLiteral("euc-jp");
                } else {
                    // 5) 仕方なくローカル 8bit
                    text = QString::fromLocal8Bit(bytes);
                    if (usedEncoding) *usedEncoding = QStringLiteral("local8bit(fallback)");
                    if (warn) *warn += QStringLiteral("fallback: local8bit was used; encoding could not be detected precisely.\n");
                }
            }
        }
    }

    if (warn && usedEncoding) {
        *warn += QStringLiteral("[readAllLinesAuto] encoding = %1 , bytes = %2\n")
                    .arg(*usedEncoding)
                    .arg(bytes.size());
    }

    splitByNewlines(text, outLines);
    return true;
}

} // namespace KifReader
#include "kiftosfenconverter.h"
#include "kifreader.h"

#include <QFile>
#include <QTextStream>
#include <QRegularExpression>
#include <QDebug>
#include <QMap>

// 先頭が「全角/半角の 1..9 が空白区切りで並ぶだけ」の行かどうかを判定。
// 例: " ９ ８ ７ … １" / "9 8 7 6 5 4 3 2 1" など。
// マッチした場合は outDigits に空白を除いた数字列（例 "987654321"）を返す。
static inline bool isLeadingBoardDigits(const QString& line, QString* outDigits)
{
    if (outDigits) outDigits->clear();

    const QString s = line.trimmed();
    if (s.isEmpty()) return false;

    auto is19 = [](QChar ch) -> bool {
        const ushort u = ch.unicode();
        // ASCII '1'..'9' または 全角 '１'(0xFF11)..'９'(0xFF19)
        return (u >= u'1' && u <= u'9') || (u >= 0xFF11 && u <= 0xFF19);
    };

    int tokenCount = 0;
    int i = 0, n = s.size();

    while (i < n) {
        // 空白をスキップ
        while (i < n && s.at(i).isSpace()) ++i;
        if (i >= n) break;

        // 次の空白までを1トークンとする
        const int start = i;
        while (i < n && !s.at(i).isSpace()) ++i;
        const QString token = s.mid(start, i - start);

        // 各トークンは 1 文字で 1..9 であること
        if (token.size() != 1 || !is19(token.at(0))) return false;

        if (outDigits) outDigits->append(token);
        ++tokenCount;
    }

    // 少なくとも 2 個以上の数字が並んでいること（盤面ヘッダ想定）
    return tokenCount >= 2;
}

// 個数だけ欲しい場合のオーバーロード
static inline bool isLeadingBoardDigits(const QString& line, int* outCount)
{
    QString digits;
    const bool ok = isLeadingBoardDigits(line, &digits); // 上の QString* 版を呼ぶ
    if (ok && outCount) *outCount = digits.size();
    return ok;
}

namespace {

// 手合 → 初期SFEN（ユーザー提示の固定マップ）
QString mapHandicapToSfenImpl(const QString& label) {
    const QString even = QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1");
    struct Pair { const char* key; const char* sfen; };
    static const Pair tbl[] = {
        {"平手",   "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1"},
        {"香落ち", "lnsgkgsn1/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"右香落ち", "1nsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"角落ち", "lnsgkgsnl/1r7/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"飛車落ち", "lnsgkgsnl/7b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"飛香落ち", "lnsgkgsn1/7b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"二枚落ち", "lnsgkgsnl/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"三枚落ち", "lnsgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"四枚落ち", "1nsgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"五枚落ち", "2sgkgsn1/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"左五枚落ち", "1nsgkgs2/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"六枚落ち", "2sgkgs2/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"左七枚落ち", "2sgkg3/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"右七枚落ち", "3gkgs2/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"八枚落ち", "3gkg3/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"十枚落ち", "4k4/9/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL w - 1"},
        {"その他", even.toUtf8().constData()}
    };
    for (const auto& p : tbl) {
        if (label.contains(QString::fromUtf8(p.key))) {
            return QString::fromUtf8(p.sfen);
        }
    }
    return even;
}

bool isTerminalWord(const QString& s, QString* matched=nullptr) {
    static const QStringList kWords = {
        QStringLiteral("投了"), QStringLiteral("中断"), QStringLiteral("持将棋"),
        QStringLiteral("千日手"), QStringLiteral("切れ負け"),
        QStringLiteral("反則勝ち"), QStringLiteral("反則負け"),
        QStringLiteral("入玉勝ち"), QStringLiteral("不戦勝"),
        QStringLiteral("不戦敗"), QStringLiteral("詰み"), QStringLiteral("不詰")
    };
    for (const QString& w : kWords) {
        if (s.contains(w)) { if (matched) *matched = w; return true; }
    }
    return false;
}

// 行頭が手数（半/全角）か？（「手数＝」などのBODは除外）
bool startsWithMoveNumber(const QString& line, int* outDigits=nullptr) {
    int i = 0, digits = 0;
    while (i < line.size()) {
        const QChar ch = line.at(i);
        const ushort u = ch.unicode();
        const bool ascii = (u >= '0' && u <= '9');
        const bool zenk  = QStringLiteral("０１２３４５６７８９").contains(ch);
        if (ascii || zenk) { ++i; ++digits; }
        else break;
    }
    if (digits == 0) return false;
    // 直後が '手' '＝' なら BOD の「手数＝」類とみなす
    if (i < line.size()) {
        QChar next = line.at(i);
        if (next == QChar(u'手') || next == QChar(u'＝')) return false;
    }
    if (outDigits) *outDigits = digits;
    return true;
}

// BODの盤面/枠/見出しをスキップ判定
// BODの盤面/枠/見出しをスキップ判定（正規表現は使わずに実装）
bool isBoardHeaderOrFrameImpl(const QString& line) {
    // 1) 盤上部の「９ ８ ７ … １」行か？（全角/半角混在・空白区切りを許容）
    int leadingDigits = 0;
    if (isLeadingBoardDigits(line, &leadingDigits)) {
        // 行全体が「空白と（全角/半角）数字のみ」で構成されているかをチェック
        int totalDigits = 0;
        bool ok = true;
        for (QChar ch : line) {
            if (ch.isSpace()) continue;
            bool ascii = (ch.unicode() >= QChar(u'1').unicode() && ch.unicode() <= QChar(u'9').unicode());
            bool zenk  = QStringLiteral("１２３４５６７８９").contains(ch);
            if (ascii || zenk) {
                ++totalDigits;
            } else {
                ok = false;
                break;
            }
        }
        if (!ok) {
            // fix boolean literal capitalization just in case
            ok = false;
        }
        if (ok && totalDigits >= 5) { // 典型は9個。保守的に5個以上あれば見出しとみなす
            return true;
        }
    }

    // 2) 罫線（+-----+ / | ... |）
    if (line.startsWith(QLatin1Char('+')) && line.endsWith(QLatin1Char('+'))) return true;
    if (line.startsWith(QChar(u'|')) && line.endsWith(QChar(u'|'))) return true;

    // 3) 持駒の見出し
    if (line.contains(QStringLiteral("先手の持駒")) || line.contains(QStringLiteral("後手の持駒")))
        return true;

    return false;
}
} // namespace

// ===== public =====

QString KifToSfenConverter::mapHandicapToSfen(const QString& label) {
    return mapHandicapToSfenImpl(label);
}

QString KifToSfenConverter::detectInitialSfenFromFile(const QString& kifPath, QString* detectedLabel)
{
    QString usedEnc, warn;
    QStringList lines;
    if (!KifReader::readLinesAuto(kifPath, lines, &usedEnc, &warn)) {
        if (detectedLabel) *detectedLabel = QStringLiteral("平手(既定)");
        return mapHandicapToSfenImpl(QStringLiteral("平手"));
    }

    // ★ 先に BOD を試す
    QString bodSfen;
    if (buildInitialSfenFromBod(lines, bodSfen, detectedLabel, &warn)) {
        qDebug().noquote() << "[detectInitialSfenFromFile] BOD detected. sfen =" << bodSfen;
        return bodSfen;
    }

    // 従来の「手合割」ベース
    QString found;
    for (auto it = lines.cbegin(); it != lines.cend(); ++it) {
        const QString line = it->trimmed();
        if (line.contains(QStringLiteral("手合割")) || line.contains(QStringLiteral("手合"))) {
            found = line; break;
        }
    }
    if (found.isEmpty()) {
        if (detectedLabel) *detectedLabel = QStringLiteral("平手(既定)");
        return mapHandicapToSfenImpl(QStringLiteral("平手"));
    }

    static const QRegularExpression s_afterColon(QStringLiteral("^.*[:：]"));
    QString label = found;
    label.remove(s_afterColon);
    label = label.trimmed();
    if (detectedLabel) *detectedLabel = label;
    return mapHandicapToSfenImpl(label);
}

QList<KifDisplayItem> KifToSfenConverter::extractMovesWithTimes(const QString& kifPath,
                                                                QString* errorMessage)
{
    QList<KifDisplayItem> out;

    QString usedEnc;
    QStringList lines;
    if (!KifReader::readLinesAuto(kifPath, lines, &usedEnc, errorMessage)) {
        return out;
    }
    qDebug().noquote()
        << QStringLiteral("[extractMovesWithTimes] encoding = %1 , lines = %2")
               .arg(usedEnc).arg(lines.size());

    // 時間 "( m:ss/HH:MM:SS )"
    static const QRegularExpression s_timeRe(
        QStringLiteral("\\(\\s*(\\d{1,2}:\\d{2}/\\d{2}:\\d{2}:\\d{2})\\s*\\)")
        );

    // 「変化：N手」ブロックを検出
    static const QRegularExpression s_varHdr(
        QStringLiteral(R"(変化[：:]\s*([0-9０-９]+)\s*手)")
        );

    // 明示的な「本譜」「変化譜」見出しにも対応
    static const QRegularExpression s_mainHdr(
        QStringLiteral(R"(^\s*本譜\s*$)")
        );
    static const QRegularExpression s_varListHdr(
        QStringLiteral(R"(^\s*変化譜\s*$)")
        );

    QString commentBuf;
    int moveIndex = 0;
    bool inVariation = false;  // 変化ブロック中か？
    bool seenTerminal = false; // 本譜で終局語を見つけたか？

    for (auto it = lines.cbegin(); it != lines.cend(); ++it) {
        const QString raw  = *it;
        const QString line = raw.trimmed();

        // コメント行は次手にひも付け
        if (line.startsWith(QLatin1Char('*'))) {
            QString c = line.mid(1).trimmed();
            if (!c.isEmpty()) {
                if (!commentBuf.isEmpty()) commentBuf += QLatin1Char('\n');
                commentBuf += c;
            }
            continue;
        }

        // 罫線やBODヘッダなどのスキップ対象
        if (line.isEmpty() || isSkippableLine(line) || isBoardHeaderOrFrame(line))
            continue;

        // 「本譜」「変化譜」見出しでモードを切替
        if (s_mainHdr.match(line).hasMatch()) { inVariation = false; continue; }
        if (s_varListHdr.match(line).hasMatch()) { inVariation = true;  continue; }

        // 「変化：N手」を見つけたら以降は（本譜見出しが来るまで）分岐扱いとして無視
        if (s_varHdr.match(line).hasMatch()) {
            inVariation = true;
            continue;
        }

        // 変化ブロックは本譜用の表示リストに入れない
        if (inVariation) continue;

        // 本譜で既に終局を見つけていれば打ち切り
        if (seenTerminal) break;

        // 手数（半/全角）から始まるか？
        int digits = 0;
        if (!startsWithMoveNumber(line, &digits)) {
            if (errorMessage) *errorMessage += QStringLiteral("[skip ?] %1\n").arg(line);
            continue;
        }

        // 手数の後の本文へ
        int i = digits;
        while (i < line.size() && line.at(i).isSpace()) ++i;
        if (i >= line.size()) continue;

        QString rest = line.mid(i).trimmed();

        // （末尾の）時間を取り出し
        QRegularExpressionMatch tm = s_timeRe.match(rest);
        QString timeText;
        if (tm.hasMatch()) {
            timeText = tm.captured(1).trimmed();
            rest = rest.left(tm.capturedStart(0)).trimmed();
        }

        if (rest.isEmpty()) {
            if (errorMessage) *errorMessage += QStringLiteral("[skip ?] %1\n").arg(line);
            continue;
        }

        // 終局/中断？
        QString term;
        if (containsAnyTerminal(rest, &term)) {
            ++moveIndex;
            const QString teban = (moveIndex % 2 == 1) ? QStringLiteral("▲") : QStringLiteral("△");

            KifDisplayItem item;
            item.prettyMove = teban + term;
            item.timeText   = (term == QStringLiteral("千日手"))
                                ? QStringLiteral("00:00/00:00:00")
                                : (timeText.isEmpty() ? QStringLiteral("00:00/00:00:00") : timeText);
            item.comment    = commentBuf;
            commentBuf.clear();

            out.push_back(item);
            qDebug().noquote()
                << QStringLiteral("[extractMovesWithTimes] terminal: %1 , %2")
                       .arg(item.prettyMove, item.timeText);

            // ★ 本譜はここで打ち切る（分岐の手は以降拾わない）
            seenTerminal = true;
            break;
        }

        // 通常の指し手
        ++moveIndex;
        const QString teban = (moveIndex % 2 == 1) ? QStringLiteral("▲") : QStringLiteral("△");

        KifDisplayItem item;
        item.prettyMove = teban + rest;                  // 例: "▲２五歩(26)"
        item.timeText   = timeText;                      // 例: "00:00/00:00:00"
        item.comment    = commentBuf;
        commentBuf.clear();

        out.push_back(item);
        qDebug().noquote()
            << QStringLiteral("[extractMovesWithTimes] move: %1 , %2")
                   .arg(item.prettyMove,
                        item.timeText.isEmpty() ? QStringLiteral("-") : item.timeText);
    }

    qDebug().noquote()
        << QStringLiteral("[extractMovesWithTimes] total moves extracted = %1")
               .arg(out.size());
    return out;
}

QStringList KifToSfenConverter::convertFile(const QString& kifPath, QString* errorMessage)
{
    QStringList out;
    QString usedEnc;
    QStringList lines;
    if (!KifReader::readLinesAuto(kifPath, lines, &usedEnc, errorMessage)) {
        return out;
    }
    qDebug().noquote() << QStringLiteral("[convertFile] encoding = %1 , lines = %2")
                          .arg(usedEnc).arg(lines.size());

    int prevToFile = 0, prevToRank = 0;

    for (auto it = lines.cbegin(); it != lines.cend(); ++it) {
        QString raw = *it;
        QString line = raw.trimmed();

        if (line.startsWith(QLatin1Char('*'))) continue;
        if (line.isEmpty() || isSkippableLine(line) || isBoardHeaderOrFrame(line)) continue;

        // 終局/中断で打ち切り
        if (containsAnyTerminal(line)) break;

        // 先頭の手数を外す
        int digits = 0;
        if (!startsWithMoveNumber(line, &digits)) {
            if (errorMessage) *errorMessage += QStringLiteral("[skip ?] %1\n").arg(line);
            continue;
        }
        int i = digits;
        while (i < line.size() && line.at(i).isSpace()) ++i;
        if (i >= line.size()) continue;

        QString moveText = line.mid(i).trimmed();
        QString usi;
        if (convertMoveLine(moveText, usi, prevToFile, prevToRank)) {
            out << usi;
            qDebug().noquote() << QStringLiteral("[USI %1] %2").arg(out.size()).arg(usi);
        } else {
            if (errorMessage) *errorMessage += QStringLiteral("[skip ?] %1\n").arg(line);
        }
    }
    qDebug().noquote() << QStringLiteral("[convertFile] moves = %1").arg(out.size());
    return out;
}

bool KifToSfenConverter::parseWithVariations(const QString& kifPath, KifParseResult& out, QString* errorMessage)
{
    out = KifParseResult{};

    // まず本譜を既存関数で取得
    QString label;
    out.mainline.baseSfen = detectInitialSfenFromFile(kifPath, &label);
    out.mainline.disp     = extractMovesWithTimes(kifPath, errorMessage);
    out.mainline.usiMoves = convertFile(kifPath, errorMessage);

    // 変化をスキャン
    QString usedEnc;
    QStringList lines;
    if (!KifReader::readLinesAuto(kifPath, lines, &usedEnc, errorMessage)) {
        return false;
    }

    static const QRegularExpression s_varHead(QStringLiteral("^\\s*変化[:：]\\s*([0-9０-９]+)手"));
    QVector<KifVariation> vars;

    int i = 0;
    while (i < lines.size()) {
        QString l = lines.at(i).trimmed();
        QRegularExpressionMatch m = s_varHead.match(l);
        if (!m.hasMatch()) { ++i; continue; }

        // 開始手数
        QString num = m.captured(1);
        int startPly = 0;
        for (QChar ch : num) {
            int v = asciiDigitToInt(ch);
            if (!v) v = zenkakuDigitToInt(ch);
            if (!v) continue;
            startPly = startPly * 10 + v;
        }
        ++i; // 変化ヘッダの次の行から

        // このブロックの指し手を集める（次の「変化：」または空行/EOFまで）
        KifVariation var;
        var.startPly = (startPly <= 0 ? 1 : startPly);

        QStringList block;
        while (i < lines.size()) {
            QString s = lines.at(i).trimmed();
            if (s.isEmpty()) break;
            if (s.startsWith(QStringLiteral("変化"))) break;
            block << s;
            ++i;
        }

        // ブロックを既存ロジックで解析（USI/表示）
        // 単純化：行頭の手数は既に含まれているはずなのでそのまま使う
        QString tmpWarn;
        // 表示
        {
            QString enc;
            // 疑似ファイルではないので、ここでは簡易実装でパース
            // blockの各行を extractMovesWithTimes と同じルールで処理
            int prevToFile = 0, prevToRank = 0;
            int moveIndex = var.startPly - 1;
            static const QRegularExpression s_timeRe(
                QStringLiteral("\\(\\s*(\\d{1,2}:\\d{2}/\\d{2}:\\d{2}:\\d{2})\\s*\\)")
            );
            QString commentBuf;
            for (const QString& raw : block) {
                const QString line = raw;
                if (line.startsWith(QLatin1Char('*'))) {
                    QString c = line.mid(1).trimmed();
                    if (!c.isEmpty()) {
                        if (!commentBuf.isEmpty()) commentBuf += QLatin1Char('\n');
                        commentBuf += c;
                    }
                    continue;
                }
                if (line.isEmpty() || isSkippableLine(line) || isBoardHeaderOrFrame(line)) continue;

                int digits = 0;
                if (!startsWithMoveNumber(line, &digits)) continue;
                int j = digits;
                while (j < line.size() && line.at(j).isSpace()) ++j;
                if (j >= line.size()) continue;
                QString rest = line.mid(j).trimmed();

                QRegularExpressionMatch tm = s_timeRe.match(rest);
                QString timeText;
                if (tm.hasMatch()) {
                    timeText = tm.captured(1).trimmed();
                    rest = rest.left(tm.capturedStart(0)).trimmed();
                }

                QString term;
                ++moveIndex;
                const QString teban = (moveIndex % 2 == 1) ? QStringLiteral("▲") : QStringLiteral("△");
                KifDisplayItem item;

                if (containsAnyTerminal(rest, &term)) {
                    item.prettyMove = teban + term;
                    item.timeText = (term == QStringLiteral("千日手"))
                                    ? QStringLiteral("00:00/00:00:00")
                                    : (timeText.isEmpty() ? QStringLiteral("00:00/00:00:00") : timeText);
                    item.comment = commentBuf; commentBuf.clear();
                    var.line.disp.push_back(item);
                    break;
                } else {
                    item.prettyMove = teban + rest;
                    item.timeText   = timeText;
                    item.comment    = commentBuf; commentBuf.clear();
                    var.line.disp.push_back(item);
                }

                QString usi;
                if (convertMoveLine(rest, usi, prevToFile, prevToRank)) {
                    var.line.usiMoves << usi;
                }
            }
        }

        vars.push_back(var);
    }

    out.variations = vars;
    return true;
}

// ===== private helpers =====

bool KifToSfenConverter::isSkippableLine(const QString& line)
{
    if (line.isEmpty()) return true;
    if (line.startsWith(QLatin1Char('#'))) return true;
    static const QStringList keys = {
        QStringLiteral("開始日時"), QStringLiteral("終了日時"), QStringLiteral("対局日"),
        QStringLiteral("棋戦"), QStringLiteral("戦型"), QStringLiteral("持ち時間"),
        QStringLiteral("秒読み"), QStringLiteral("消費時間"), QStringLiteral("場所"),
        QStringLiteral("備考"), QStringLiteral("図"), QStringLiteral("振り駒"),
        QStringLiteral("先手省略名"), QStringLiteral("後手省略名"),
        QStringLiteral("手数----指手---------消費時間--"),
        QStringLiteral("手数――指手――――――――消費時間――"),
        QStringLiteral("先手："), QStringLiteral("後手："),
        QStringLiteral("先手番"), QStringLiteral("後手番"),
        QStringLiteral("手合割"), QStringLiteral("手合")
    };
    for (const auto& k : keys) if (line.contains(k)) return true;

    // 「まで◯手」行もスキップ
    static const QRegularExpression s_made(QStringLiteral("^\\s*まで[0-9０-９]+手"));
    if (s_made.match(line).hasMatch()) return true;

    return false;
}

bool KifToSfenConverter::isBoardHeaderOrFrame(const QString& line)
{
    return isBoardHeaderOrFrameImpl(line);
}

bool KifToSfenConverter::containsAnyTerminal(const QString& s, QString* matched)
{
    return isTerminalWord(s, matched);
}

int KifToSfenConverter::asciiDigitToInt(QChar c)
{
    ushort u = c.unicode();
    if (u >= '0' && u <= '9') return int(u - '0');
    return 0;
}

int KifToSfenConverter::zenkakuDigitToInt(QChar c)
{
    const QString z = QStringLiteral("０１２３４５６７８９");
    int idx = z.indexOf(c);
    return (idx >= 0) ? idx : 0;
}

int KifToSfenConverter::kanjiDigitToInt(QChar c)
{
    switch (c.unicode()) {
    case u'一': return 1;
    case u'二': return 2;
    case u'三': return 3;
    case u'四': return 4;
    case u'五': return 5;
    case u'六': return 6;
    case u'七': return 7;
    case u'八': return 8;
    case u'九': return 9;
    default: return 0;
    }
}

QChar KifToSfenConverter::rankNumToLetter(int r)
{
    if (r < 1 || r > 9) return QChar();
    return QChar(QLatin1Char('a' + (r - 1)));
}

bool KifToSfenConverter::findDestination(const QString& line, int& toFile, int& toRank, bool& isSameAsPrev)
{
    isSameAsPrev = false;
    if (line.contains(QStringLiteral("同"))) {
        toFile = toRank = 0;
        isSameAsPrev = true;
        return true;
    }
    // 最初の括弧の手前のみ参照（"(27)" や 時間括弧と衝突しないように）
    static const QRegularExpression s_paren(QStringLiteral("[\\(（]"));
    int paren = line.indexOf(s_paren);
    QString head = (paren >= 0) ? line.left(paren) : line;

    // 目的地は行頭近くの「数字＋漢数字」or「数字＋数字」
    static const QRegularExpression s_digitKanji(QStringLiteral("([1-9１-９])([一二三四五六七八九])"));
    static const QRegularExpression s_digitDigit(QStringLiteral("([1-9１-９])([1-9１-９])"));
    QRegularExpressionMatch m = s_digitKanji.match(head);
    if (!m.hasMatch()) m = s_digitDigit.match(head);
    if (!m.hasMatch()) return false;

    auto flexDigit = [](QChar c)->int {
        int v = asciiDigitToInt(c);
        if (v == 0) v = zenkakuDigitToInt(c);
        return v;
    };

    QChar fch = m.capturedView(1).at(0);
    QChar rch = m.capturedView(2).at(0);
    toFile = flexDigit(fch);
    int r = kanjiDigitToInt(rch);
    if (r == 0) r = flexDigit(rch);
    toRank = r;
    return (toFile >= 1 && toFile <= 9 && toRank >= 1 && toRank <= 9);
}

QChar KifToSfenConverter::pieceKanjiToUsiUpper(const QString& s)
{
    // 代表1文字のみ見ればほぼ十分
    if (s.contains(QStringLiteral("歩")) || s.contains(QStringLiteral("と"))) return QLatin1Char('P');
    if (s.contains(QStringLiteral("香")) || s.contains(QStringLiteral("杏"))) return QLatin1Char('L');
    if (s.contains(QStringLiteral("桂")) || s.contains(QStringLiteral("圭"))) return QLatin1Char('N');
    if (s.contains(QStringLiteral("銀")) || s.contains(QStringLiteral("全"))) return QLatin1Char('S');
    if (s.contains(QStringLiteral("金"))) return QLatin1Char('G');
    if (s.contains(QStringLiteral("角")) || s.contains(QStringLiteral("馬"))) return QLatin1Char('B');
    if (s.contains(QStringLiteral("飛")) || s.contains(QStringLiteral("龍")) || s.contains(QStringLiteral("竜"))) return QLatin1Char('R');
    if (s.contains(QStringLiteral("玉")) || s.contains(QStringLiteral("王"))) return QLatin1Char('K');
    return QChar();
}

bool KifToSfenConverter::isPromotionMoveText(const QString& line)
{
    if (line.contains(QStringLiteral("不成"))) return false;
    return line.contains(QStringLiteral("成"));
}

bool KifToSfenConverter::convertMoveLine(const QString& moveText,
                                         QString& usi,
                                         int& prevToFile, int& prevToRank)
{
    // 目的地
    int toF=0, toR=0; bool same=false;
    if (!findDestination(moveText, toF, toR, same)) return false;
    if (same) { toF = prevToFile; toR = prevToRank; }
    if (!(toF>=1 && toF<=9 && toR>=1 && toR<=9)) return false;

    // 打ち？
    const bool isDrop = moveText.contains(QStringLiteral("打"));
    const QChar toRankLetter = rankNumToLetter(toR);

    // from は "(xy)" から読む（なければ 0）
    int fromF=0, fromR=0;
    {
        static const QRegularExpression s_par(QStringLiteral("[\\(（]\\s*([0-9１-９])([0-9１-９])\\s*[\\)）]"));
        QRegularExpressionMatch m = s_par.match(moveText);
        if (m.hasMatch()) {
            QChar a = m.capturedView(1).at(0);
            QChar b = m.capturedView(2).at(0);
            fromF = asciiDigitToInt(a); if (!fromF) fromF = zenkakuDigitToInt(a);
            fromR = asciiDigitToInt(b); if (!fromR) fromR = zenkakuDigitToInt(b);
        }
    }

    if (isDrop) {
        // 駒種を拾う（例: "角打", "香打"）
        QChar usiPiece = pieceKanjiToUsiUpper(moveText);
        if (usiPiece.isNull()) return false;
        usi = QStringLiteral("%1*%2%3").arg(usiPiece).arg(toF).arg(toRankLetter);
    } else {
        if (!(fromF>=1 && fromF<=9 && fromR>=1 && fromR<=9)) return false;
        const QChar fromRankLetter = rankNumToLetter(fromR);
        usi = QStringLiteral("%1%2%3%4").arg(fromF).arg(fromRankLetter).arg(toF).arg(toRankLetter);
        if (isPromotionMoveText(moveText)) usi += QLatin1Char('+');
    }

    // 「同」のために保存
    prevToFile = toF;
    prevToRank = toR;
    return true;
}

// ====== Game Info Extraction (file-order, duplicates kept as separate rows) ======
static inline QString normalizeKey(const QString& raw) {
    QString k = raw.trimmed();
    if (k.endsWith(u'：') || k.endsWith(u':')) k.chop(1);
    return k.trimmed();
}
static inline QString normalizeValue(QString v) {
    v = v.trimmed();
    v.replace(QStringLiteral("\\n"), QStringLiteral("\n"));
    return v;
}

// 全角コロンのみ許容（半角コロンは無視）かつ「行頭（先頭空白は許容）」でのヘッダ判定
static const QRegularExpression kHeaderLine(
    QStringLiteral("^\\s*([^：]+?)\\s*：\\s*(.*?)\\s*$")
    );
// 「*」「＊」で始まるコメント行
static const QRegularExpression kLineIsComment(
    QStringLiteral("^\\s*[\\*\\＊]")
    );
// 指し手行（手数で始まる）。半角/全角数字どちらにもマッチ
static const QRegularExpression kLineLooksLikeMoveNo(
    QStringLiteral("^\\s*[0-9０-９]+\\s")
    );
// 変化ヘッダ「変化：◯手」は対局情報から除外
static const QRegularExpression kVariationHead(
    QStringLiteral("^\\s*変化[：:]\\s*[0-9０-９]+手")
    );

QList<KifGameInfoItem> KifToSfenConverter::extractGameInfo(const QString& filePath)
{
    QList<KifGameInfoItem> ordered;
    if (filePath.isEmpty()) return ordered;

    // Auto-detect encoding (Shift-JIS / UTF-8 etc.)
    QString usedEnc, warn;
    QStringList lines;
    if (!KifReader::readLinesAuto(filePath, lines, &usedEnc, &warn)) {
        qWarning() << "[KIF] read failed:" << filePath << "warn:" << warn;
        return ordered;
    }
    qDebug().noquote() << QStringLiteral("[KIF] encoding = %1 , lines = %2")
                              .arg(usedEnc).arg(lines.size());

    for (const QString& rawLine : lines) {
        const QString line = rawLine;
        const QString t = line.trimmed();

        // 1) コメント/指し手/棋譜表ヘッダ/全角コロン無し/変化ヘッダ を早期フィルタ
        if (kLineIsComment.match(t).hasMatch()) continue;
        if (kLineLooksLikeMoveNo.match(t).hasMatch()) continue;
        if (t.startsWith(QStringLiteral("手数"))) continue;
        if (!t.contains(QChar(0xFF1A))) continue; // 全角コロン「：」が無い
        if (kVariationHead.match(t).hasMatch()) continue; // 変化：◯手

        // ★ BODの持駒行は対局情報から除外（表記ゆれ対応：持駒/持ち駒）
        if (t.startsWith(QStringLiteral("先手の持駒")) ||
            t.startsWith(QStringLiteral("後手の持駒")) ||
            t.startsWith(QStringLiteral("先手の持ち駒")) ||
            t.startsWith(QStringLiteral("後手の持ち駒"))) {
            continue;
        }

        // 2) 全角コロン限定で key/value 抽出（行頭のみ許容）
        QRegularExpressionMatch m = kHeaderLine.match(line);
        if (!m.hasMatch()) continue;

        const QString key = normalizeKey(m.captured(1));
        if (key.isEmpty()) continue;
        const QString val = normalizeValue(m.captured(2));

        // 3) 出現順のまま格納（重複キーも別行として push_back）
        ordered.push_back({ key, val });
    }

    // ※ 並べ替えも集約も行わない：KIFファイルの先頭からの出現順をそのまま維持
    return ordered;
}

QMap<QString, QString> KifToSfenConverter::extractGameInfoMap(const QString& filePath)
{
    // 注意: QMap はキー重複を保持しません（後勝ち）。
    // 複数値を保持したい場合は、シグネチャを QMultiMap<QString, QString> に変更してください。
    QMap<QString, QString> m;
    const auto items = extractGameInfo(filePath);
    for (const auto& it : items) m.insert(it.key, it.value); // 後勝ち
    return m;
}

// Helper: map Kanji numerals to int (supports "十", "十一", "二十", "二十一", ASCII digits too)
static int parseKanjiNumber(const QString& s, int pos, int* consumed)
{
    // Try ASCII digits first
    int i = pos, n = s.size();
    int val = 0; bool any = false;
    while (i < n && s.at(i).isDigit()) { val = val*10 + (s.at(i).unicode() - '0'); ++i; any = true; }
    if (any) { if (consumed) *consumed = i - pos; return val; }

    // Kanji numerals 1..99 (simple)
    auto k2 = [](QChar c)->int{
        switch (c.unicode()) {
        case u'〇': case u'零': return 0;
        case u'一': return 1; case u'二': return 2; case u'三': return 3;
        case u'四': return 4; case u'五': return 5; case u'六': return 6;
        case u'七': return 7; case u'八': return 8; case u'九': return 9;
        default: return -1;
        }
    };
    int tens = 0, ones = 0; bool hasTen = false;
    i = pos;
    if (i < n && s.at(i) == QChar(u'十')) { hasTen = true; tens = 1; ++i; }
    else {
        int d = (i<n)?k2(s.at(i)):-1;
        if (d >= 0) { ++i; if (i<n && s.at(i) == QChar(u'十')) { hasTen = true; tens = d; ++i; }
            else { ones = d; if (consumed) *consumed = i - pos; return ones; } }
    }
    if (hasTen) {
        if (i < n) {
            int d = k2(s.at(i));
            if (d >= 0) { ones = d; ++i; }
        }
        if (consumed) *consumed = i - pos;
        return tens*10 + ones;
    }
    // none
    if (consumed) *consumed = 0;
    return -1;
}

// Piece map for BOD tokens → (base letter, promoted?)
static bool bodKanjiToBaseLetter(const QString& kanji, QChar& base, bool& promoted)
{
    promoted = false;
    if (kanji.contains(QStringLiteral("歩"))) { base = QLatin1Char('P'); return true; }
    if (kanji.contains(QStringLiteral("香"))) { base = QLatin1Char('L'); return true; }
    if (kanji.contains(QStringLiteral("桂"))) { base = QLatin1Char('N'); return true; }
    if (kanji.contains(QStringLiteral("銀"))) { base = QLatin1Char('S'); return true; }
    if (kanji.contains(QStringLiteral("金"))) { base = QLatin1Char('G'); return true; }
    if (kanji.contains(QStringLiteral("角"))) { base = QLatin1Char('B'); return true; }
    if (kanji.contains(QStringLiteral("飛"))) { base = QLatin1Char('R'); return true; }
    if (kanji.contains(QStringLiteral("玉")) || kanji.contains(QStringLiteral("王"))) { base = QLatin1Char('K'); return true; }

    // promoted single-kanji
    if (kanji.contains(QStringLiteral("と"))) { base = QLatin1Char('P'); promoted = true; return true; }
    if (kanji.contains(QStringLiteral("杏"))) { base = QLatin1Char('L'); promoted = true; return true; }
    if (kanji.contains(QStringLiteral("圭"))) { base = QLatin1Char('N'); promoted = true; return true; }
    if (kanji.contains(QStringLiteral("全"))) { base = QLatin1Char('S'); promoted = true; return true; }
    if (kanji.contains(QStringLiteral("馬"))) { base = QLatin1Char('B'); promoted = true; return true; }
    if (kanji.contains(QStringLiteral("龍")) || kanji.contains(QStringLiteral("竜"))) { base = QLatin1Char('R'); promoted = true; return true; }

    return false;
}

// --- Kanji numerals → int（1..99想定） ---
static int kanjiDigit(QChar c) {
    switch (c.unicode()) {
    case u'〇': case u'零': return 0;
    case u'一': return 1; case u'二': return 2; case u'三': return 3;
    case u'四': return 4; case u'五': return 5; case u'六': return 6;
    case u'七': return 7; case u'八': return 8; case u'九': return 9;
    default: return -1;
    }
}

bool KifToSfenConverter::buildInitialSfenFromBod(const QStringList& lines,
                                                 QString& outSfen,
                                                 QString* detectedLabel,
                                                 QString* warn)
{
    // 1) ── ヘルパ群（この関数内のみで使用） ───────────────────────────────
    auto isSpaceLike = [](QChar ch)->bool {
        return ch.isSpace() || ch == QChar(0x3000); // 全角スペース
    };

    // 駒1文字 → (USI基本文字, 成りフラグ)
    auto kanjiToBase = [](const QString& s, QChar& base, bool& promoted)->bool {
        promoted = false;
        if (s.contains(QStringLiteral("歩"))) { base = QLatin1Char('P'); return true; }
        if (s.contains(QStringLiteral("香"))) { base = QLatin1Char('L'); return true; }
        if (s.contains(QStringLiteral("桂"))) { base = QLatin1Char('N'); return true; }
        if (s.contains(QStringLiteral("銀"))) { base = QLatin1Char('S'); return true; }
        if (s.contains(QStringLiteral("金"))) { base = QLatin1Char('G'); return true; }
        if (s.contains(QStringLiteral("角"))) { base = QLatin1Char('B'); return true; }
        if (s.contains(QStringLiteral("飛"))) { base = QLatin1Char('R'); return true; }
        if (s.contains(QStringLiteral("玉")) || s.contains(QStringLiteral("王"))) { base = QLatin1Char('K'); return true; }
        // 成駒系（単独文字）
        if (s.contains(QStringLiteral("と"))) { base = QLatin1Char('P'); promoted = true; return true; }
        if (s.contains(QStringLiteral("杏"))) { base = QLatin1Char('L'); promoted = true; return true; }
        if (s.contains(QStringLiteral("圭"))) { base = QLatin1Char('N'); promoted = true; return true; }
        if (s.contains(QStringLiteral("全"))) { base = QLatin1Char('S'); promoted = true; return true; }
        if (s.contains(QStringLiteral("馬"))) { base = QLatin1Char('B'); promoted = true; return true; }
        if (s.contains(QStringLiteral("龍")) || s.contains(QStringLiteral("竜"))) { base = QLatin1Char('R'); promoted = true; return true; }
        return false;
    };

    // BOD盤面1行 例: "| ・v桂 ・v玉 ・ 馬 ・ 龍 ・|一" → 9トークン（「・」「v駒」「駒」）
    auto parseBodRow = [&](const QString& line, QStringList& outTokens, QChar& outRankKanji)->bool {
        static const QRegularExpression rowRe(QStringLiteral("^\\s*\\|(.+)\\|\\s*([一二三四五六七八九])\\s*$"));
        QRegularExpressionMatch m = rowRe.match(line);
        if (!m.hasMatch()) return false;

        const QString inner = m.captured(1);
        outRankKanji = m.captured(2).at(0);
        outTokens.clear();

        const QString promotedSingles = QStringLiteral("と杏圭全馬龍竜");
        const QString baseSingles = QStringLiteral("歩香桂銀金角飛玉王") + promotedSingles;

        int i = 0, n = inner.size();
        while (i < n && outTokens.size() < 9) {
            while (i < n && isSpaceLike(inner.at(i))) ++i;
            if (i >= n) break;

            QChar ch = inner.at(i);

            if (ch == QChar(0xFF65)) { outTokens << QStringLiteral("・"); ++i; continue; } // ･ → 空
            if (ch == QChar(0xFF56)) { ch = QLatin1Char('v'); } // ｖ → v として扱う

            if (ch == QChar(0x30FB)) { // '・'
                outTokens << QStringLiteral("・");
                ++i;
                continue;
            }

            if (ch == QLatin1Char('v')) {
                // 後手駒：次の非空白1文字が駒
                ++i;
                while (i < n && isSpaceLike(inner.at(i))) ++i;
                if (i < n) {
                    QChar p = inner.at(i);
                    if (baseSingles.contains(p)) {
                        outTokens << (QStringLiteral("v") + p);
                        ++i;
                    } else {
                        outTokens << QStringLiteral("・");
                    }
                } else {
                    outTokens << QStringLiteral("・");
                }
                continue;
            }

            if (baseSingles.contains(ch)) {
                // 先手駒：単独1文字
                outTokens << QString(ch);
                ++i;
                continue;
            }

            // その他は読み飛ばし
            ++i;
        }

        while (outTokens.size() < 9) outTokens << QStringLiteral("・");
        return true;
    };

    // 1段（9マス分のトークン列） → SFEN行（空点は連続数で圧縮）
    auto rowTokensToSfen = [&](const QStringList& tokens)->QString {
        QString row;
        int empty = 0;
        auto flushEmpty = [&](){
            if (empty > 0) { row += QString::number(empty); empty = 0; }
        };

        int used = 0;
        for (const QString& tok : tokens) {
            if (used >= 9) break;

            if (tok == QStringLiteral("・")) {
                ++empty; ++used;
                continue;
            }

            const bool gote = tok.startsWith(QLatin1Char('v'));
            const QString body = gote ? tok.mid(1) : tok;

            QChar base; bool promoted = false;
            if (!kanjiToBase(body, base, promoted)) {
                ++empty; ++used; // 未知は空マス扱い
                continue;
            }

            flushEmpty();
            if (promoted) row += QLatin1Char('+');
            row += (gote ? base.toLower() : base.toUpper());
            ++used;
        }
        while (used < 9) { ++empty; ++used; }
        flushEmpty();
        return row;
    };

    // 「歩二」「歩×2」「歩2」などの枚数解釈（デフォルト1）
    auto kanjiDigit = [](QChar c)->int {
        switch (c.unicode()) {
        case u'〇': case u'零': return 0;
        case u'一': return 1; case u'二': return 2; case u'三': return 3;
        case u'四': return 4; case u'五': return 5; case u'六': return 6;
        case u'七': return 7; case u'八': return 8; case u'九': return 9;
        default: return -1;
        }
    };
    auto parseKanjiNumberString = [&](const QString& s)->int {
        if (s.isEmpty()) return -1;
        int idx = s.indexOf(QChar(u'十'));
        if (idx >= 0) {
            int tens = 1;
            if (idx > 0) {
                int d = kanjiDigit(s.at(0));
                if (d <= 0) return -1;
                tens = d;
            }
            int ones = 0;
            if (idx + 1 < s.size()) {
                int d = kanjiDigit(s.at(idx + 1));
                if (d < 0) return -1;
                ones = d;
            }
            return tens * 10 + ones;
        }
        if (s.size() == 1) {
            int d = kanjiDigit(s.at(0));
            return (d >= 0) ? d : -1;
        }
        return -1;
    };
    auto parseCountSuffixFlexible = [&](const QString& token)->int {
        if (token.size() <= 1) return 1;
        QString rest = token.mid(1).trimmed();
        if (rest.isEmpty()) return 1;
        static const QRegularExpression reAscii(QStringLiteral("^(?:[×x*]?)(\\d+)$"));
        QRegularExpressionMatch m = reAscii.match(rest);
        if (m.hasMatch()) return m.captured(1).toInt();
        int n = parseKanjiNumberString(rest);
        return (n > 0) ? n : 1;
    };

    // 「先手の持駒：…」「後手の持駒：…」を解析
    auto parseHandsLine = [&](const QString& line, QMap<QChar,int>& outCounts, bool isBlack) {
        static const QString prefixB = QStringLiteral("先手の持駒");
        static const QString prefixW = QStringLiteral("後手の持駒");
        QString t = line.trimmed();
        if (!t.startsWith(prefixB) && !t.startsWith(prefixW)) return;

        const bool sideBlack = t.startsWith(prefixB);
        if (sideBlack != isBlack) return;

        int idx = t.indexOf(QChar(u'：')); if (idx < 0) idx = t.indexOf(QLatin1Char(':'));
        if (idx < 0) return;

        QString rhs = t.mid(idx+1).trimmed();
        if (rhs == QStringLiteral("なし")) return;

        rhs.replace(QChar(u'、'), QLatin1Char(' '));
        rhs.replace(QChar(0x3000), QLatin1Char(' '));
        const QStringList toks = rhs.split(QRegularExpression(QStringLiteral("\\s+")), Qt::SkipEmptyParts);

        for (QString tok : toks) {
            tok = tok.trimmed();
            if (tok.isEmpty()) continue;

            QChar head = tok.at(0);
            QChar base; bool promoted=false;
            if (!kanjiToBase(QString(head), base, promoted)) continue;
            if (base == QLatin1Char('K')) continue; // 玉は持駒にならない

            int cnt = parseCountSuffixFlexible(tok);
            outCounts[base] += cnt;
        }
    };

    auto buildHandsSfen = [](const QMap<QChar,int>& black, const QMap<QChar,int>& white)->QString {
        auto emitSide = [](const QMap<QChar,int>& m, bool gote)->QString{
            const char order[] = {'R','B','G','S','N','L','P'};
            QString s;
            for (char c : order) {
                const QChar key = QLatin1Char(c);
                int cnt = m.value(key, 0);
                if (cnt <= 0) continue;
                if (cnt > 1) s += QString::number(cnt);
                s += (gote ? key.toLower() : key);
            }
            return s;
        };
        QString s = emitSide(black, false) + emitSide(white, true);
        if (s.isEmpty()) s = QStringLiteral("-");
        return s;
    };

    auto zenk2ascii = [](QString s)->QString{
        static const QString z = QStringLiteral("０１２３４５６７８９");
        for (int i=0;i<s.size();++i) {
            int idx = z.indexOf(s.at(i));
            if (idx >= 0) s[i] = QChar('0' + idx);
        }
        return s;
    };

    // 2) ── 盤面 9行の収集（rank '一'..'九' に対応づけ） ─────────────────────
    QMap<QChar, QString> rowByRank;
    for (const QString& raw : lines) {
        QStringList toks;
        QChar rank;
        if (parseBodRow(raw, toks, rank)) {
            rowByRank[rank] = rowTokensToSfen(toks);
        }
    }
    if (rowByRank.size() != 9) {
        if (warn) *warn += QStringLiteral("[BOD] board rows not 9 (=%1)\n").arg(rowByRank.size());
        return false;
    }

    // 3) ── 持駒 ──────────────────────────────────────────────────────────────
    QMap<QChar,int> handB, handW;
    for (const QString& line : lines) {
        parseHandsLine(line, handB, true);
        parseHandsLine(line, handW, false);
    }

    // 4) ── 手番 ──────────────────────────────────────────────────────────────
    QChar turn = QLatin1Char('b'); // 既定: 先手番
    for (const QString& l : lines) {
        const QString t = l.trimmed();
        if (t.contains(QStringLiteral("先手番"))) { turn = QLatin1Char('b'); break; }
        if (t.contains(QStringLiteral("後手番"))) { turn = QLatin1Char('w'); break; }
    }

    // 5) ── 手数（「手数＝n」→ 次手 n+1。無ければ 1） ─────────────────────────
    int moveNumber = 1;
    static const QRegularExpression reTeSu(QStringLiteral("手数\\s*[=＝]\\s*([0-9０-９]+)"));
    for (const QString& l : lines) {
        auto mt = reTeSu.match(l);
        if (mt.hasMatch()) {
            moveNumber = zenk2ascii(mt.captured(1)).toInt() + 1;
            break;
        }
    }

    // 6) ── SFEN組み立て：**1段目→9段目**（USI仕様） ─────────────────────────
    static const QChar ranks_1to9[9] = {u'一',u'二',u'三',u'四',u'五',u'六',u'七',u'八',u'九'};
    QStringList boardRows;
    for (QChar rk : ranks_1to9) {
        boardRows << rowByRank.value(rk);
    }

    const QString board = boardRows.join(QLatin1Char('/'));
    const QString hands = buildHandsSfen(handB, handW);
    outSfen = QStringLiteral("%1 %2 %3 %4")
                  .arg(board, QString(turn), hands, QString::number(moveNumber));

    if (detectedLabel) *detectedLabel = QStringLiteral("BOD");
    return true;
}
#include "kifucontentbuilder.h"
#include "kiftosfenconverter.h" // KifGameInfoItem
#include "kifurecordlistmodel.h"
#include <QTableWidget>
#include <QDateTime>
#include <QRegularExpression>

static inline QString fwColonLine(const QString& key, const QString& val)
{
    return QStringLiteral("%1：%2").arg(key, val);
}

QStringList KifuContentBuilder::buildKifuDataList(const KifuExportContext& ctx)
{
    QStringList out;

    // 1) ヘッダ
    const QList<KifGameInfoItem> header = collectGameInfo(ctx);
    for (const auto& it : header) {
        if (!it.key.trimmed().isEmpty())
            out << fwColonLine(it.key.trimmed(), it.value.trimmed());
    }
    if (!out.isEmpty()) out << QString();

    // 2) セパレータ
    out << QStringLiteral("手数----指手---------消費時間--");

    // 3) 本譜
    const QList<KifDisplayItem> disp = collectMainline(ctx);

    int moveNo = 1;
    for (const auto& it : disp) {
        const QString cmt = it.comment.trimmed();
        if (!cmt.isEmpty()) {
            const QStringList lines = cmt.split(QRegularExpression(QStringLiteral("\r?\n")), Qt::KeepEmptyParts);
            for (const QString& raw : lines) {
                const QString t = raw.trimmed();
                if (t.isEmpty()) continue;
                if (t.startsWith(QLatin1Char('*'))) out << t;
                else                                out << (QStringLiteral("*") + t);
            }
        }
        const QString time = it.timeText.isEmpty() ? QStringLiteral("00:00/00:00:00") : it.timeText;
        out << QStringLiteral("%1 %2 %3").arg(QString::number(moveNo), it.prettyMove, time);
        ++moveNo;
    }

    // 4) 終了
    out << QString();
    out << QStringLiteral("まで%1手").arg(QString::number(qMax(0, disp.size())));

    return out;
}

QList<KifGameInfoItem> KifuContentBuilder::collectGameInfo(const KifuExportContext& ctx)
{
    QList<KifGameInfoItem> items;

    // a) 既存の「対局情報」テーブルがあれば採用
    if (ctx.gameInfoTable && ctx.gameInfoTable->rowCount() > 0) {
        const int rows = ctx.gameInfoTable->rowCount();
        for (int r = 0; r < rows; ++r) {
            const QTableWidgetItem* keyItem   = ctx.gameInfoTable->item(r, 0);
            const QTableWidgetItem* valueItem = ctx.gameInfoTable->item(r, 1);
            if (!keyItem)   continue;
            const QString key = keyItem->text().trimmed();
            const QString val = valueItem ? valueItem->text().trimmed() : QString();
            if (!key.isEmpty()) items.push_back({key, val});
        }
        return items;
    }

    // b) 自動生成
    QString black, white;
    resolvePlayerNames(ctx, black, white);

    items.push_back({ QStringLiteral("開始日時"), QDateTime::currentDateTime().toString(QStringLiteral("yyyy/MM/dd HH:mm")) });
    items.push_back({ QStringLiteral("先手"), black });
    items.push_back({ QStringLiteral("後手"), white });

    const QString sfen = ctx.startSfen.trimmed();
    const QString initPP = QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL");
    QString teai = QStringLiteral("平手");
    if (!sfen.isEmpty()) {
        const QString pp = sfen.section(QLatin1Char(' '), 0, 0);
        if (!pp.isEmpty() && pp != initPP) teai = QStringLiteral("その他");
    }
    items.push_back({ QStringLiteral("手合割"), teai });

    return items;
}

QList<KifDisplayItem> KifuContentBuilder::collectMainline(const KifuExportContext& ctx)
{
    // 優先: 解析済みデータ
    if (ctx.resolvedRows && !ctx.resolvedRows->isEmpty()) {
        int mainRow = -1;
        for (int i = 0; i < ctx.resolvedRows->size(); ++i) {
            if (ctx.resolvedRows->at(i).parent < 0) { mainRow = i; break; }
        }
        if (mainRow < 0) mainRow = 0;
        return ctx.resolvedRows->at(mainRow).disp;
    }

    // 次点: ライブ記録
    if (ctx.liveDisp && !ctx.liveDisp->isEmpty()) return *ctx.liveDisp;

    // 最終手段: モデルから抽出
    QList<KifDisplayItem> out;
    if (ctx.recordModel) {
        const int rows = ctx.recordModel->rowCount();
        for (int r = 0; r < rows; ++r) {
            const QString move = ctx.recordModel->data(ctx.recordModel->index(r, 0), Qt::DisplayRole).toString();
            const QString time = ctx.recordModel->data(ctx.recordModel->index(r, 1), Qt::DisplayRole).toString();
            const QString t = move.trimmed();
            if (t.isEmpty()) continue;
            if (t.startsWith(QLatin1Char('='))) continue; // ヘッダ除外
            KifDisplayItem it;
            it.prettyMove = t;
            it.timeText   = time.isEmpty() ? QStringLiteral("00:00/00:00:00") : time;
            out.push_back(it);
        }
    }
    return out;
}

void KifuContentBuilder::resolvePlayerNames(const KifuExportContext& ctx, QString& outBlack, QString& outWhite)
{
    // MainWindow::resolvePlayerNamesForHeader_ のロジックを移植
    switch (ctx.playMode) {
    case HumanVsHuman:
        outBlack = ctx.human1.isEmpty() ? QObject::tr("先手") : ctx.human1;
        outWhite = ctx.human2.isEmpty() ? QObject::tr("後手") : ctx.human2;
        break;
    case EvenHumanVsEngine:
        outBlack = ctx.human1.isEmpty()  ? QObject::tr("先手")   : ctx.human1;
        outWhite = ctx.engine2.isEmpty() ? QObject::tr("Engine") : ctx.engine2;
        break;
    case EvenEngineVsHuman:
        outBlack = ctx.engine1.isEmpty() ? QObject::tr("Engine") : ctx.engine1;
        outWhite = ctx.human2.isEmpty()  ? QObject::tr("後手")   : ctx.human2;
        break;
    case EvenEngineVsEngine:
        outBlack = ctx.engine1.isEmpty() ? QObject::tr("Engine1"): ctx.engine1;
        outWhite = ctx.engine2.isEmpty() ? QObject::tr("Engine2"): ctx.engine2;
        break;
    case HandicapEngineVsHuman:
        outBlack = ctx.engine1.isEmpty() ? QObject::tr("Engine") : ctx.engine1;
        outWhite = ctx.human2.isEmpty()  ? QObject::tr("後手")   : ctx.human2;
        break;
    case HandicapHumanVsEngine:
        outBlack = ctx.human1.isEmpty()  ? QObject::tr("先手")   : ctx.human1;
        outWhite = ctx.engine2.isEmpty() ? QObject::tr("Engine") : ctx.engine2;
        break;
    default:
        outBlack = QObject::tr("先手");
        outWhite = QObject::tr("後手");
        break;
    }
}
#include "kifuvariationengine.h"
#include "sfenpositiontracer.h"   // ★ これを必ず入れる（SFEN合成で使用）

#include <QElapsedTimer>
#include <QDebug>
#include <QSet>

// ヘルパ：ラベルは prettyMove をそのまま使う（必要ならトリム）
QString KifuVariationEngine::pickLabel(const KifDisplayItem& d) {
    return d.prettyMove.trimmed();
}

KifuVariationEngine::KifuVariationEngine() = default;

void KifuVariationEngine::ingest(const KifParseResult& res,
                                 const QList<QString>& sfenMain,
                                 const QVector<UsiMove>& usiMain,
                                 const QList<KifDisplayItem>& dispMain)
{
    QElapsedTimer t; t.start();
    qDebug() << "[VE] ingest() begin";

    // 既存データをクリア
    m_dispMain.clear();
    m_usiMain.clear();
    m_vars.clear();
    m_idx.clear();
    m_sourceToId.clear();

    // 0) 本譜（id=0）
    {
        Variation v;
        v.id          = 0;
        v.fileOrder   = 0;
        v.isMainline  = true;
        v.startPly    = 1;
        v.disp        = dispMain;
        v.usi         = usiMain;
        v.sourceIndex = 0;
        v.sfen        = sfenMain;   // 0..N（開始局面含む）

        m_vars.push_back(v);
        m_dispMain = dispMain;
        m_usiMain  = usiMain;
    }

    // ユーティリティ：ある基準局面から USI を順に適用して SFEN 列を合成
    auto composeFromBase = [](const QString& base, const QVector<UsiMove>& usis) -> QList<QString> {
        QList<QString> out;
        if (base.isEmpty()) return out;
        SfenPositionTracer tr;
        if (!tr.setFromSfen(base)) return {};
        out.reserve(usis.size() + 1);
        out.push_back(tr.toSfenString());      // [0] = 基準（直前局面）
        for (int i = 0; i < usis.size(); ++i) {
            tr.applyUsiMove(usis.at(i));
            out.push_back(tr.toSfenString());  // [1..] 各手後
        }
        return out;
    };

    // 1) 変化群（id は 1 始まり）
    int nextId = 1;
    for (int i = 0; i < res.variations.size(); ++i) {
        const auto& kv = res.variations[i];

        Variation v;
        v.id          = nextId++;
        v.fileOrder   = i + 1;
        v.isMainline  = false;
        v.startPly    = kv.startPly;         // グローバル手数での開始
        v.disp        = kv.line.disp;
        v.usi         = kv.line.usiMoves;
        v.sourceIndex = i;

        // --- 変化の SFEN を用意 ---
        if (!kv.line.sfenList.isEmpty()) {
            // パーサが SFEN を持っているならそれを採用
            v.sfen = kv.line.sfenList;
        } else {
            // ★合成：globalPrev = startPly-1 の局面を「もっとも深い既存行」から取る
            const int globalPrev = v.startPly - 1;
            QString basePrev;
            int baseFromVid = -1;
            int baseIdx     = -1;

            // 既に構築済みの行（本譜=先頭, 変化=その後）を「逆順」に走査して最深を選ぶ
            for (int p = m_vars.size() - 1; p >= 0; --p) {
                const auto& par = m_vars[p];
                if (par.isMainline) {
                    // 本譜は sfen[globalPrev] がそのまま「直前局面」
                    if (globalPrev >= 0 && globalPrev < par.sfen.size()) {
                        basePrev   = par.sfen.at(globalPrev);
                        baseFromVid= par.id;              // 0
                        baseIdx    = globalPrev;
                        break;
                    }
                } else {
                    // 変化 p の sfen[k] は「グローバル (p.startPly + k - 1) 手目後」を表す
                    // よって globalPrev に対応するインデックスは：
                    const int k = globalPrev - par.startPly + 1; // 0..disp.size()
                    if (k >= 0 && k < par.sfen.size()) {
                        basePrev   = par.sfen.at(k);
                        baseFromVid= par.id;
                        baseIdx    = k;
                        break;
                    }
                }
            }

            if (!basePrev.isEmpty()) {
                v.sfen = composeFromBase(basePrev, v.usi);
                qDebug().noquote().nospace()
                    << "[VE] compose var id=" << v.id
                    << " start=" << v.startPly
                    << " base.fromVid=" << baseFromVid
                    << " base.idx=" << baseIdx
                    << " out.len=" << v.sfen.size();
            } else {
                // フォールバック：本譜から（理論上ここはほぼ通らない想定）
                if (!m_vars.isEmpty() && !m_vars[0].sfen.isEmpty()) {
                    const auto& mainSfen = m_vars[0].sfen;
                    if (globalPrev >= 0 && globalPrev < mainSfen.size()) {
                        v.sfen = composeFromBase(mainSfen.at(globalPrev), v.usi);
                        qWarning().noquote()
                            << "[VE] compose fallback from MAIN at prev=" << globalPrev
                            << " var=" << v.id;
                    }
                }
            }
        }

        m_sourceToId.insert(i, v.id);
        m_vars.push_back(v);

        qDebug() << "[VE] var id=" << v.id
                 << "src=" << v.sourceIndex
                 << "start=" << v.startPly
                 << "len=" << v.disp.size()
                 << "sfen=" << v.sfen.size();
    }

    // 2) ply -> (variationId, localIndex) の索引を構築
    auto addIndex = [&](int ply, int vid, int li) {
        m_idx[ply].push_back(qMakePair(vid, li));
    };

    // 本譜（id=0）：ply = li + 1
    if (!m_vars.isEmpty()) {
        const auto& main = m_vars[0];
        for (int li = 0; li < main.disp.size(); ++li) {
            addIndex(li + 1, 0, li);
        }
    }

    // 変化：ply = startPly + li
    for (int vpos = 1; vpos < m_vars.size(); ++vpos) {
        const auto& v = m_vars[vpos];
        for (int li = 0; li < v.disp.size(); ++li) {
            addIndex(v.startPly + li, v.id, li);
        }
    }

    // デバッグ：索引ダンプ
    {
        QStringList lines;
        for (auto it = m_idx.constBegin(); it != m_idx.constEnd(); ++it) {
            lines << QString("  ply %1 -> count %2").arg(it.key()).arg(it.value().size());
        }
        lines.sort();
        qDebug().noquote() << "[VE] ingest() built index:\n " << lines.join("\n  ");
    }

    qDebug() << "[VE] ingest() end elapsed(ms)=" << t.elapsed();
}

// 後勝ちで一本化：本譜をベースに、variationId の手を startPly-1 から上書き（足りなければ末尾に追記）
ResolvedLine KifuVariationEngine::resolveAfterWins(int variationId) const
{
    ResolvedLine rl;
    rl.startPly = 1;
    rl.disp = m_dispMain;  // 本譜をベース
    rl.usi  = m_usiMain;

    // 対象 variation を検索
    const Variation* vptr = nullptr;
    for (const auto& v : m_vars) {
        if (v.id == variationId) { vptr = &v; break; }
    }
    if (!vptr || vptr->isMainline) {
        // 見つからない or 本譜(id=0)なら、そのまま本譜を返す
        return rl;
    }
    const Variation& v = *vptr;

    const int base = qMax(0, v.startPly - 1);   // 上書き開始位置（0-based）

    // 表示（disp）を後勝ちで上書き／追記
    for (int li = 0; li < v.disp.size(); ++li) {
        const int idx = base + li;
        if (idx < rl.disp.size()) rl.disp[idx] = v.disp.at(li);
        else                      rl.disp.push_back(v.disp.at(li));
    }

    // USI も同様に上書き／追記
    for (int li = 0; li < v.usi.size(); ++li) {
        const int idx = base + li;
        if (idx < rl.usi.size()) rl.usi[idx] = v.usi.at(li);
        else                     rl.usi.push_back(v.usi.at(li));
    }

    // （SFEN は呼び出し側で既存の rebuildSfenRecord() を用いて再構築してください）
    return rl;
}

// kifuvariationengine.cpp
#include "kifuvariationengine.h"
#include "sfenpositiontracer.h"
#include <QElapsedTimer>
#include <algorithm>

// 先後（奇数手=先手、偶数手=後手）
static inline bool isBlackOnPly(int ply) { return (ply % 2) == 1; }

// idからVariation参照を取る小ヘルパ
const KifuVariationEngine::Variation* findVarById(const QList<KifuVariationEngine::Variation>& vars, int vid) {
    for (const auto& v : vars) if (v.id == vid) return &v;
    return nullptr;
}

QString KifuVariationEngine::prevSfenFor(int variationId, int li) const
{
    // variationId に対応する Variation を探す
    const Variation* var = nullptr;
    for (const auto& v : m_vars) {
        if (v.id == variationId) { var = &v; break; }
    }
    if (!var) return {};

    // li は「この variation のローカル手インデックス」
    // prev SFEN は「その手を指す直前の局面」＝ var->sfen[li]
    if (li < 0 || li >= var->sfen.size()) return {};
    return var->sfen.at(li);
}

QList<BranchCandidate>
KifuVariationEngine::branchCandidatesForPly(int ply,
                                            bool includeMainline,
                                            const QString& ctxPrevSfen) const
{
    QList<BranchCandidate> out;

    auto it = m_idx.find(ply);
    if (it == m_idx.end()) return out;

    const auto& pairs = it.value();
    QSet<QString> seen;

    for (int i = 0; i < pairs.size(); ++i) {
        const int vid = pairs[i].first;
        const int li  = pairs[i].second;

        // 該当 variation
        const Variation* var = nullptr;
        for (const auto& v : m_vars) if (v.id == vid) { var = &v; break; }
        if (!var) continue;

        // 本譜を出す/出さない
        if (!includeMainline && var->isMainline) continue;

        // ★ 直前局面：本譜/変化を問わず variation 側の SFEN から取る
        const QString prev = prevSfenFor(vid, li);

        // 文脈SFENが指定されていれば一致するものだけ通す
        if (!ctxPrevSfen.isEmpty()) {
            if (prev.isEmpty() || prev != ctxPrevSfen) continue;
        }

        // ラベル（この variation の表示配列から）
        QString label;
        if (li >= 0 && li < var->disp.size()) {
            label = pickLabel(var->disp.at(li));   // クラス内の静的/プライベートでOK
        }
        if (label.isEmpty()) continue;

        if (seen.contains(label)) continue;
        seen.insert(label);

        BranchCandidate c;
        c.label       = label;
        c.variationId = vid;
        c.ply         = ply;
        c.isMainline  = var->isMainline;
        c.isBlack     = (ply % 2 == 1);
        out.push_back(std::move(c));

        // デバッグ
        qDebug().noquote().nospace()
            << "  [add] idx=" << i
            << " vid=" << vid
            << " li=" << li
            << " start=" << var->startPly
            << " label=\"" << label << "\""
            << " isMain=" << (var->isMainline ? "true" : "false")
            << " prev(cand)=" << (prev.isEmpty() ? "<EMPTY>" : prev)
            << (ctxPrevSfen.isEmpty() ? "" :
                    QString("  prev(ctx)=%1").arg(ctxPrevSfen));
    }

    return out;
}

// ★ 2引数版（既存互換）: 本譜の前局面SFENを自動採用
QList<BranchCandidate>
KifuVariationEngine::branchCandidatesForPly(int ply, bool includeMainline) const
{
    QString ctx;
    if (ply > 0 && !m_vars.isEmpty()) {
        const auto &main = m_vars.front();          // id=0 の本譜
        const int idx = ply - 1;                    // 「直前」の局面
        if (idx >= 0 && idx < main.sfen.size())
            ctx = main.sfen.at(idx);
    }
    return branchCandidatesForPly(ply, includeMainline, ctx); // ← 3引数版へ
}

int KifuVariationEngine::idForSourceIndex(int sourceIndex) const {
    return m_sourceToId.value(sourceIndex, -1);
}

QList<QString> KifuVariationEngine::mainlineSfen() const
{
    return m_vars.isEmpty() ? QList<QString>() : m_vars.front().sfen;
}
QList<QString> KifuVariationEngine::sfenForVariationId(int variationId) const
{
    for (const auto& v : m_vars) if (v.id == variationId) return v.sfen;
    return {};
}
int KifuVariationEngine::variationIdFromSourceIndex(int sourceIndex) const
{
    return m_sourceToId.value(sourceIndex, -1);
}
#include "matchcoordinator.h"
#include "shogiclock.h"
#include "usi.h"
#include "shogiview.h"
#include "usicommlogmodel.h"
#include "shogienginethinkingmodel.h"
#include "shogigamecontroller.h"
#include "shogiboard.h"
#include "boardinteractioncontroller.h"
#include "startgamedialog.h"
#include "enginesettingsconstants.h"
#include "kifurecordlistmodel.h"

#include <limits>
#include <QObject>
#include <QDebug>
#include <QElapsedTimer>
#include <QtGlobal>
#include <QDateTime>
#include <QTimer>
#include <QMetaObject>
#include <QMetaMethod>
#include <QSettings>

static inline int clampMsToIntLocal(qint64 v) {
    if (v > std::numeric_limits<int>::max()) return std::numeric_limits<int>::max();
    if (v < std::numeric_limits<int>::min()) return std::numeric_limits<int>::min();
    return static_cast<int>(v);
}

// 平手初期SFENの簡易判定（必要なら厳密化可）
static bool isStandardStartposSfen_(const QString& sfen)
{
    const QString canon = QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1");
    return (!sfen.isEmpty() && sfen.trimmed() == canon);
}

// 直前のフル position 文字列から、先頭 handCount 手だけ残したベースを作る。
// 例）prev="position startpos moves 7g7f 3c3d 2g2f 8c8d", handCount=2
//   → "position startpos moves 7g7f 3c3d"
static QString buildBasePositionUpToHands_(const QString& prevFull, int handCount, const QString& startSfenHint)
{
    QString head;  // "position startpos" or "position sfen <...>"
    QStringList moves;

    // prevFull を優先して head/moves を抽出
    if (!prevFull.isEmpty()) {
        const QString trimmed = prevFull.trimmed();

        if (trimmed.startsWith(QStringLiteral("position startpos"))) {
            head = QStringLiteral("position startpos");
        } else if (trimmed.startsWith(QStringLiteral("position sfen "))) {
            // "position sfen " 以降の SFEN 先頭トークンまでを head として採用（末尾の moves 部は除外）
            // 単純に " moves " の前までを head とする
            const int idxMoves = trimmed.indexOf(QStringLiteral(" moves "));
            head = (idxMoves >= 0) ? trimmed.left(idxMoves) : trimmed; // moves 無ければ全文
        }

        // moves の抽出
        const int idxMoves = trimmed.indexOf(QStringLiteral(" moves "));
        if (idxMoves >= 0) {
            const QString after = trimmed.mid(idxMoves + 7); // 7 = strlen(" moves ")
            const QStringList toks = after.split(QLatin1Char(' '), Qt::SkipEmptyParts);
            for (const QString& t : toks) {
                if (!t.isEmpty()) moves.append(t);
            }
        }
    }

    // prevFull から head が取れなかった場合：SFENヒントで head を決める
    if (head.isEmpty()) {
        if (isStandardStartposSfen_(startSfenHint)) {
            head = QStringLiteral("position startpos");
        } else if (!startSfenHint.isEmpty()) {
            head = QStringLiteral("position sfen %1").arg(startSfenHint);
        } else {
            head = QStringLiteral("position startpos"); // フォールバック
        }
    }

    // handCount でトリミング
    if (handCount <= 0) {
        return head; // moves なし
    }

    // moves が prevFull 由来で空（または prevFull が空）の場合は、そのまま head のみを返す
    if (moves.isEmpty()) {
        return head;
    }

    const int take = qMin(handCount, moves.size());
    QStringList headMoves = moves.mid(0, take);
    return QStringLiteral("%1 moves %2").arg(head, headMoves.join(QLatin1Char(' ')));
}

using P = MatchCoordinator::Player;

static inline P toP(int gcPlayer) { return (gcPlayer == 1) ? MatchCoordinator::P1 : MatchCoordinator::P2; }

MatchCoordinator::MatchCoordinator(const Deps& d, QObject* parent)
    : QObject(parent) 
    , m_gc(d.gc)
    , m_clock(d.clock)
    , m_view(d.view)
    , m_usi1(d.usi1)
    , m_usi2(d.usi2)
    , m_hooks(d.hooks)
    , m_comm1(d.comm1)
    , m_think1(d.think1)
    , m_comm2(d.comm2)
    , m_think2(d.think2)
{
    // 既定値
    m_cur = P1;
    m_turnEpochP1Ms = m_turnEpochP2Ms = -1;

    // ★共有SFENリストを受け取る
    m_sfenRecord = d.sfenRecord;

    // デバッグ：どのリストを使うか明示
    qInfo().noquote()
        << "[MC][init] shared sfenRecord*=" << static_cast<const void*>(m_sfenRecord)
        << " eveSfenRecord@=" << static_cast<const void*>(&m_eveSfenRecord);

    // 念のため NPE ガード（無いと困る設計なのでログだけ）
    if (!m_sfenRecord) {
        qWarning() << "[MC][init] sfenRecord is null! Presenterと同期できません。Deps.sfenRecordを渡してください。";
    }

    wireClock_(); // ★CTOR でも配線
}

MatchCoordinator::~MatchCoordinator() = default;

void MatchCoordinator::updateUsiPtrs(Usi* e1, Usi* e2) {
    m_usi1 = e1;
    m_usi2 = e2;
}

void MatchCoordinator::startNewGame(const QString& sfenStart) {
    // 既存
    if (m_hooks.initializeNewGame) m_hooks.initializeNewGame(sfenStart);
    setPlayersNamesForMode_();
    setEngineNamesBasedOnMode_();
    setGameInProgressActions_(true);
    renderShogiBoard_();

    // ★ GC の手番を SFEN から決定（無ければ先手）
    ShogiGameController::Player start = ShogiGameController::Player1;
    if (!sfenStart.isEmpty()) {
        const auto parts = sfenStart.split(' ', Qt::SkipEmptyParts);
        if (parts.size() >= 2 && (parts[1] == QLatin1String("w") || parts[1] == QLatin1String("W"))) {
            start = ShogiGameController::Player2;
        }
    }

    // GC に反映（currentPlayerChanged → TurnManager は恒常接続で自動伝播）
    if (m_gc) m_gc->setCurrentPlayer(start);

    // 司令塔の手番も同期（既存のまま）
    m_cur = (m_gc && m_gc->currentPlayer() == ShogiGameController::Player2) ? P2 : P1;
    updateTurnDisplay_(m_cur);

    if (m_hooks.log) m_hooks.log(QStringLiteral("MatchCoordinator: startNewGame done"));
    emit gameStarted();
}

// 1) 人間側の投了
void MatchCoordinator::handleResign() {
    GameEndInfo info;
    info.cause = Cause::Resignation;

    // 投了は「現在手番側」が行う：GCの現在手番から判定
    info.loser = (m_gc && m_gc->currentPlayer() == ShogiGameController::Player1) ? P1 : P2;
    //const Player winner = (m_cur == P1 ? P2 : P1);

    // エンジンへの最終通知（HvE / EvE の両方に対応）
    if (m_hooks.sendRawToEngine) {
        if (m_usi1 && !m_usi2) {
            // HvE：エンジンは m_usi1。人間が投了＝エンジン勝ち。
            m_hooks.sendRawToEngine(m_usi1, QStringLiteral("gameover win"));
            m_hooks.sendRawToEngine(m_usi1, QStringLiteral("quit")); // 再戦しないなら送る
        } else {
            // ★ 追加：hooks 未指定でも最低限の通知を司令塔内で実施
            if (m_usi1 && !m_usi2) {
                // HvE：エンジンは m_usi1。人間が投了＝エンジン勝ち。
                sendRawTo_(m_usi1, QStringLiteral("gameover win"));
                sendRawTo_(m_usi1, QStringLiteral("quit"));
            } else {
                // EvE：勝者/敗者のエンジンそれぞれに通知
                const Player winner = (m_cur == P1 ? P2 : P1);
                Usi* winEng  = (winner     == P1) ? m_usi1 : m_usi2;
                Usi* loseEng = (info.loser == P1) ? m_usi1 : m_usi2;
                if (loseEng) sendRawTo_(loseEng, QStringLiteral("gameover lose"));
                if (winEng)  {
                    sendRawTo_(winEng,  QStringLiteral("gameover win"));
                    sendRawTo_(winEng,  QStringLiteral("quit"));
                }
            }
        }
    }

    // 司令塔のゲームオーバー状態を確定（棋譜「投了」一意追記は appendMoveOnce=true で司令塔→UIへ）
    setGameOver(info, /*loserIsP1=*/(info.loser==P1), /*appendMoveOnce=*/true);

    // ★ 追加：投了時も結果ダイアログを表示
    displayResultsAndUpdateGui_(info);
}

// 2) エンジン側の投了
void MatchCoordinator::handleEngineResign(int idx) {
    // エンジン投了時はまず時計だけ停止（stop は送らない）
    if (m_clock) m_clock->stopClock();

    GameEndInfo info;
    info.cause = Cause::Resignation;
    info.loser = (idx == 1 ? P1 : P2);

    // 負け側には lose + quit、勝ち側には win + quit を送る
    Usi* loserEng  = (info.loser == P1) ? m_usi1 : m_usi2;
    Usi* winnerEng = (info.loser == P1) ? m_usi2 : m_usi1;

    if (loserEng) {
        loserEng->sendGameOverLoseAndQuitCommands();
        loserEng->setSquelchResignLogging(true); // 任意：終局後の雑音ログ抑制
    }
    if (winnerEng) {
        winnerEng->sendGameOverWinAndQuitCommands();
        winnerEng->setSquelchResignLogging(true);
    }

    // 司令塔のゲームオーバー状態を確定（棋譜「投了」一意追記は appendMoveOnce=true で司令塔→UIへ）
    const bool loserIsP1 = (info.loser == P1);
    setGameOver(info, loserIsP1, /*appendMoveOnce=*/true);

    // ★ 追加：エンジン投了時も結果ダイアログを表示
    displayResultsAndUpdateGui_(info);
}

void MatchCoordinator::notifyTimeout(Player loser) {
    // 1) 時計停止（以降の進行を止める）
    if (m_clock) m_clock->stopClock();

    const Player winner = (loser == P1 ? P2 : P1);

    // 2) HvE の人間側判定（あれば利用）：人間が時間切れならエンジン勝ち
    Player humanSide = P1;
    const bool hasHumanSide = static_cast<bool>(m_hooks.humanPlayerSide);
    if (hasHumanSide) {
        humanSide = m_hooks.humanPlayerSide();
    }

    // 3) エンジンへ最終通知
    if (m_usi1 && !m_usi2) {
        // 片側エンジン（HvE）
        if (!hasHumanSide || loser == humanSide) {
            // 人間が時間切れ → エンジン勝ち
            m_usi1->sendGameOverWinAndQuitCommands();
        } else {
            // 例外的：エンジンが時間切れ（ほぼ無いが一応）
            m_usi1->sendGameOverLoseAndQuitCommands();
        }
        m_usi1->setSquelchResignLogging(true);
    } else {
        // EvE：両エンジンが居る
        Usi* loserEng  = (loser  == P1) ? m_usi1 : m_usi2;
        Usi* winnerEng = (winner == P1) ? m_usi1 : m_usi2;
        if (loserEng)  { loserEng->sendGameOverLoseAndQuitCommands();  loserEng->setSquelchResignLogging(true); }
        if (winnerEng) { winnerEng->sendGameOverWinAndQuitCommands();  winnerEng->setSquelchResignLogging(true); }
    }

    // 4) UI へ終局通知
    GameEndInfo info; info.cause = Cause::Timeout; info.loser = loser;
    setGameOver(info, /*loserIsP1=*/(loser == P1), /*appendMoveOnce=*/true);
    displayResultsAndUpdateGui_(info);
}

void MatchCoordinator::flipBoard() {
    // 実際の反転は GUI 側で実施（レイアウト/ラベル入替等を考慮）
    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();
    emit boardFlipped(true);
}

void MatchCoordinator::onTurnFinishedAndSwitch() {
    // 1) 現在の時間を読み、次手の go を計算
    const GoTimes t = computeGoTimes_();

    // 2) 手番を入れ替え
    m_cur = (m_cur == P1 ? P2 : P1);
    updateTurnDisplay_(m_cur);

    // 3) 次に指す側のエンジンへ go 送信（対人/対エンジン/エンジンvsエンジンは上位で制御可）
    if (m_hooks.sendGoToEngine) {
        if (m_cur == P1 && m_usi1) m_hooks.sendGoToEngine(m_usi1, t);
        if (m_cur == P2 && m_usi2) m_hooks.sendGoToEngine(m_usi2, t);
    } else {
        sendGoToCurrentEngine_(t); // ★ 追加：hooks 未指定なら司令塔内で送る
    }

}

// ---- private helpers ----

void MatchCoordinator::setPlayersNamesForMode_() {
    if (m_hooks.setPlayersNames) {
        // TODO: 実際の名前決定ロジックを移設
        m_hooks.setPlayersNames(QStringLiteral("Player1"), QStringLiteral("Player2"));
    }
}

void MatchCoordinator::setEngineNamesBasedOnMode_() {
    if (m_hooks.setEngineNames) {
        // TODO: 実際のエンジン名取得ロジックを移設（Usi から取得など）
        m_hooks.setEngineNames(QStringLiteral("Engine#1"), QStringLiteral("Engine#2"));
    }
}

void MatchCoordinator::setGameInProgressActions_(bool inProgress) {
    if (m_hooks.setGameActions) m_hooks.setGameActions(inProgress);
}

void MatchCoordinator::renderShogiBoard_() {
    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();
}

void MatchCoordinator::updateTurnDisplay_(Player p) {
    m_cur = p; // ★ 同期
    if (m_hooks.updateTurnDisplay) m_hooks.updateTurnDisplay(p);
}

void MatchCoordinator::stopClockAndSendStops_() {
    if (m_clock) m_clock->stopClock();
    if (m_hooks.sendStopToEngine) {
        if (m_usi1) m_hooks.sendStopToEngine(m_usi1);
        if (m_usi2) m_hooks.sendStopToEngine(m_usi2);
    } else {
        sendStopAllEngines_(); // ★ 追加
    }
}

void MatchCoordinator::displayResultsAndUpdateGui_(const GameEndInfo& info) {
    // 対局中メニューのON/OFFなどUI側の状態を更新
    setGameInProgressActions_(false);

    // 先後の文字列（日本語）
    const bool loserIsP1  = (info.loser == P1);
    const QString loserJP = loserIsP1 ? tr("先手") : tr("後手");
    const QString winnerJP= loserIsP1 ? tr("後手") : tr("先手");

    // メッセージ本文（日本語）
    QString msg;
    switch (info.cause) {
    case Cause::Resignation:
        // 例）「先手の投了。後手の勝ちです。」
        msg = tr("%1の投了。%2の勝ちです。").arg(loserJP, winnerJP);
        break;
    case Cause::Timeout:
        // 例）「先手の時間切れ。後手の勝ちです。」
        msg = tr("%1の時間切れ。%2の勝ちです。").arg(loserJP, winnerJP);
        break;
    case Cause::BreakOff:
    default:
        // 念のためのフォールバック
        msg = tr("対局が終了しました。");
        break;
    }

    // ダイアログ表示（MainWindow 側フックで QMessageBox を出します）
    if (m_hooks.showGameOverDialog) {
        m_hooks.showGameOverDialog(tr("対局終了"), msg);
    }

    if (m_hooks.log) m_hooks.log(QStringLiteral("Game ended"));

    // UI 全体へも通知（既存のUI処理と整合）
    emit gameEnded(info);
    emit gameOverShown();
}

void MatchCoordinator::initializeAndStartEngineFor(Player side,
                                                   const QString& enginePathIn,
                                                   const QString& engineNameIn)
{
    Usi*& eng = (side == P1 ? m_usi1 : m_usi2);

    if (!eng) {
        // HvE フォールバック：m_usi1 しか無い場合は m_usi1 を使う
        if (m_usi1 && !m_usi2) {
            if (m_hooks.log) m_hooks.log(QStringLiteral("[Match] fallback to m_usi1 for HvE"));
            eng = m_usi1;
        } else {
            if (m_hooks.log) m_hooks.log(QStringLiteral("[Match] engine ptr is null (side=%1)").arg(side == P1 ? "P1" : "P2"));
            return;
        }
    }

    QString path = enginePathIn;
    QString name = engineNameIn;

    // 例外を投げない前提：失敗は内部でシグナル/ログ通知される
    eng->initializeAndStartEngineCommunication(path, name);

    // 投了シグナル配線（m_usi1=先手扱い）
    wireResignToArbiter_(eng, (eng == m_usi1));
}

void MatchCoordinator::wireResignSignals()
{
    if (m_usi1) wireResignToArbiter_(m_usi1, /*asP1=*/true);
    if (m_usi2) wireResignToArbiter_(m_usi2, /*asP1=*/false);
}

void MatchCoordinator::wireResignToArbiter_(Usi* engine, bool asP1)
{
    if (!engine) return;

    // 既存接続の掃除は「該当シグナルのみ」を明示して行う
    QObject::disconnect(engine, &Usi::bestMoveResignReceived, this, nullptr);

    if (asP1) {
        QObject::connect(engine, &Usi::bestMoveResignReceived,
                         this,   &MatchCoordinator::onEngine1Resign,
                         Qt::UniqueConnection);
    } else {
        QObject::connect(engine, &Usi::bestMoveResignReceived,
                         this,   &MatchCoordinator::onEngine2Resign,
                         Qt::UniqueConnection);
    }
}

void MatchCoordinator::onEngine1Resign()
{
    // 既存のハンドラへ委譲（番号は 1 = P1）
    this->handleEngineResign(1);
}

void MatchCoordinator::onEngine2Resign()
{
    // 既存のハンドラへ委譲（番号は 2 = P2）
    this->handleEngineResign(2);
}

void MatchCoordinator::destroyEngine(int idx)
{
    Usi*& ref = (idx == 1 ? m_usi1 : m_usi2);
    if (ref) {
        delete ref;
        ref = nullptr;
    }
}

void MatchCoordinator::destroyEngines()
{
    destroyEngine(1);
    destroyEngine(2);
}

Usi* MatchCoordinator::enginePtr(int idx) const
{
    return (idx == 1 ? m_usi1 : (idx == 2 ? m_usi2 : nullptr));
}

int MatchCoordinator::indexForEngine_(const Usi* p) const
{
    if (!p) return 0;
    if (p == m_usi1) return 1;
    if (p == m_usi2) return 2;
    return 0;
}

void MatchCoordinator::setPlayMode(PlayMode m)
{
    m_playMode = m;
}

void MatchCoordinator::initEnginesForEvE(const QString& engineName1,
                                         const QString& engineName2)
{
    // 既存エンジンの破棄
    destroyEngines();

    // モデル（GUI から貰えない場合はフォールバック生成）
    UsiCommLogModel*          comm1  = m_comm1 ? m_comm1 : new UsiCommLogModel(this);
    ShogiEngineThinkingModel* think1 = m_think1 ? m_think1 : new ShogiEngineThinkingModel(this);
    UsiCommLogModel*          comm2  = m_comm2 ? m_comm2 : new UsiCommLogModel(this);
    ShogiEngineThinkingModel* think2 = m_think2 ? m_think2 : new ShogiEngineThinkingModel(this);

    if (!m_comm1)  { m_comm1  = comm1;  qWarning() << "[EvE] comm1 fallback created"; }
    if (!m_think1) { m_think1 = think1; qWarning() << "[EvE] think1 fallback created"; }
    if (!m_comm2)  { m_comm2  = comm2;  qWarning() << "[EvE] comm2 fallback created"; }
    if (!m_think2) { m_think2 = think2; qWarning() << "[EvE] think2 fallback created"; }

    // USI を生成（この時点ではプロセス未起動）
    m_usi1 = new Usi(comm1, think1, m_gc, m_playMode, this);
    m_usi2 = new Usi(comm2, think2, m_gc, m_playMode, this);

    // 状態初期化
    m_usi1->resetResignNotified(); m_usi1->clearHardTimeout();
    m_usi2->resetResignNotified(); m_usi2->clearHardTimeout();

    // 投了配線
    wireResignToArbiter_(m_usi1, /*asP1=*/true);
    wireResignToArbiter_(m_usi2, /*asP1=*/false);

    // ログ識別
    m_usi1->setLogIdentity(QStringLiteral("[E1]"), QStringLiteral("P1"), engineName1);
    m_usi2->setLogIdentity(QStringLiteral("[E2]"), QStringLiteral("P2"), engineName2);
    m_usi1->setSquelchResignLogging(false);
    m_usi2->setSquelchResignLogging(false);

    // MainWindow 互換：司令塔が保有する USI を最新化
    updateUsiPtrs(m_usi1, m_usi2);
}

bool MatchCoordinator::engineThinkApplyMove(Usi* engine,
                                            QString& positionStr,
                                            QString& ponderStr,
                                            QPoint* outFrom,
                                            QPoint* outTo)
{
    if (!engine || !m_gc) return false;

    const GoTimes t = computeGoTimes_();

    // byoyomi が設定されていれば USI 的には秒読みを使う
    const bool useByoyomi = (t.byoyomi > 0);

    // qint64 → int への安全な変換（オーバーフロー防止）
    auto clampMsToInt = [](qint64 ms) -> int {
        if (ms < 0) return 0;
        if (ms > std::numeric_limits<int>::max()) return std::numeric_limits<int>::max();
        return static_cast<int>(ms);
    };

    const QString btimeStr = QString::number(t.btime);
    const QString wtimeStr = QString::number(t.wtime);

    QPoint from(-1, -1), to(-1, -1);
    m_gc->setPromote(false);

    // 例外を投げない前提：失敗は内部でログ/シグナル通知済み
    engine->handleEngineVsHumanOrEngineMatchCommunication(
        positionStr,              // 現局面（SFEN/position）
        ponderStr,                // ponder
        from, to,                 // 出力される移動先
        clampMsToInt(t.byoyomi),  // byoyomi ms (int)
        btimeStr,                 // btime (QString)
        wtimeStr,                 // wtime (QString)
        clampMsToInt(t.binc),     // 先手加算 (int)
        clampMsToInt(t.winc),     // 後手加算 (int)
        useByoyomi                // byoyomi 使用フラグ
        );

    if (outFrom) *outFrom = from;
    if (outTo)   *outTo   = to;

    // resign/win/draw 等では from/to が (-1,-1) のままになる想定 → false で中断
    auto isValidTo = [](const QPoint& p) {
        return (p.x() >= 1 && p.x() <= 9 && p.y() >= 1 && p.y() <= 9);
    };
    if (!isValidTo(to)) {
        qInfo() << "[Match] engineThinkApplyMove: no legal 'to' returned (resign/abort?). from="
                << from << "to=" << to;
        if (m_hooks.log) m_hooks.log(QStringLiteral("[Match] engineThinkApplyMove: no legal move (resign/abort?)"));
        return false;
    }

    // from は 1..9（盤上）または 10/11（打ち駒）を許容。細かい妥当性は validateAndMove に委譲。
    return true;
}

bool MatchCoordinator::engineMoveOnce(Usi* eng,
                                      QString& positionStr,
                                      QString& ponderStr,
                                      bool /*useSelectedField2*/,
                                      int engineIndex,
                                      QPoint* outTo)
{
    if (!m_gc) return false;

    const auto moverBefore = m_gc->currentPlayer();
    qDebug() << "[EVE] engineMoveOnce enter"
             << "engineIndex=" << engineIndex
             << "moverBefore=" << int(moverBefore)
             << "thread=" << QThread::currentThread();

    QPoint from, to;
    if (!engineThinkApplyMove(eng, positionStr, ponderStr, &from, &to)) {
        qDebug() << "[EVE] engineThinkApplyMove FAILED";
        return false;
    }
    qDebug() << "[EVE] engineThinkApplyMove OK from=" << from << "to=" << to;

    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();

    switch (moverBefore) {
    case ShogiGameController::Player1:
        qDebug() << "[EVE] calling appendEvalP1";
        if (m_hooks.appendEvalP1) m_hooks.appendEvalP1();
        else qDebug() << "[EVE][WARN] appendEvalP1 NOT set";
        break;
    case ShogiGameController::Player2:
        qDebug() << "[EVE] calling appendEvalP2";
        if (m_hooks.appendEvalP2) m_hooks.appendEvalP2();
        else qDebug() << "[EVE][WARN] appendEvalP2 NOT set";
        break;
    default:
        qDebug() << "[EVE][WARN] moverBefore=NoPlayer -> skip eval append";
        break;
    }

    if (outTo) *outTo = to;
    return true;
}

bool MatchCoordinator::playOneEngineTurn(Usi* mover,
                                         Usi* receiver,
                                         QString& positionStr,
                                         QString& ponderStr,
                                         int engineIndex)
{
    QPoint to;
    if (!engineMoveOnce(mover, positionStr, ponderStr,
                        /*useSelectedField2=*/false,
                        engineIndex, &to)) {
        return false;
    }

    // 次手ヒントを相手エンジンへ
    if (receiver) {
        receiver->setPreviousFileTo(to.x());
        receiver->setPreviousRankTo(to.y());
    }

    // ここでの終局判定は未定義メンバ m_gameIsOver を参照せず、
    // 司令塔の gameEnded() 発火側に委譲します。
    return true;
}

void MatchCoordinator::sendGameOverWinAndQuit()
{
    switch (m_playMode) {
    case HumanVsHuman:
        // 送信不要
        break;

    case EvenHumanVsEngine:
    case HandicapHumanVsEngine:
        // ★ 単発は常に m_usi1 を使う
        if (m_usi1) m_usi1->sendGameOverWinAndQuitCommands();
        break;

    case EvenEngineVsHuman:
    case HandicapEngineVsHuman:
        // 単発は常に m_usi1
        if (m_usi1) m_usi1->sendGameOverWinAndQuitCommands();
        break;

    case EvenEngineVsEngine:
    case HandicapEngineVsEngine:
        if (m_usi1) m_usi1->sendGameOverWinAndQuitCommands();
        if (m_usi2) m_usi2->sendGameOverWinAndQuitCommands();
        break;

    default:
        break;
    }
}

void MatchCoordinator::configureAndStart(const StartOptions& opt)
{
    // ===== デバッグ: 入口で現状の m_positionStr1 / 履歴を記録 =====
    qDebug().noquote() << "[MC][configureAndStart] ENTER"
                       << "opt.sfenStart=" << opt.sfenStart
                       << "m_positionStr1(before)=" << m_positionStr1
                       << "hist.size=" << m_positionStrHistory.size()
                       << "hist.last=" << (m_positionStrHistory.isEmpty() ? QString("<empty>") : m_positionStrHistory.constLast());

    m_playMode = opt.mode;

    // 盤・名前などの初期化（GUI側へ委譲）
    if (m_hooks.initializeNewGame) m_hooks.initializeNewGame(opt.sfenStart);
    if (m_hooks.setPlayersNames)   m_hooks.setPlayersNames(QString(), QString());
    if (m_hooks.setEngineNames)    m_hooks.setEngineNames(opt.engineName1, opt.engineName2);
    if (m_hooks.setGameActions)    m_hooks.setGameActions(true);

    // ---- 開始手番の決定（SFEN 解析：position sfen ... / 素のSFEN の両対応）
    auto decideStartSideFromSfen = [](const QString& sfen) -> ShogiGameController::Player {
        ShogiGameController::Player start = ShogiGameController::Player1;
        if (sfen.isEmpty()) return start;

        const QStringList tok = sfen.split(' ', Qt::SkipEmptyParts);
        if (tok.size() < 2) return start;

        int sideIdx = -1;
        // 形式1: "position sfen <board> <side> <..." → side は index=3
        if (tok.size() >= 4 && tok[0] == QLatin1String("position") && tok[1] == QLatin1String("sfen")) {
            sideIdx = 3;
        }
        // 形式2: "<board> <side> <..." → side は index=1
        else if (tok.size() >= 2) {
            sideIdx = 1;
        }

        if (sideIdx >= 0 && sideIdx < tok.size()) {
            const QString side = tok[sideIdx];
            if (side.compare(QLatin1String("w"), Qt::CaseInsensitive) == 0) {
                start = ShogiGameController::Player2; // 後手番
            } else {
                start = ShogiGameController::Player1; // 先手番
            }
        }
        return start;
    };

    const ShogiGameController::Player startSide = decideStartSideFromSfen(opt.sfenStart);

    // ★ GC へ開始手番を反映（無ければ先手既定）
    if (m_gc) {
        m_gc->setCurrentPlayer(startSide);
    }
    // ★ 盤描画は「手番反映のあと」に行う
    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();

    // EvE 用の内部棋譜コンテナを初期化
    m_eveSfenRecord.clear();
    m_eveGameMoves.clear();
    m_eveMoveIndex = 0;

    // HvE/HvH 用の共通安全策
    m_currentMoveIndex = 0;

    // 司令塔の内部手番も GC に同期（既存コードとの互換維持）
    m_cur = (startSide == ShogiGameController::Player2) ? P2 : P1;
    updateTurnDisplay_(m_cur);

    // ------------------------------------------------------------
    // ★★ m_positionStrHistory をベースに「moves だけ」トリムする ★★
    //     ・ヘッダ（"position startpos" / "position sfen ..."）は絶対に書き換えない
    //     ・opt.sfenStart 末尾の手数(N) → 残す手数 = N-1
    // ------------------------------------------------------------
    auto parseKeepMovesFromSfen = [](const QString& sfenLike) -> int {
        // "position sfen <board> <side> <stand> <move>"
        // もしくは "<board> <side> <stand> <move>"
        QString s = sfenLike.trimmed();
        if (s.startsWith(QLatin1String("position sfen "))) {
            s = s.mid(QStringLiteral("position sfen ").size()).trimmed();
        }
        const QStringList tok = s.split(QLatin1Char(' '), Qt::SkipEmptyParts);
        if (tok.size() >= 4) {
            bool ok = false;
            const int mv = tok.last().toInt(&ok);
            if (ok) {
                const int keep = qMax(0, mv - 1); // "b - 1" → 0手, "b - 3" → 2手
                return keep;
            }
        }
        return -1; // 不明
    };

    // ★ 平手初期局面（startpos相当）かを判定
    auto isStandardStartposSfen = [](const QString& sfenLike) -> bool {
        // 「position sfen …」が付いていても切り落とす
        QString s = sfenLike.trimmed();
        if (s.startsWith(QLatin1String("position sfen "))) {
            s = s.mid(QStringLiteral("position sfen ").size()).trimmed();
        }
        // board turn hand move
        const QStringList tok = s.split(QLatin1Char(' '), Qt::SkipEmptyParts);
        if (tok.size() < 4) return false;

        const QString board = tok[0];
        const QString turn  = tok[1];
        const QString hand  = tok[2];
        const QString move  = tok[3];

        // 平手初期の盤面
        static const QString kStartBoard =
            QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL");

        if (board != kStartBoard) return false;
        if (turn.compare(QLatin1String("b"), Qt::CaseInsensitive) != 0) return false;
        if (hand != QLatin1String("-")) return false;

        bool ok = false;
        const int mv = move.toInt(&ok);
        if (!ok) return false;
        return (mv == 1);
    };

    const int keepMoves = parseKeepMovesFromSfen(opt.sfenStart);
    qDebug().noquote() << "[MC][configureAndStart] keepMoves(from sfenStart)=" << keepMoves;

    auto trimMovesPreserveHeader = [](const QString& full, int keep) -> QString {
        // full: "position startpos moves 7g7f 3c3d 2g2f" など
        const QString movesKey = QStringLiteral(" moves ");
        const int pos = full.indexOf(movesKey);
        QString head = full.trimmed();
        QString tail;

        if (pos >= 0) {
            head = full.left(pos).trimmed();                  // 例: "position startpos" / "position sfen <...>"
            tail = full.mid(pos + movesKey.size()).trimmed(); // 例: "7g7f 3c3d 2g2f"
        }

        if (keep <= 0 || tail.isEmpty()) {
            return head; // ヘッダのみ（startpos/sfen は“そのまま”）
        }

        QStringList mv = tail.split(QLatin1Char(' '), Qt::SkipEmptyParts);
        if (keep < mv.size()) mv = mv.mid(0, keep);
        if (mv.isEmpty()) return head;
        return head + movesKey + mv.join(QLatin1Char(' '));
    };

    bool applied = false;

    // ---- 履歴があれば、moves だけをトリムして流用（ヘッダは維持）
    if (!m_positionStrHistory.isEmpty() && keepMoves >= 0) {
        const QString prevFull = m_positionStrHistory.constLast();
        if (prevFull.startsWith(QLatin1String("position "))) {
            const QString trimmed = trimMovesPreserveHeader(prevFull, keepMoves);
            qDebug().noquote() << "[MC][configureAndStart] prevFull(from hist)=" << prevFull;
            qDebug().noquote() << "[MC][configureAndStart] trimmed(from hist, keep=" << keepMoves << ")=" << trimmed;

            m_positionStr1    = trimmed;
            m_positionPonder1 = trimmed;

            // 履歴はベースを差し替えて 1 件から再スタート（UNDO用）
            m_positionStrHistory.clear();
            m_positionStrHistory.append(trimmed);

            applied = true;
        } else {
            qWarning().noquote() << "[MC][configureAndStart] history.last is not 'position ...' :" << prevFull;
        }
    }

    // ---- 履歴が使えないときのフォールバック
    if (!applied) {
        // まず従来初期化
        initializePositionStringsForStart(opt.sfenStart);
        qDebug().noquote() << "[MC][configureAndStart] fallback init. m_positionStr1(before-startpos-fix)=" << m_positionStr1;

        // ★★★ 平手初期局面なら "position startpos" に強制上書き（movesなしの純ヘッダ）
        if (isStandardStartposSfen(opt.sfenStart)) {
            m_positionStr1    = QStringLiteral("position startpos");
            m_positionPonder1 = m_positionStr1;
            qDebug().noquote() << "[MC][configureAndStart] startpos header override ->" << m_positionStr1;
        }

        // 履歴も同期
        m_positionStrHistory.clear();
        if (!m_positionStr1.isEmpty()) m_positionStrHistory.append(m_positionStr1);
    }

    // ===== デバッグ: 現在のベース position を記録 =====
    qDebug().noquote() << "[MC][configureAndStart] m_positionStr1(current)=" << m_positionStr1
                       << "hist.size=" << m_positionStrHistory.size()
                       << "hist.last=" << (m_positionStrHistory.isEmpty() ? QString("<empty>") : m_positionStrHistory.constLast());

    // ---- モード別の起動ルート
    switch (m_playMode) {
    case EvenEngineVsEngine:
    case HandicapEngineVsEngine: {
        initEnginesForEvE(opt.engineName1, opt.engineName2);
        initializeAndStartEngineFor(P1, opt.enginePath1, opt.engineName1);
        initializeAndStartEngineFor(P2, opt.enginePath2, opt.engineName2);
        startEngineVsEngine_(opt);
        break;
    }
    case EvenHumanVsEngine:
    case HandicapHumanVsEngine: {
        const bool engineIsP1 = opt.engineIsP1;
        startHumanVsEngine_(opt, engineIsP1);
        break;
    }
    case EvenEngineVsHuman:
    case HandicapEngineVsHuman: {
        const bool engineIsP1 = true; // 先手エンジン
        startHumanVsEngine_(opt, engineIsP1);
        break;
    }
    case HumanVsHuman:
        startHumanVsHuman_(opt);
        break;
    default:
        break;
    }

    // ===== デバッグ: 退出時点の m_positionStr1 を記録 =====
    qDebug().noquote() << "[MC][configureAndStart] LEAVE m_positionStr1(final)=" << m_positionStr1
                       << "hist.size=" << m_positionStrHistory.size()
                       << "hist.last=" << (m_positionStrHistory.isEmpty() ? QString("<empty>") : m_positionStrHistory.constLast());
}

// HvH（人間対人間）
void MatchCoordinator::startHumanVsHuman_(const StartOptions& /*opt*/)
{
    if (m_hooks.log) m_hooks.log(QStringLiteral("[Match] Start HvH"));

    // --- 手番の単一ソースを確立：GC → TurnManager → m_cur → 表示
    ShogiGameController::Player side =
        m_gc ? m_gc->currentPlayer() : ShogiGameController::NoPlayer;
    if (side == ShogiGameController::NoPlayer) {
        side = ShogiGameController::Player1;         // 既定は先手
        if (m_gc) m_gc->setCurrentPlayer(side);
    }

    m_cur = (side == ShogiGameController::Player2) ? P2 : P1;

    // 盤描画は手番反映のあと（ハイライト/時計のズレ防止）
    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();
    updateTurnDisplay_(m_cur);
}

// HvE（人間対エンジン）
//   engineIsP1 == true ならエンジンは先手座席、false なら後手座席
void MatchCoordinator::startHumanVsEngine_(const StartOptions& opt, bool engineIsP1)
{
    if (m_hooks.log) {
        m_hooks.log(QStringLiteral("[Match] Start HvE (engineIsP1=%1)").arg(engineIsP1));
    }

    // 以前のエンジンは破棄（安全化）
    destroyEngines();

    // ★ 単発エンジン＝表示は常に #1 スロット（上段）へ流す
    //    → 座席が P1/P2 でも comm/think は #1 を使う
    UsiCommLogModel*          comm  = m_comm1;
    ShogiEngineThinkingModel* think = m_think1;
    if (!comm)  { comm  = new UsiCommLogModel(this);         m_comm1  = comm;  }
    if (!think) { think = new ShogiEngineThinkingModel(this); m_think1 = think; }

    // USI を生成（この時点ではプロセス未起動）
    m_usi1 = new Usi(comm, think, m_gc, m_playMode, this);
    m_usi2 = nullptr; // HvE は単発

    // 投了配線（m_usi1=先手扱いでよい：内部で asP1=true として扱う）
    wireResignToArbiter_(m_usi1, /*asP1=*/true);

    // ログ識別（UI 表示用）
    if (m_usi1) {
        const QString dispName = opt.engineName1.isEmpty() ? QStringLiteral("Engine") : opt.engineName1;
        m_usi1->setLogIdentity(QStringLiteral("[E1]"), QStringLiteral("P1"), dispName);
        m_usi1->setSquelchResignLogging(false);
    }

    // ★★★ ここが肝心：USI エンジンを起動（path/name 必須） ★★★
    initializeAndStartEngineFor(P1, opt.enginePath1, opt.engineName1);

    // UI 側にエンジン名を通知（必要時）
    if (m_hooks.setEngineNames) m_hooks.setEngineNames(opt.engineName1, QString());

    // --- 手番の単一ソースを確立：GC → m_cur → 表示 ---
    ShogiGameController::Player side =
        m_gc ? m_gc->currentPlayer() : ShogiGameController::NoPlayer;
    if (side == ShogiGameController::NoPlayer) {
        // 既定は先手（SFEN未指定時）
        side = ShogiGameController::Player1;
        if (m_gc) m_gc->setCurrentPlayer(side);
    }
    m_cur = (side == ShogiGameController::Player2) ? P2 : P1;

    // 盤描画は手番反映のあと（ハイライト/時計のズレ防止）
    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();
    updateTurnDisplay_(m_cur);
}

// EvE の初手を開始する（起動・初期化済み前提）
void MatchCoordinator::startEngineVsEngine_(const StartOptions& /*opt*/)
{
    if (!m_usi1 || !m_usi2 || !m_gc) return;

    if (m_gc->currentPlayer() == ShogiGameController::NoPlayer) {
        m_gc->setCurrentPlayer(ShogiGameController::Player1);
    }
    m_cur = (m_gc->currentPlayer() == ShogiGameController::Player2) ? P2 : P1;
    updateTurnDisplay_(m_cur);

    initPositionStringsForEvE_();

    const GoTimes t1 = computeGoTimes_();
    const QString btimeStr1 = QString::number(t1.btime);
    const QString wtimeStr1 = QString::number(t1.wtime);

    QPoint p1From(-1, -1), p1To(-1, -1);
    m_gc->setPromote(false);

    m_usi1->handleEngineVsHumanOrEngineMatchCommunication(
        m_positionStr1, m_positionPonder1,
        p1From, p1To,
        static_cast<int>(t1.byoyomi),
        btimeStr1, wtimeStr1,
        static_cast<int>(t1.binc), static_cast<int>(t1.winc),
        (t1.byoyomi > 0)
        );

    QString rec1;
    PlayMode pm = m_playMode;

    // ★ 先手1手目：次の手を渡す
    int nextEve = m_eveMoveIndex + 1;
    if (!m_gc->validateAndMove(
            p1From, p1To, rec1,
            pm,
            nextEve,
            &m_eveSfenRecord,
            m_eveGameMoves
            )) {
        return;
    } else {
        m_eveMoveIndex = nextEve;
    }

    if (m_clock) {
        const qint64 thinkMs = m_usi1 ? m_usi1->lastBestmoveElapsedMs() : 0;
        m_clock->setPlayer1ConsiderationTime(static_cast<int>(thinkMs));
        m_clock->applyByoyomiAndResetConsideration1();
    }
    if (m_hooks.appendKifuLine && m_clock) {
        m_hooks.appendKifuLine(rec1, m_clock->getPlayer1ConsiderationAndTotalTime());
    }

    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();
    if (m_hooks.showMoveHighlights) m_hooks.showMoveHighlights(p1From, p1To);
    updateTurnDisplay_((m_gc->currentPlayer() == ShogiGameController::Player1) ? P1 : P2);

    if (m_usi2) {
        m_usi2->setPreviousFileTo(p1To.x());
        m_usi2->setPreviousRankTo(p1To.y());
    }

    m_positionStr2     = m_positionStr1;
    m_positionPonder2.clear();

    const GoTimes t2 = computeGoTimes_();
    const QString btimeStr2 = QString::number(t2.btime);
    const QString wtimeStr2 = QString::number(t2.wtime);

    QPoint p2From(-1, -1), p2To(-1, -1);
    m_gc->setPromote(false);

    m_usi2->handleEngineVsHumanOrEngineMatchCommunication(
        m_positionStr2, m_positionPonder2,
        p2From, p2To,
        static_cast<int>(t2.byoyomi),
        btimeStr2, wtimeStr2,
        static_cast<int>(t2.binc), static_cast<int>(t2.winc),
        (t2.byoyomi > 0)
        );

    QString rec2;

    // ★ 後手1手目：次の手を渡す
    nextEve = m_eveMoveIndex + 1;
    if (!m_gc->validateAndMove(
            p2From, p2To, rec2,
            pm,
            nextEve,
            &m_eveSfenRecord,
            m_eveGameMoves
            )) {
        return;
    } else {
        m_eveMoveIndex = nextEve;
    }

    if (m_clock) {
        const qint64 thinkMs = m_usi2 ? m_usi2->lastBestmoveElapsedMs() : 0;
        m_clock->setPlayer2ConsiderationTime(static_cast<int>(thinkMs));
        m_clock->applyByoyomiAndResetConsideration2();
    }
    if (m_hooks.appendKifuLine && m_clock) {
        m_hooks.appendKifuLine(rec2, m_clock->getPlayer2ConsiderationAndTotalTime());
    }

    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();
    if (m_hooks.showMoveHighlights) m_hooks.showMoveHighlights(p2From, p2To);
    updateTurnDisplay_((m_gc->currentPlayer() == ShogiGameController::Player1) ? P1 : P2);

    QTimer::singleShot(std::chrono::milliseconds(0), this, &MatchCoordinator::kickNextEvETurn_);
}

Usi* MatchCoordinator::primaryEngine() const
{
    return m_usi1;
}

Usi* MatchCoordinator::secondaryEngine() const
{
    return m_usi2;
}

void MatchCoordinator::initPositionStringsForEvE_()
{
    m_positionStr1.clear();
    m_positionPonder1.clear();
    m_positionStr2.clear();
    m_positionPonder2.clear();

    const QString base = QStringLiteral("position startpos moves");
    m_positionStr1 = base;
    m_positionStr2 = base;
}

void MatchCoordinator::kickNextEvETurn_()
{
    if (m_playMode != EvenEngineVsEngine && m_playMode != HandicapEngineVsEngine) return;
    if (!m_usi1 || !m_usi2 || !m_gc) return;

    const bool p1ToMove = (m_gc->currentPlayer() == ShogiGameController::Player1);
    Usi* mover    = p1ToMove ? m_usi1 : m_usi2;
    Usi* receiver = p1ToMove ? m_usi2 : m_usi1;

    QString& pos    = p1ToMove ? m_positionStr1     : m_positionStr2;
    QString& ponder = p1ToMove ? m_positionPonder1  : m_positionPonder2;
    if (p1ToMove) pos = m_positionStr2; else pos = m_positionStr1;

    QPoint from(-1,-1), to(-1,-1);
    if (!engineThinkApplyMove(mover, pos, ponder, &from, &to))
        return;

    QString rec;

    // ★ 次の手を渡す
    int nextEve = m_eveMoveIndex + 1;
    if (!m_gc->validateAndMove(from, to, rec, m_playMode,
                               nextEve, &m_eveSfenRecord, m_eveGameMoves)) {
        return;
    } else {
        m_eveMoveIndex = nextEve;
    }

    if (m_clock) {
        const qint64 thinkMs = mover ? mover->lastBestmoveElapsedMs() : 0;
        if (p1ToMove) {
            m_clock->setPlayer1ConsiderationTime(static_cast<int>(thinkMs));
            m_clock->applyByoyomiAndResetConsideration1();
        } else {
            m_clock->setPlayer2ConsiderationTime(static_cast<int>(thinkMs));
            m_clock->applyByoyomiAndResetConsideration2();
        }
    }
    if (m_hooks.appendKifuLine && m_clock) {
        const QString elapsed = p1ToMove
                                    ? m_clock->getPlayer1ConsiderationAndTotalTime()
                                    : m_clock->getPlayer2ConsiderationAndTotalTime();
        m_hooks.appendKifuLine(rec, elapsed);
    }

    if (receiver) {
        receiver->setPreviousFileTo(to.x());
        receiver->setPreviousRankTo(to.y());
    }

    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();
    if (m_hooks.showMoveHighlights) m_hooks.showMoveHighlights(from, to);
    updateTurnDisplay_(
        (m_gc->currentPlayer() == ShogiGameController::Player1) ? P1 : P2
        );

    QTimer::singleShot(0, this, &MatchCoordinator::kickNextEvETurn_);
}

// ===== 時間制御の設定／照会 =====

void MatchCoordinator::setTimeControlConfig(bool useByoyomi,
                                            int byoyomiMs1, int byoyomiMs2,
                                            int incMs1,     int incMs2,
                                            bool loseOnTimeout)
{
    m_tc.useByoyomi       = useByoyomi;
    m_tc.byoyomiMs1       = qMax(0, byoyomiMs1);
    m_tc.byoyomiMs2       = qMax(0, byoyomiMs2);
    m_tc.incMs1           = qMax(0, incMs1);
    m_tc.incMs2           = qMax(0, incMs2);
    m_tc.loseOnTimeout    = loseOnTimeout;
}

const MatchCoordinator::TimeControl& MatchCoordinator::timeControl() const {
    return m_tc;
}

// ===== エポック管理（1手の開始時刻） =====

void MatchCoordinator::markTurnEpochNowFor(Player side, qint64 nowMs /*=-1*/) {
    if (nowMs < 0) nowMs = QDateTime::currentMSecsSinceEpoch();
    if (side == P1) m_turnEpochP1Ms = nowMs; else m_turnEpochP2Ms = nowMs;
}

qint64 MatchCoordinator::turnEpochFor(Player side) const {
    return (side == P1) ? m_turnEpochP1Ms : m_turnEpochP2Ms;
}

void MatchCoordinator::resetTurnEpochs() {
    m_turnEpochP1Ms = m_turnEpochP2Ms = -1;
}

// ===== ターン計測（HvH用の簡易ストップウォッチ） =====

void MatchCoordinator::armTurnTimerIfNeeded() {
    if (!m_turnTimerArmed) {
        m_turnTimer.start();
        m_turnTimerArmed = true;
    }
}

void MatchCoordinator::finishTurnTimerAndSetConsiderationFor(Player mover) {
    if (!m_turnTimerArmed) return;
    const qint64 ms = m_turnTimer.isValid() ? m_turnTimer.elapsed() : 0;
    if (m_clock) {
        if (mover == P1) m_clock->setPlayer1ConsiderationTime(static_cast<int>(ms));
        else             m_clock->setPlayer2ConsiderationTime(static_cast<int>(ms));
    }
    m_turnTimer.invalidate();
    m_turnTimerArmed = false;
}

// ===== 人間側の計測（HvEでの人間手） =====

void MatchCoordinator::armHumanTimerIfNeeded() {
    if (!m_humanTimerArmed) {
        m_humanTurnTimer.start();
        m_humanTimerArmed = true;
    }
}

void MatchCoordinator::finishHumanTimerAndSetConsideration() {
    // どちらが「人間側」かは Main からのフックで取得（HvE想定）
    if (!m_hooks.humanPlayerSide) return;
    const Player side = m_hooks.humanPlayerSide();

    // ShogiClock 内部の考慮msをそのまま反映
    if (m_clock) {
        const qint64 clkMs = (side == P1) ? m_clock->player1ConsiderationMs()
                                          : m_clock->player2ConsiderationMs();
        if (side == P1) m_clock->setPlayer1ConsiderationTime(static_cast<int>(clkMs));
        else            m_clock->setPlayer2ConsiderationTime(static_cast<int>(clkMs));
    }
    if (m_humanTurnTimer.isValid()) m_humanTurnTimer.invalidate();
    m_humanTimerArmed = false;
}

void MatchCoordinator::disarmHumanTimerIfNeeded() {
    if (!m_humanTimerArmed) return;
    m_humanTimerArmed = false;
    m_humanTurnTimer.invalidate();
}

// ===== USI用 残時間算出 =====


MatchCoordinator::GoTimes MatchCoordinator::computeGoTimes_() const {
    GoTimes t;

    const bool hasRemainHook = static_cast<bool>(m_hooks.remainingMsFor);
    const bool hasIncHook    = static_cast<bool>(m_hooks.incrementMsFor);
    const bool hasByoHook    = static_cast<bool>(m_hooks.byoyomiMs);

    // 残り（ms）
    const qint64 rawB = hasRemainHook ? qMax<qint64>(0, m_hooks.remainingMsFor(P1)) : 0;
    const qint64 rawW = hasRemainHook ? qMax<qint64>(0, m_hooks.remainingMsFor(P2)) : 0;

    // デバッグ（入力値）
    qDebug().noquote()
        << "[Match] computeGoTimes_: hooks{remain=" << hasRemainHook
        << ", inc=" << hasIncHook
        << ", byo=" << hasByoHook
        << "} rawB=" << rawB << " rawW=" << rawW
        << " useByoyomi=" << m_tc.useByoyomi;

    if (m_tc.useByoyomi) {
        // 秒読み：btime/wtime はメイン残のみ。秒読み“適用中”なら 0 を送る。
        const bool bApplied = m_clock ? m_clock->byoyomi1Applied() : false;
        const bool wApplied = m_clock ? m_clock->byoyomi2Applied() : false;

        t.btime = bApplied ? 0 : rawB;
        t.wtime = wApplied ? 0 : rawW;
        t.byoyomi = (hasByoHook ? m_hooks.byoyomiMs() : 0);
        t.binc = t.winc = 0;

        qDebug().noquote()
            << "[Match] computeGoTimes_: BYO"
            << " bApplied=" << bApplied << " wApplied=" << wApplied
            << " => btime=" << t.btime << " wtime=" << t.wtime
            << " byoyomi=" << t.byoyomi;
    } else {
        // フィッシャー：btime/wtime は残り。inc は m_tc で保持。
        t.btime = rawB;
        t.wtime = rawW;
        t.byoyomi = 0;
        t.binc = m_tc.incMs1;
        t.winc = m_tc.incMs2;

        // （ポリシー）送信直前に増加分を引いてから渡す
        if (t.binc > 0) t.btime = qMax<qint64>(0, t.btime - t.binc);
        if (t.winc > 0) t.wtime = qMax<qint64>(0, t.wtime - t.winc);

        qDebug().noquote()
            << "[Match] computeGoTimes_: FISCHER"
            << " => btime=" << t.btime << " wtime=" << t.wtime
            << " binc=" << t.binc << " winc=" << t.winc;
    }

    return t;
}

void MatchCoordinator::sendGoToCurrentEngine_(const GoTimes& t)
{
    Usi* target = (m_cur == P1) ? m_usi1 : m_usi2;
    if (!target) {
        qDebug() << "[Match] sendGoToCurrentEngine_: target null";
        return;
    }

    const bool useByoyomi = (t.byoyomi > 0 && t.binc == 0 && t.winc == 0);

    qDebug().noquote()
        << "[Match] sendGoToCurrentEngine_:"
        << "cur=" << (m_cur==P1?"P1":"P2")
        << " btime=" << t.btime
        << " wtime=" << t.wtime
        << " byoyomi=" << t.byoyomi
        << " binc=" << t.binc
        << " winc=" << t.winc
        << " useByoyomi=" << useByoyomi;

    target->sendGoCommand(
        clampMsToIntLocal(t.byoyomi),         // byoyomi(ms)
        QString::number(t.btime),             // btime(ms)
        QString::number(t.wtime),             // wtime(ms)
        clampMsToIntLocal(t.binc),            // 先手inc(ms)
        clampMsToIntLocal(t.winc),            // 後手inc(ms)
        useByoyomi
        );
}

void MatchCoordinator::computeGoTimesForUSI(qint64& outB, qint64& outW) const {
    const GoTimes t = computeGoTimes_();
    outB = t.btime;
    outW = t.wtime;
}

void MatchCoordinator::refreshGoTimes() {
    qint64 b=0, w=0;
    computeGoTimesForUSI(b, w);
    m_bTimeStr = QString::number(b);
    m_wTimeStr = QString::number(w);
    emit timesForUSIUpdated(b, w);
}

int MatchCoordinator::computeMoveBudgetMsForCurrentTurn() const {
    const bool p1turn = (m_gc && m_gc->currentPlayer() == ShogiGameController::Player1);
    const int  mainMs = p1turn ? m_bTimeStr.toInt() : m_wTimeStr.toInt();
    const int  byoMs  = m_tc.useByoyomi ? (p1turn ? m_tc.byoyomiMs1 : m_tc.byoyomiMs2) : 0;
    return mainMs + byoMs;
}

void MatchCoordinator::setClock(ShogiClock* clock)
{
    if (m_clock == clock) return;
    unwireClock_();
    m_clock = clock;
    wireClock_();
}

void MatchCoordinator::onClockTick_()
{
    // デバッグ：ここが動いていれば Coordinator は時計を受信できている
    qDebug() << "[Match] onClockTick_()";
    emitTimeUpdateFromClock_();
}

void MatchCoordinator::pokeTimeUpdateNow()
{
    emitTimeUpdateFromClock_();
}

void MatchCoordinator::emitTimeUpdateFromClock_()
{
    if (!m_clock || !m_gc) return;

    const qint64 p1ms = m_clock->getPlayer1TimeIntMs();
    const qint64 p2ms = m_clock->getPlayer2TimeIntMs();
    const bool p1turn = (m_gc->currentPlayer() == ShogiGameController::Player1);

    const bool hasByoyomi = p1turn ? m_clock->hasByoyomi1()
                                   : m_clock->hasByoyomi2();
    const bool inByoyomi  = p1turn ? m_clock->byoyomi1Applied()
                                  : m_clock->byoyomi2Applied();
    const bool enableUrgency = (!hasByoyomi) || inByoyomi;

    const qint64 activeMs = p1turn ? p1ms : p2ms;
    const qint64 urgencyMs = enableUrgency ? activeMs
                                           : std::numeric_limits<qint64>::max();

    // デバッグ：UI へ送る値を確認
    qDebug() << "[Match] emit timeUpdated p1ms=" << p1ms << " p2ms=" << p2ms
             << " p1turn=" << p1turn << " urgencyMs=" << urgencyMs;

    emit timeUpdated(p1ms, p2ms, p1turn, urgencyMs);
}

void MatchCoordinator::wireClock_()
{
    if (!m_clock) return;
    if (m_clockConn) { QObject::disconnect(m_clockConn); m_clockConn = {}; }

    // 明示シグネチャにしておくと安心（ShogiClock 側の timeUpdated が多態でも解決）
    m_clockConn = connect(m_clock, &ShogiClock::timeUpdated,
                          this, &MatchCoordinator::onClockTick_,
                          Qt::UniqueConnection);
    Q_ASSERT(m_clockConn);
}

void MatchCoordinator::unwireClock_()
{
    if (m_clockConn) { QObject::disconnect(m_clockConn); m_clockConn = {}; }
}

void MatchCoordinator::clearGameOverState()
{
    const bool wasOver = m_gameOver.isOver;
    m_gameOver = GameOverState{}; // 全クリア
    if (wasOver) {
        emit gameOverStateChanged(m_gameOver);
        qDebug() << "[Match] clearGameOverState()";
    }
}

// 司令塔が終局を確定させる唯一の入口
void MatchCoordinator::setGameOver(const GameEndInfo& info, bool loserIsP1, bool appendMoveOnce)
{
    if (m_gameOver.isOver) {
        qDebug() << "[MC] setGameOver() ignored: already over";
        return;
    }

    qDebug().nospace()
        << "[MC] setGameOver cause="
        << ((info.cause==Cause::Timeout)?"Timeout":"Resign")
        << " loser=" << ((info.loser==P1)?"P1":"P2")
        << " appendMoveOnce=" << appendMoveOnce;

    m_gameOver.isOver        = true;
    m_gameOver.hasLast       = true;
    m_gameOver.lastLoserIsP1 = loserIsP1;
    m_gameOver.lastInfo      = info;
    m_gameOver.when          = QDateTime::currentDateTime();

    emit gameOverStateChanged(m_gameOver);
    emit gameEnded(info);

    if (appendMoveOnce && !m_gameOver.moveAppended) {
        qDebug() << "[MC] emit requestAppendGameOverMove";
        emit requestAppendGameOverMove(info);
    }
}

void MatchCoordinator::markGameOverMoveAppended()
{
    if (!m_gameOver.isOver) return;
    if (m_gameOver.moveAppended) return;

    m_gameOver.moveAppended = true;
    emit gameOverStateChanged(m_gameOver);
    qDebug() << "[Match] markGameOverMoveAppended()";
}

void MatchCoordinator::sendGameOverWinAndQuitTo(int idx)
{
    Usi* target = (idx == 1 ? m_usi1 : m_usi2);
    if (!target) return;

    // HvE のときは opponent が nullptr の可能性があるが、WIN 側だけ送れば良い。
    target->sendGameOverWinAndQuitCommands();
}

// 投了と同様に“対局の実体”として中断を一元処理
void MatchCoordinator::handleBreakOff()
{
    // すでに終局なら何もしない
    if (m_gameOver.isOver) return;

    // 進行系タイマを停止（人間用のみでOK）
    disarmHumanTimerIfNeeded();

    // 司令塔として終局状態を確定（中断）
    m_gameOver.isOver         = true;
    m_gameOver.when           = QDateTime::currentDateTime();
    m_gameOver.hasLast        = true;
    m_gameOver.lastInfo.cause = Cause::BreakOff;

    // ★ 中断行の生成＋KIF追記＋一度だけの追記ブロック確定（内部で emit 済み）
    appendBreakOffLineAndMark();

    // 起動中エンジンに quit
    if (m_usi1) m_usi1->sendQuitCommand();
    if (m_usi2) m_usi2->sendQuitCommand();
}

// 検討を開始する（単発エンジンセッション）
// - 既存の HvE と同じく m_usi1 を使用し、表示モデルは #1 スロットに流す。
// - resign シグナルは P1 扱いで司令塔（Arbiter）に配線する（検討でも安全側）。
// 検討を開始する（単発エンジンセッション）
void MatchCoordinator::startAnalysis(const AnalysisOptions& opt)
{
    // 1) モード設定（検討 / 詰み探索）
    setPlayMode(opt.mode); // ConsidarationMode or TsumiSearchMode

    // 2) 以前の単発エンジンは破棄
    destroyEngines();

    // 3) 表示モデル（無ければ生成して保持）
    UsiCommLogModel*          comm  = m_comm1;
    ShogiEngineThinkingModel* think = m_think1;
    if (!comm)  { comm  = new UsiCommLogModel(this);          m_comm1  = comm;  }
    if (!think) { think = new ShogiEngineThinkingModel(this); m_think1 = think; }

    // 4) 単発エンジン生成（常に m_usi1 を使用）
    m_usi1 = new Usi(comm, think, m_gc, m_playMode, this);

    // 既存の接続（bestmove等）はそのまま。エラー用だけスロット接続を追加。
    connect(m_usi1, &Usi::errorOccurred,
            this,   &MatchCoordinator::onUsiError_,
            Qt::UniqueConnection);

    // 5) 投了配線
    wireResignToArbiter_(m_usi1, /*asP1=*/true);

    // 6) ログ識別
    m_usi1->setLogIdentity(QStringLiteral("[E1]"), QStringLiteral("P1"), opt.engineName);
    m_usi1->setSquelchResignLogging(false);

    // 7) USI 初期化＆起動（例外非使用前提）
    initializeAndStartEngineFor(P1, opt.enginePath, opt.engineName);

    // 8) UI 側にエンジン名を通知（必要時）
    if (m_hooks.setEngineNames) m_hooks.setEngineNames(opt.engineName, QString());

    // 9) 詰み探索の配線（TsumiSearchMode のときのみ）
    if (opt.mode == TsumiSearchMode && m_usi1) {
        connect(m_usi1, &Usi::checkmateSolved,
                this,  &MatchCoordinator::onCheckmateSolved_,
                Qt::UniqueConnection);
        connect(m_usi1, &Usi::checkmateNoMate,
                this,  &MatchCoordinator::onCheckmateNoMate_,
                Qt::UniqueConnection);
        connect(m_usi1, &Usi::checkmateNotImplemented,
                this,  &MatchCoordinator::onCheckmateNotImplemented_,
                Qt::UniqueConnection);
        connect(m_usi1, &Usi::checkmateUnknown,
                this,  &MatchCoordinator::onCheckmateUnknown_,
                Qt::UniqueConnection);
    }

    // 10) 解析/詰み探索の実行
    QString pos = opt.positionStr; // "position sfen <...>"
    if (opt.mode == TsumiSearchMode) {
        m_usi1->executeTsumeCommunication(pos, opt.byoyomiMs);
    } else {
        m_usi1->executeAnalysisCommunication(pos, opt.byoyomiMs);
    }
}

void MatchCoordinator::onCheckmateSolved_(const QStringList& pv)
{
    if (m_hooks.showGameOverDialog) {
        const QString msg = tr("詰みあり（手順 %1 手）").arg(pv.size());
        m_hooks.showGameOverDialog(tr("詰み探索"), msg);
    }
}

void MatchCoordinator::onCheckmateNoMate_()
{
    if (m_hooks.showGameOverDialog) {
        m_hooks.showGameOverDialog(tr("詰み探索"), tr("詰みなし"));
    }
}

void MatchCoordinator::onCheckmateNotImplemented_()
{
    if (m_hooks.showGameOverDialog) {
        m_hooks.showGameOverDialog(tr("詰み探索"), tr("（エンジン側）未実装"));
    }
}

void MatchCoordinator::onCheckmateUnknown_()
{
    if (m_hooks.showGameOverDialog) {
        m_hooks.showGameOverDialog(tr("詰み探索"), tr("不明（解析不能）"));
    }
}

// 検討の停止（stop コマンド送信のみ。プロセス終了は destroyEngines() に委譲）
void MatchCoordinator::stopAnalysis()
{
    if (m_playMode != ConsidarationMode) return;
    if (m_usi1) {
        m_usi1->sendStopCommand();
        // 必要なら：m_usi1->waitForStopOrPonderhitCommand();
    }
}

// 検討中かを返す（モードと m_usi1 の有無で判定）
bool MatchCoordinator::isAnalysisActive() const
{
    return (m_playMode == ConsidarationMode) && (m_usi1 != nullptr);
}

// 検討モードを手動終了する（quit送信→エンジン破棄）
//  - ConsidarationMode 以外では何もしない
//  - Usi::sendQuitCommand() は終了時のログ抑止などの安全策込み
//  - 送信後にプロセス/スレッドを片付け、Usi オブジェクトも破棄
//  - モードは NotStarted に戻す（isAnalysisActive() が偽になる）
void MatchCoordinator::handleBreakOffConsidaration()
{
    if (m_playMode != ConsidarationMode)
        return;

    // 単発検討は m_usi1 を利用している前提（存在すれば確実に止める）
    if (m_usi1) {
        m_usi1->cleanupEngineProcessAndThread(); // 読み取り側をドレインして安全終了
        destroyEngine(1);                       // Usi オブジェクト自体も破棄
    }

    // 念のため、片側だけの想定でも m_usi2 が残っていれば同様に止める
    if (m_usi2) {
        m_usi2->cleanupEngineProcessAndThread();
        destroyEngine(2);
    }

    // モードを通常状態へ戻す（以降 isAnalysisActive()==false）
    setPlayMode(NotStarted);

    // UI 側のボタン等を「対局中でない」状態へ（フック未設定なら何もしない）
    setGameInProgressActions_(false);

    // 手番表示などの軽い再描画（必要なければ削ってOK）
    updateTurnDisplay_(m_cur);
}

void MatchCoordinator::continueAnalysis(const QString& positionStr, int byoyomiMs)
{
    // 検討モードで単発エンジン m_usi1 が起動済みであることが前提
    if (m_playMode != ConsidarationMode || !m_usi1) {
        if (m_hooks.log) m_hooks.log(QStringLiteral("[Analysis] continueAnalysis skipped (no active engine)"));
        return;
    }

    // Usi::executeAnalysisCommunication は非常参照引数なのでコピーを渡す
    QString pos = positionStr;
    m_usi1->executeAnalysisCommunication(pos, byoyomiMs);
}

void MatchCoordinator::startTsumeSearch(const QString& sfen, int timeMs, bool infinite)
{
    Usi* eng = primaryEngine();
    if (!eng) return;

    // ここでは接続や未宣言シグナルのemitは行わない
    // （先にビルドを通すための最小実装。結果処理は後続で接続可能）
    eng->sendPositionAndGoMate(sfen, timeMs, infinite);
}

void MatchCoordinator::stopTsumeSearch()
{
    Usi* eng = primaryEngine();
    if (!eng) return;

    // 詰み探索の停止
    eng->sendStopForMate();
}

// 【新規/任意】詰み探索中にbestmoveが来た場合の保険
void MatchCoordinator::onUsiBestmoveDuringTsume_(const QString& bestmove)
{
    Q_UNUSED(bestmove);
    // 多くの場合は無視で良い。ログだけ残す。
    qInfo() << "[Tsume] bestmove during mate-search:" << bestmove;
}

void MatchCoordinator::onUsiError_(const QString& msg)
{
    // ログへ（あれば）
    if (m_hooks.log) m_hooks.log(QStringLiteral("[USI-ERROR] ") + msg);
    // 実行中の USI オペを明示的に打ち切る
    if (m_usi1) m_usi1->cancelCurrentOperation();
    if (m_usi2) m_usi2->cancelCurrentOperation();
}

// ---------------------------------------------
// 初期 "position ... moves" を SFEN から生成
// ---------------------------------------------
void MatchCoordinator::initializePositionStringsForStart(const QString& sfenStart)
{
    initPositionStringsFromSfen_(sfenStart);
}

void MatchCoordinator::initPositionStringsFromSfen_(const QString& sfenBase)
{
    // m_positionStr1/m_positionPonder1 だけ使う（単発エンジン系）
    m_positionStr1.clear();
    m_positionPonder1.clear();

    // ★追加：USIのposition履歴はSFENと混ぜないため、開始ごとにクリア
    m_positionStrHistory.clear();

    QString base = sfenBase;
    if (base.isEmpty()) {
        // フォールバックは startpos
        m_positionStr1    = QStringLiteral("position startpos moves");
        m_positionPonder1 = m_positionStr1;
        return;
    }

    // "position sfen ..." 形式に正規化
    // 既に "position " で始まっていればそのまま使う
    if (base.startsWith(QLatin1String("position "))) {
        m_positionStr1    = base;
        m_positionPonder1 = base;
    } else {
        m_positionStr1    = QStringLiteral("position sfen %1").arg(base);
        m_positionPonder1 = m_positionStr1;
    }
}

// ---------------------------------------------
// 初手がエンジン手番なら 1手だけ起動
// ---------------------------------------------
void MatchCoordinator::startInitialEngineMoveIfNeeded()
{
    if (!m_gc) return;

    const bool engineIsP1 = (m_playMode == EvenEngineVsHuman) || (m_playMode == HandicapEngineVsHuman);
    const bool engineIsP2 = (m_playMode == EvenHumanVsEngine) || (m_playMode == HandicapHumanVsEngine);

    const auto sideToMove = m_gc->currentPlayer();

    if (engineIsP1 && sideToMove == ShogiGameController::Player1) {
        startInitialEngineMoveFor_(P1);
    } else if (engineIsP2 && sideToMove == ShogiGameController::Player2) {
        startInitialEngineMoveFor_(P2);
    }
}

// （内部）指定したエンジン側で 1手だけ指す
void MatchCoordinator::startInitialEngineMoveFor_(Player engineSide)
{
    Usi* eng = primaryEngine();
    if (!eng || !m_gc) return;

    auto extractMoveNumber = [](const QString& sfen) -> int {
        const QStringList tok = sfen.split(' ', Qt::SkipEmptyParts);
        if (tok.size() >= 5) return tok.last().toInt();
        return -1;
    };

    if (m_positionStr1.isEmpty()) {
        initPositionStringsFromSfen_(QString()); // startpos moves
    }
    if (!m_positionStr1.startsWith(QLatin1String("position "))) {
        m_positionStr1 = QStringLiteral("position startpos moves");
    }

    const int mcCur = m_currentMoveIndex;
    const int recSizeBefore = m_sfenRecord ? m_sfenRecord->size() : -1;
    const QString recTailBefore = (m_sfenRecord && !m_sfenRecord->isEmpty()) ? m_sfenRecord->last() : QString();
    qInfo().noquote() << "[IDX][HvE:init] enter  mcCur=" << mcCur
                      << " recSizeBefore=" << recSizeBefore
                      << " recTailBefore='" << recTailBefore << "'";

    qint64 bMs = 0, wMs = 0;
    computeGoTimesForUSI(bMs, wMs);
    const QString bTime = QString::number(bMs);
    const QString wTime = QString::number(wMs);

    const auto tc = timeControl();
    const int  byoyomiMs = (engineSide == P1) ? tc.byoyomiMs1 : tc.byoyomiMs2;

    QPoint eFrom(-1, -1), eTo(-1, -1);
    m_gc->setPromote(false);

    eng->handleEngineVsHumanOrEngineMatchCommunication(
        m_positionStr1,
        m_positionPonder1,
        eFrom, eTo,
        byoyomiMs,
        bTime, wTime,
        tc.incMs1, tc.incMs2,
        tc.useByoyomi
        );

    QString rec;
    int nextIdx = mcCur + 1; // ★ 「次の手」
    const bool ok = m_gc->validateAndMove(
        eFrom, eTo, rec, m_playMode,
        nextIdx, m_sfenRecord, m_gameMoves);

    const QString recTailAfter = (m_sfenRecord && !m_sfenRecord->isEmpty()) ? m_sfenRecord->last() : QString();
    const int recTailNum = recTailAfter.isEmpty() ? -1 : extractMoveNumber(recTailAfter);

    qInfo().noquote() << "[IDX][HvE:init] v&m=" << ok
                      << " nextIdx=" << nextIdx
                      << " recTailAfter='" << recTailAfter << "' num=" << recTailNum;

    if (!ok) return;

    const qint64 thinkMs = eng->lastBestmoveElapsedMs();
    if (m_clock) {
        if (engineSide == P1) {
            m_clock->setPlayer1ConsiderationTime(static_cast<int>(thinkMs));
            m_clock->applyByoyomiAndResetConsideration1(); // ← 条件を外して常に適用
        } else {
            m_clock->setPlayer2ConsiderationTime(static_cast<int>(thinkMs));
            m_clock->applyByoyomiAndResetConsideration2(); // ← 条件を外して常に適用
        }
    }
    if (m_hooks.appendKifuLine && m_clock) {
        const QString elapsed = (engineSide == P1)
        ? m_clock->getPlayer1ConsiderationAndTotalTime()
        : m_clock->getPlayer2ConsiderationAndTotalTime();
        m_hooks.appendKifuLine(rec, elapsed);
    }

    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();
    m_cur = (m_gc->currentPlayer() == ShogiGameController::Player2) ? P2 : P1;
    updateTurnDisplay_(m_cur);

    armHumanTimerIfNeeded();

    if (engineSide == P1) { if (m_hooks.appendEvalP1) m_hooks.appendEvalP1(); }
    else                  { if (m_hooks.appendEvalP2) m_hooks.appendEvalP2(); }
}

// ---------------------------------------------
// HvE: 人間が指した直後の 1手返しを司令塔で完結
// ---------------------------------------------
void MatchCoordinator::onHumanMove_HvE(const QPoint& humanFrom, const QPoint& humanTo)
{
    auto extractMoveNumber = [](const QString& sfen) -> int {
        const QStringList tok = sfen.split(' ', Qt::SkipEmptyParts);
        // SFEN は <board> <turn> <hands> <move> の 4 トークン
        if (tok.size() >= 4) return tok.last().toInt();
        return -1;
    };

    // ★★★ ここで同期 ★★★
    int mcCur = m_currentMoveIndex;
    if (m_sfenRecord) {
        const int fromRec = qMax(0, m_sfenRecord->size() - 1);
        if (fromRec != mcCur) {
            qInfo() << "[IDX][HvE] sync mcCur" << mcCur << "->" << fromRec
                    << "(by recSize=" << m_sfenRecord->size() << ")";
            mcCur = fromRec;
            m_currentMoveIndex = fromRec;
        }
    }

    const int recSizeBefore = m_sfenRecord ? m_sfenRecord->size() : -1;
    const QString recTailBefore = (m_sfenRecord && !m_sfenRecord->isEmpty()) ? m_sfenRecord->last() : QString();
    qInfo().noquote() << "[IDX][HvE] enter  mcCur=" << mcCur
                      << " recSizeBefore=" << recSizeBefore
                      << " recTailBefore='" << recTailBefore << "'"
                      << " humanFrom=" << humanFrom << " humanTo=" << humanTo;

    // 人間側のストップウォッチ締め＆考慮確定（既存）
    finishHumanTimerAndSetConsideration();

    if (Usi* eng = primaryEngine()) {
        eng->setPreviousFileTo(humanTo.x());
        eng->setPreviousRankTo(humanTo.y());
    }

    // USIに渡す残り時間
    qint64 bMs = 0, wMs = 0;
    computeGoTimesForUSI(bMs, wMs);
    const QString bTime = QString::number(bMs);
    const QString wTime = QString::number(wMs);

    const bool engineIsP1 =
        (m_playMode == EvenEngineVsHuman) || (m_playMode == HandicapEngineVsHuman);
    const ShogiGameController::Player engineSeat =
        engineIsP1 ? ShogiGameController::Player1 : ShogiGameController::Player2;

    const bool engineTurnNow = (m_gc && (m_gc->currentPlayer() == engineSeat));
    qInfo().noquote() << "[IDX][HvE] engineTurnNow=" << engineTurnNow
                      << " engineSeat=" << int(engineSeat);
    if (!engineTurnNow) { if (!gameOverState().isOver) armHumanTimerIfNeeded(); return; }

    Usi* eng = primaryEngine();
    if (!eng || !m_gc || !m_sfenRecord) { if (!gameOverState().isOver) armHumanTimerIfNeeded(); return; }

    if (m_positionStr1.isEmpty()) { initPositionStringsFromSfen_(QString()); }
    if (!m_positionStr1.startsWith(QLatin1String("position "))) {
        m_positionStr1 = QStringLiteral("position startpos moves");
    }

    const auto tc = timeControl();
    const int byoyomiMs = engineIsP1 ? tc.byoyomiMs1 : tc.byoyomiMs2;

    QPoint eFrom = humanFrom, eTo = humanTo;
    m_gc->setPromote(false);

    eng->handleHumanVsEngineCommunication(
        m_positionStr1, m_positionPonder1,
        eFrom, eTo,
        byoyomiMs,
        bTime, wTime,
        m_positionStrHistory,
        tc.incMs1, tc.incMs2,
        tc.useByoyomi
        );

    QString rec;
    int nextIdx = mcCur + 1;              // ★ 同期後の mcCur から算出
    const bool ok = m_gc->validateAndMove(
        eFrom, eTo, rec, m_playMode,
        nextIdx, m_sfenRecord, m_gameMoves);

    const QString recTailAfter = (m_sfenRecord && !m_sfenRecord->isEmpty()) ? m_sfenRecord->last() : QString();
    const int recTailNum = recTailAfter.isEmpty() ? -1 : extractMoveNumber(recTailAfter);

    qInfo().noquote() << "[IDX][HvE] v&m=" << ok
                      << " argMove(nextIdx)=" << nextIdx
                      << " mcCur(before sync calc)=" << mcCur
                      << " recTailAfter='" << recTailAfter << "' num=" << recTailNum;

    if (ok) {
        m_currentMoveIndex = nextIdx;
        qInfo().noquote() << "[IDX][HvE] mcCur ->" << m_currentMoveIndex;
    } else {
        if (!gameOverState().isOver) armHumanTimerIfNeeded();
        return;
    }

    if (m_hooks.showMoveHighlights) m_hooks.showMoveHighlights(eFrom, eTo);

    // ★ エンジンの考慮時間を“確定”してから棋譜に追記する（ここが不在だった）
    const qint64 thinkMs = eng->lastBestmoveElapsedMs();
    if (m_clock) {
        if (m_gc->currentPlayer() == ShogiGameController::Player1) {
            // 直前に指したのは後手(P2)
            m_clock->setPlayer2ConsiderationTime(static_cast<int>(thinkMs));
            m_clock->applyByoyomiAndResetConsideration2(); // ← 追加
        } else {
            // 直前に指したのは先手(P1)
            m_clock->setPlayer1ConsiderationTime(static_cast<int>(thinkMs));
            m_clock->applyByoyomiAndResetConsideration1(); // ← 追加
        }
    }

    if (m_hooks.appendKifuLine && m_clock) {
        const QString elapsed = (m_gc->currentPlayer() == ShogiGameController::Player1)
        ? m_clock->getPlayer2ConsiderationAndTotalTime()
        : m_clock->getPlayer1ConsiderationAndTotalTime();
        m_hooks.appendKifuLine(rec, elapsed);
    }

    if (m_hooks.renderBoardFromGc) m_hooks.renderBoardFromGc();
    m_cur = (m_gc->currentPlayer() == ShogiGameController::Player2) ? P2 : P1;
    updateTurnDisplay_(m_cur);

    if (!gameOverState().isOver) armHumanTimerIfNeeded();
}

// 人間手直後に「考慮時間確定 → byoyomi/inc 適用 → KIF追記 → 人間手ハイライト」を済ませ、
// その後のエンジン1手返し等は既存の2引数版へ委譲する。
void MatchCoordinator::onHumanMove_HvE(const QPoint& humanFrom, const QPoint& humanTo, const QString& prettyMove)
{
    // 0) 人間手のハイライト
    if (m_hooks.showMoveHighlights) {
        m_hooks.showMoveHighlights(humanFrom, humanTo);
    }

    // 1) 人間側の考慮時間を確定 → byoyomi/inc を適用 → KIF 追記
    if (m_clock) {
        const bool humanIsP1 =
            (m_playMode == EvenHumanVsEngine) || (m_playMode == HandicapHumanVsEngine);

        if (humanIsP1) {
            const qint64 ms = m_clock->player1ConsiderationMs();
            m_clock->setPlayer1ConsiderationTime(static_cast<int>(ms));
            m_clock->applyByoyomiAndResetConsideration1();

            if (m_hooks.appendKifuLine) {
                m_hooks.appendKifuLine(prettyMove, m_clock->getPlayer1ConsiderationAndTotalTime());
            }
            // 従来互換：クリア
            m_clock->setPlayer1ConsiderationTime(0);
        } else {
            const qint64 ms = m_clock->player2ConsiderationMs();
            m_clock->setPlayer2ConsiderationTime(static_cast<int>(ms));
            m_clock->applyByoyomiAndResetConsideration2();

            if (m_hooks.appendKifuLine) {
                m_hooks.appendKifuLine(prettyMove, m_clock->getPlayer2ConsiderationAndTotalTime());
            }
            // 従来互換：クリア
            m_clock->setPlayer2ConsiderationTime(0);
        }

        // ラベルなど即時更新
        pokeTimeUpdateNow();
    }

    // 2) 以降（エンジン go → bestmove → 盤/棋譜反映）は既存の2引数版に委譲
    //    finishHumanTimerAndSetConsideration() は2引数版の先頭で呼ばれるが、二重でも実害が出ない想定。
    onHumanMove_HvE(humanFrom, humanTo);
}

void MatchCoordinator::setUndoBindings(const UndoRefs& refs, const UndoHooks& hooks) {
    u_ = refs;
    h_ = hooks;
}

bool MatchCoordinator::undoTwoPlies()
{
    if (!u_.gc) return false;

    // --- ロールバック前のフル position を退避（今回の肝） ---
    QString prevFullPosition;
    if (u_.positionStrList && !u_.positionStrList->isEmpty()) {
        prevFullPosition = u_.positionStrList->last();
    } else if (!m_positionStrHistory.isEmpty()) {
        prevFullPosition = m_positionStrHistory.constLast();
    }

    // --- SFEN履歴の現在位置を把握 ---
    QStringList* srec = u_.sfenRecord ? u_.sfenRecord : m_sfenRecord;
    int curSfenIdx = -1;

    if (srec && !srec->isEmpty()) {
        curSfenIdx = srec->size() - 1; // 末尾が現局面
    } else if (u_.currentMoveIndex) {
        curSfenIdx = *u_.currentMoveIndex + 1; // 行0始まり → SFENは開始局面含むので+1
    } else if (u_.gameMoves) {
        curSfenIdx = u_.gameMoves->size() + 1;
    } else {
        return false;
    }

    // 2手戻し後の SFEN 添字（= 残すべき手数）
    const int targetSfenIdx = qMax(0, curSfenIdx - 2);   // 0 = 開始局面
    const int remainHands   = qMax(0, targetSfenIdx);    // 残すべき手数（開始=0→手数=N）

    // --- 盤面を targetSfenIdx に復元 ---
    if (u_.gc && srec && targetSfenIdx < srec->size()) {
        const QString sfen = srec->at(targetSfenIdx);
        if (u_.gc->board()) {
            u_.gc->board()->setSfen(sfen);
        }
        const bool sideToMoveIsBlack = sfen.contains(QStringLiteral(" b "));
        u_.gc->setCurrentPlayer(sideToMoveIsBlack ? ShogiGameController::Player1
                                                  : ShogiGameController::Player2);
    }

    // --- 棋譜/モデル/履歴を末尾2件ずつ削除 ---
    if (u_.recordModel)              tryRemoveLastItems_(u_.recordModel, 2);
    if (u_.gameMoves && u_.gameMoves->size() >= 2) {
        u_.gameMoves->remove(u_.gameMoves->size() - 2, 2);
    }
    if (u_.positionStrList && u_.positionStrList->size() >= 2) {
        u_.positionStrList->remove(u_.positionStrList->size() - 2, 2);
    }
    if (srec && srec->size() >= 2) {
        srec->remove(srec->size() - 2, 2);
    }

    // --- USI用 position 履歴も2手ぶん巻き戻す ---
    if (m_positionStrHistory.size() >= 2) {
        m_positionStrHistory.remove(m_positionStrHistory.size() - 2, 2);
    } else {
        m_positionStrHistory.clear();
    }

    // --- ★ 巻き戻し後の “現在ベース” を厳密に再構成（prev を 先頭 remainHands 手にトリム） ---
    const QString startSfen0 = (srec && !srec->isEmpty()) ? srec->first() : QString();
    const QString nextBase   = buildBasePositionUpToHands_(prevFullPosition, remainHands, startSfen0);

    // 現在値と履歴に反映
    m_positionStr1    = nextBase;
    m_positionPonder1 = nextBase;

    if (u_.positionStrList) {
        // GUI側履歴の末尾を nextBase に整合（末尾が無い/異なる場合は置き換え）
        if (u_.positionStrList->isEmpty()) {
            u_.positionStrList->append(nextBase);
        } else {
            // 末尾を差し替え（「待った」直後の基底を明示的に保持）
            (*u_.positionStrList)[u_.positionStrList->size() - 1] = nextBase;
        }
    }

    if (m_positionStrHistory.isEmpty() || m_positionStrHistory.constLast() != nextBase) {
        m_positionStrHistory.clear();
        m_positionStrHistory.append(nextBase);
    }

    // --- 現在行（0始まり）を同期 ---
    const int targetMoveRow = qMax(0, targetSfenIdx - 1);
    if (u_.currentMoveIndex) {
        *u_.currentMoveIndex = targetMoveRow;
    }

    // --- 表示/ハイライトの同期 ---
    if (u_.boardCtl) u_.boardCtl->clearAllHighlights();
    if (h_.updateHighlightsForPly) h_.updateHighlightsForPly(targetSfenIdx);
    if (h_.updateTurnAndTimekeepingDisplay) h_.updateTurnAndTimekeepingDisplay();

    // --- 入力許可（人間手番なら盤クリックOK） ---
    const auto stm = u_.gc ? u_.gc->currentPlayer() : ShogiGameController::NoPlayer;
    const bool humanNow = h_.isHumanSide ? h_.isHumanSide(stm) : false;
    if (u_.view) u_.view->setMouseClickMode(humanNow);

    return true;
}

void MatchCoordinator::armTimerAfterUndo_() {
    if (!u_.gc || !u_.clock || !h_.isHumanSide || !h_.isHvH) return;

    const auto sideToMove = u_.gc->currentPlayer();
    if (!h_.isHumanSide(sideToMove)) return;

    if (h_.isHvH()) {
        // 人対人：共有ターンタイマ
        armTurnTimerIfNeeded();
    } else {
        // 人対エンジン系：人間用タイマ
        armHumanTimerIfNeeded();
    }
}

bool MatchCoordinator::tryRemoveLastItems_(QObject* model, int n) {
    if (!model) return false;

    // まずは直接呼び出し（ダウンキャスト）
    if (auto* km = qobject_cast<KifuRecordListModel*>(model)) {
        return km->removeLastItems(n);
    }

    // フォールバック：メタ呼び出し（Q_INVOKABLE/slot を拾える）
    const QMetaObject* mo = model->metaObject();
    const int idx = mo->indexOfMethod("removeLastItems(int)");
    if (idx < 0) return false;

    bool ok = QMetaObject::invokeMethod(model, "removeLastItems", Q_ARG(int, n));
    return ok;
}

MatchCoordinator::StartOptions MatchCoordinator::buildStartOptions(
    PlayMode mode,
    const QString& startSfenStr,
    const QStringList* sfenRecord,
    const StartGameDialog* dlg) const
{
    StartOptions opt;
    opt.mode = mode;

    // --- 開始SFEN（空なら既定=司令塔側で startpos 扱い）
    if (!startSfenStr.isEmpty()) {
        opt.sfenStart = startSfenStr;
    } else if (sfenRecord && !sfenRecord->isEmpty()) {
        opt.sfenStart = sfenRecord->first();
    } else {
        opt.sfenStart.clear();
    }

    // --- エンジン座席（PlayMode から）
    const bool engineIsP1 =
        (mode == PlayMode::EvenEngineVsHuman) ||
        (mode == PlayMode::HandicapEngineVsHuman);
    opt.engineIsP1 = engineIsP1;
    opt.engineIsP2 = !engineIsP1;

    // --- 対局ダイアログあり：そのまま採用
    if (dlg) {
        const auto engines = dlg->getEngineList();

        const int idx1 = dlg->engineNumber1();
        if (idx1 >= 0 && idx1 < engines.size()) {
            opt.engineName1 = dlg->engineName1();
            opt.enginePath1 = engines.at(idx1).path;
        }

        const int idx2 = dlg->engineNumber2();
        if (idx2 >= 0 && idx2 < engines.size()) {
            opt.engineName2 = dlg->engineName2();
            opt.enginePath2 = engines.at(idx2).path;
        }
        return opt;
    }

    // --- 対局ダイアログなし：INI から直近選択を復元（StartGameDialog と同じ仕様）
    {
        using namespace EngineSettingsConstants;

        QSettings settings(SettingsFileName, QSettings::IniFormat);

        // 1) エンジン一覧（name/path）の読み出し
        struct Eng { QString name; QString path; };
        QVector<Eng> list;
        int count = settings.beginReadArray("Engines");
        for (int i = 0; i < count; ++i) {
            settings.setArrayIndex(i);
            Eng e;
            e.name = settings.value("name").toString();
            e.path = settings.value("path").toString();
            list.push_back(e);
        }
        settings.endArray();

        auto pathForName = [&](const QString& nm) -> QString {
            if (nm.isEmpty()) return {};
            for (const auto& e : list) {
                if (e.name == nm) return e.path;
            }
            return {};
        };

        // 2) 直近の対局設定（GameSettings）からエンジン名を取得
        settings.beginGroup("GameSettings");
        const QString name1 = settings.value("engineName1").toString();
        const QString name2 = settings.value("engineName2").toString();
        settings.endGroup();

        if (!name1.isEmpty()) {
            opt.engineName1 = name1;
            opt.enginePath1 = pathForName(name1);
        }
        if (!name2.isEmpty()) {
            opt.engineName2 = name2;
            opt.enginePath2 = pathForName(name2);
        }
        // パスが空でもここでは許容（initializeAndStartEngineCommunication 内で失敗は通知）
        return opt;
    }
}

void MatchCoordinator::ensureHumanAtBottomIfApplicable(const StartGameDialog* dlg, bool bottomIsP1)
{
    if (!dlg) return;

    const bool humanP1  = dlg->isHuman1();
    const bool humanP2  = dlg->isHuman2();
    const bool oneHuman = (humanP1 ^ humanP2); // HvE / EvH のときだけ true

    if (!oneHuman) {
        // HvH / EvE は対象外（仕様どおり）
        return;
    }

    // 「現在の向き（bottomIsP1）」と「人間が先手か？」が食い違っていたら1回だけ反転
    const bool needFlip = (humanP1 != bottomIsP1);
    if (needFlip) {
        // MainWindow::onActionFlipBoardTriggered(false) の代わりに司令塔から反転
        // 既存の flipBoard() が view と内部状態を適切に切り替える想定
        this->flipBoard();
        // この呼び出しにより、既存の onBoardFlipped シグナル連鎖で
        // MainWindow 側の m_bottomIsP1 も従来どおりトグルされます
    }
}

void MatchCoordinator::prepareAndStartGame(PlayMode mode,
                                           const QString& startSfenStr,
                                           const QStringList* sfenRecord,
                                           const StartGameDialog* dlg,
                                           bool bottomIsP1)
{
    // 1) オプション構築
    StartOptions opt = buildStartOptions(mode, startSfenStr, sfenRecord, dlg);

    // 2) 人間を手前へ（必要なら反転）
    ensureHumanAtBottomIfApplicable(dlg, bottomIsP1);

    // 3) 対局の構成と開始
    configureAndStart(opt);

    // 4) 初手がエンジン手番なら go→bestmove
    startInitialEngineMoveIfNeeded();
}

void MatchCoordinator::startMatchTimingAndMaybeInitialGo()
{
    // タイマー起動
    if (m_clock) m_clock->startClock();

    // 初手がエンジンなら go
    startInitialEngineMoveIfNeeded();
}

void MatchCoordinator::handleTimeUpdated()
{
    // MainWindow::onMatchTimeUpdated → 司令塔へ
    emit timeTick(); // UI側はこの信号でリフレッシュをかける

    QString turn, p1, p2;
    recomputeClockSnapshot(turn, p1, p2);
    emit uiUpdateTurnAndClock(turn, p1, p2);
}

void MatchCoordinator::handlePlayerTimeOut(int player)
{
    if (!m_gc) return;
    // 負け処理を司令塔で集約
    m_gc->applyTimeoutLossFor(player);
    emit uiNotifyTimeout(player);
    handleGameEnded();
}

void MatchCoordinator::handleResignationRequest()
{
    if (!m_gc) return;
    m_gc->applyResignationOfCurrentSide();
    emit uiNotifyResign();
    handleGameEnded();
}

void MatchCoordinator::handleGameEnded()
{
    if (!m_gc) return;
    m_gc->finalizeGameResult();
    emit uiNotifyGameEnded();
}

void MatchCoordinator::handleGameOverStateChanged()
{
    // 元 MainWindow::onGameOverStateChanged のロジックをここへ
    // 例：go/stopの扱い・UI有効/無効トグルの司令塔視点の判断などを集約
    // 必要に応じて追加のUI信号を定義して通知
}

// これに置き換え（該当関数のみ）
void MatchCoordinator::recomputeClockSnapshot(QString& turnText, QString& p1, QString& p2) const
{
    turnText.clear(); p1.clear(); p2.clear();
    if (!m_clock) return;

    // 手番テキスト：GCがあれば currentPlayer() で判定
    if (m_gc) {
        const bool p1Turn = (m_gc->currentPlayer() == ShogiGameController::Player1);
        turnText = p1Turn ? QObject::tr("先手番") : QObject::tr("後手番");
    }

    // 残り時間：ShogiClockの既存ゲッターを利用
    const qint64 t1ms = qMax<qint64>(0, m_clock->getPlayer1TimeIntMs());
    const qint64 t2ms = qMax<qint64>(0, m_clock->getPlayer2TimeIntMs());

    auto mmss = [](qint64 ms) {
        const qint64 s = ms / 1000;
        const qint64 m = s / 60;
        const qint64 r = s % 60;
        return QStringLiteral("%1:%2")
            .arg(m, 2, 10, QLatin1Char('0'))
            .arg(r, 2, 10, QLatin1Char('0'));
    };

    p1 = mmss(t1ms);
    p2 = mmss(t2ms);
}

PlayMode MatchCoordinator::playMode() const
{
    return m_playMode;
}

void MatchCoordinator::appendGameOverLineAndMark(Cause cause, Player loser)
{
    if (!m_gameOver.isOver) return;
    if (m_gameOver.moveAppended) return;
    if (!m_clock || !m_hooks.appendKifuLine) {
        markGameOverMoveAppended();
        return;
    }

    // 残り時間を固定
    m_clock->stopClock();

    // 表記（▲/△は絶対座席）
    const QString mark = (loser == P1) ? QStringLiteral("▲") : QStringLiteral("△");
    const QString line = (cause == Cause::Resignation)
                             ? QStringLiteral("%1投了").arg(mark)
                             : QStringLiteral("%1時間切れ").arg(mark);

    // 「この手」の思考時間を暫定的に反映（KIF 表示のため）
    const qint64 now     = QDateTime::currentMSecsSinceEpoch();
    const qint64 epochMs = turnEpochFor(loser);
    qint64 considerMs    = (epochMs > 0) ? (now - epochMs) : 0;
    if (considerMs < 0) considerMs = 0;
    if (loser == P1) m_clock->setPlayer1ConsiderationTime(int(considerMs));
    else             m_clock->setPlayer2ConsiderationTime(int(considerMs));

    const QString elapsed = (loser == P1)
                                ? m_clock->getPlayer1ConsiderationAndTotalTime()
                                : m_clock->getPlayer2ConsiderationAndTotalTime();

    // 1回だけ即時追記
    m_hooks.appendKifuLine(line, elapsed);

    // HvE/HvH の人間用ストップウォッチ解除
    disarmHumanTimerIfNeeded();

    // 重複追記ブロックを有効化
    markGameOverMoveAppended();
}

void MatchCoordinator::onHumanMove_HvH(ShogiGameController::Player moverBefore)
{
    const Player moverP = (moverBefore == ShogiGameController::Player1) ? P1 : P2;

    // 直前手の消費時間（consideration）を確定
    finishTurnTimerAndSetConsiderationFor(moverP);

    // ★ 追加：HvH でも秒読み/インクリメントを適用し、総考慮へ加算して表示値を確定
    if (m_clock) {
        if (moverP == P1) {
            m_clock->applyByoyomiAndResetConsideration1();
        } else {
            m_clock->applyByoyomiAndResetConsideration2();
        }
    }

    // 表示更新（時計ラベル等）
    if (m_hooks.log) m_hooks.log(QStringLiteral("[Match] HvH: finalize previous turn"));
    if (m_clock)     handleTimeUpdated(); // 既存の UI 更新経路

    // 次手番の計測と UI 準備
    armTurnTimerIfNeeded();
}

void MatchCoordinator::forceImmediateMove()
{
    if (!m_gc) return;

    const bool isEvE =
        (m_playMode == EvenEngineVsEngine) || (m_playMode == HandicapEngineVsEngine);

    if (isEvE) {
        // 現在手番のエンジンへ stop
        const Player turn =
            (m_gc->currentPlayer() == ShogiGameController::Player1) ? P1 : P2;
        Usi* eng = (turn == P1) ? m_usi1 : m_usi2;
        if (eng && m_hooks.sendStopToEngine) {
            m_hooks.sendStopToEngine(eng);
        }
        return;
    }

    // HvE の場合は主エンジンへ stop
    if (Usi* eng = primaryEngine()) {
        if (m_hooks.sendStopToEngine) {
            m_hooks.sendStopToEngine(eng);
        }
    }
}

void MatchCoordinator::sendStopAllEngines_()
{
    if (m_usi1) m_usi1->sendStopCommand();
    if (m_usi2) m_usi2->sendStopCommand();
}

void MatchCoordinator::sendRawTo_(Usi* which, const QString& cmd)
{
    if (!which) return;
    which->sendRaw(cmd);   // ← sendRawCommand ではなく sendRaw を呼ぶ
}

namespace {
// qint64 → int の安全な縮小（オーバーフロー防止）
inline int clampMsToInt(qint64 v) {
    if (v > std::numeric_limits<int>::max()) return std::numeric_limits<int>::max();
    if (v < std::numeric_limits<int>::min()) return std::numeric_limits<int>::min();
    return static_cast<int>(v);
}
}

void MatchCoordinator::sendGoTo(Usi* u, const GoTimes& t)
{
    if (!u) return;
    const bool useByoyomi = (t.byoyomi > 0 && t.binc == 0 && t.winc == 0);
    u->sendGoCommand(
        clampMsToInt(t.byoyomi),
        QString::number(t.btime),
        QString::number(t.wtime),
        clampMsToInt(t.binc),
        clampMsToInt(t.winc),
        useByoyomi
        );
}

void MatchCoordinator::sendStopTo(Usi* u)
{
    if (!u) return;
    u->sendStopCommand();
}

void MatchCoordinator::sendRawTo(Usi* u, const QString& cmd)
{
    if (!u) return;
    u->sendRaw(cmd);
}

void MatchCoordinator::sendGoToEngine(Usi* which, const GoTimes& t)
{
    if (!which) return;

    // byoyomi と increment は通常どちらか。両方指定なら increment 優先など
    // ポリシーは必要に応じて調整。ここでは「両方ゼロでないなら increment 優先」にします。
    const bool useByoyomi = (t.byoyomi > 0 && t.binc == 0 && t.winc == 0);

    which->sendGoCommand(
        clampMsToInt(t.byoyomi),        // byoyomi(ms)
        QString::number(t.btime),       // btime(ms)
        QString::number(t.wtime),       // wtime(ms)
        clampMsToInt(t.binc),           // 先手 increment(ms)
        clampMsToInt(t.winc),           // 後手 increment(ms)
        useByoyomi                      // byoyomi を使うか
        );
}

void MatchCoordinator::sendStopToEngine(Usi* which)
{
    if (!which) return;
    which->sendStopCommand();
}

void MatchCoordinator::sendRawToEngine(Usi* which, const QString& cmd)
{
    if (!which) return;
    which->sendRaw(cmd);
}

void MatchCoordinator::appendBreakOffLineAndMark()
{
    // 既に終局でなければ何もしない
    if (!m_gameOver.isOver) return;

    // すでに「中断」等が追記済みなら二重追記防止
    if (m_gameOver.moveAppended) return;

    // 現在手番（＝次に指す側）を GC から取得
    const ShogiGameController::Player gcTurn =
        (m_gc ? m_gc->currentPlayer() : ShogiGameController::NoPlayer);

    // ▲/△は「絶対座席」を表記（P1=▲, P2=△）
    const Player curP = (gcTurn == ShogiGameController::Player1) ? P1 : P2;
    const QString line = (curP == P1) ? QStringLiteral("▲中断") : QStringLiteral("△中断");

    // 「この手」の考慮時間を暫定確定（KIF用）
    // MatchCoordinator 内の turnEpochFor(...) を利用して今の経過msを算出
    if (m_clock) {
        const qint64 now     = QDateTime::currentMSecsSinceEpoch();
        const qint64 epochMs = turnEpochFor(curP);
        qint64 considerMs    = (epochMs > 0) ? (now - epochMs) : 0;
        if (considerMs < 0) considerMs = 0;

        if (curP == P1) m_clock->setPlayer1ConsiderationTime(int(considerMs));
        else            m_clock->setPlayer2ConsiderationTime(int(considerMs));
    }

    // "MM:SS/HH:MM:SS" を時計から取得
    QString elapsed;
    if (m_clock) {
        elapsed = (curP == P1)
        ? m_clock->getPlayer1ConsiderationAndTotalTime()
        : m_clock->getPlayer2ConsiderationAndTotalTime();
    }

    // 棋譜欄に 1 回だけ即時追記（MainWindow::appendKifuLine につながる Hook）
    if (m_hooks.appendKifuLine) {
        m_hooks.appendKifuLine(line, elapsed);
    }

    // 人間用ストップウォッチ解除（HvE/HvHに備える既存パターン）
    disarmHumanTimerIfNeeded();

    // 二重追記ブロック確定（以降は UI 側からも重複しない）
    markGameOverMoveAppended();
}

ShogiClock* MatchCoordinator::clock()
{
    return m_clock;
}

const ShogiClock* MatchCoordinator::clock() const
{
    return m_clock;
}
#include "movevalidator.h"
#include "shogimove.h"
#include "legalmovestatus.h"

#include <iostream>
#include <iomanip>
#include <QMap>
#include <array>
#include <QDebug>

// 指した手が合法手であるかどうかを判定するクラス
// コンストラクタ
MoveValidator::MoveValidator(QObject* parent) : QObject(parent)
{
    // 全ての駒の種類を1文字のアルファベットで表す。
    m_allPieces = {'P', 'L', 'N', 'S', 'G', 'B', 'R', 'K', 'Q', 'M', 'O', 'T', 'C', 'U',
                   'p', 'l', 'n', 's', 'g', 'b', 'r', 'k', 'q', 'm', 'o', 't', 'c', 'u'};

    // 先手と後手の駒台の順序番号
    m_pieceOrderBlack = {{'P', 0}, {'L', 1}, {'N', 2}, {'S', 3}, {'G', 4}, {'B', 5}, {'R', 6}};
    m_pieceOrderWhite = {{'r', 2}, {'b', 3}, {'g', 4}, {'s', 5}, {'n', 6}, {'l', 7}, {'p', 8}};
}

// 二歩が存在するかどうかをチェックする。
// 先手あるいは後手の歩が同じ筋に複数存在する場合、二歩が存在すると判定する。
void MoveValidator::checkDoublePawn(const QVector<QChar>& boardData)
{
    // 筋
    for (int file = 0; file < BOARD_SIZE; ++file) {
        int pawnCountWhite = 0;
        int pawnCountBlack = 0;
        // 段
        for (int rank = 0; rank < BOARD_SIZE; ++rank) {
            int index = rank * BOARD_SIZE + file;
            if (boardData[index] == 'P') ++pawnCountWhite;
            if (boardData[index] == 'p') ++pawnCountBlack;
        }

        // 先手あるいは後手の歩が同じ筋に複数存在する場合、二歩が存在すると判定する。
        if (pawnCountWhite > 1 || pawnCountBlack > 1) {
            const QString errorMessage = tr("An error occurred in MoveValidator::checkDoublePawn. There is a double pawn situation.");
            emit errorOccurred(errorMessage);
            return; // ★ 打ち切り
        }
    }
}

// 各駒の数が最大数を超えていないかチェックする。
void MoveValidator::checkPieceCount(const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand)
{
    // 各駒のカウント数
    QMap<QChar, int> currentPieceCount;

    // 将棋盤上の駒の数をカウントする。
    for (auto piece : boardData) {
        // 空白マス以外の駒の数をカウントする。
        if(piece != ' ') {
            currentPieceCount[piece]++;
        }
    }

    // 駒台の駒の数をカウントする。
    for (auto it = pieceStand.begin(); it != pieceStand.end(); ++it) {
        currentPieceCount[it.key()] += it.value();
    }

    // 各駒の最大数
    static const QMap<QChar, int> maxTotalPieceCount = {
        {'P', 18}, {'L', 4}, {'N', 4}, {'S', 4}, {'G', 4}, {'B', 2}, {'R', 2}, {'K', 1},
        {'p', 18}, {'l', 4}, {'n', 4}, {'s', 4}, {'g', 4}, {'b', 2}, {'r', 2}, {'k', 1}
    };

    // 各駒の数が最大数を超えていないかチェックする。
    for (auto it = maxTotalPieceCount.begin(); it != maxTotalPieceCount.end(); ++it) {
        // 各駒の数が最大数を超えていた場合
        if (currentPieceCount[it.key()] > it.value()) {
            const QString errorMessage = tr("An error occurred in MoveValidator::checkPieceCount. The number of pieces exceeds the maximum allowed.");
            emit errorOccurred(errorMessage);
            return; // ★ 打ち切り
        }
    }
}

// 玉が一方の対局者につき一つ存在していることをチェックする。
void MoveValidator::checkKingPresence(const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand)
{
    // 先手と後手の玉の数をカウントする。
    int kingCountWhite = pieceStand['K'];
    int kingCountBlack = pieceStand['k'];

    // 盤面上の先手と後手の玉の数をカウントする。
    for (const auto& piece : boardData) {
        if (piece == 'K') ++kingCountWhite;
        if (piece == 'k') ++kingCountBlack;
    }

    // 先手と後手の玉が一つずつ存在していない場合、エラーになる。
    if ((kingCountWhite != 1) || (kingCountBlack != 1)) {
        const QString errorMessage = tr("An error occurred in MoveValidator::checkKingPresence. There is not exactly one king per player.");
        emit errorOccurred(errorMessage);
        return; // ★ 打ち切り
    }
}

// 将棋の盤面上の各駒が適切な位置にあるかどうかをチェックする。
void MoveValidator::checkCorrectPosition(const QVector<QChar>& boardData)
{
    // 将棋盤のマスの数だけ繰り返す。
    for (int i = 0; i < boardData.size(); ++i) {
        // 各マスの駒文字を取得する。
        QChar piece = boardData[i];

        // マスのインデックスから段番号を計算する。
        int rank = i / BOARD_SIZE + 1;

        // 以下のルールを適用する。
        // - 先手の歩('P')と香車('L')は1段目に存在できない。
        // - 先手の桂馬('N')は1段目と2段目に存在できない。
        // - 後手の歩('p')と香車('l')は9段目に存在できない。
        // - 後手の桂馬('n')は8段目と9段目に存在できない。
        // これらのルールを満たさない場合、関数はfalseを返す。
        if ((piece == 'p' && rank == BOARD_SIZE) || (piece == 'l' && rank == BOARD_SIZE) ||
            (piece == 'n' && (rank == 8 || rank == BOARD_SIZE)) ||
            (piece == 'P' && rank == 1) || (piece == 'L' && rank == 1) ||
            (piece == 'N' && (rank == 1 || rank == 2))) {
            const QString errorMessage = tr("An error occurred in MoveValidator::checkCorrectPosition. A piece that should be promoted is in an incorrect position.");
            emit errorOccurred(errorMessage);
            return; // ★ 打ち切り
        }
    }
}

// 盤面データのチェックを実行する。
void MoveValidator::validateBoardAndPieces(const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand)
{
    // 二歩が存在する場合
    checkDoublePawn(boardData);

    // 各駒の数が最大数を超えている場合
    checkPieceCount(boardData, pieceStand);

    // 成るべき駒が不適切な位置にある場合
    checkCorrectPosition(boardData);

    // 一方の対局者につき一つの玉が存在していない場合
    checkKingPresence(boardData, pieceStand);
}

// 指し手の筋の値を検証する。
// 筋の値が有効でない場合、エラーメッセージをログに出力し、エラーメッセージボックスを表示する。
void MoveValidator::validateMoveFileValue(int fromSquareX)
{
    // 筋の値が10より大きい場合は無効とする。
    if (fromSquareX > 10) {
        // エラーメッセージを作成する。
        const QString errorMessage = tr("An error occurred in MoveValidator::validateMoveFileValue. Validation Error: The file value of the move is incorrect.");

        // 無効な筋の値をログに出力する。
        qDebug() << "Move file value: " << fromSquareX;

        emit errorOccurred(errorMessage);
        return; // ★ 打ち切り
    }
}

// 指し手の駒が盤面の駒と一致するかを検証する。
// 指し手の駒が盤面の駒と一致しない場合、エラーメッセージをログに出力し、エラーメッセージボックスを表示する。
// 一致する場合はtrueを返す。
void MoveValidator::validateMovingPiece(const ShogiMove& currentMove, const QVector<QChar>& boardData)
{
    // 指し手が将棋盤上の駒を動かす場合
    if (currentMove.fromSquare.x() < BOARD_SIZE) {
        // 指し手のマスのインデックスを計算する。
        int fromIndex = currentMove.fromSquare.y() * BOARD_SIZE + currentMove.fromSquare.x();

        // 指し手の駒と盤面の駒が一致しない場合はエラーとする。
        if (currentMove.movingPiece != boardData[fromIndex]) {
            // エラーメッセージを作成する。
            const QString errorMessage = tr("An error occurred in MoveValidator::validateMovingPiece. Validation Error: The piece in the move does not match the piece on the square.");

            // 指し手の駒の情報をログに出力する。
            qDebug() << "Move piece: " << currentMove.movingPiece;

            // 盤面の駒の情報をログに出力する。
            qDebug() << "Piece on the square: " << boardData[fromIndex];

            emit errorOccurred(errorMessage);
            return; // ★ 打ち切り
        }
    }
}

// 駒台のエラー情報をログに出力し、エラーメッセージボックスを表示する。
void MoveValidator::logAndShowPieceStandError(const QString& errorMessage, QChar piece, const QMap<QChar, int>& pieceStand)
{
    // エラーメッセージをログに出力する。
    qWarning() << errorMessage;

    // 問題のある駒の情報をログに出力する。
    qDebug() << "Piece: " << piece;

    // 問題のある駒の駒台での数をログに出力する。
    qDebug() << "Number of pieces in the stand: " << pieceStand[piece];

    emit errorOccurred(errorMessage);
}

// 駒台の駒が有効かどうかを検証する。
// 指し手が駒台から駒を打つ場合、その駒の数が正の数かをチェックする。
// 無効な場合はエラーメッセージをログに出力し、エラーメッセージボックスを表示する。
// 有効な場合はtrueを返し、無効な場合はfalseを返す。
void MoveValidator::validatePieceStand(Turn turn, const ShogiMove& currentMove, const QMap<QChar, int>& pieceStand)
{
    // 先手の駒台から打つ場合
    if (currentMove.fromSquare.x() == BOARD_SIZE) {
        if (turn == BLACK) {
            // 先手の駒台の駒の数が正の数でない場合はエラーとする。
            if (pieceStand[currentMove.movingPiece] <= 0) {
                // エラーメッセージを作成
                const QString errorMessage = tr("An error occurred in MoveValidator::validatePieceStand. The number of pieces in the stand of the player moving is not positive.");

                // エラーメッセージと駒の情報をログに出力し、エラーメッセージボックスを表示する。
                logAndShowPieceStandError(errorMessage, currentMove.movingPiece, pieceStand);
                return; // ★ 打ち切り
            }
        } else {
            // 後手なのに先手の駒台から駒を打とうとしている場合はエラーとする。
            const QString errorMessage = tr("An error occurred in MoveValidator::validatePieceStand. It's White's turn, but trying to drop a piece from Black's piece stand.");

            // エラーメッセージと駒の情報をログに出力し、エラーメッセージボックスを表示する。
            logAndShowPieceStandError(errorMessage, currentMove.movingPiece, pieceStand);
            return; // ★ 打ち切り
        }
    }
    // 後手の駒台から打つ場合
    else if (currentMove.fromSquare.x() == BOARD_SIZE + 1) {
        if (turn == WHITE) {
            // 後手の駒台の駒の数が正の数でない場合はエラーとする。
            if (pieceStand[currentMove.movingPiece] <= 0) {
                // エラーメッセージを作成
                const QString errorMessage = tr("An error occurred in MoveValidator::validatePieceStand. The number of pieces on White's piece stand to drop is not positive.");

                // エラーメッセージと駒の情報をログに出力し、エラーメッセージボックスを表示する。
                logAndShowPieceStandError(errorMessage, currentMove.movingPiece, pieceStand);
                return; // ★ 打ち切り
            }
        } else {
            // 先手なのに後手の駒台から駒を打とうとしている場合はエラーとする。
            const QString errorMessage = tr("An error occurred in MoveValidator::validatePieceStand. It's Black's turn, but trying to drop a piece from White's piece stand.");

            // エラーメッセージと駒の情報をログに出力し、エラーメッセージボックスを表示する。
            logAndShowPieceStandError(errorMessage, currentMove.movingPiece, pieceStand);
            return; // ★ 打ち切り
        }
    }
}

// 取った駒が盤面の駒と一致するかを検証する。
// 取った駒が盤面の移動先の駒と一致しない場合、エラーメッセージをログに出力し、エラーメッセージボックスを表示する。
// 一致する場合はtrueを返し、一致しない場合はfalseを返す。
void MoveValidator::validateCapturedPiece(const ShogiMove& currentMove, const QVector<QChar>& boardData)
{
    // 移動先のマスのインデックスを計算する。
    int toIndex = currentMove.toSquare.y() * BOARD_SIZE + currentMove.toSquare.x();

    // 取った駒と盤面の駒が一致しない場合はエラーとする。
    if (currentMove.capturedPiece != boardData[toIndex]) {
        // エラーメッセージを作成する。
        const QString errorMessage = tr("An error occurred in MoveValidator::validateCapturedPiece. The captured piece does not match the piece on the destination square of the board.");

        // エラーメッセージをログに出力する。
        qWarning() << errorMessage;

        // 取った駒の情報をログに出力する。
        qDebug() << "Captured piece: " << currentMove.capturedPiece;

        // 盤面の駒の情報をログに出力する。
        qDebug() << "Piece on the square: " << boardData[toIndex];

        emit errorOccurred(errorMessage);
        return; // ★ 打ち切り
    }
}

// 複数の検証を一括して行う。
// 盤面データと持ち駒、指し手の筋、指し手の駒、駒台の駒、取った駒が有効であるかを検証する。
// 無効な場合はエラーメッセージをログに出力し、エラーメッセージボックスを表示する。
void MoveValidator::validateMoveComponents(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand, const ShogiMove& currentMove)
{
    // 盤面データと持ち駒のチェックを行う。
    validateBoardAndPieces(boardData, pieceStand);

    // 指し手の筋の値を検証する。
    validateMoveFileValue(currentMove.fromSquare.x());

    // 指し手の駒が盤面の駒と一致するかを検証する。
    validateMovingPiece(currentMove, boardData);

    // 駒台の駒が有効かどうかを検証する。
    validatePieceStand(turn, currentMove, pieceStand);

    // 取った駒が盤面の駒と一致するかを検証する。
    validateCapturedPiece(currentMove, boardData);
}

// 指し手が合法手かどうかを判定する。
LegalMoveStatus MoveValidator::isLegalMove(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand, ShogiMove& currentMove)
{
    // 複数の検証を一括して行う。
    // 盤面データと持ち駒、指し手の筋、指し手の駒、駒台の駒、取った駒が有効であるかを検証する。
    // 無効な場合はエラーメッセージをログに出力し、エラーメッセージボックスを表示する。
    validateMoveComponents(turn, boardData, pieceStand, currentMove);

    // 先手、後手の2種類
    // 歩、香車、桂馬、銀、金、角、飛車、玉、と金、成香、成桂、成銀、馬、龍の14種類
    // の合計28種類の駒が存在するマスを表すbitboardを作成する。
    BoardStateArray piecePlacedBitboards;
    generateBitboard(boardData, piecePlacedBitboards);

    // 先手の歩、先手の香車、先手の桂馬〜先手の龍、
    // 後手の歩、後手の香車、後手の桂馬〜後手の龍の28種類に分けて
    // 各駒ごとに駒が存在するマスを表すbitboardを作成する。
    QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>> allPieceBitboards;
    generateAllPieceBitboards(allPieceBitboards, boardData);

    // allPieceBitboardsの出力
    // 例．平手で各40個の駒それぞれが存在するマスを示すbitboard
    // 先手の1七歩の場合
    // Piece: P
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 1
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    //begin
    // printAllPieceBitboards(allPieceBitboards);
    //end

    // 各個々の駒が移動できるマスを表すbitboardを作成する。
    QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>> allPieceAttackBitboards;
    generateAllIndividualPieceAttackBitboards(allPieceBitboards, piecePlacedBitboards, allPieceAttackBitboards);

    // allPieceAttackBitboardsの出力
    // 例．平手で各40個の駒の移動可能なマスを示すbitboard
    // 先手の1七歩の場合、1六に移動できる。
    // Piece: P
    // 先手:
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 1
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    //begin
    // printIndividualPieceAttackBitboards(allPieceBitboards, allPieceAttackBitboards);
    //end

    // necessaryMovesBitboard
    // 例．先手8八玉が後手2二角から王手を受けている場合、2二、3三、4四、5五、6六、7七に
    // 玉以外の先手の駒をそのマスに指すことができれば後手の王手を回避できる。
    // 後手の王手を回避するために玉以外の先手の駒の移動可能なマスを表すbitboard
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 1 0
    // 0 0 0 0 0 0 1 0 0
    // 0 0 0 0 0 1 0 0 0
    // 0 0 0 0 1 0 0 0 0
    // 0 0 0 1 0 0 0 0 0
    // 0 0 1 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    std::bitset<NUM_BOARD_SQUARES> necessaryMovesBitboard;

    // 玉を除いた攻撃範囲のマスを表すbitboard
    // 上の例の場合、後手2二角を0にしたもの
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 1 0 0
    // 0 0 0 0 0 1 0 0 0
    // 0 0 0 0 1 0 0 0 0
    // 0 0 0 1 0 0 0 0 0
    // 0 0 1 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    std::bitset<NUM_BOARD_SQUARES> attackWithoutKingBitboard;

    // 相手の手番に仮設定
    Turn opponentTurn = (turn == BLACK) ? WHITE : BLACK;

    // 局面がすでに相手玉に王手をかけている状態かどうかを調べる。
    // numOpponentChecks = 0: 手番の玉は王手されていない。
    // numOpponentChecks = 1: 手番の玉は相手の1つの駒から王手されている。
    // numOpponentChecks = 2: 手番の玉は相手の駒から両王手されている。
    int numOpponentChecks = isKingInCheck(opponentTurn, allPieceBitboards, allPieceAttackBitboards, necessaryMovesBitboard, attackWithoutKingBitboard);

    // 王手をかけている局面でさらに指すのはおかしいのでエラーとなる。
    if (numOpponentChecks) {
        // 局面がすでに王手をかけた状態になっている。さらに指すのはおかしい。
        const QString errorMessage = tr("An error occurred in MoveValidator::isLegalMove. Validation Error: The position is already in check. Making another move is incorrect.");

        // 手番の玉が王手されているかどうかの判定値
        qDebug() << "numOpponentChecks = " << numOpponentChecks;

        // 局面を漢字で出力する。
        printBoardAndPieces(boardData, pieceStand);

        // エラーメッセージを表示する。
        emit errorOccurred(errorMessage);

        LegalMoveStatus legalMoveStatus;
        legalMoveStatus.promotingMoveExists = false;
        legalMoveStatus.nonPromotingMoveExists = false;
        return legalMoveStatus; // ★ 打ち切り
    }

    // 手番の玉が王手されているかどうかを調べる。
    // numchecks = 0: 手番の玉は王手されていない。
    // numchecks = 1: 手番の玉は相手の1つの駒から王手されている。
    // numchecks = 2: 手番の玉は相手の駒から両王手されている。
    int numChecks = isKingInCheck(turn, allPieceBitboards, allPieceAttackBitboards, necessaryMovesBitboard, attackWithoutKingBitboard);

    //begin
    // qDebug() << "numChecks = " << numChecks;
    // qDebug() << (turn == BLACK ? "先手" : "後手") << "の玉が王手されている: " << (numChecks ? "はい" : "いいえ");
    //end

    // 盤上の駒を動かして指す合法手リスト
    QVector<ShogiMove> legalMovesList;

    //begin
    std::cout << "Current Shogi move: " << currentMove << std::endl;;
    //end

    // 指し手が合法手かどうか判定する。
    // 合法手ならtrue、合法手でないならfalseを返す。
    return validateMove(numChecks, boardData, currentMove, turn, piecePlacedBitboards, pieceStand, necessaryMovesBitboard, legalMovesList,
                        opponentTurn, attackWithoutKingBitboard);
}

// 将棋盤内の駒を動かした場合の合法手がどうかを判定する。
LegalMoveStatus MoveValidator::isBoardMoveValid(const Turn& turn, const QVector<QChar>& boardData, const ShogiMove& currentMove,
                                                const int& numChecks, const QChar& piece, const std::bitset<NUM_BOARD_SQUARES>& attackBitboard,
                                                const std::bitset<NUM_BOARD_SQUARES>& pieceBitboard, const std::bitset<NUM_BOARD_SQUARES>& necessaryMovesBitboard,
                                                QVector<ShogiMove>& legalMovesList)
{
    // 指定された駒を動かした場合の全指し手リスト生成
    QVector<ShogiMove> allBoardPieceMovesList;

    generateShogiMoveFromBitboard(piece, pieceBitboard, attackBitboard, allBoardPieceMovesList, boardData);

    // 考慮すべき指し手のリストを保存する。王手されていない場合は全ての手を、
    // 王手されている場合は王手を防ぐ可能性のある手だけを保存する。
    QVector<ShogiMove> relevantMovesList;

    if (numChecks) {
        // 手番の玉は王手されている（両王手も含む）。
        // 王手をかけられた側は、片方の駒を玉以外で取るか、あるいは合駒をしても、もう一方の駒で玉を取られてしまうので、
        // 応手としては玉を動かすしかない。
        if (numChecks == 2 && currentMove.movingPiece != ((turn == BLACK) ? 'K' : 'k')) {           
            // エラー発生。指し手の駒が玉ではない。
            const QString errorMessage = tr("An error occurred in MoveValidator::isBoardMoveValid. The piece in the move is not a king.");

            // 指し手の駒
            qDebug() << "Piece: " << currentMove.movingPiece;

            emit errorOccurred(errorMessage);
            LegalMoveStatus legalMoveStatus;
            legalMoveStatus.promotingMoveExists = false;
            legalMoveStatus.nonPromotingMoveExists = false;
            return legalMoveStatus; // ★ 打ち切り
        }

        // 王手されているときに王手を避ける指し手リスト候補を生成する。
        // 例.先手8八玉が後手2二角から王手を受けている場合、2二、3三、4四、5五、6六、7七に
        // 玉以外の先手の駒をそのマスに指すことができれば後手の王手を回避できる手を生成。
        // また、玉を移動させる手も生成するが王手が回避できていない手も含まれている。
        // 王手が回避できない手は、後の処理で除去している。
        // 1 Shogi move: From: (6, 7) To: (6, 6) Moving Piece: P Captured Piece:   Promotion: false
        // 2 Shogi move: From: (8, 9) To: (7, 7) Moving Piece: N Captured Piece:   Promotion: false
        // 3 Shogi move: From: (8, 8) To: (9, 8) Moving Piece: K Captured Piece:   Promotion: false
        // 4 Shogi move: From: (8, 8) To: (7, 8) Moving Piece: K Captured Piece:   Promotion: false
        filterMovesThatBlockThreat(turn, allBoardPieceMovesList, necessaryMovesBitboard, relevantMovesList);
    } else {
        // 手番の玉は王手されていない。
        relevantMovesList = allBoardPieceMovesList;
    }

    // 合法手リストを作成する。
    filterLegalMovesList(turn, relevantMovesList, boardData, legalMovesList);

    // 指し手が合法手の中にあるかどうかをチェックする。
    // 合法手に一致すればtrueを返し、無ければfalseを返す。
    return checkLegalMoveStatus(currentMove, legalMovesList);
}

// 駒台の駒を打った手が合法手かどうかを判定する。
bool MoveValidator::isHandPieceMoveValid(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand, const ShogiMove& currentMove,
                                         const int& numChecks, const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard, QVector<ShogiMove>& legalMovesList)
{
    switch(numChecks) {
    case 0:
        // 自玉に王手がかかっていない。
        // 打った駒が歩かそれ以外の駒かを判別して合法手を生成する。
        if (!generateLegalMovesForPiece(turn, boardData, pieceStand, currentMove, emptySquareBitboard, legalMovesList)) {
            // エラーが発生した場合、falseを返す。
            return false;
        }

        break;

    case 1: {
        // 自玉に王手がかかっている。ただし両王手ではない。
        // 合法手の候補リスト
        QVector<ShogiMove> candidateLegalMovesList;

        // 打った駒が歩かそれ以外の駒かを判別して合法手を生成する。
        if (!generateLegalMovesForPiece(turn, boardData, pieceStand, currentMove, emptySquareBitboard, candidateLegalMovesList)) {
            // エラーが発生した場合、falseを返す。
            return false;
        }

        // 合法手リストを作成する
        filterLegalMovesList(turn, candidateLegalMovesList, boardData, legalMovesList);

        break;
    }

    case 2: {
        // エラー発生。両王手の場合、駒台から駒を打つ手はあり得ない。
        const QString errorMessage = tr("An error occurred in MoveValidator::isHandPieceMoveValid. In the case of double check, dropping a piece from the piece stand is not possible.");

        emit errorOccurred(errorMessage);
        return false; // ★ 打ち切り
    }

    default: {
        // エラー発生。手番の玉に王手をかけている駒の数が3枚以上あり、おかしい。
        const QString errorMessage = tr("An error occurred in MoveValidator::isHandPieceMoveValid. The number of pieces putting the player's king in check is 3 or more.");

        qDebug() << "Number of pieces putting the player's king in check: " << numChecks;

        // エラーメッセージを表示する。
        emit errorOccurred(errorMessage);
        return false; // ★ 打ち切り
    }
    }

    // 指し手が合法手の中にあるかどうかをチェックする。
    // 合法手に一致すればtrueを代入し、無ければfalseを代入する。
    return isMoveInList(currentMove, legalMovesList);
}

// 打った駒が歩かそれ以外の駒かを判別して合法手を生成する。
bool MoveValidator::generateLegalMovesForPiece(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand, const ShogiMove& currentMove,
                                               const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard, QVector<ShogiMove>& legalMovesList)
{
    // 打った駒
    QChar dropPiece = currentMove.movingPiece;

    // 駒台に駒が存在しない場合は、エラーを出力して処理を終了する。
    if (pieceStand[dropPiece] <= 0) {
        // エラー発生。打った駒が駒台に存在しない。
        const QString errorMessage = tr("An error occurred in MoveValidator::generateLegalMovesForPiece. The piece to be dropped does not exist in the piece stand.");

        // 打った駒
        qDebug() << "Piece: " << dropPiece;

        // エラーメッセージを表示する。
        emit errorOccurred(errorMessage);
        return false; // ★ 打ち切り
    }

    switch (dropPiece.toUpper().toLatin1()) {
    case 'P':
        // 歩を打った場合の指し手を生成する。
        generateDropMoveForPawn(legalMovesList, pieceStand, emptySquareBitboard, turn, boardData);

        break;

    case 'L':
    case 'N':
    case 'S':
    case 'G':
    case 'B':
    case 'R':
        // 歩以外の駒を打った場合の指し手を生成する。
        generateDropMoveForPiece(legalMovesList, pieceStand, emptySquareBitboard, turn, dropPiece);

        break;

    default:
        // エラー発生。打った駒を表す文字がおかしい。
        const QString errorMessage = tr("An error occurred in MoveValidator::generateLegalMovesForPiece. The character representing the piece to be dropped is incorrect.");

        // 打った駒
        qDebug() << "Piece: " << dropPiece;

        // エラーメッセージを表示する。
        emit errorOccurred(errorMessage);
        return false; // ★ 打ち切り
    }

    return true;
}

 // 歩を打った場合の指し手を生成する。
void MoveValidator::generateDropMoveForPawn(QVector<ShogiMove>& legalMovesList, const QMap<QChar, int>& pieceStand, const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard,
                                            const Turn& turn, const QVector<QChar>& boardData) const
{
    // 歩が無い筋を1で表すbitboard
    std::bitset<NUM_BOARD_SQUARES> emptyFilePawnBitboard;

    // 歩が無い筋を1で表すbitboardの作成
    generateBitboardForEmptyFiles(turn, boardData, emptyFilePawnBitboard);

    // 駒が置かれていないマスを表すemptySquareBitboardと歩が無い筋を1で表すemptyFilePawnBitboardをAND演算したbitboard
    std::bitset<NUM_BOARD_SQUARES> emptySquaresNoPawnsFilesBitboard;

    // 駒が置かれていないマスを表すemptySquareBitboardと歩が無い筋を1で表すemptyFilePawnBitboardをAND演算した
    // emptySquaresNoPawnsFilesBitboardを作成する。
    performAndOperation(emptySquareBitboard, emptyFilePawnBitboard, emptySquaresNoPawnsFilesBitboard);

    // 歩を駒台から打つ場合の指し手を生成し、全指し手リストlegalMovesListに追加する。
    generateDropPawnMoves(legalMovesList, pieceStand, emptySquaresNoPawnsFilesBitboard, turn);
}

// 指定局面での合法手を生成する。
int MoveValidator::generateLegalMoves(const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand)
{
    // 盤面データと持ち駒のチェック
    validateBoardAndPieces(boardData, pieceStand);

    // 先手、後手の2種類
    // 歩、香車、桂馬、銀、金、角、飛車、玉、と金、成香、成桂、成銀、馬、龍の14種類
    // の合計28種類の駒が存在するマスを表すbitboardを作成する。
    BoardStateArray piecePlacedBitboards;
    generateBitboard(boardData, piecePlacedBitboards);

    // piecePlacedBitboardsの出力
    // 例．平手の場合、1〜9筋の7段目に先手の歩が9枚並んでいる。
    // 先手:
    // Piece type 歩:
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 1 1 1 1 1 1 1 1 1
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    //begin
    // printBitboards(piecePlacedBitboards);
    //end

    // 先手の歩、先手の香車、先手の桂馬〜先手の龍、
    // 後手の歩、後手の香車、後手の桂馬〜後手の龍の28種類に分けて
    // 各駒ごとに駒が存在するマスを表すbitboardを作成する。
    QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>> allPieceBitboards;
    generateAllPieceBitboards(allPieceBitboards, boardData);

    // allPieceBitboardsの出力
    // 例．平手で各40個の駒それぞれが存在するマスを示すbitboard
    // 先手の1七歩の場合
    // Piece: P
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 1
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    //begin
    // printAllPieceBitboards(allPieceBitboards);
    //end

    // 各個々の駒が移動できるマスを表すbitboardを作成する。
    QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>> allPieceAttackBitboards;
    generateAllIndividualPieceAttackBitboards(allPieceBitboards, piecePlacedBitboards, allPieceAttackBitboards);

    // allPieceAttackBitboardsの出力
    // 例．平手で各40個の駒の移動可能なマスを示すbitboard
    // 先手の1七歩の場合、1六に移動できる。
    // Piece: P
    // 先手:
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 1
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    //begin
    // printIndividualPieceAttackBitboards(allPieceBitboards, allPieceAttackBitboards);
    //end

    // 盤上の駒を動かした場合の全指し手リスト生成
    QVector<ShogiMove> allBoardPieceMovesList;

    // 盤上の駒を動かした場合の全指し手リスト生成
    // allPieceBitboardsは、手番のbitboardのみ必要
    // allPieceAttackBitboardsは、手番のbitboardのみ必要
    generateShogiMoveFromBitboards(turn, allPieceBitboards, allPieceAttackBitboards, allBoardPieceMovesList, boardData);

    // 例．先手8八玉が後手2二角から王手を受けている場合、2二、3三、4四、5五、6六、7七に
    // 玉以外の先手の駒をそのマスに指すことができれば後手の王手を回避できる。
    // 後手の王手を回避するために玉以外の先手の駒の移動可能なマスを表すbitboard
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 1 0
    // 0 0 0 0 0 0 1 0 0
    // 0 0 0 0 0 1 0 0 0
    // 0 0 0 0 1 0 0 0 0
    // 0 0 0 1 0 0 0 0 0
    // 0 0 1 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    std::bitset<MoveValidator::NUM_BOARD_SQUARES> necessaryMovesBitboard;

    // 玉を除いた攻撃範囲のマスを表すbitboard
    // 上の例の場合、後手2二角を0にしたもの
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    // 0 0 0 0 0 0 1 0 0
    // 0 0 0 0 0 1 0 0 0
    // 0 0 0 0 1 0 0 0 0
    // 0 0 0 1 0 0 0 0 0
    // 0 0 1 0 0 0 0 0 0
    // 0 0 0 0 0 0 0 0 0
    std::bitset<MoveValidator::NUM_BOARD_SQUARES> attackWithoutKingBitboard;

    // 相手の手番に仮設定
    Turn opponentTurn = (turn == BLACK) ? WHITE : BLACK;

    // 局面がすでに相手玉に王手をかけている状態かどうかを調べる。
    // numOpponentChecks = 0: 手番の玉は王手されていない。
    // numOpponentChecks = 1: 手番の玉は相手の1つの駒から王手されている。
    // numOpponentChecks = 2: 手番の玉は相手の駒から両王手されている。
    int numOpponentChecks = isKingInCheck(opponentTurn, allPieceBitboards, allPieceAttackBitboards, necessaryMovesBitboard, attackWithoutKingBitboard);

    // 王手をかけている局面でさらに指すのはおかしいのでエラーとなる。
    if (numOpponentChecks) {
        // エラー発生。局面がすでに王手をかけた状態になっている。さらに指すのはおかしい。
        const QString errorMessage = tr("An error occurred in MoveValidator::generateLegalMoves. The position is already in check. Making another move is incorrect.");

        printBoardAndPieces(boardData, pieceStand);

        // エラーメッセージを表示する。
        emit errorOccurred(errorMessage);
        return 0; // ★ 打ち切り
    }

    // 手番の玉が王手されているかどうかを調べる。
    // numChecks = 0: 手番の玉は王手されていない。
    // numChecks = 1: 手番の玉は相手の1つの駒から王手されている。
    // numChecks = 2: 手番の玉は相手の駒から両王手されている。
    int numChecks = isKingInCheck(turn, allPieceBitboards, allPieceAttackBitboards, necessaryMovesBitboard, attackWithoutKingBitboard);

    //begin
    // qDebug() << "numChecks = " << numChecks;
    // qDebug() << (turn == BLACK ? "先手" : "後手") << "の玉が王手されている: " << (numChecks ? "はい" : "いいえ");
    //end

    // 盤上の駒を動かして指す合法手リスト
    QVector<ShogiMove> legalMovesList;

    // 駒が置かれていないマスを表すbitboard
    std::bitset<MoveValidator::NUM_BOARD_SQUARES> emptySquareBitboard;

    if (numChecks) {
        // 自玉が王手されている場合
        // 王手されているときに王手を避ける指し手リスト
        QVector<ShogiMove> kingBlockingMovesList;

        // 王手されているときに王手を避ける指し手リスト候補を生成する。
        // 例.先手8八玉が後手2二角から王手を受けている場合、2二、3三、4四、5五、6六、7七に
        // 玉以外の先手の駒をそのマスに指すことができれば後手の王手を回避できる手を生成。
        // また、玉を移動させる手も生成するが王手が回避できていない手も含まれている。
        // 王手が回避できない手は、後の処理で除去している。
        // 1 Shogi move: From: (6, 7) To: (6, 6) Moving Piece: P Captured Piece:   Promotion: false
        // 2 Shogi move: From: (8, 9) To: (7, 7) Moving Piece: N Captured Piece:   Promotion: false
        // 3 Shogi move: From: (8, 8) To: (9, 8) Moving Piece: K Captured Piece:   Promotion: false
        // 4 Shogi move: From: (8, 8) To: (7, 8) Moving Piece: K Captured Piece:   Promotion: false
        filterMovesThatBlockThreat(turn, allBoardPieceMovesList, necessaryMovesBitboard, kingBlockingMovesList);

        // 指し手リストkingBlockingMovesListの各指し手moveに対して指した直後の盤面データを作成し、
        // その局面で相手が盤上の駒を動かした際の手を生成して、その中に自玉に王手が掛かっていない手だけを
        // 合法手リストlegalMovesListに加える。
        filterLegalMovesList(turn, kingBlockingMovesList, boardData, legalMovesList);

        if (numChecks == 2) {
            // 相手から両王手が掛けられた場合、基本的に自玉を直接動かすことでしか対処できない。
            // 合い駒（自分の手番で駒を打って王手を防ぐ）で防ごうとすると、相手の次の手番でその合い駒を取られてしまい、
            // 再度王手となってしまう。それだけでなく、合い駒を打つことはルールで禁止されている。
            // よって打つ手は生成できない。
            // 全指し手リストの出力
            //begin
            // qDebug() << "";
            // printShogiBoard(boardData);
            // qDebug() << "全指し手リスト";
            // printShogiMoveList(legalMovesList);
            //end
            return legalMovesList.size();
        }

        // 駒台から駒を打てるマスは玉と王手を掛けている駒のマスを除いた攻撃範囲のマスのみ
        emptySquareBitboard = attackWithoutKingBitboard;
    } else {
        // 自玉が王手されていない場合
        // 指し手リストallBoardPieceMovesListの各指し手moveに対して指した直後の盤面データを作成し、
        // その局面で相手が盤上の駒を動かした際の手を生成して、その中に自玉に王手が掛かっていない手だけを
        // 合法手リストlegalMovesListに加える。
        filterLegalMovesList(turn, allBoardPieceMovesList, boardData, legalMovesList);

        // 駒が置かれていないマスを表すbitboardを作成する。
        generateEmptySquareBitboard(boardData, emptySquareBitboard);
    }

    // 歩以外の駒を駒台から打つ場合の指し手を生成し、全指し手リストlegalMovesListに追加する。
    generateDropNonPawnMoves(legalMovesList, pieceStand, emptySquareBitboard, turn);

    // 歩を打った場合の指し手を生成し、legalMovesListに追加する。
    generateDropMoveForPawn(legalMovesList, pieceStand, emptySquareBitboard, turn, boardData);

    // 全指し手リストの出力
    //begin
    // qDebug() << "";
    // printShogiBoard(boardData);
    // qDebug() << "全指し手リスト";
    // printShogiMoveList(legalMovesList);
    //end

    return legalMovesList.size();
}

// 駒が置かれていないマスを表すemptySquareBitboardと歩が無い筋を1で表すemptyFilePawnBitboardをAND演算した
// emptySquaresNoPawnsFilesBitboardを作成する。
void MoveValidator::performAndOperation(const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard, const std::bitset<NUM_BOARD_SQUARES>& emptyFilePawnBitboard,
                         std::bitset<NUM_BOARD_SQUARES>& emptySquaresNoPawnsFilesBitboard) const
{
    emptySquaresNoPawnsFilesBitboard = emptySquareBitboard & emptyFilePawnBitboard;

    //begin
    // printSingleBitboard(emptySquaresNoPawnsFilesBitboard);
    //end

}

// 歩が無い筋を1で表すbitboardを作成する。
void MoveValidator::generateBitboardForEmptyFiles(const Turn& turn, const QVector<QChar>& boardData, std::bitset<NUM_BOARD_SQUARES>& emptyFilePawnBitboard) const
{
    const QChar pawn = (turn == BLACK) ? 'P' : 'p';
    std::array<bool, 9> fileContainsPawn = {false, false, false, false, false, false, false, false, false};

    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            int index = rank * BOARD_SIZE + file;
            if(boardData[index] == pawn) {
                fileContainsPawn[file] = true;
            }
        }
    }

    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            int index = rank * BOARD_SIZE + file;
            emptyFilePawnBitboard[index] = fileContainsPawn[file] ? 0 : 1;
        }
    }

    //begin
    // printSingleBitboard(emptyFilePawnBitboard);
    //end
}

// 先手、後手の2種類
// 歩、香車、桂馬、銀、金、角、飛車、玉、と金、成香、成桂、成銀、馬、龍の14種類
// の合計28種類の駒が存在するマスを表すbitboardを作成する。
void MoveValidator::generateBitboard(const QVector<QChar>& boardData, BoardStateArray& piecePlacedBitboard) const
{
    for (int i = 0; i < boardData.size(); ++i) {
        QChar piece = boardData.at(i);
        Turn turnPiece = piece.isUpper() ? BLACK : WHITE;
        piece = piece.toUpper();

        switch (piece.unicode()) {
        // 歩
        case 'P':
            piecePlacedBitboard[turnPiece][PAWN].set(i, true);
            break;
        // 香車
        case 'L':
            piecePlacedBitboard[turnPiece][LANCE].set(i, true);
            break;
        // 桂馬
        case 'N':
            piecePlacedBitboard[turnPiece][KNIGHT].set(i, true);
            break;
        // 銀
        case 'S':
            piecePlacedBitboard[turnPiece][SILVER].set(i, true);
            break;
        // 金
        case 'G':
            piecePlacedBitboard[turnPiece][GOLD].set(i, true);
            break;
        // 角
        case 'B':
            piecePlacedBitboard[turnPiece][BISHOP].set(i, true);
            break;
        // 飛車
        case 'R':
            piecePlacedBitboard[turnPiece][ROOK].set(i, true);
            break;
        // 玉
        case 'K':
            piecePlacedBitboard[turnPiece][KING].set(i, true);
            break;
        // と金
        case 'Q':
            piecePlacedBitboard[turnPiece][PROMOTED_PAWN].set(i, true);
            break;
        // 成香
        case 'M':
            piecePlacedBitboard[turnPiece][PROMOTED_LANCE].set(i, true);
            break;
        // 成桂
        case 'O':
            piecePlacedBitboard[turnPiece][PROMOTED_KNIGHT].set(i, true);
            break;
        // 成銀
        case 'T':
            piecePlacedBitboard[turnPiece][PROMOTED_SILVER].set(i, true);
            break;
        // 馬
        case 'C':
            piecePlacedBitboard[turnPiece][HORSE].set(i, true);
            break;
        // 龍
        case 'U':
            piecePlacedBitboard[turnPiece][DRAGON].set(i, true);
            break;
        }
    }
}

// piecePlacedBitboardを標準出力する。
void MoveValidator::printBitboards(const BoardStateArray& piecePlacedBitboard) const
{
    // 将棋の各駒の名称
    static const QStringList pieceName = { "歩", "香車", "桂馬", "銀", "金", "角", "飛車", "玉", "と金", "成香", "成桂", "成銀", "馬", "龍" };

    for (int turnNumber = 0; turnNumber < NUM_PLAYERS; ++turnNumber) {
        for (int pieceType = 0; pieceType < NUM_PIECE_TYPES; ++pieceType) {
            qDebug() << (turnNumber == 0 ? "先手:" : "後手:");
            qDebug() << "Piece type" << pieceName.at(pieceType) << ":";
            const std::bitset<NUM_BOARD_SQUARES>& bitboard = piecePlacedBitboard[turnNumber][pieceType];
            QString bitboardRow;
            for (int rank = 0; rank < BOARD_SIZE; ++rank) {
                bitboardRow.clear();
                for (int file = BOARD_SIZE - 1; file >= 0; --file) {
                    int index = rank * BOARD_SIZE + file;

                    // std::bitsetのtest()メンバ関数は、指定されたインデックスのビットが1(true)であるか、
                    // 0(false)であるかをチェックするために使用される。test()関数は、指定されたインデックスに
                    // あるビットがセットされている場合に true を返し、そうでない場合に false を返す。
                    // このコードにおいて、QString::number(bitboard.test(index)) + ' ')は、
                    // bitboardのindex位置にあるビットがセットされているかどうかを出力する。
                    // セットされていれば1が出力され、セットされていなければ0が出力される。
                    // これにより、駒のあるマスと無いマスを1と0で表示することができる。
                    bitboardRow.append(QString::number(bitboard.test(index)) + ' ');
                }
                qDebug() << bitboardRow;
            }
            qDebug() << "";
        }
    }
}

// 自分の各駒が存在するbitboard中でindexで指定されたマスに味方の駒が存在するかどうかを判定する。
bool MoveValidator::isPieceOnSquare(int& index, const std::array<std::bitset<NUM_BOARD_SQUARES>, NUM_PIECE_TYPES>& turnBitboards) const
{
    for (int pieceType = 0; pieceType < NUM_PIECE_TYPES; ++pieceType) {
        if (turnBitboards[pieceType].test(index)) {
            return true;
        }
    }

    return false;
}

// 盤面データboardDataからtargetPieceに該当する駒が存在するマスを表すbitboardを各駒ごとに作成し、そのリストを返す。
QVector<std::bitset<MoveValidator::NUM_BOARD_SQUARES>> MoveValidator::generateIndividualPieceBitboards(const QVector<QChar>& boardData, const QChar& targetPiece) const
{
    QVector<std::bitset<NUM_BOARD_SQUARES>> individualPieceBitboards;

    for (int i = 0; i < boardData.size(); ++i) {
        QChar piece = boardData.at(i);

        if (piece == targetPiece) {
            std::bitset<NUM_BOARD_SQUARES> pieceBitboard;

            pieceBitboard.set(i, true);

            individualPieceBitboards.append(pieceBitboard);
        }
    }

    return individualPieceBitboards;
}

// 先手の歩、先手の香車、先手の桂馬〜先手の龍、
// 後手の歩、後手の香車、後手の桂馬〜後手の龍の28種類に分けて
// 各駒ごとに駒が存在するマスを表すbitboardを作成する。
// 例．平手で各40個の駒それぞれが存在するマスを示すbitboard
// 先手の1七歩の場合
// Piece: P
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 1
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
void MoveValidator::generateAllPieceBitboards(QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards, const QVector<QChar>& boardData) const
{
    allPieceBitboards.clear();

    for (int i = 0; i < m_allPieces.size(); ++i) {
        const QChar& targetPiece = m_allPieces.at(i);
        allPieceBitboards.append(generateIndividualPieceBitboards(boardData, targetPiece));
    }
}

// allPieceBitboardsの出力
// 例．平手で各40個の駒それぞれが存在するマスを示すbitboard
// 先手の1七歩の場合
// Piece: P
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 1
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
void MoveValidator::printAllPieceBitboards(const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards) const
{
    for (int i = 0; i < allPieceBitboards.size(); ++i) {
        qDebug() << "Piece:" << m_allPieces.at(i);
        const auto& currentBitboards = allPieceBitboards.at(i);
        for (const auto& bitboard : currentBitboards) {
            QString bitboardString;
            for (int rank = 0; rank < BOARD_SIZE; ++rank) {
                for (int file = BOARD_SIZE - 1; file >= 0; --file) {
                    int index = rank * BOARD_SIZE + file;
                    bitboardString.append(bitboard.test(index) ? '1' : '0').append(' ');
                }
                bitboardString.append('\n');
            }
            bitboardString.append('\n');
            qDebug().noquote() << bitboardString;
        }
    }
}

// 各個々の駒が移動できるマスを表すbitboardを作成する。
// 例．平手で各40個の駒の移動可能なマスを示すbitboard
// 先手の1七歩の場合、1六に移動できる。
// Piece: P
// 先手:
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 1
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
void MoveValidator::generateAllIndividualPieceAttackBitboards(const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards, const BoardStateArray& piecePlacedBitboard,
                                                              QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceAttackBitboards) const
{
    allPieceAttackBitboards.resize(allPieceBitboards.size());

    for (int i = 0; i < allPieceBitboards.size(); ++i) {
        allPieceAttackBitboards[i].clear();
        QChar piece = m_allPieces.at(i);
        Turn turnPiece = piece.isUpper() ? BLACK : WHITE;
        piece = piece.toUpper();
        for (int j = 0; j < allPieceBitboards[i].size(); ++j) {
            std::bitset<MoveValidator::NUM_BOARD_SQUARES> attackBitboard;

            generateSinglePieceAttackBitboard(attackBitboard, allPieceBitboards[i].at(j), turnPiece, piece, piecePlacedBitboard);

            allPieceAttackBitboards[i].append(attackBitboard);
        }
    }
}

// allPieceAttackBitboardsの出力
// 例．平手で各40個の駒の移動可能なマスを示すbitboard
// 先手の1七歩の場合、1六に移動できる。
// Piece: P
// 先手:
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 1
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
// 0 0 0 0 0 0 0 0 0
void MoveValidator::printIndividualPieceAttackBitboards(const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards,
                                                        const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceAttackBitboards) const
{
    for (int i = 0; i < allPieceBitboards.size(); ++i) {
        //begin
        // QChar piece = allPieces.at(i);
        // Turn turnPiece = piece.isUpper() ? BLACK : WHITE;
        // qDebug() << "attack";
        // qDebug() << "Piece: " << piece;
        // qDebug() << (turnPiece == 0 ? "先手:" : "後手:");
        //end
        const auto& currentAttackBitboards = allPieceAttackBitboards.at(i);
        for (const auto& bitboard : currentAttackBitboards) {
            QString bitboardRow;
            for (int rank = 0; rank < BOARD_SIZE; ++rank) {
                bitboardRow.clear();
                for (int file = BOARD_SIZE - 1; file >= 0; --file) {
                    int index = rank * BOARD_SIZE + file;
                    bitboardRow.append(QString::number(bitboard.test(index)) + ' ');
                }
                qDebug() << bitboardRow;
            }
            qDebug() << "";
        }
    }
}

// bitboardリストから各bitboardを取り出し、そのbitboardの内容を標準出力する。
void MoveValidator::printBitboardContent(const QVector<std::bitset<NUM_BOARD_SQUARES>>& bitboards) const
{
    for (const auto& bitboard : bitboards) {
        printSingleBitboard(bitboard);
    }
}

// bitboardの内容を標準出力する。
// bitboardの内容を標準出力する。
void MoveValidator::printSingleBitboard(const std::bitset<NUM_BOARD_SQUARES>& bitboard) const
{
    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        QString bitboardRow;
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            int index = rank * BOARD_SIZE + file;
            bitboardRow.append(QString::number(bitboard.test(index)) + ' ');
        }
        qDebug() << bitboardRow;
    }
    qDebug() << "";
}

// 指し手リストから各指し手を標準出力する。
void MoveValidator::printShogiMoveList(const QVector<ShogiMove>& moveList) const
{
    int i = 0;
    for (const auto& move : moveList) {
        std::cout << std::setw(3) << std::setfill(' ') << ++i << " Shogi move: " << move << std::endl;
    }
}

// 盤上の駒を動かした場合の全指し手リスト生成
void MoveValidator::generateShogiMoveFromBitboards(const Turn& turn, const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards,
                                                   const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceAttackBitboards,
                                                   QVector<ShogiMove>& allMovesList, const QVector<QChar>& boardData) const
{
    int start = (turn == BLACK) ? P_IDX : p_IDX;
    int end = (turn == BLACK) ? U_IDX + 1 : u_IDX + 1;

    for (int i = start; i < end; ++i) {
        QChar piece = m_allPieces.at(i);

        //begin
        // qDebug() << "Piece: " << piece;
        // qDebug() << (turn == BLACK ? "先手:" : "後手:");
        // printBitboardContent(allPieceBitboards[i]);
        //end

        for (int j = 0; j < allPieceBitboards[i].size(); ++j) {
            auto& bitboard = allPieceBitboards[i].at(j);
            auto& attackBitboard = allPieceAttackBitboards[i].at(j);
            ShogiMove move;

            for (int rank = 0; rank < BOARD_SIZE; ++rank) {
                for (int file = BOARD_SIZE - 1; file >= 0; --file) {
                    int index = rank * BOARD_SIZE + file;
                    if (bitboard.test(index)) {
                        move.movingPiece = piece;
                        move.fromSquare = QPoint(file, rank);
                    }
                }
            }

            for (int rank = 0; rank < BOARD_SIZE; ++rank) {
                for (int file = BOARD_SIZE - 1; file >= 0; --file) {
                    int index = rank * BOARD_SIZE + file;
                    if (attackBitboard.test(index)) {
                        move.toSquare = QPoint(file, rank);
                        move.capturedPiece = boardData.at(index);

                        bool disallowedMove =
                                (piece == 'P' && rank == 0) ||
                                (piece == 'p' && rank == 8) ||
                                (piece == 'L' && rank == 0) ||
                                (piece == 'l' && rank == 8) ||
                                (piece == 'N' && (rank == 0 || rank == 1)) ||
                                (piece == 'n' && (rank == 7 || rank == 8));

                        // 成らない手の生成
                        if (!disallowedMove) {
                            allMovesList.append(move);
                        }

                        // 成る手の生成
                        generateAllPromotions(move, allMovesList);
                    }
                }
            }
        }
    }
    //begin
    // printShogiBoard(boardData);
    // printShogiMoveList(allMovesList);
    //end
}

// 各駒が存在するマスの位置を示すsinglePieceBitboardから移動可能なマスの位置を示すattackBitboardを生成する。
void MoveValidator::generateSinglePieceAttackBitboard(std::bitset<MoveValidator::NUM_BOARD_SQUARES>& attackBitboard,
                                                      const std::bitset<MoveValidator::NUM_BOARD_SQUARES>& singlePieceBitboard,
                                                      const Turn& turn, QChar pieceType, const BoardStateArray& piecePlacedBitboard) const
{
    // singlePieceBitboardの全てのビットを反復処理する。
    for (int index = 0; index < NUM_BOARD_SQUARES; ++index) {
        if (singlePieceBitboard.test(index)) {
            switch (pieceType.toUpper().toLatin1()) {
            case 'P':
                // 歩が存在するマスを表すbitboardから歩が移動可能なマスを表すbitboardを生成する。
                if (turn == BLACK) {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, 0}}, false, false);
                } else {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{1, 0}}, false, false);
                }
                break;
            case 'L':
                // 香車が存在するマスを表すbitboardから香車が移動可能なマスを表すbitboardを生成する。
                if (turn == BLACK) {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, 0}}, true, true);
                } else {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{1, 0}}, true, true);
                }
                break;
            case 'N':
                // 桂馬が存在するマスを表すbitboardから桂馬が移動可能なマスを表すbitboardを生成する。
                if (turn == BLACK) {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-2, -1}, {-2, 1}}, false, false);
                } else {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{2, -1}, {2, 1}}, false, false);
                }
                break;
            case 'S':
                // 銀が存在するマスを表すbitboardから銀が移動可能なマスを表すbitboardを生成する。
                if (turn == BLACK) {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, -1}, {-1, 0}, {-1, 1}, {1, -1}, {1, 1}}, false, false);
                } else {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{1, -1}, {1, 0}, {1, 1}, {-1, -1}, {-1, 1}}, false, false);
                }
                break;
            case 'G':
            case 'Q':
            case 'M':
            case 'O':
            case 'T':
                // 金（と金、成香、成桂、成銀）が存在するマスを表すbitboardから金（と金、成香、成桂、成銀）が移動可能なマスを表すbitboardを生成する。
                if (turn == BLACK) {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, 0}}, false, false);
                } else {
                    generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, 0}}, false, false);
                }
                break;
            case 'B':
                // 角が存在するマスを表すbitboardから角が移動可能なマスを表すbitboardを生成する。
                generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, -1}, {-1, 1}, {1, -1}, {1, 1}}, true, true);
                break;
            case 'R':
                // 飛車が存在するマスを表すbitboardから飛車が移動可能なマスを表すbitboardを生成する。
                generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}, true, true);
                break;
            case 'K':
                // 玉が存在するマスを表すbitboardから玉が移動可能なマスを表すbitboardを生成する。
                generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}}, false, false);
                break;
            case 'C':
                // 馬が存在するマスを表すbitboardから馬が移動可能なマスを表すbitboardを生成する。
                generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, -1}, {-1, 1}, {1, -1}, {1, 1}}, true, true);
                generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}, false, false);
                break;
            case 'U':
                // 龍が存在するマスを表すbitboardから歩が移動可能なマスを表すbitboardを生成する。
                generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}, true, true);
                generateAttackBitboard(attackBitboard, turn, piecePlacedBitboard, singlePieceBitboard, {{-1, -1}, {-1, 1}, {1, -1}, {1, 1}}, false, false);
                break;
            default:
                break;
            }
        }
    }
}

// 特定の種類の駒が攻撃可能なマスを表すビットボードを生成する。
// continuousは、駒が連続して移動できるか（飛車、角、馬、龍など）を指定する。
// enemyOccupiedStopは、敵の駒が存在するマスに到達した時点で駒の進行を止めるかを指定する（飛車、角、馬、龍など）。
void MoveValidator::generateAttackBitboard(std::bitset<NUM_BOARD_SQUARES>& attackBitboard, const Turn& turn,
                                           const BoardStateArray& piecePlacedBitboard, const std::bitset<NUM_BOARD_SQUARES>& pieceBitboard,
                                           const QList<QPoint>& directions, bool continuous, bool enemyOccupiedStop) const
{
    // 盤面の全てのマスを確認します。
    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            int index = rank * BOARD_SIZE + file;

            // 特定の種類の駒がそのマスに存在するかどうかをチェックする。
            if (pieceBitboard.test(index)) {
                // 駒が移動可能な全ての方向について確認する。
                for (const auto& direction : directions) {
                    int currentRank = rank;
                    int currentFile = file;
                    int opponent = 1 - turn;

                    // 駒が移動可能な限り、指定された方向に進む。
                    while (true) {
                        currentRank += direction.x();
                        currentFile += direction.y();

                        // 移動先のマスが盤面内にあるかを確認する。
                        if (currentRank >= 0 && currentRank < BOARD_SIZE &&
                            currentFile >= 0 && currentFile < BOARD_SIZE) {
                            int targetIndex = currentRank * BOARD_SIZE + currentFile;

                            // 味方の駒がある場所には移動できないため、その場合はループを抜ける。
                            if (isPieceOnSquare(targetIndex, piecePlacedBitboard[turn])) {
                                break;
                            }

                            // 空きマスか相手の駒がある場所に移動する。
                            attackBitboard.set(targetIndex, true);

                            // 対戦相手の駒がある場合はその駒を取ることができるが、その先には進めないためループを抜ける。
                            if (isPieceOnSquare(targetIndex, piecePlacedBitboard[opponent])) {
                                if (enemyOccupiedStop) break;
                            }

                            // 連続で動かない場合（飛車や角など）は、ここでループを抜ける。
                            if (!continuous) {
                                break;
                            }
                        } else {
                            // 盤の外に出たらループを抜けます。
                            break;
                        }
                    }
                }
            }
        }
    }
    //begin
    // printSingleBitboard(attackBitboard);
    //end
}

// 王手されているときに王手を避ける指し手リスト候補を生成する。
// 例.先手8八玉が後手2二角から王手を受けている場合、2二、3三、4四、5五、6六、7七に
// 玉以外の先手の駒をそのマスに指すことができれば後手の王手を回避できる手を生成。
// また、玉を移動させる手も生成するが王手が回避できていない手も含まれている。
// 王手が回避できない手は、後の処理で除去している。
// 1 Shogi move: From: (6, 7) To: (6, 6) Moving Piece: P Captured Piece:   Promotion: false
// 2 Shogi move: From: (8, 9) To: (7, 7) Moving Piece: N Captured Piece:   Promotion: false
// 3 Shogi move: From: (8, 8) To: (9, 8) Moving Piece: K Captured Piece:   Promotion: false
// 4 Shogi move: From: (8, 8) To: (7, 8) Moving Piece: K Captured Piece:   Promotion: false
void MoveValidator::filterMovesThatBlockThreat(const Turn& turn, const QVector<ShogiMove>& allMovesList, const std::bitset<NUM_BOARD_SQUARES>& necessaryMovesBitboard,
                                               QVector<ShogiMove>& kingBlockingMovesList) const
{
    kingBlockingMovesList.clear();
    QChar kingPiece = (turn == BLACK) ? 'K' : 'k';

    for (const auto &move : allMovesList) {
        // マスの番号を9x9ボードに基づいて計算します。
        int squareIndex = move.toSquare.y() * BOARD_SIZE + move.toSquare.x();

        // そのマスがビットボードで1になっているかどうかを確認します。
        // また、動かす駒が玉の場合も手を追加します。
        if (necessaryMovesBitboard[squareIndex] || move.movingPiece == kingPiece) {
            kingBlockingMovesList.append(move);
        }
    }
    //begin
    // printShogiMoveList(kingBlockingMovesList);
    //end
}

// 手番の玉が王手されているかどうかを調べる。
int MoveValidator::isKingInCheck(const Turn& turn, const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceBitboards,
                                  const QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>>& allPieceAttackBitboards,
                                  std::bitset<NUM_BOARD_SQUARES>& necessaryMovesBitboard,
                                  std::bitset<NUM_BOARD_SQUARES>& attackWithoutKingBitboard)
{
    // bitboardの初期化
    necessaryMovesBitboard.reset();
    attackWithoutKingBitboard.reset();

    int kingIndex = turn == BLACK ? K_IDX : k_IDX;
    const std::bitset<NUM_BOARD_SQUARES>& kingBitboard = allPieceBitboards[kingIndex][0];
    int numChecks = 0;

    for (int i = 0; i < allPieceBitboards.size(); ++i) {
        if (i == kingIndex) continue;

        for (int j = 0; j < allPieceBitboards[i].size(); ++j) {
            const auto& attackBitboard = allPieceAttackBitboards[i][j];
            if ((kingBitboard & attackBitboard).any()) {
                //begin
                // qDebug() << "piece = " << allPieces[i];
                //end
                // 玉を除いた攻撃範囲のマスを表すbitboard
                attackWithoutKingBitboard = attackBitboard & ~kingBitboard;

                // 玉を除いた攻撃範囲のマスを表すbitboardと王手をかけている相手の駒の位置を表すbitboardをOR演算する。
                // これにより王手を防ぐために駒を置きたいマスと王手を掛けている相手の駒の位置のマスを表すbitboardが生成できる。
                // このnecessaryMovesBitboardは、numChecksが1のときのみ必要なbitboardで
                // 両王手すなわちnumChecksが2のときは、意味のないbitboardになってしまう。
                necessaryMovesBitboard = attackWithoutKingBitboard | allPieceBitboards[i][j];
                ++numChecks;
            }
        }
    }

    if (numChecks > 2) {
        // エラー発生。手番の玉は相手の3つ以上の駒から同時に王手されている。
        const QString errorMessage = tr("An error occurred in MoveValidator::isKingInCheck. The player's king is checked by three or more pieces at the same time.");

        emit errorOccurred(errorMessage);
        return numChecks;
    }

    //begin
    // qDebug() << "numChecks = " << numChecks;
    // printSingleBitboard(attackWithoutKingBitboard);
    // printSingleBitboard(necessaryMovesBitboard);
    //end
    return numChecks;
}

// 指し手リストmoveListの各指し手moveに対して指した直後の盤面データboardDataAfterMoveを作成し、
// その局面で相手が盤上の駒を動かした際の手を生成して、その中に自玉に王手が掛かっていない手だけを
// 合法手リストlegalMovesListに加える。
void MoveValidator::filterLegalMovesList(const Turn& turn, const QVector<ShogiMove>& moveList, const QVector<QChar>& boardData, QVector<ShogiMove>& legalMovesList)
{
    // 合法手リストのクリア
    legalMovesList.clear();

    // 指した直後の盤面データ
    QVector<QChar> boardDataAfterMove;

    QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>> allPieceBitboards;
    QVector<QVector<std::bitset<NUM_BOARD_SQUARES>>> allPieceAttackBitboards;

    // 指し手リストのループ
    for (const auto& move : moveList) {
        // 1手指した後の局面データを用意する。
        applyMovesToBoard(move, boardData, boardDataAfterMove);

        // 先手の歩、先手の香車、先手の桂馬〜先手の龍、
        // 後手の歩、後手の香車、後手の桂馬〜後手の龍の28種類に分けて
        // 各駒ごとに駒が存在するマスを表すbitboardを作成する。
        generateAllPieceBitboards(allPieceBitboards, boardDataAfterMove);
        //begin
        // printAllPieceBitboards(allPieceBitboards);
        //end

        // 先手、後手の2種類
        // 歩、香車、桂馬、銀、金、角、飛車、玉、と金、成香、成桂、成銀、馬、龍の14種類
        // の合計28種類の駒が存在するマスを表すbitboardを作成する。
        BoardStateArray bitboard;
        generateBitboard(boardDataAfterMove, bitboard);

        // 各個々の駒が移動できるマスを表すbitboardを作成する。
        generateAllIndividualPieceAttackBitboards(allPieceBitboards, bitboard, allPieceAttackBitboards);
        //begin
        // printIndividualPieceAttackBitboards(allPieceBitboards, allPieceAttackBitboards);
        //end

        // 手番の指定
        Turn opponentTurn = (turn == BLACK) ? WHITE : BLACK;
        QVector<ShogiMove> allMovesList;

        // 盤上の駒を動かした場合の全指し手リスト生成
        generateShogiMoveFromBitboards(opponentTurn, allPieceBitboards, allPieceAttackBitboards, allMovesList, boardDataAfterMove);

        // necessaryMovesBitboard
        // 例．先手8八玉が後手2二角から王手を受けている場合、2二、3三、4四、5五、6六、7七に
        // 玉以外の先手の駒をそのマスに指すことができれば後手の王手を回避できる。
        // 後手の王手を回避するために玉以外の先手の駒の移動可能なマスを表すbitboard
        // 0 0 0 0 0 0 0 0 0
        // 0 0 0 0 0 0 0 1 0
        // 0 0 0 0 0 0 1 0 0
        // 0 0 0 0 0 1 0 0 0
        // 0 0 0 0 1 0 0 0 0
        // 0 0 0 1 0 0 0 0 0
        // 0 0 1 0 0 0 0 0 0
        // 0 0 0 0 0 0 0 0 0
        // 0 0 0 0 0 0 0 0 0
        std::bitset<NUM_BOARD_SQUARES> necessaryMovesBitboard;

        // 玉を除いた攻撃範囲のマスを表すbitboard
        std::bitset<NUM_BOARD_SQUARES> attackWithoutKingBitboard;

        // 手番の玉が王手されているかどうかを調べる。
        // numchecks = 0: 手番の玉は王手されていない。
        // numchecks = 1: 手番の玉は相手の1つの駒から王手されている。
        // numchecks = 2: 手番の玉は相手の駒から両王手されている。
        int numchecks = isKingInCheck(turn, allPieceBitboards, allPieceAttackBitboards, necessaryMovesBitboard, attackWithoutKingBitboard);
        //begin
        // qDebug() << (turn == BLACK ? "先手" : "後手") << "の玉が王手されている: " << (numchecks ? "はい" : "いいえ");
        //end

        // 玉が王手状態でない場合、そのmoveをlegalMovesListに追加
        if (!numchecks) {
            legalMovesList.append(move);
        }
    }
}

// 駒が置かれていないマスを表すbitboardを作成する。
void MoveValidator::generateEmptySquareBitboard(const QVector<QChar>& boardData, std::bitset<MoveValidator::NUM_BOARD_SQUARES>& emptySquareBitboard) const
{
    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            int index = rank * BOARD_SIZE + file;
            // 駒が置かれていないマスを１とする
            if (boardData[index] == ' ') {
                emptySquareBitboard.set(index);
            }
        }
    }
    //begin
    // printSingleBitboard(emptySquareBitboard);
    //end
}

// 駒台から駒を打つ場合の指し手を生成する。
void MoveValidator::generateDropMoveForPiece(QVector<ShogiMove>& allMovesList, const QMap<QChar, int>& pieceStand, const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard,
                                             const Turn& turn, const QChar& piece) const
{
    int count = pieceStand[piece];

    // その駒が駒台に1つ以上存在する場合
    if (count > 0) {
        // ビットボードを走査して空きマス（1）を探す。
        for (int rank = 0; rank < BOARD_SIZE; ++rank) {
            for (int file = BOARD_SIZE - 1; file >= 0; --file) {
                int index = rank * BOARD_SIZE + file;

                // そのマスが空いている場合
                if (emptySquareBitboard.test(index)) {
                    // 駒の種類とランクによる制限を考慮して、その駒を打つ手を生成する。
                    bool canDrop = true;

                    if ((piece == 'L' && rank == 0) || (piece == 'N' && rank < 2)) canDrop = false;
                    else if ((piece == 'l' && rank == BOARD_SIZE - 1) || (piece == 'n' && rank >= BOARD_SIZE - 2)) canDrop = false;

                    if (canDrop) {
                        // 駒台を示す座標
                        int fromFile = turn == BLACK ? 9 : 10;
                        int fromRank = turn == BLACK ? m_pieceOrderBlack[piece] : m_pieceOrderWhite[piece];
                        allMovesList.append(ShogiMove(QPoint(fromFile, fromRank), QPoint(file, rank), piece, ' ', false));
                    }
                }
            }
        }
    }
    //begin
    // printShogiMoveList(allMovesList);
    //end
}

// 歩以外の駒を駒台から打つ場合の指し手を生成する。
void MoveValidator::generateDropNonPawnMoves(QVector<ShogiMove>& allMovesList, const QMap<QChar, int>& pieceStand, const std::bitset<NUM_BOARD_SQUARES>& emptySquareBitboard, const Turn& turn) const
{
    QList<QChar> pieces = turn == BLACK ? QList<QChar>({'L', 'N', 'S', 'G', 'B', 'R'}) : QList<QChar>({'l', 'n', 's', 'g', 'b', 'r'});

    // 手番の持ち駒を一つずつ確認する。
    for (auto it = pieces.cbegin(); it != pieces.cend(); ++it) {
        generateDropMoveForPiece(allMovesList, pieceStand, emptySquareBitboard, turn, *it);
    }
    //begin
    // printShogiMoveList(allMovesList);
    //end
}

// 歩を駒台から打つ場合の指し手を生成する。
void MoveValidator::generateDropPawnMoves(QVector<ShogiMove>& allMovesList, const QMap<QChar, int>& pieceStand, const std::bitset<NUM_BOARD_SQUARES>& emptySquaresNoPawnsFilesBitboard,
                                          const Turn& turn) const
{
    QChar pawn = turn == BLACK ? 'P' : 'p';
    int count = pieceStand[pawn];

    // 駒が駒台に1つ以上存在する場合
    if (count > 0) {
        // ビットボードを走査して空きマス（1）を探す。
        for (int rank = 0; rank < BOARD_SIZE; ++rank) {
            for (int file = BOARD_SIZE - 1; file >= 0; --file) {
                int index = rank * BOARD_SIZE + file;

                // そのマスが空いている場合
                if (emptySquaresNoPawnsFilesBitboard.test(index)) {
                    // 駒の種類とランクによる制限を考慮して、その駒を打つ手を生成する。
                    bool canDrop = true;
                    if (pawn == 'P' && rank == 0) canDrop = false;
                    else if (pawn == 'p' && rank == BOARD_SIZE - 1) canDrop = false;

                    if (canDrop) {
                        // 駒台を示す座標
                        int fromFile = turn == BLACK ? 9 : 10;
                        int fromRank = turn == BLACK ? m_pieceOrderBlack[pawn] : m_pieceOrderWhite[pawn];
                        allMovesList.append(ShogiMove(QPoint(fromFile, fromRank), QPoint(file, rank), pawn, ' ', false));
                    }
                }
            }
        }
    }
    //begin
    // printShogiMoveList(allMovesList);
    //end
}

// 盤面データを9x9のマスに表示する。
void MoveValidator::printShogiBoard(const QVector<QChar>& boardData)
{
    QString boardString;
    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            QChar piece = boardData[rank * BOARD_SIZE + file];
            if (piece == ' ') {
                boardString.append("  ");
            } else {
                boardString.append(piece).append(' ');
            }
        }
        boardString.append('\n');
    }
    boardString.append('\n');
    qDebug().noquote() << boardString;
}

// 盤上の駒を動かした場合の全指し手リストを生成する。
void MoveValidator::generateShogiMoveFromBitboard(const QChar piece, const std::bitset<NUM_BOARD_SQUARES>& bitboard,
                                                  const std::bitset<NUM_BOARD_SQUARES>& attackBitboard,
                                                  QVector<ShogiMove>& allMovesList, const QVector<QChar>& boardData) const
{
    ShogiMove move;

    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            int index = rank * BOARD_SIZE + file;
            if (bitboard.test(index)) {
                move.movingPiece = piece;
                move.fromSquare = QPoint(file, rank);
            }
        }
    }

    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            int index = rank * BOARD_SIZE + file;
            if (attackBitboard.test(index)) {
                move.toSquare = QPoint(file, rank);
                move.capturedPiece = boardData.at(index);

                bool disallowedMove =
                    (piece == 'P' && rank == 0) ||
                    (piece == 'p' && rank == 8) ||
                    (piece == 'L' && rank == 0) ||
                    (piece == 'l' && rank == 8) ||
                    (piece == 'N' && (rank == 0 || rank == 1)) ||
                    (piece == 'n' && (rank == 7 || rank == 8));

                // 成らない手の生成
                if (!disallowedMove) {
                    allMovesList.append(move);
                }

                // 成る手の生成
                generateAllPromotions(move, allMovesList);
            }
        }
    }

    //begin
    // printShogiBoard(boardData);
    // printShogiMoveList(allMovesList);
    //end
}

// 指し手が合法手の中にあるかどうかをチェックする。
// 合法手に一致すればtrueを返し、無ければfalseを返す。
bool MoveValidator::isMoveInList(const ShogiMove& currentMove, const QVector<ShogiMove>& movesList) const
{
    for (const auto& move : movesList) {
        if (currentMove == move) {
            return true;
        }
    }

    return false;
}

// 指し手が合法手の中にあるかどうかをチェックし、legalMoveStatusに結果を格納する。
// 合法手に一致すればtrueを代入し、無ければfalseを代入する。
LegalMoveStatus MoveValidator::checkLegalMoveStatus(const ShogiMove& currentMove, const QVector<ShogiMove>& movesList) const
{
    LegalMoveStatus legalMoveStatus;

    // 不成の指し手が存在するかどうかを確認する。
    legalMoveStatus.nonPromotingMoveExists = isMoveInList(currentMove, movesList);

    // 成りの指し手を生成する。
    ShogiMove promotingMove = currentMove;
    promotingMove.isPromotion = true;

    // 成りの指し手が合法手リストに存在するかどうかを確認する。
    legalMoveStatus.promotingMoveExists = isMoveInList(promotingMove, movesList);

    return legalMoveStatus;
}

// 盤面と持ち駒を引数として、局面を漢字で出力する。
void MoveValidator::printBoardAndPieces(const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand) const
{
    QString row;

    // 駒の表示順序を保持するための追加のデータ構造
    static const QVector<QChar> pieceOrder = {'P', 'L', 'N', 'S', 'G', 'B', 'R', 'K', 'k', 'r', 'b', 'g', 's', 'n', 'l', 'p'};

    // 駒とその表示名を関連付けるマップ
    static const QMap<QChar, QString> pieceKanjiNames = {
        {' ', " 　"}, {'P', " 歩"}, {'L', " 香"}, {'N', " 桂"}, {'S', " 銀"}, {'G', " 金"}, {'B', " 角"}, {'R', " 飛"}, {'K', " 玉"},
        {'Q', " と"}, {'M', " 杏"}, {'O', " 圭"}, {'T', " 全"}, {'C', " 馬"}, {'U', " 龍"},
        {'p', "v歩"}, {'l', "v香"}, {'n', "v桂"}, {'s', "v銀"}, {'g', "v金"}, {'b', "v角"}, {'r', "v飛"}, {'k', "v玉"},
        {'q', "vと"}, {'m', "v杏"}, {'o', "v圭"}, {'t', "v全"}, {'c', "v馬"}, {'u', "v龍"}
    };

    // 先に後手の持ち駒を表示します。
    QString gotePieces = "持ち駒：";
    for (const auto& piece : pieceOrder) {
        if (piece.isLower()) {
            gotePieces += pieceKanjiNames[piece] + " " + QString::number(pieceStand[piece]) + " ";
        }
    }
    qDebug() << gotePieces;

    // 段の漢字
    static const QVector<QString> rowKanjiNames = {"一", "二", "三", "四", "五", "六", "七", "八", "九"};

    // 次に盤面を表示します。
    qDebug() << "  ９ ８ ７ ６ ５ ４ ３ ２ １";
    qDebug() << "+------------------------+";
    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            int index = rank * BOARD_SIZE + file;
            row.append(pieceKanjiNames[boardData[index]]);
        }
        qDebug() << "|" << row << "|" << rowKanjiNames[rank];
        row.clear();
    }
    qDebug() << "+------------------------+";

    // 最後に先手の持ち駒を表示します。
    QString sentePieces = "持ち駒：";
    for (const auto& piece : pieceOrder) {
        if (piece.isUpper()) {
            sentePieces += pieceKanjiNames[piece] + " " + QString::number(pieceStand[piece]) + " ";
        }
    }
    qDebug() << sentePieces;
}

// 成って指した手を生成する。
void MoveValidator::generateAllPromotions(ShogiMove& move, QVector<ShogiMove>& promotions) const
{
    // 駒が成れるかどうかを判断するための条件
    bool canPromote = false;
    int fromRank = move.fromSquare.y();
    int toRank = move.toSquare.y();

    if (move.movingPiece == 'P' || move.movingPiece == 'L' || move.movingPiece == 'N' || move.movingPiece == 'S' ||
        move.movingPiece == 'B' || move.movingPiece == 'R') {
        // 先手の場合
        if (toRank <= 2 || fromRank <= 2) {
            canPromote = true;
        }
    } else if (move.movingPiece == 'p' || move.movingPiece == 'l' || move.movingPiece == 'n' || move.movingPiece == 's' ||
               move.movingPiece == 'b' || move.movingPiece == 'r') {
        // 後手の場合
        if (toRank >= 6 || fromRank >= 6) {
            canPromote = true;
        }
    }

    // 成れる場合、成る手を生成
    if (canPromote) {
        move.isPromotion = true;
        promotions.append(move);
        move.isPromotion = false;
    }
}

// 1手指した後の局面データを作成する。
void MoveValidator::applyMovesToBoard(const ShogiMove& move, const QVector<QChar>& boardData, QVector<QChar>& boardDataAfterMove) const
{
    int fromIndex = move.fromSquare.y() * MoveValidator::BOARD_SIZE + move.fromSquare.x();
    int toIndex = move.toSquare.y() * MoveValidator::BOARD_SIZE + move.toSquare.x();

    // 移動前の盤面情報を1手指した後の盤面情報にコピー
    boardDataAfterMove = boardData;

    // 移動前のマスの駒を空に更新
    boardDataAfterMove[fromIndex] = ' ';

    // 移動後のマスに自分の駒を更新
    if (move.isPromotion) {
        // 駒を成って指した直後の盤面データを作成する。
        applyPromotionMovesToBoard(move, toIndex, boardDataAfterMove);
    } else {
        // 駒を不成で指した直後の盤面データを作成する。
        applyStandardMovesToBoard(move, toIndex, boardDataAfterMove);
    }
}

// 駒を持ち駒から打った後の持ち駒数を更新する。
void MoveValidator::decreasePieceCount(const ShogiMove& move, const QMap<QChar, int>& pieceStand, QMap<QChar, int>& pieceStandAfterMove)
{
    // 移動前の持ち駒情報を1手指した後の持ち駒情報にコピーする。
    pieceStandAfterMove = pieceStand;

    // 打った駒文字
    QChar piece = move.movingPiece;

    // 駒がマップに存在するかチェックする。
    if (pieceStand.contains(piece)) {
        // 駒の数が1以上なら、1つ減らす。
        if (pieceStandAfterMove[piece] > 0) {
            pieceStandAfterMove[piece]--;
        } else {
            // 駒の数が0なら、エラーメッセージを出力する。
            const QString errorMessage = tr("An error occurred in MoveValidator::decreasePieceCount. There is no piece of %1.").arg(piece);

            emit errorOccurred(errorMessage);
            return; // ★ 打ち切り
        }
    } else {
        // 駒がマップに存在しない場合、エラーメッセージを出力する。
        const QString errorMessage = tr("An error occurred in MoveValidator::decreasePieceCount. There is no piece of %1.").arg(piece);

        emit errorOccurred(errorMessage);
        return; // ★ 打ち切り
    }
}

// 駒を成って指した直後の盤面データを作成する。
void MoveValidator::applyPromotionMovesToBoard(const ShogiMove& move, int& toIndex, QVector<QChar>& boardDataAfterMove) const
{
    // 駒を成駒に変換するマップ
    static const QMap<QChar, QChar> promotionMap = {
        {'P', 'Q'}, {'p', 'q'},
        {'L', 'M'}, {'l', 'm'},
        {'N', 'O'}, {'n', 'o'},
        {'S', 'T'}, {'s', 't'},
        {'B', 'C'}, {'b', 'c'},
        {'R', 'U'}, {'r', 'u'}
    };

    QChar movingPiece = move.movingPiece;
    QChar promotedPiece = ' ';

    if (promotionMap.contains(movingPiece)) {
        promotedPiece = promotionMap[movingPiece];
    }

    boardDataAfterMove[toIndex] = promotedPiece;
}

// 駒を不成で指した直後の盤面データを作成する。
void MoveValidator::applyStandardMovesToBoard(const ShogiMove& move, int& toIndex, QVector<QChar>& boardDataAfterMove) const
{
    boardDataAfterMove[toIndex] = move.movingPiece;
}

// 指し手が合法手かどうか判定する。
LegalMoveStatus MoveValidator::validateMove(const int& numChecks, const QVector<QChar>& boardData, const ShogiMove& currentMove, const Turn& turn, BoardStateArray& piecePlacedBitboards,
                                 const QMap<QChar, int>& pieceStand, std::bitset<NUM_BOARD_SQUARES>& necessaryMovesBitboard, QVector<ShogiMove>& legalMovesList,
                                 const Turn& opponentTurn, const std::bitset<NUM_BOARD_SQUARES>& attackWithoutKingBitboard)
{
    if (currentMove.fromSquare.x() < BOARD_SIZE) {
        // 将棋盤内の駒を動かした場合の指し手のマスの位置を示すbitboardとそのマスの駒の移動可能なマスの位置を示すbitboardを作成し、
        // 指し手が合法手かどうか判定する。
        return generateBitboardAndValidateMove(numChecks, boardData, piecePlacedBitboards, currentMove, turn, necessaryMovesBitboard, legalMovesList);
    } else {
        LegalMoveStatus legalMoveStatus;
        legalMoveStatus.promotingMoveExists = false;

        if (numChecks) {
            // 自玉が王手されている場合
            // 駒台の駒を打った場合の合法手かどうかの判定
            legalMoveStatus.nonPromotingMoveExists = validateMoveWithChecks(currentMove, turn, boardData, pieceStand, numChecks, attackWithoutKingBitboard, legalMovesList);
        } else {
            // 自玉が王手されていない場合
            // 駒台の駒を打った場合の合法手かどうかの判定
            legalMoveStatus.nonPromotingMoveExists = validateMoveWithoutChecks(currentMove, turn, boardData, pieceStand, numChecks, legalMovesList, opponentTurn);
        }

        return legalMoveStatus;
    }
}

// 将棋盤内の駒を動かした場合の指し手のマスの位置を示すbitboardとそのマスの駒の移動可能なマスの位置を示すbitboardを作成し、
// 指し手が合法手かどうか判定する。
LegalMoveStatus MoveValidator::generateBitboardAndValidateMove(const int& numChecks, const QVector<QChar>& boardData, BoardStateArray& piecePlacedBitboards, const ShogiMove& currentMove,
                                                    const Turn& turn, std::bitset<NUM_BOARD_SQUARES>& necessaryMovesBitboard,
                                                    QVector<ShogiMove>& legalMovesList)
{
    // 指し手のマスのインデックス
    int fromIndex = currentMove.fromSquare.y() * BOARD_SIZE + currentMove.fromSquare.x();

    // 指し手のマスの駒文字
    QChar piece = boardData[fromIndex];

    // 指し手のマスの位置を示すbitboardの生成
    std::bitset<NUM_BOARD_SQUARES> pieceBitboard;
    pieceBitboard.set(fromIndex, true);

    // 駒が移動できるマスを表すbitboard
    std::bitset<NUM_BOARD_SQUARES> attackBitboard;

    // 駒が移動できるマスを表すbitboardを作成する。
    generateSinglePieceAttackBitboard(attackBitboard, pieceBitboard, turn, piece, piecePlacedBitboards);

    // 将棋盤内の駒を動かした場合の指し手が合法手かどうか判定する。
    return isBoardMoveValid(turn, boardData, currentMove, numChecks, piece, attackBitboard, pieceBitboard, necessaryMovesBitboard, legalMovesList);
}

// 自玉が王手されている場合、駒台の駒を打った場合の合法手かどうかを判定する。
bool MoveValidator::validateMoveWithChecks(const ShogiMove& currentMove, const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand,
                                                      const int& numChecks, const std::bitset<NUM_BOARD_SQUARES>& attackWithoutKingBitboard, QVector<ShogiMove>& legalMovesList)
{
    return isHandPieceMoveValid(turn, boardData, pieceStand, currentMove, numChecks,  attackWithoutKingBitboard, legalMovesList);
}

// 自玉が王手されていない場合、駒台の駒を打った場合の合法手かどうかの判定
bool MoveValidator::validateMoveWithoutChecks(const ShogiMove& currentMove, const Turn& turn, const QVector<QChar>& boardData, const QMap<QChar, int>& pieceStand,
                                              const int& numChecks, QVector<ShogiMove>& legalMovesList, const Turn& opponentTurn)
{
    // 自玉が王手されていない場合
    // 駒が置かれていないマスを表すbitboard
    std::bitset<MoveValidator::NUM_BOARD_SQUARES> emptySquareBitboard;

    // 駒が置かれていないマスを表すbitboardを作成する。
    generateEmptySquareBitboard(boardData, emptySquareBitboard);

    // 駒台の駒を打った場合の合法手かどうかの判定
    bool isLegal = isHandPieceMoveValid(turn, boardData, pieceStand, currentMove, numChecks,  emptySquareBitboard, legalMovesList);

    // 打った手が合法手でかつ打った駒が歩の場合、打ち歩詰めになっているかを以降の処理で判定する。
    // 合法手があり、かつ打った歩が玉の前のマスの場合
    //begin
    // qDebug() << "isLegal: " << isLegal;
    // qDebug() << "isPawnInFrontOfKing: " << isPawnInFrontOfKing(currentMove, turn, boardData);
    //end
    if ((isLegal) && (isPawnInFrontOfKing(currentMove, turn, boardData))) {
        // 指した直後の盤面データ
        QVector<QChar> boardDataAfterMove;

        // 持ち駒
        QMap<QChar, int> pieceStandAfterMove;

        // 打った局面に進める。
        // 1手指した後の局面データを用意する。
        applyMovesToBoard(currentMove, boardData, boardDataAfterMove);

        // 駒を持ち駒から打った後の持ち駒数を更新する。
        decreasePieceCount(currentMove, pieceStand, pieceStandAfterMove);

        //begin
        // printBoardAndPieces(boardDataAfterMove, pieceStandAfterMove);
        //end

        // 手番を相手に設定し、こちらが歩を相手の合法手数を計算する。
        if (generateLegalMoves(opponentTurn, boardDataAfterMove, pieceStandAfterMove)) {
            // 合法手があれば打ち歩詰めではないので指し手はOK
            return true;
        } else {
            // 合法手が無ければ打ち歩詰めなので指し手はNG
            qDebug() << tr("An error occurred in MoveValidator::validateMoveWithoutChecks. Dropping a pawn to give checkmate is not allowed.");

            return false;
        }
    }

    return isLegal;
}

// 玉の前のマスに駒台の歩を打ったかどうかを判定する。
bool MoveValidator::isPawnInFrontOfKing(const ShogiMove& currentMove, const Turn& turn, const QVector<QChar>& boardData) const
{
    // 手番に応じた玉の文字と歩の進行方向を設定
    QChar opponentKingPiece = (turn == BLACK) ? 'k' : 'K';
    int direction = (turn == BLACK) ? +1 : -1;

    // 段と筋をスキャン
    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            int index = rank * BOARD_SIZE + file;

            // 現在のマスに相手玉がいるかチェック
            if (boardData[index] == opponentKingPiece) {
                // 歩のマスが相手玉の1つ手前（後手の場合は1つ後ろ）のマスに一致しているか、
                // および、移動駒が歩であることを確認
                if ((currentMove.toSquare.x() == file) &&
                    (currentMove.toSquare.y() == rank + direction) &&
                    ((turn == BLACK && currentMove.movingPiece == 'P' && currentMove.fromSquare.x() == 9) ||
                     (turn == WHITE && currentMove.movingPiece == 'p' && currentMove.fromSquare.x() == 10))) {
                    return true;
                } else {
                    return false;
                }
            }
        }
    }

    // どの条件も満たさない場合は、falseを返す。
    return false;
}
#include "navigationcontroller.h"
#include "navigationcontext.h"
#include <QPushButton>
#include <QtGlobal>

NavigationController::NavigationController(const Buttons& b,
                                           INavigationContext* ctx,
                                           QObject* parent)
    : QObject(parent), m_ctx(ctx)
{
    if (b.first)  connect(b.first,  &QPushButton::clicked, this, [this](bool){ toFirst();  });
    if (b.back10) connect(b.back10, &QPushButton::clicked, this, [this](bool){ back10();   });
    if (b.prev)   connect(b.prev,   &QPushButton::clicked, this, [this](bool){ prev();     });
    if (b.next)   connect(b.next,   &QPushButton::clicked, this, [this](bool){ next();     });
    if (b.fwd10)  connect(b.fwd10,  &QPushButton::clicked, this, [this](bool){ fwd10();    });
    if (b.last)   connect(b.last,   &QPushButton::clicked, this, [this](bool){ toLast();   });
}

int NavigationController::clampRow(int row) const {
    const int n = m_ctx->resolvedRowCount();
    return qBound(0, row, n > 0 ? n - 1 : 0);
}

void NavigationController::toFirst() {
    const bool has = m_ctx->hasResolvedRows();
    const int  row = has ? clampRow(m_ctx->activeResolvedRow()) : 0;
    m_ctx->applySelect(row, 0);
}

void NavigationController::back10() {
    const bool has = m_ctx->hasResolvedRows();
    const int  row = has ? clampRow(m_ctx->activeResolvedRow()) : 0;

    const int maxPly = m_ctx->maxPlyAtRow(row);                 // 空なら MainWindow 側でモデル行数-1から算出
    const int cur    = qBound(0, m_ctx->currentPly(), maxPly);
    const int target = qMax(0, cur - 10);

    m_ctx->applySelect(row, target);
}

void NavigationController::prev() {
    const bool has = m_ctx->hasResolvedRows();
    const int  row = has ? clampRow(m_ctx->activeResolvedRow()) : 0;

    const int maxPly = m_ctx->maxPlyAtRow(row);
    const int cur    = qBound(0, m_ctx->currentPly(), maxPly);
    const int target = qMax(0, cur - 1);

    m_ctx->applySelect(row, target);
}

void NavigationController::next() {
    // 解決済み行が無くても続行する（row は 0 扱い）
    const bool has = m_ctx->hasResolvedRows();
    const int  row = has ? clampRow(m_ctx->activeResolvedRow()) : 0;

    const int maxPly = m_ctx->maxPlyAtRow(row);         // 空の時は MainWindow 側でモデル行数から算出
    const int cur    = qBound(0, m_ctx->currentPly(), maxPly);
    if (cur >= maxPly) return;

    m_ctx->applySelect(row, cur + 1);                    // 空の時は MainWindow 側のフォールバックが実行
}

void NavigationController::fwd10() {
    const bool has = m_ctx->hasResolvedRows();
    const int  row = has ? clampRow(m_ctx->activeResolvedRow()) : 0;

    const int maxPly = m_ctx->maxPlyAtRow(row);
    const int cur    = qBound(0, m_ctx->currentPly(), maxPly);
    if (cur >= maxPly) return;                                   // 末尾なら何もしない

    const int target = qMin(maxPly, cur + 10);
    m_ctx->applySelect(row, target);
}

void NavigationController::toLast() {
    const bool has   = m_ctx->hasResolvedRows();
    const int  row   = has ? clampRow(m_ctx->activeResolvedRow()) : 0;
    const int  lastPly = m_ctx->maxPlyAtRow(row);                // 空なら 0（開始局面）想定

    m_ctx->applySelect(row, lastPly);
}
#include "positioneditcontroller.h"
#include "shogiview.h"
#include "shogiboard.h"
#include "shogigamecontroller.h"
#include "boardinteractioncontroller.h"

#include <QStringList>
#include <QRegularExpression>
#include <Qt>

namespace {

// 将棋の平手初期配置（board部分）
static const QString kInitialBoard =
    QStringLiteral("lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL");
static const QString kInitialStand = QStringLiteral("-");

// 入力文字列（startpos / sfen ... / すでに最小SFEN / それ以外）を最小SFENに正規化
static QString toMinimalSfen(const QString& in)
{
    const QString s = in.trimmed();
    if (s.isEmpty()) {
        return QStringLiteral("%1 %2 %3 %4").arg(kInitialBoard, "b", kInitialStand, "1");
    }

    const QStringList parts = s.split(QRegularExpression("\\s+"), Qt::SkipEmptyParts);
    if (parts.isEmpty()) {
        return QStringLiteral("%1 %2 %3 %4").arg(kInitialBoard, "b", kInitialStand, "1");
    }

    // 1) "startpos"（moves は編集開始では無視）
    if (parts[0] == QStringLiteral("startpos")) {
        return QStringLiteral("%1 %2 %3 %4").arg(kInitialBoard, "b", kInitialStand, "1");
    }

    // 2) "sfen <board> <turn> <stand> <ply> (moves ...)?"
    if (parts[0] == QStringLiteral("sfen")) {
        if (parts.size() >= 5) {
            // moves は無視、最小SFENを返す
            return QStringLiteral("%1 %2 %3 %4").arg(parts[1], parts[2], parts[3], parts[4]);
        }
        // 壊れていれば平手へ
        return QStringLiteral("%1 %2 %3 %4").arg(kInitialBoard, "b", kInitialStand, "1");
    }

    // 3) 既に最小SFEN（board に / を含む）
    if (parts.size() >= 4 && parts[0].contains(QLatin1Char('/'))) {
        return QStringLiteral("%1 %2 %3 %4").arg(parts[0], parts[1], parts[2], parts[3]);
    }

    // 4) 不明形式は平手へ
    return QStringLiteral("%1 %2 %3 %4").arg(kInitialBoard, "b", kInitialStand, "1");
}

// 最小SFEN（board turn stand ply）を受け取り、手番と手数を上書きして返す
static QString forceTurnAndPly(const QString& minimalSfen, QChar turnBW, int ply = 1)
{
    QStringList t = minimalSfen.split(QLatin1Char(' '), Qt::SkipEmptyParts);
    while (t.size() < 4) t << QString();
    t[1] = QString(turnBW);
    t[3] = QString::number(ply);
    return QStringLiteral("%1 %2 %3 %4").arg(t[0], t[1], t[2], t[3]);
}

static QChar toBW(ShogiGameController::Player p)
{
    // Player1=先手(b), Player2=後手(w)
    return (p == ShogiGameController::Player2) ? QLatin1Char('w') : QLatin1Char('b');
}

static ShogiGameController::Player fromBW(const QString& bw)
{
    return (bw == QStringLiteral("w"))
    ? ShogiGameController::Player2
    : ShogiGameController::Player1;
}

} // namespace

void PositionEditController::beginPositionEditing(const BeginEditContext& c)
{
    if (!c.view || !c.gc) return;
    if (!c.view->board()) return;

    // 編集セッションの参照を保持
    m_view = c.view;
    m_gc   = c.gc;
    m_bic  = c.bic;

    ShogiBoard* board = c.view->board();

    // 0) 既存 GC 手番から desiredTurn を決める（未設定なら先手扱い）
    ShogiGameController::Player preSide = c.gc->currentPlayer();
    if (preSide == ShogiGameController::NoPlayer) preSide = ShogiGameController::Player1;
    const QChar desiredTurn = toBW(preSide);

    // 1) 編集開始SFENの決定（record / current / resume / 盤 から）
    QString baseSfen;
    if (c.sfenRecord && !c.sfenRecord->isEmpty()) {
        const int lastIdx = c.sfenRecord->size() - 1;
        int idx = -1;
        if (c.gameOver) {
            idx = lastIdx;
        } else if (c.selectedPly >= 0 && c.selectedPly <= lastIdx) {
            idx = c.selectedPly;
        } else if (c.activePly >= 0 && c.activePly <= lastIdx) {
            idx = c.activePly;
        } else {
            idx = lastIdx;
        }
        if (idx >= 0 && idx <= lastIdx) baseSfen = c.sfenRecord->at(idx);
    }
    if (baseSfen.isEmpty()) {
        if (c.currentSfenStr && !c.currentSfenStr->isEmpty()) {
            baseSfen = *c.currentSfenStr;
        } else if (c.resumeSfenStr && !c.resumeSfenStr->isEmpty()) {
            baseSfen = *c.resumeSfenStr;
        } else {
            // 盤の現在状態から最小SFENを組み立てる
            baseSfen = QStringLiteral("%1 %2 %3 %4")
                           .arg(board->convertBoardToSfen(),
                                board->currentPlayer(),
                                board->convertStandToSfen(),
                                QString::number(1));
        }
    }

    // 2) 最小SFENへ正規化し、手番/手数を強制上書き
    const QString minimal  = toMinimalSfen(baseSfen);
    const QString adjusted = forceTurnAndPly(minimal, desiredTurn, /*ply*/1);

    // 3) 盤へ適用し、編集モードへ
    board->setSfen(adjusted);
    c.view->setPositionEditMode(true);
    c.view->setMouseClickMode(true);
    c.view->update();

    // ★ 3.5) メニュー切替（MainWindow へ通知）
    if (c.onEnterEditMenu) c.onEnterEditMenu();

    // 4) ハイライト等の初期化
    if (c.bic) {
        c.bic->setMode(BoardInteractionController::Mode::Edit);
        c.bic->clearAllHighlights();
    }

    // 5) GC の手番を盤へ同期
    const QString bw = board->currentPlayer();
    c.gc->setCurrentPlayer(fromBW(bw));

    // 6) 「編集終了」ボタン表示
    if (c.onShowEditExitButton) c.onShowEditExitButton();

    // 7) 任意: startSfenStr にも記録（必要なら）
    if (c.sfenRecord && c.startSfenStr) {
        if (!c.sfenRecord->isEmpty()) *c.startSfenStr = c.sfenRecord->first();
        else                          *c.startSfenStr = adjusted;
    }
}

void PositionEditController::finishPositionEditing(const PositionEditController::FinishEditContext& c)
{
    if (!c.gc || !c.view || !c.view->board()) return;

    ShogiBoard* board = c.view->board();

    // 盤モデルから SFEN を再構成（最小SFEN）
    const QString bw = board->currentPlayer();
    const QString sfenNow = QStringLiteral("%1 %2 %3 %4")
                                .arg(board->convertBoardToSfen(),
                                     bw,
                                     board->convertStandToSfen(),
                                     QString::number(1));

    // 盤面へ反映し、描画
    board->setSfen(sfenNow);
    c.view->setPositionEditMode(false);
    c.view->setMouseClickMode(false);
    c.view->update();

    // sfenRecord を 0手局面として再保存
    if (c.sfenRecord) {
        c.sfenRecord->clear();
        c.sfenRecord->push_back(sfenNow);
    }

    // startSfen にも反映
    if (c.startSfenStr) {
        if (c.sfenRecord && !c.sfenRecord->isEmpty()) *c.startSfenStr = c.sfenRecord->first();
        else                                          *c.startSfenStr = sfenNow;
    }

    // 再開フラグを落とす
    if (c.isResumeFromCurrent) *c.isResumeFromCurrent = false;

    // UI 後片付け
    if (c.bic) {
        c.bic->clearAllHighlights();
    }
    if (c.onHideEditExitButton) c.onHideEditExitButton();

    // 追加: メニュー非表示（MainWindow 実装のコールバック）
    if (c.onLeaveEditMenu) c.onLeaveEditMenu();

    // ★ 追加: 編集セッションの参照を保持（アクション用スロットで利用）
    m_view = c.view;
    m_gc   = c.gc;
    m_bic  = c.bic;
}

// ─────────────────────────────────────────────────────────────
// 追加: 盤操作 API
// ─────────────────────────────────────────────────────────────
void PositionEditController::resetPiecesToStand(ShogiView* view, BoardInteractionController* bic)
{
    if (!view) return;
    if (bic) bic->clearAllHighlights();
    view->resetAndEqualizePiecesOnStands();
}

void PositionEditController::setStandardStartPosition(ShogiView* view, BoardInteractionController* bic)
{
    if (!view) return;
    if (bic) bic->clearAllHighlights();
    view->initializeToFlatStartingPosition();
}

void PositionEditController::setTsumeShogiStartPosition(ShogiView* view, BoardInteractionController* bic)
{
    if (!view) return;
    if (bic) bic->clearAllHighlights();
    view->shogiProblemInitialPosition();
}

// ─────────────────────────────────────────────────────────────
// 追加: 「編集終了」ボタンの出し入れ（ShogiView 内の既存ボタンを利用）
// ─────────────────────────────────────────────────────────────
void PositionEditController::showEditExitButtonOnBoard(ShogiView* view, QObject* receiver, const char* finishSlot)
{
    if (!view) return;

    // ShogiView 側で作成&配置（必要なら内部で生成）
    view->relayoutEditExitButton();

    // ボタン取得
    if (QPushButton* exitBtn = view->findChild<QPushButton*>(QStringLiteral("editExitButton"))) {
        // 重複接続防止
        QObject::disconnect(exitBtn, SIGNAL(clicked()), receiver, finishSlot);
        // 旧式シグナル（ラムダ不使用ポリシーに合わせる）
        QObject::connect(exitBtn, SIGNAL(clicked()), receiver, finishSlot);
        exitBtn->show();
        exitBtn->raise();
    }
}

void PositionEditController::hideEditExitButtonOnBoard(ShogiView* view)
{
    if (!view) return;
    if (QPushButton* exitBtn = view->findChild<QPushButton*>(QStringLiteral("editExitButton"))) {
        exitBtn->hide();
    }
}

void PositionEditController::onReturnAllPiecesOnStandTriggered()
{
    if (!m_view) return;
    resetPiecesToStand(m_view, m_bic);
}

void PositionEditController::onFlatHandInitialPositionTriggered()
{
    if (!m_view) return;
    setStandardStartPosition(m_view, m_bic);
}

void PositionEditController::onShogiProblemInitialPositionTriggered()
{
    if (!m_view) return;
    setTsumeShogiStartPosition(m_view, m_bic);
}

void PositionEditController::onToggleSideToMoveTriggered()
{
    if (!m_gc) return;
    auto cur = m_gc->currentPlayer();
    m_gc->setCurrentPlayer(
        (cur == ShogiGameController::Player1)
            ? ShogiGameController::Player2
            : ShogiGameController::Player1);
    if (m_view) m_view->update();
}

bool PositionEditController::applyEditMove(const QPoint& from,
                                           const QPoint& to,
                                           ShogiView* view,
                                           ShogiGameController* gc,
                                           BoardInteractionController* bic)
{
    if (!view || !gc || !bic) return false;

    // validate & apply in edit-mode
    QPoint hFrom = from, hTo = to;
    const bool ok = gc->editPosition(hFrom, hTo);

    // UI 後処理（ドラッグ終了／結果通知）
    view->endDrag();
    bic->onMoveApplied(hFrom, hTo, ok);

    if (ok) {
        view->update();
    }
    return ok;
}
#include "sfenpositiontracer.h"
#include <QtGlobal>
#include <QHash>
#include <QPoint>

SfenPositionTracer::SfenPositionTracer() { resetToStartpos(); }

void SfenPositionTracer::resetToStartpos() {
    clearBoard();
    setStartposBoard();
    m_blackToMove = true;
    m_plyNext = 1;
    m_handB.fill(0);
    m_handW.fill(0);
}

QStringList SfenPositionTracer::generateSfensForMoves(const QStringList& usiMoves) {
    resetToStartpos();
    QStringList out;
    out.reserve(usiMoves.size());
    for (const QString& mv : usiMoves) {
        if (!applyUsiMove(mv)) break;
        out << toSfenString();
    }
    return out;
}

bool SfenPositionTracer::applyUsiMove(const QString& usiIn) {
    QString usi = usiIn.trimmed();

    // Drop: "P*5e"
    if (usi.contains(QLatin1Char('*'))) {
        const int star = usi.indexOf('*');
        if (star != 1 || usi.size() < 4) return false;
        const QChar up = usi.at(0).toUpper();
        const int col = fileToCol(usi.at(2).toLatin1() - '0');
        const int row = rankLetterToRow(usi.at(3));
        if (col<0 || row<0) return false;

        Kind k = letterToKind(up);
        if (k == KIND_N) return false;
        if (!subHand(m_blackToMove, k, 1)) {
            // 枚数チェックは緩めにしておく（0でも続行したい場合はtrueに）
            // return false;
        }
        m_board[row][col] = makeToken(up, m_blackToMove, false);

    } else {
        // Normal: "7g7f" or "2b3c+"
        if (usi.size() < 4) return false;
        const int colFrom = fileToCol(usi.at(0).toLatin1() - '0');
        const int rowFrom = rankLetterToRow(usi.at(1));
        const int colTo   = fileToCol(usi.at(2).toLatin1() - '0');
        const int rowTo   = rankLetterToRow(usi.at(3));
        const bool promote = (usi.size() >= 5 && usi.at(4) == QLatin1Char('+'));
        if (colFrom<0 || rowFrom<0 || colTo<0 || rowTo<0) return false;

        const QString fromTok = m_board[rowFrom][colFrom];
        if (fromTok.isEmpty()) return false;

        // 捕獲
        const QString toTok = m_board[rowTo][colTo];
        if (!toTok.isEmpty()) {
            const QChar capBase = baseUpperFromToken(toTok);
            Kind capK = letterToKind(capBase);
            if (capK != KIND_N) addHand(m_blackToMove, capK, 1);
        }

        // 駒を移動
        const QChar base = baseUpperFromToken(fromTok);
        const bool wasPromoted = isPromotedToken(fromTok);
        const bool nowPromoted = promote ? true : wasPromoted;
        m_board[rowTo][colTo] = makeToken(base, m_blackToMove, nowPromoted);
        m_board[rowFrom][colFrom].clear();
    }

    // 手番・手数更新
    m_blackToMove = !m_blackToMove;
    ++m_plyNext;
    return true;
}

QString SfenPositionTracer::toSfenString() const {
    const QString board = boardToSfenField();
    const QString stm = m_blackToMove ? QStringLiteral("b") : QStringLiteral("w");
    const QString hands = handsToSfenField();
    const QString ply = QString::number(m_plyNext);
    return QStringLiteral("%1 %2 %3 %4").arg(board, stm, hands, ply);
}

// ---------- ユーティリティ実装 ----------

int SfenPositionTracer::fileToCol(int file) { // 1..9 -> 0..8 (9筋が左端)
    if (file < 1 || file > 9) return -1;
    return 9 - file;
}

int SfenPositionTracer::rankLetterToRow(QChar r) { // a..i -> 0..8
    const ushort u = r.toLower().unicode();
    if (u < 'a' || u > 'i') return -1;
    return int(u - 'a');
}

QChar SfenPositionTracer::kindToLetter(Kind k) {
    switch (k) {
    case P: return QLatin1Char('P');
    case L: return QLatin1Char('L');
    case N: return QLatin1Char('N');
    case S: return QLatin1Char('S');
    case G: return QLatin1Char('G');
    case B: return QLatin1Char('B');
    case R: return QLatin1Char('R');
    default: return QChar();
    }
}
SfenPositionTracer::Kind SfenPositionTracer::letterToKind(QChar upper) {
    switch (upper.toUpper().unicode()) {
    case 'P': return P;
    case 'L': return L;
    case 'N': return N;
    case 'S': return S;
    case 'G': return G;
    case 'B': return B;
    case 'R': return R;
    default:  return KIND_N;
    }
}
QChar SfenPositionTracer::toSideCase(QChar upper, bool black) {
    return black ? upper.toUpper() : upper.toLower();
}
QString SfenPositionTracer::makeToken(QChar upper, bool black, bool promoted) {
    const QChar s = toSideCase(upper, black);
    return promoted ? (QString(QLatin1Char('+')) + s) : QString(s);
}
bool SfenPositionTracer::isPromotedToken(const QString& t) {
    return (!t.isEmpty() && t.at(0) == QLatin1Char('+'));
}
QChar SfenPositionTracer::baseUpperFromToken(const QString& t) {
    if (t.isEmpty()) return QChar();
    const QChar c = isPromotedToken(t) ? t.at(1) : t.at(0);
    return c.toUpper();
}

void SfenPositionTracer::clearBoard() {
    for (int r=0; r<9; ++r)
        for (int c=0; c<9; ++c)
            m_board[r][c].clear();
}

void SfenPositionTracer::setStartposBoard() {
    // 平手初期配置（SFEN: lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1）
    // 上段(a)は後手の駒（小文字）、下段(i)は先手の駒（大文字）
    const char* row0 = "lnsgkgsnl";
    const char* row1 = "1r5b1";
    const char* row2 = "ppppppppp";
    const char* row6 = "PPPPPPPPP";
    const char* row7 = "1B5R1";
    const char* row8 = "LNSGKGSNL";

    auto fillFromPattern = [&](int row, const char* pat) {
        int c = 0;
        for (int i=0; pat[i] != '\0' && c<9; ++i) {
            const char ch = pat[i];
            if (ch >= '1' && ch <= '9') {
                int n = ch - '0';
                while (n-- > 0 && c < 9) { m_board[row][c++].clear(); }
            } else {
                m_board[row][c++] = QString(QChar(ch));
            }
        }
        while (c < 9) m_board[row][c++].clear();
    };

    fillFromPattern(0, row0);
    fillFromPattern(1, row1);
    fillFromPattern(2, row2);
    for (int r=3; r<=5; ++r) for (int c=0; c<9; ++c) m_board[r][c].clear();
    fillFromPattern(6, row6);
    fillFromPattern(7, row7);
    fillFromPattern(8, row8);
}

void SfenPositionTracer::addHand(bool black, Kind k, int n) {
    (black ? m_handB : m_handW)[k] += n;
}
bool SfenPositionTracer::subHand(bool black, Kind k, int n) {
    auto& v = (black ? m_handB : m_handW)[k];
    if (v < n) { v = 0; return false; }
    v -= n; return true;
}

QString SfenPositionTracer::boardToSfenField() const {
    QString s;
    s.reserve(90);
    for (int r=0; r<9; ++r) {
        int empties = 0;
        for (int c=0; c<9; ++c) {
            const QString& t = m_board[r][c];
            if (t.isEmpty()) {
                ++empties;
            } else {
                if (empties > 0) { s += QString::number(empties); empties = 0; }
                s += t;
            }
        }
        if (empties > 0) s += QString::number(empties);
        if (r != 8) s += QLatin1Char('/');
    }
    return s;
}

QString SfenPositionTracer::handsToSfenField() const {
    auto appendSide = [](QString& out, const std::array<int,KIND_N>& h, bool black) {
        // 推奨順: R B G S N L P
        const Kind order[] = { R, B, G, S, N, L, P };
        for (Kind k : order) {
            int n = h[k];
            if (n <= 0) continue;
            if (n > 1) out += QString::number(n);
            const QChar up = kindToLetter(k);
            out += black ? up : up.toLower();
        }
    };
    QString out;
    appendSide(out, m_handB, true);
    appendSide(out, m_handW, false);
    return out.isEmpty() ? QStringLiteral("-") : out;
}

bool SfenPositionTracer::setFromSfen(const QString& sfen) {
    m_handB.fill(0);
    m_handW.fill(0);
    clearBoard();

    const QStringList parts = sfen.split(QLatin1Char(' '), Qt::SkipEmptyParts);
    if (parts.size() < 4) return false;

    // --- board ---
    const QString board = parts[0];
    const QStringList ranks = board.split(QLatin1Char('/'));
    if (ranks.size() != 9) return false;

    for (int r = 0; r < 9; ++r) {
        const QString& row = ranks[r];
        int c = 0;
        for (int i = 0; i < row.size() && c < 9; ++i) {
            const QChar ch = row.at(i);
            if (ch.isDigit()) {
                int n = ch.digitValue();
                while (n-- > 0 && c < 9) { m_board[r][c++].clear(); }
            } else if (ch == QLatin1Char('+')) {
                if (i + 1 >= row.size()) return false;
                const QChar p = row.at(++i);
                m_board[r][c++] = QString(QLatin1Char('+')) + p;
            } else {
                m_board[r][c++] = QString(ch);
            }
        }
        while (c < 9) m_board[r][c++].clear();
    }

    // --- stm ---
    m_blackToMove = (parts[1] == QStringLiteral("b"));

    // --- hands ---
    const QString hands = parts[2];
    if (hands != QStringLiteral("-")) {
        int num = 0;
        for (QChar ch : hands) {
            if (ch.isDigit()) {
                num = num * 10 + ch.digitValue();
            } else {
                const bool black = ch.isUpper();
                const int n = (num > 0) ? num : 1;
                num = 0;
                Kind k = letterToKind(ch.toUpper());
                if (k != KIND_N) addHand(black, k, n);
            }
        }
    }

    // --- ply ---
    bool ok = false;
    int ply = parts[3].toInt(&ok);
    m_plyNext = ok && ply > 0 ? ply : 1;

    return true;
}

QString SfenPositionTracer::tokenAtFileRank(int file, QChar rankLetter) const {
    int col = fileToCol(file);
    int row = rankLetterToRow(rankLetter);
    if (col < 0 || row < 0) return QString();
    return m_board[row][col];
}

// ========== 新設ユーティリティ（宣言はヘッダに追加） ==========

QStringList SfenPositionTracer::buildSfenRecord(const QString& initialSfen,
                                                const QStringList& usiMoves,
                                                bool hasTerminal)
{
    SfenPositionTracer tracer;
    // 初期SFENのセットに失敗したら平手初期局面でフォールバック
    if (!tracer.setFromSfen(initialSfen)) {
        tracer.setFromSfen(QStringLiteral(
            "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1"));
    }

    QStringList list;
    list << tracer.toSfenString(); // 0) 開始局面

    for (const QString& mv : usiMoves) {
        tracer.applyUsiMove(mv);
        list << tracer.toSfenString(); // 1..N) 各手後
    }
    if (hasTerminal) {
        // 終局/中断の表示を楽にするため、末尾に同一局面をもう1つ
        list << tracer.toSfenString();
    }
    return list;
}

QVector<ShogiMove> SfenPositionTracer::buildGameMoves(const QString& initialSfen,
                                                      const QStringList& usiMoves)
{
    QVector<ShogiMove> out;
    out.reserve(usiMoves.size());

    SfenPositionTracer tracer;
    tracer.setFromSfen(initialSfen);

    for (const QString& usi : usiMoves) {
        // 駒打ち: "P*5e"
        if (usi.size() >= 4 && usi.at(1) == QLatin1Char('*')) {
            const bool black     = tracer.blackToMove();
            const QChar dropUp   = usi.at(0).toUpper();          // P/L/N/S/G/B/R
            const int  file      = usi.at(2).toLatin1() - '0';   // '1'..'9'
            const int  rank      = rankLetterToNum(usi.at(3));   // 1..9
            if (file < 1 || file > 9 || rank < 1 || rank > 9) { tracer.applyUsiMove(usi); continue; }

            const QPoint from    = dropFromSquare(dropUp, black); // 駒台の擬似座標
            const QPoint to      = QPoint(file - 1, rank - 1);
            const QChar  moving  = dropLetterWithSide(dropUp, black);
            const QChar  captured= QLatin1Char(' ');
            const bool   promo   = false;

            out.push_back(ShogiMove(from, to, moving, captured, promo));
            tracer.applyUsiMove(usi);
            continue;
        }

        // 通常手: "7g7f" or "2b3c+" など
        if (usi.size() < 4) { tracer.applyUsiMove(usi); continue; }

        const int ff = usi.at(0).toLatin1() - '0';
        const int rf = rankLetterToNum(usi.at(1));
        const int ft = usi.at(2).toLatin1() - '0';
        const int rt = rankLetterToNum(usi.at(3));
        const bool isProm = (usi.size() >= 5 && usi.at(4) == QLatin1Char('+'));
        if (ff<1||ff>9||rf<1||rf>9||ft<1||ft>9||rt<1||rt>9) { tracer.applyUsiMove(usi); continue; }

        // 動く前の盤面から取る/動く駒を決定
        const QString fromTok = tracer.tokenAtFileRank(ff, usi.at(1)); // "+p" 等もありえる
        const QString toTok   = tracer.tokenAtFileRank(ft, usi.at(3));

        const QPoint from(ff - 1, rf - 1);
        const QPoint to  (ft - 1, rt - 1);

        const QChar moving   = tokenToOneChar(fromTok);
        const QChar captured = tokenToOneChar(toTok);

        out.push_back(ShogiMove(from, to, moving, captured, isProm));
        tracer.applyUsiMove(usi);
    }

    return out;
}

// ========== 既存補助の移設（MainWindow / KifuLoadCoordinator からの共通化） ==========

int SfenPositionTracer::rankLetterToNum(QChar r) { // 'a'..'i' -> 1..9
    const ushort u = r.toLower().unicode();
    return (u < 'a' || u > 'i') ? -1 : int(u - 'a') + 1;
}

QPoint SfenPositionTracer::dropFromSquare(QChar dropUpper, bool black) {
    const int x = black ? 9 : 10; // 先手=9, 後手=10（UI内の「駒台」側レーン）
    int y = -1;
    switch (dropUpper.toUpper().unicode()) {
    case 'P': y = black ? 0 : 8; break;
    case 'L': y = black ? 1 : 7; break;
    case 'N': y = black ? 2 : 6; break;
    case 'S': y = black ? 3 : 5; break;
    case 'G': y = 4;            break; // 金だけ共通
    case 'B': y = black ? 5 : 3; break;
    case 'R': y = black ? 6 : 2; break;
    default:  y = -1;           break;
    }
    return QPoint(x, y);
}

QChar SfenPositionTracer::dropLetterWithSide(QChar upper, bool black) {
    return black ? upper.toUpper() : upper.toLower();
}

QChar SfenPositionTracer::tokenToOneChar(const QString& tok) {
    if (tok.isEmpty()) return QLatin1Char(' ');
    if (tok.size() == 1) return tok.at(0);
    static const QHash<QString,QChar> map = {
                                              {"+P",'Q'},{"+L",'M'},{"+N",'O'},{"+S",'T'},{"+B",'C'},{"+R",'U'},
                                              {"+p",'q'},{"+l",'m'},{"+n",'o'},{"+s",'t'},{"+b",'c'},{"+r",'u'},
                                              };
    const auto it = map.find(tok);
    return it == map.end() ? QLatin1Char(' ') : *it;
}
#include "shogiboard.h"
#include "qdebug.h"

// 将棋盤に関するクラス
// コンストラクタ
ShogiBoard::ShogiBoard(int ranks, int files, QObject *parent)
    : QObject(parent), m_ranks(ranks), m_files(files)
{
    // 将棋盤の81マスに空白を代入する。
    initBoard();

    // 駒台の各駒の数を全て0にする。
    initStand();
}

// 指定した位置の駒を表す文字を返す。
// file: 筋（1〜9は盤上、10と11は先手と後手の駒台）
// rank: 段（先手は1〜7「歩、香車、桂馬、銀、金、角、飛車」、後手は3〜9「飛車、角、金、銀、桂馬、香車、歩」を使用）
QChar ShogiBoard::getPieceCharacter(const int file, const int rank)
{
    static const QMap<int, QChar> pieceMapBlack = {{1,'P'},{2,'L'},{3,'N'},{4,'S'},{5,'G'},{6,'B'},{7,'R'},{8,'K'}};
    static const QMap<int, QChar> pieceMapWhite = {{2,'k'},{3,'r'},{4,'b'},{5,'g'},{6,'s'},{7,'n'},{8,'l'},{9,'p'}};

    if (file >= 1 && file <= 9) {
        return m_boardData.at((rank - 1) * files() + (file - 1));
    } else if (file == 10) {
        const auto it = pieceMapBlack.find(rank);
        if (it != pieceMapBlack.end()) return it.value();

        const QString errorMessage =
            tr("An error occurred in ShogiBoard::getPieceCharacter. Invalid rank for the black player's stand.");
        qDebug() << "rank:" << rank;
        emit errorOccurred(errorMessage);
        return QChar(); // ★ 打ち切り
    } else if (file == 11) {
        const auto it = pieceMapWhite.find(rank);
        if (it != pieceMapWhite.end()) return it.value();

        const QString errorMessage =
            tr("An error occurred in ShogiBoard::getPieceCharacter. Invalid rank for the white player's stand.");
        qDebug() << "rank:" << rank;
        emit errorOccurred(errorMessage);
        return QChar(); // ★ 打ち切り
    } else {
        const QString errorMessage =
            tr("An error occurred in ShogiBoard::getPieceCharacter. Invalid file value.");
        qDebug() << "file:" << file;
        emit errorOccurred(errorMessage);
        return QChar(); // ★ 打ち切り
    }
}

// 将棋盤のマスに駒を配置する。
// file 筋、rank 段で指定されたマスに駒文字pieceをセットする。
void ShogiBoard::setData(const int file, const int rank, const QChar piece)
{
    // file 筋、rank 段で指定されたマスに駒文字pieceをセットする。
    if (setDataInternal(file, rank, piece)) {
        // ShogiView::setBoardのconnectで使用されているシグナル
        // スロットのrepaint関数が実行される。（将棋盤、駒台の再描画）
        emit dataChanged(file, rank);
    }
}

// 駒を指定したマスへ移動する。配置データのみを更新する。
// 駒を指定したマスへ移動する。配置データのみを更新する。
// ★編集局面でも使用されるため、歩/桂/香の禁置き段では自動で成駒に置き換える（必成）。
void ShogiBoard::movePieceToSquare(QChar selectedPiece, const int fileFrom, const int rankFrom,
                                   const int fileTo, const int rankTo, const bool promote)
{
    auto promotedOf = [](QChar p)->QChar {
        static const QMap<QChar, QChar> promoteMap = {
            {'P','Q'},{'L','M'},{'N','O'},{'S','T'},{'B','C'},{'R','U'},
            {'p','q'},{'l','m'},{'n','o'},{'s','t'},{'b','c'},{'r','u'}
        };
        return promoteMap.contains(p) ? promoteMap[p] : p;
    };

    // 1) 「成る」指定が来ていれば、先に成駒へ
    if (promote) {
        selectedPiece = promotedOf(selectedPiece);
    }

    // 2) 元位置を空白に
    if ((fileFrom >= 1) && (fileFrom <= 9)) {
        setData(fileFrom, rankFrom, ' ');
    }

    // 3) まず素の駒を置く（盤上のみ）
    if ((fileTo >= 1) && (fileTo <= 9)) {
        setData(fileTo, rankTo, selectedPiece);

        // 4) 置いた結果に対して「必成」補正（歩/桂/香）
        QChar placed = getPieceCharacter(fileTo, rankTo);

        // 先手の必成
        if (placed == 'P' && rankTo == 1) {
            setData(fileTo, rankTo, 'Q'); // 先手歩 → と金
        } else if (placed == 'L' && rankTo == 1) {
            setData(fileTo, rankTo, 'M'); // 先手香 → 成香
        } else if (placed == 'N' && (rankTo == 1 || rankTo == 2)) {
            setData(fileTo, rankTo, 'O'); // 先手桂 → 成桂
        }
        // 後手の必成
        else if (placed == 'p' && rankTo == 9) {
            setData(fileTo, rankTo, 'q'); // 後手歩 → と金
        } else if (placed == 'l' && rankTo == 9) {
            setData(fileTo, rankTo, 'm'); // 後手香 → 成香
        } else if (placed == 'n' && (rankTo == 8 || rankTo == 9)) {
            setData(fileTo, rankTo, 'o'); // 後手桂 → 成桂
        }
    }
}

// 将棋盤の81マスに空白を代入する。
void ShogiBoard::initBoard()
{
    m_boardData.fill(' ', ranks() * files());
}

// 駒台の各駒の数を全て0にする。
void ShogiBoard::initStand()
{
    // 持ち駒情報を全て初期化
    m_pieceStand.clear();

    // 駒のキーのリスト
    static const QList<QChar> pieces = {'p', 'l', 'n', 's', 'g', 'b', 'r', 'k',
                                        'P', 'L', 'N', 'S', 'G', 'B', 'R', 'K'};

    // 各駒をQMapに挿入
    // 全ての持ち駒の枚数を0にする。
    for (const QChar& piece : pieces) {
        m_pieceStand.insert(piece, 0);
    }
}

// 将棋盤のマスに駒を配置する。
bool ShogiBoard::setDataInternal(const int file, const int rank, const QChar piece)
{
    // マス番号を計算する。
    int index = (rank - 1) * files() + (file - 1);

    // マスの駒文字が一致する場合は何もせずにfalseを返す。
    if (m_boardData.at(index) == piece) return false;

    // マスの駒文字を設定する。
    m_boardData[index] = piece;

    // trueを返す。
    return true;
}

// 将棋盤内のデータ（81マスの駒文字情報）を返す。
const QVector<QChar>& ShogiBoard::boardData() const
{
    return m_boardData;
}

// 駒台のデータ（駒台の各駒の枚数情報）を返す。
const QMap<QChar, int>& ShogiBoard::getPieceStand() const
{
    return m_pieceStand;
}

// 将棋盤内のみのSFEN文字列を入力し、エラーチェックを行い、成り駒を1文字に変換したSFEN文字列を返す。
QString ShogiBoard::validateAndConvertSfenBoardStr(QString initialSfenStr)
{
    // 成り駒文字列
    const QStringList promotions = {"+P", "+L", "+N", "+S", "+B", "+R",
                                    "+p", "+l", "+n", "+s", "+b", "+r"};

    // 成り駒変換文字
    const QString replacements = "QMOTCUqmotcu";

    // SFEN文字列中の成り駒を1文字に変換する。
    for (int i = 0; i < promotions.size(); ++i) {
        initialSfenStr.replace(promotions[i], replacements[i]);
    }

    QStringList sfenParts = initialSfenStr.split("/");

    if (sfenParts.size() != 9) {
        // SFEN文字列は正確に9つの部分を含んでいる必要がある。
        const QString errorMessage = tr("An error occurred in ShogiBoard::validateAndConvertSfenBoardStr. SFEN string must contain exactly 9 parts.");

        qDebug() << "initialSfenStr: " << initialSfenStr;
        emit errorOccurred(errorMessage);
        return QString(); // ★ 打ち切り
    }

    // 各段に配置可能な駒のリスト
   static  const QStringList pieces[9] = {
        {"S", "G", "B", "R", "K", "Q", "M", "O", "T", "C", "U", "p", "l", "n", "s", "g", "b", "r", "k", "q", "m", "o", "t", "c", "u"},  // 1
        {"P", "L", "S", "G", "B", "R", "K", "Q", "M", "O", "T", "C", "U", "p", "l", "n", "s", "g", "b", "r", "k", "q", "m", "o", "t", "c", "u"},  // 2
        {"P", "L", "N", "S", "G", "B", "R", "K", "Q", "M", "O", "T", "C", "U", "p", "l", "n", "s", "g", "b", "r", "k", "q", "m", "o", "t", "c", "u"},  // 3
        {"P", "L", "N", "S", "G", "B", "R", "K", "Q", "M", "O", "T", "C", "U", "p", "l", "n", "s", "g", "b", "r", "k", "q", "m", "o", "t", "c", "u"},  // 4
        {"P", "L", "N", "S", "G", "B", "R", "K", "Q", "M", "O", "T", "C", "U", "p", "l", "n", "s", "g", "b", "r", "k", "q", "m", "o", "t", "c", "u"},  // 5
        {"P", "L", "N", "S", "G", "B", "R", "K", "Q", "M", "O", "T", "C", "U", "p", "l", "n", "s", "g", "b", "r", "k", "q", "m", "o", "t", "c", "u"},  // 6
        {"P", "L", "N", "S", "G", "B", "R", "K", "Q", "M", "O", "T", "C", "U", "p", "l", "n", "s", "g", "b", "r", "k", "q", "m", "o", "t", "c", "u"},  // 7
        {"P", "L", "N", "S", "G", "B", "R", "K", "Q", "M", "O", "T", "C", "U", "p", "l", "s", "g", "b", "r", "k", "q", "m", "o", "t", "c", "u"},  // 8
        {"P", "L", "N", "S", "G", "B", "R", "K", "Q", "M", "O", "T", "C", "U", "s", "g", "b", "r", "k", "q", "m", "o", "t", "c", "u"}   // 9
    };

    for (int i = 0; i < 9; ++i) {
        QString rankStr = sfenParts.at(i);
        int pieceCount = 0;
        for (QChar ch : rankStr) {
            if (ch.isDigit()) {
                pieceCount += ch.digitValue();
            } else if (pieces[i].contains(ch)) {
                ++pieceCount;
            } else {
                // SFEN文字列内に予期しない文字がある。
                const QString errorMessage = tr("An error occurred in ShogiBoard::validateAndConvertSfenBoardStr. Unexpected character in SFEN string.");

                // エラーメッセージを表示する。
                qDebug() << "sfenStr: " << initialSfenStr;
                qDebug() << "i: " << i;
                qDebug() << "rankStr: " << rankStr;
                qDebug() << "ch: " << ch;

                emit errorOccurred(errorMessage);
                return QString(); // ★ 打ち切り
            }
        }

        if (pieceCount != 9) {
            // 各段は正確に9個の駒または空マスを含む必要がある。
            const QString errorMessage = tr("An error occurred in ShogiBoard::validateAndConvertSfenBoardStr. Each rank must contain exactly 9 pieces or empty squares.");

            // エラーメッセージを表示する。
            qDebug() << "sfenStr: " << initialSfenStr;
            qDebug() << "pieceCount: " << pieceCount;

            emit errorOccurred(errorMessage);
            return QString(); // ★ 打ち切り
        }
    }

    return initialSfenStr;
}

// SFEN文字列の持ち駒部分の文字列を入力して、持ち駒を表す配列に各駒の枚数をセットする。
void ShogiBoard::setPieceStandFromSfen(const QString& str)
{
    // 初期化時にすべての持ち駒を0にする。
    initStand();

    // 持ち駒なしの場合は何もせずに関数を終了する。
    if (str == "-") return;

    // スペースが含まれている場合はエラーをスローする。
    if (str.contains(' ')) {
        // 持ち駒の文字列にスペースが含まれている。
        const QString errorMessage = tr("An error occurred in ShogiBoard::setPieceStandFromSFEN. The piece stand string contains a space.");

        // エラーメッセージを表示する。
        qDebug() << "str: " << str;

        emit errorOccurred(errorMessage);
        return; // ★ 打ち切り
    }

    // 2桁の数字が含まれているかどうかを示すフラグ
    bool isTwoDigits = false;

    // 持ち駒の文字列を解析し、駒台の駒の数を更新する。
    // 文字列を1文字ずつ調べるループ
    for (int i = 0; i < str.length(); ++i) {
        // 文字が数字の場合
        if (str[i].isDigit()) {
            // 2桁の数字の場合
            if (isTwoDigits) {
                // 次の文字のインデックスが文字列の長さ未満であることを確認し、範囲外アクセスを防ぐ。
                // また、次の文字が有効な駒の種類を表しているかどうかを確認する。
                if (i + 1 < str.length() && m_pieceStand.contains(str[i + 1])) {
                    // str[i - 1]は10の位の数でとstr[i]は1の位の数なのでそれらを1つの数字に変換する。
                    int twoDigits = 10 * str[i - 1].digitValue() + str[i].digitValue();

                    // 次の文字（駒の種類）を取得する。
                    QChar pieceType = str[i + 1];

                    // 取得した駒の種類に対して持ち駒の数を加算する。
                    m_pieceStand[pieceType] += twoDigits;

                    // 数字と駒のタイプを表す2文字を処理したので、次の文字へインデックスを進める。
                    ++i;

                    // 2桁の数字のフラグを無効にする。
                    isTwoDigits = false;
                }
                // 数字の次に有効な駒が来ていない場合、例外を投げる。
                else {
                    // 数字の後に無効な駒が指定されている。
                    const QString errorMessage = tr("An error occurred in ShogiBoard::setPieceStandFromSFEN. Invalid piece type after number.");

                    // エラーメッセージを表示する。
                    qDebug() << "str: " << str;
                    qDebug() << "i: " << i;
                    qDebug() << "str[i]: " << str[i];

                    emit errorOccurred(errorMessage);
                    return; // ★ 打ち切り
                }
            }
            else {
                // 次の文字のインデックスが文字列の長さ未満であることを確認し、範囲外アクセスを防ぐ。
                // また、次の文字が有効な駒の種類を表しているかどうかを確認する。
                if (i + 1 < str.length() && m_pieceStand.contains(str[i + 1])) {
                    // 現在の数字を整数値に変換する、
                    int count = str[i].digitValue();

                    // 次の文字（駒の種類）を取得する。
                    QChar pieceType = str[i + 1];

                    // 取得した駒の種類に対して持ち駒の数を加算する。
                    m_pieceStand[pieceType] += count;

                    // 数字と駒のタイプを表す2文字を処理したので、次の文字へインデックスを進める。
                    ++i;
                }
                // 数字の次も数字の場合
                else if (str[i+1].isDigit()) {
                    // 2桁の数字であることを示すフラグを有効にする。
                    isTwoDigits = true;
                }
                // 数字の次に有効な駒が来ていない場合、例外を投げる。
                else {
                    // 数字の後に無効な駒が指定されている。
                    const QString errorMessage = tr("An error occurred in ShogiBoard::setPieceStandFromSFEN. Invalid piece type after number.");

                    // エラーメッセージを表示する。
                    qDebug() << "str: " << str;
                    qDebug() << "i: " << i;
                    qDebug() << "str[i]: " << str[i];

                    emit errorOccurred(errorMessage);
                    return; // ★ 打ち切り
                }
            }
        }
         // 現在の文字が駒の種類を直接表している場合（数字が前にない場合は1枚と数える。）
        else if (m_pieceStand.contains(str[i])) {
            m_pieceStand[str[i]] += 1;
        }
         // 有効な駒でも数字でもない不正な文字が含まれている場合、例外を投げる。
        else {
            // 無効な駒が含まれている。
            const QString errorMessage = tr("An error occurred in ShogiBoard::setPieceStandFromSFEN. Invalid piece type in piece stand string.");

            // エラーメッセージを表示する。
            qDebug() << "str: " << str;

            emit errorOccurred(errorMessage);
            return; // ★ 打ち切り
        }
    }
}

// SFEN文字列から将棋盤内に駒を配置する。
void ShogiBoard::setPiecePlacementFromSfen(QString& initialSfenStr)
{
    // 将棋盤内のみのSFEN文字列を入力し、エラーチェックを行い、成り駒を1文字に変換したSFEN文字列を返す。
    QString sfenStr = validateAndConvertSfenBoardStr(initialSfenStr);

    // SFEN文字列のインデックス
    int strIndex = 0;

    // 空白マスの数
    int emptySquares = 0;

    // 筋の数、すなわち9
    const int fileCount = files();

    // 駒文字
    QChar pieceChar;

    // 段
    for (int rank = 1; rank <= ranks(); ++rank) {
        // 筋
        for (int file = fileCount; file > 0; --file) {
            // 空白マスの数が0より大きい場合
            if (emptySquares > 0) {
                // 現在のマスの駒文字を空白に設定する。
                pieceChar = ' ';

                // 空白マスの数を1減らす。
                emptySquares--;
            }
            // 空白マスの数が0以下のの場合
            else {
                // SFEN文字列から駒文字を取得する。
                pieceChar = sfenStr.at(strIndex++);

                // 駒文字が数字の場合
                if (pieceChar.isDigit()) {
                    // 数字を整数に変換し、空白マスの数として設定する。
                    emptySquares = pieceChar.toLatin1() - '0';

                    // 現在のマスの駒文字を空白に設定する。
                    pieceChar = ' ';

                    // 空白マスの数を1減らす。
                    emptySquares--;
                }
            }
            // 指定したマスに駒を配置する。
            setDataInternal(file, rank, pieceChar.toLatin1());
        }

        // SFEN文字列のインデックスを進める。
        strIndex++;
    }
}

// SFEN文字列を入力し、エラーチェックを行い、次の手番、次の手が何手目かを取得する。
void ShogiBoard::validateSfenString(const QString& sfenStr, QString& sfenBoardStr, QString& sfenStandStr)
{
    QStringList sfenComponents = sfenStr.split(" ");

    if (sfenComponents.size() != 4) {
        // SFEN文字列は正確に3つのスペースで区切る必要がある。
        const QString errorMessage = tr("An error occurred in ShogiBoard::validateSfenString. SFEN string must be separated by exactly 3 spaces.");

        // エラーメッセージを表示する。
        qDebug() << "sfenStr: " << sfenStr;
        qDebug() << "sfenComponents.size(): " << sfenComponents.size();

        emit errorOccurred(errorMessage);
        return; // ★ 打ち切り
    }

    // 将棋盤内のみのSFEN文字列を取得する。
    sfenBoardStr = sfenComponents.at(0);

    // 先手あるいは下手"b"、後手あるいは上手"w"の指定を取得する。
    QString playerTurnStr = sfenComponents.at(1);

    // 手番の指定が"b"または"w"のいずれかである場合
    if (playerTurnStr == "b" || playerTurnStr == "w") {
        // 現在の手番を設定する。
        m_currentPlayer = playerTurnStr;
    }
    // それ以外の場合
    else {
        // SFEN文字列は先手あるいは下手"b"または後手あるいは上手"w"の指定が必要
        const QString errorMessage = tr("An error occurred in ShogiBoard::validateSfenString. SFEN string must specify either black 'b' or white 'w'.");

        // エラーメッセージを表示する。
        qDebug() << "sfenStr: " << sfenStr;
        qDebug() << "playerTurnStr: " << playerTurnStr;

        emit errorOccurred(errorMessage);
        return; // ★ 打ち切り
    }

    // 持ち駒のSFEN文字列を取得する。
    sfenStandStr = sfenComponents.at(2);

    // 次の手が何手目かを取得できたかどうかを返すフラグ
    bool conversionSuccessful;

    // 次の手が何手目かを取得する。
    m_currentMoveNumber = sfenComponents.at(3).toInt(&conversionSuccessful);

    // 次の手が何手目かを取得できない場合、または次の手が何手目かが負の整数の場合
    if (!conversionSuccessful || m_currentMoveNumber <= 0) {
        // SFEN文字列の最後の部分は正の整数（次の手が何手目かを示す）である必要がある。
        const QString errorMessage = tr("An error occurred in ShogiBoard::validateSfenString. The last part of the SFEN string must be a positive integer (indicating the next move number).");

        // エラーメッセージを表示する。
        qDebug() << "sfenStr: " << sfenStr;

        emit errorOccurred(errorMessage);
        return; // ★ 打ち切り
    }
}

// 将棋盤と駒台を含むSFEN文字列で将棋盤全体を更新する場合、この関数を使う。
// 将棋盤に入力で渡されるsfen形式の文字列に文法的に誤りが無いかチェックする。
// 将棋盤と駒台のSFEN文字列を指定して将棋盤と駒台の駒の更新を行い、再描画する。
// 入力は、将棋盤と駒台を含むSFEN文字列
void ShogiBoard::setSfen(const QString& sfenStr)
{
    {
        const QString preview = (sfenStr.size() > 200) ? sfenStr.left(200) + " ..." : sfenStr;
        qInfo().noquote() << "[BOARD] setSfen: " << preview;
        if (sfenStr.startsWith(QLatin1String("position "))) {
            qWarning() << "[BOARD] *** NON-SFEN passed to setSfen (caller bug)";
            // ここで return せず敢えて続行すると、後段で assert になる可能性あり
            // 原因究明中はログ優先でOK。必要なら早期 return してクラッシュを防ぐのも手。
        }
    }

    // 例．
    // "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1"の
    // "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL"の文字列
    QString sfenBoardStr;

    // sfen形式の文字列の持ち駒部分
    QString sfenStandStr;

    // SFEN文字列に以下のチェックを行い、将棋盤内の文字列sfenStr0と
    // 駒台の文字列sfenStr2を取得する。
    // SFEN文字列にスペース文字が3個含まれているか。
    // SFEN文字列に先手、後手の指定があるか。
    // SFEN文字列に次の手が何手目かの指定があるか。
    validateSfenString(sfenStr, sfenBoardStr, sfenStandStr);

    // sfen文字列から将棋盤内に駒を配置する。
    // m_boardDataに駒文字をセットする。
    // 入力は、将棋盤内のみのSFEN文字列
    // 将棋盤内のみのSFEN文字列のチェックも最初に行う。
    setPiecePlacementFromSfen(sfenBoardStr);

    // SFEN文字列の持ち駒部分の文字列を入力して、持ち駒を表す配列に各駒の枚数をセットする。
    // 駒台の各持ち駒の枚数をカウントし、m_pieceStandにセットする。
    // 入力は、持ち駒のSFEN文字列
    // 持ち駒部分のSFEN文字列のチェックも行う。
    setPieceStandFromSfen(sfenStandStr);

    // ShogiView::setBoardのconnectで使用されているシグナル
    // スロットのrepaint関数が実行される。（将棋盤、駒台の再描画）
    emit boardReset();
}

// 成り駒の文字をSFEN形式の駒文字列に変換する。
QString ShogiBoard::convertPieceToSfen(const QChar piece) const
{
    // 駒文字をSFEN形式の駒文字に変換するためのマップ
    static const QMap<QChar, QString> sfenMap = {{'Q', "+P"}, {'M', "+L"}, {'O', "+N"}, {'T', "+S"},
                                                 {'C', "+B"}, {'U', "+R"}, {'q', "+p"}, {'m', "+l"},
                                                 {'o', "+n"}, {'t', "+s"}, {'c', "+b"}, {'u', "+r"}};

    // 該当する成り駒がある場合、SFEN形式の駒文字を返す。
    return sfenMap.contains(piece) ? sfenMap.value(piece) : QString(piece);
}

// 盤面をSFEN形式へ変換する。
QString ShogiBoard::convertBoardToSfen()
{
    // SFEN形式文字列
    QString str = "";

    // 段
    for (int rank = 1; rank <= ranks(); ++rank) {
        // 空白文字のカウンタ
        int spacecount = 0;
        // 筋
        for (int file = files(); file > 0; --file) {
            // 駒文字
            QChar piece = getPieceCharacter(file, rank);

            // 駒文字が空白の場合
            if (piece == ' ') {
                // 空白文字のカウントに1を足す。
                spacecount++;

                // 空白文字のカウンタが9、あるいは1筋の場合
                if (spacecount == 9 || file == 1) {
                    // 空白文字のカウンタを文字列に変換し、SFEN形式文字列に連結する。
                    str += QString::number(spacecount);
                }
            }
            // 駒文字が空白文字以外の場合
            else {
                // 空白文字のカウンタが0より大きい場合
                if (spacecount > 0) {
                    // 空白文字のカウンタを文字列に変換し、SFEN形式文字列に連結する。
                    str += QString::number(spacecount);

                    // 空白文字のカウンタを0にリセットする。
                    spacecount = 0;
                }

                // 駒文字をSFEN形式文字列に連結する。
                str += convertPieceToSfen(piece);
            }
        }

        // 9筋以外の場合、"/"をSFEN形式文字列に連結する。
        if (rank != 9) str += "/";
    }

    // SFEN形式文字列を返す。
    return str;
}

// 駒台の駒数をSFEN形式へ変換する。
QString ShogiBoard::convertStandToSfen() const
{
    // 持ち駒のSFEN形式文字列
    QString handPiece = "";

    // 駒文字のリスト
    QList<QChar> keys = {'R', 'B', 'G', 'S', 'N', 'L', 'P'};

    // 駒文字のリストを走査し、持ち駒のSFEN形式文字列を作成する。
    for(const auto& key : keys) {
        // 先手または下手
        // 駒文字に該当する駒数を取得する。
        int value = m_pieceStand.value(key, 0);

        // 駒数が1以上の場合
        if (value > 0) {
            // 駒数が1より大きい場合、駒数を文字列に変換し、SFEN形式文字列に連結する。
            handPiece += (value > 1 ? QString::number(value) : "") + convertPieceToSfen(key);
        }

        // 後手または上手
        // 駒文字に該当する駒数を取得する。
        value = m_pieceStand.value(key.toLower(), 0);

        // 駒数が1以上の場合
        if (value > 0) {
            // 駒数が1より大きい場合、駒数を文字列に変換し、SFEN形式文字列に連結する。
            handPiece += (value > 1 ? QString::number(value) : "") + convertPieceToSfen(key.toLower());
        }
    }

    // 持ち駒のSFEN形式文字列を返す。
    // 持ち駒がない場合は"-"を返す。
    return handPiece.isEmpty() ? "-" : handPiece;
}

// src/core/shogiboard.cpp
#include <QDebug>

void ShogiBoard::addSfenRecord(const QString& nextTurn, int moveIndex, QStringList* sfenRecord)
{
    if (!sfenRecord) {
        qDebug() << "[SFEN][add] sfenRecord is null";
        return;
    }

    // moveIndex: 0 始まりの着手番号を想定
    //   通常記録     → +1 で手数フィールドへ
    //   特例(-1等)   → 1 を明示（開始直後など）
    const int moveCountField = (moveIndex < 0) ? 1 : (moveIndex + 1);

    const int before = sfenRecord->size();
    const QString boardSfen = convertBoardToSfen();
    QString stand = convertStandToSfen();
    if (stand.isEmpty()) stand = QStringLiteral("-");

    qDebug().noquote() << "[SFEN][add] BEFORE size=" << before
                       << " rec*=" << static_cast<const void*>(sfenRecord)
                       << " nextTurn=" << nextTurn
                       << " moveIndex=" << moveIndex
                       << " => field=" << moveCountField;
    qDebug().noquote() << "[SFEN][add] board=" << boardSfen << " stand=" << stand;

    const QString sfen = QStringLiteral("%1 %2 %3 %4")
                             .arg(boardSfen, nextTurn, stand, QString::number(moveCountField));
    sfenRecord->append(sfen);

    qDebug().noquote() << "[SFEN][add] AFTER  size=" << sfenRecord->size()
                       << " appended=" << sfen;

    if (!sfenRecord->isEmpty()) {
        // head / tail を直接出す（std::min は使わない）
        qDebug().noquote() << "[SFEN][add] head[0]=" << sfenRecord->first();
        qDebug().noquote() << "[SFEN][add] tail[last]=" << sfenRecord->last();
    }

    // 先頭が破壊されてないか簡易チェック
    if (!sfenRecord->isEmpty()) {
        const QStringList parts = sfenRecord->first().split(QLatin1Char(' '), Qt::KeepEmptyParts);
        if (parts.size() == 4) {
            const QString turn0 = parts[1];
            const QString move0 = parts[3];
            if (move0 != QLatin1String("1")) {
                qDebug().noquote() << "[WARN][SFEN][add] head[0] moveCount != 1  head=" << sfenRecord->first();
            }
            if (turn0 != QLatin1String("b") && turn0 != QLatin1String("w")) {
                qDebug().noquote() << "[WARN][SFEN][add] head[0] turn invalid  head=" << sfenRecord->first();
            }
        } else {
            qDebug().noquote() << "[WARN][SFEN][add] head[0] malformed  head=" << sfenRecord->first();
        }
    }
}

// 局面編集中に右クリックで成駒/不成駒/先後を巡回変換する（禁置き段＋二歩をスキップ）。
void ShogiBoard::promoteOrDemotePiece(const int fileFrom, const int rankFrom)
{
    auto nextInCycle = [](const QVector<QChar>& cyc, QChar cur)->QChar {
        int idx = cyc.indexOf(cur);
        if (idx < 0) return cur;
        return cyc[(idx + 1) % cyc.size()];
    };

    const auto lanceCycle  = QVector<QChar>{'L','M','l','m'}; // 香 → 成香 → 相手香 → 相手成香
    const auto knightCycle = QVector<QChar>{'N','O','n','o'}; // 桂 → 成桂 → 相手桂 → 相手成桂
    const auto silverCycle = QVector<QChar>{'S','T','s','t'};
    const auto bishopCycle = QVector<QChar>{'B','C','b','c'};
    const auto rookCycle   = QVector<QChar>{'R','U','r','u'};
    const auto pawnCycle   = QVector<QChar>{'P','Q','p','q'}; // 歩 → と金 → 相手歩 → 相手と金

    const QChar cur = getPieceCharacter(fileFrom, rankFrom);
    QVector<QChar> base;
    switch (cur.unicode()) {
    case 'L': case 'M': case 'l': case 'm': base = lanceCycle;  break;
    case 'N': case 'O': case 'n': case 'o': base = knightCycle; break;
    case 'S': case 'T': case 's': case 't': base = silverCycle; break;
    case 'B': case 'C': case 'b': case 'c': base = bishopCycle; break;
    case 'R': case 'U': case 'r': case 'u': base = rookCycle;   break;
    case 'P': case 'Q': case 'p': case 'q': base = pawnCycle;   break;
    default:
        return; // 金・玉などは変換対象外
    }

    const bool onBoard = (fileFrom >= 1 && fileFrom <= 9);

    // 段による不成禁止（必成）を判定
    auto isRankDisallowed = [&](QChar piece)->bool {
        if (!onBoard) return false;
        // 先手側
        if (piece == 'L' && rankFrom == 1) return true;
        if (piece == 'N' && (rankFrom == 1 || rankFrom == 2)) return true;
        if (piece == 'P' && rankFrom == 1) return true;
        // 後手側
        if (piece == 'l' && rankFrom == 9) return true;
        if (piece == 'n' && (rankFrom == 8 || rankFrom == 9)) return true;
        if (piece == 'p' && rankFrom == 9) return true;
        return false;
    };

    // 二歩禁止：その筋に別の同側の“歩（不成）”が既にあるなら P/p は不可
    auto isNiFuDisallowed = [&](QChar candidate)->bool {
        if (!onBoard) return false;
        if (candidate != 'P' && candidate != 'p') return false;
        for (int r = 1; r <= 9; ++r) {
            if (r == rankFrom) continue; // 自マスは除外
            const QChar pc = getPieceCharacter(fileFrom, r);
            if (candidate == 'P' && pc == 'P') return true; // 同筋に先手歩
            if (candidate == 'p' && pc == 'p') return true; // 同筋に後手歩
        }
        return false;
    };

    auto isDisallowed = [&](QChar piece)->bool {
        return isRankDisallowed(piece) || isNiFuDisallowed(piece);
    };

    // 禁止形は巡回列から除外（= 自動スキップ）
    QVector<QChar> filtered;
    filtered.reserve(base.size());
    for (QChar p : base) {
        if (!isDisallowed(p)) filtered.push_back(p);
    }
    if (filtered.isEmpty()) return;

    // 現在形が filtered 外（既に禁止形）なら、base を回して最初の許可形へジャンプ
    QChar next = cur;
    if (filtered.indexOf(cur) < 0) {
        QChar probe = cur;
        for (int i = 0; i < base.size(); ++i) {
            probe = nextInCycle(base, probe);
            if (filtered.indexOf(probe) >= 0) { next = probe; break; }
        }
    } else {
        // 通常：filtered 内で次へ
        int idx = filtered.indexOf(cur);
        next = filtered[(idx + 1) % filtered.size()];
    }

    setData(fileFrom, rankFrom, next);
}

// 手番の持ち駒を出力する。
void ShogiBoard::printPlayerPieces(const QString& player, const QString& pieceSet) const
{
    // 駒文字と漢字表記のマップ
    static const QMap<QChar, QString> pieceNames = {
        {'K', "玉"}, {'R', "飛"}, {'B', "角"}, {'G', "金"}, {'S', "銀"}, {'N', "桂"}, {'L', "香"}, {'P', "歩"},
        {'k', "玉"}, {'r', "飛"}, {'b', "角"}, {'g', "金"}, {'s', "銀"}, {'n', "桂"}, {'l', "香"}, {'p', "歩"}
    };

    qDebug() << player << "の持ち駒";

    // 駒文字のリストを走査し、持ち駒の枚数を出力する。
    for (const QChar& piece : pieceSet) {
        qDebug() << pieceNames[piece] << " " << m_pieceStand[piece];
    }
}

// 持ち駒を出力する。
void ShogiBoard::printPieceStand()
{
    printPlayerPieces("先手", "KRGBSNLP");
    printPlayerPieces("後手", "krgbsnlp");
}

// 駒の文字を変換する。成駒は相手の駒になるように、大文字を小文字に、小文字を大文字に変換する。
QChar ShogiBoard::convertPieceChar(const QChar c) const
{
    // 駒文字の変換マップ
    static const QMap<QChar, QChar> conversionMap = {
        {'Q', 'p'}, {'M', 'l'}, {'O', 'n'}, {'T', 's'}, {'C', 'b'}, {'U', 'r'},
        {'q', 'P'}, {'m', 'L'}, {'o', 'N'}, {'t', 'S'}, {'c', 'B'}, {'u', 'R'}
    };

    // 変換マップに含まれている場合、変換した文字を返す。
    if (conversionMap.contains(c)) {
        return conversionMap.value(c);
    }

    // それ以外の場合、大文字を小文字に、小文字を大文字に変換して返す。
    return c.isUpper() ? c.toLower() : c.toUpper();
}

// 指したマスが将棋盤内で相手の駒があった場合、自分の駒台の枚数に1加える。
void ShogiBoard::addPieceToStand(QChar dest)
{
    // 駒の文字を変換する。成駒は相手の駒になるように、大文字を小文字に、小文字を大文字に変換する。
    QChar pieceChar = convertPieceChar(dest);

    // 駒台の該当する駒の数を1増やす。
    if (m_pieceStand.contains(pieceChar)) {
            m_pieceStand[pieceChar]++;
    }
}

// 駒台から駒を指した場合、駒台の駒の枚数を1減らす。
void ShogiBoard::decrementPieceOnStand(QChar source)
{
    // 駒が駒台に存在するか確認する。
    if (m_pieceStand.contains(source)) {
        // 駒の数を1減らす。
        m_pieceStand[source]--;
    }
}

// 駒台から指そうとした場合、駒台の駒数が0以下の時は、駒台の駒は無いので指せない。
bool ShogiBoard::isPieceAvailableOnStand(const QChar source, const int fileFrom) const
{
    // 駒台から指そうとした場合
    if (fileFrom == 10 || fileFrom == 11) {
        // 駒が駒台に存在し、その数が0より大きいかを確認する。
        if (m_pieceStand.contains(source) && m_pieceStand[source] > 0) {
            // 駒が存在し、その数が0より大きい場合、指せる。
            return true;
        }
        // それ以外は指せない。
        else {
            return false;
        }
    }
    // 盤内から指そうとした場合、チェック範囲外のため、指せる。
    else {
        // 指せる。
        return true;
    }
}

// 成駒を元の駒に変換する。
QChar ShogiBoard::convertPromotedPieceToOriginal(const QChar dest) const
{
    // 成駒を元の駒に変換するマップ
    static const QMap<QChar, QChar> promotedToOriginalMap = {
        {'Q', 'P'}, // 先手のと金 -> 先手の歩
        {'M', 'L'}, // 先手の成香 -> 先手の香車
        {'O', 'N'}, // 先手の成桂 -> 先手の桂馬
        {'T', 'S'}, // 先手の成銀 -> 先手の銀
        {'C', 'B'}, // 先手の馬 -> 先手の角
        {'U', 'R'}, // 先手の龍 -> 先手の飛車
        {'q', 'p'}, // 後手のと金 -> 後手の歩
        {'m', 'l'}, // 後手の成香 -> 後手の香車
        {'o', 'n'}, // 後手の成桂 -> 後手の桂馬
        {'t', 's'}, // 後手の成銀 -> 後手の銀
        {'c', 'b'}, // 後手の馬 -> 後手の角
        {'u', 'r'}  // 後手の龍 -> 後手の飛車
    };

    return promotedToOriginalMap.value(dest, dest);
}

// 自分の駒台に駒を置いた場合、自分の駒台の枚数に1加える。
void ShogiBoard::incrementPieceOnStand(const QChar dest)
{
    // 成駒を元の駒に変換
    QChar originalPiece = convertPromotedPieceToOriginal(dest);

    // 駒台の該当する駒の数を増やす。
    if (m_pieceStand.contains(originalPiece)) {
        m_pieceStand[originalPiece]++;
    }
}

// 先手か後手かのどちらか（bあるいはw）を返す。
QString ShogiBoard::currentPlayer() const
{
    return m_currentPlayer;
}

// 局面編集中に使用される。将棋盤と駒台の駒を更新する。
void ShogiBoard::updateBoardAndPieceStand(const QChar source, const QChar dest, const int fileFrom, const int rankFrom, const int fileTo, const int rankTo, const bool promote)
{
    // 指した先が将棋盤内の場合
    if (fileTo < 10) {
        // 指したマスに相手の駒があった場合、自分の駒台の枚数に1加える。
        addPieceToStand(dest);
    // 駒台に駒を移した場合
    } else {
        // 駒台の駒の枚数に1加える。
        incrementPieceOnStand(dest);
    }

    // 駒台から駒を指すかどうかを確認する。
    if (fileFrom == 10 || fileFrom == 11) {
        // 駒台から指した場合、駒台の駒の枚数を1減らす。
        decrementPieceOnStand(source);
    }

    //begin
    // printPieceCount();
    //end

    // 指す駒を指したマスに移動させる。m_boardDataの入れ替えだけを行う。
    movePieceToSquare(source, fileFrom, rankFrom, fileTo, rankTo, promote);
}

// 駒の初期値を設定する。
void ShogiBoard::setInitialPieceStandValues()
{
    // 駒の初期値のリスト
    static const QList<QPair<QChar, int>> initialValues = {
        {'P', 9}, // 先手の歩
        {'L', 2}, // 先手の香車
        {'N', 2}, // 先手の桂馬
        {'S', 2}, // 先手の銀
        {'G', 2}, // 先手の金
        {'B', 1}, // 先手の角
        {'R', 1}, // 先手の飛車
        {'K', 1}, // 先手の王
        {'k', 1}, // 後手の玉
        {'r', 1}, // 後手の飛車
        {'b', 1}, // 後手の角
        {'g', 2}, // 後手の金
        {'s', 2}, // 後手の銀
        {'n', 2}, // 後手の桂馬
        {'l', 2}, // 後手の香車
        {'p', 9}, // 後手の歩
    };

    // 駒台の駒の初期値を設定する。
    for (const auto& pair : initialValues) {
        m_pieceStand[pair.first] = pair.second;
    }
}

// 「全ての駒を駒台へ」をクリックした時に実行される。
// 先手と後手の駒を同じ枚数にして全ての駒を駒台に載せる。
void ShogiBoard::resetGameBoard()
{
    // 将棋盤のマスを全て空白文字にする。
    m_boardData.fill(' ', ranks() * files());

    // 駒の初期値を設定する。
    setInitialPieceStandValues();
}

// 「先後反転」をクリックした時に実行される。
// 先手の配置を後手の配置に変更し、後手の配置を先手の配置に変更する。
void ShogiBoard::flipSides()
{
    // 元の配置データをバックアップ
    QVector<QChar> originalBoardData = m_boardData;

    // 新たな盤面データのリストを作成する。
    QVector<QChar> newBoardData;

    // 先手と後手の駒を反転
    for (int i = 0; i < 81; i++) {
        // 反転させる駒文字を取得する。
        QChar pieceChar = originalBoardData.at(80 - i);

        // 駒文字が大文字の場合、小文字に反転させる。
        // 駒文字が小文字の場合、大文字に反転させる。
        pieceChar = pieceChar.isLower() ? pieceChar.toUpper() : pieceChar.toLower();

        // 新たな盤面データに駒文字を追加する。
        newBoardData.append(pieceChar);
    }

    // 配置データを新たなもので上書き
    m_boardData = newBoardData;

    // 駒台の駒数を複写する。
    static const QMap<QChar, int> originalPieceStand = m_pieceStand;

    // 先手と後手の駒台上の駒の数を反転する。
    for (auto it = originalPieceStand.cbegin(); it != originalPieceStand.cend(); ++it) {
        // 駒文字を反転させる。
        QChar flippedChar = it.key().isLower() ? it.key().toUpper() : it.key().toLower();

        // 駒台の駒数を反転させる。
        m_pieceStand[flippedChar] = it.value();
    }
}

// 持ち駒を出力する。
void ShogiBoard::printPieceCount() const
{
    qDebug() << "先手の持ち駒:";
    qDebug() << "歩: " << m_pieceStand['P'];
    qDebug() << "香車: " << m_pieceStand['L'];
    qDebug() << "桂馬: " << m_pieceStand['N'];
    qDebug() << "銀: " << m_pieceStand['S'];
    qDebug() << "金: " << m_pieceStand['G'];
    qDebug() << "角: " << m_pieceStand['B'];
    qDebug() << "飛車: " << m_pieceStand['R'];

    qDebug() << "後手の持ち駒:";
    qDebug() << "歩: " << m_pieceStand['p'];
    qDebug() << "香車: " << m_pieceStand['l'];
    qDebug() << "桂馬: " << m_pieceStand['n'];
    qDebug() << "銀: " << m_pieceStand['s'];
    qDebug() << "金: " << m_pieceStand['g'];
    qDebug() << "角: " << m_pieceStand['b'];
    qDebug() << "飛車: " << m_pieceStand['r'];
}
#include "shogiclock.h"
#include <QtGlobal>
#include <QDebug>

Q_LOGGING_CATEGORY(lcShogiClock, "shogi.clock")

ShogiClock::ShogiClock(QObject *parent)
    : QObject(parent)
{
    m_timer = new QTimer(this);
    m_timer->setTimerType(Qt::PreciseTimer);
    m_timer->setInterval(kTickMs);
    connect(m_timer, &QTimer::timeout, this, &ShogiClock::updateClock);
}

void ShogiClock::setLoseOnTimeout(bool v) { m_loseOnTimeout = v; }

void ShogiClock::setPlayerTimes(int player1Seconds, int player2Seconds,
                                int byoyomi1Seconds, int byoyomi2Seconds,
                                int bincSeconds, int wincSeconds,
                                bool isLimitedTime)
{
    qCDebug(lcShogiClock) << "setPlayerTimes p1=" << player1Seconds
                          << "p2=" << player2Seconds
                          << "byo1=" << byoyomi1Seconds
                          << "byo2=" << byoyomi2Seconds
                          << "inc1=" << bincSeconds
                          << "inc2=" << wincSeconds
                          << "limited=" << isLimitedTime;

    // byoyomi と increment は排他扱い
    if (byoyomi1Seconds > 0 || byoyomi2Seconds > 0) {
        m_byoyomi1TimeMs = qMax(0, byoyomi1Seconds) * 1000LL;
        m_byoyomi2TimeMs = qMax(0, byoyomi2Seconds) * 1000LL;
        m_bincMs = 0; m_wincMs = 0;
    } else if (bincSeconds > 0 || wincSeconds > 0) {
        m_byoyomi1TimeMs = 0; m_byoyomi2TimeMs = 0;
        m_bincMs = qMax(0, bincSeconds) * 1000LL;
        m_wincMs = qMax(0, wincSeconds) * 1000LL;
    } else {
        m_byoyomi1TimeMs = m_byoyomi2TimeMs = 0;
        m_bincMs = m_wincMs = 0;
    }

    m_player1TimeMs = qMax(0, player1Seconds) * 1000LL;
    m_player2TimeMs = qMax(0, player2Seconds) * 1000LL;

    m_timeLimitSet = isLimitedTime;
    m_byoyomi1Applied = false;
    m_byoyomi2Applied = false;
    m_clockRunning = false;
    m_gameOver = false;

    // 考慮の初期化
    m_player1ConsiderationTimeMs = 0;
    m_player2ConsiderationTimeMs = 0;
    m_player1TotalConsiderationTimeMs = 0;
    m_player2TotalConsiderationTimeMs = 0;

    // GUI表示用の直近/前回値も初期化
    m_p1LastMoveShownSec = m_p2LastMoveShownSec = 0;
    m_p1PrevShownTotalSec = m_p2PrevShownTotalSec = 0;

    // 表示キャッシュを初期化して即反映（残りは切り上げ秒）
    m_prevShownSecP1 = remainingDisplaySecP1();
    m_prevShownSecP2 = remainingDisplaySecP2();
    emit timeUpdated();
}

void ShogiClock::setCurrentPlayer(int player)
{
    m_currentPlayer = (player == 2 ? 2 : 1);
}

void ShogiClock::startClock()
{
    if (m_clockRunning) return;

    saveState(); // undo用

    m_elapsedTimer.restart();
    m_lastTickMs = m_elapsedTimer.elapsed();

    // 残り時間の秒表示キャッシュをセットして一旦描画
    m_prevShownSecP1 = remainingDisplaySecP1();
    m_prevShownSecP2 = remainingDisplaySecP2();
    emit timeUpdated();

    m_timer->start();
    m_clockRunning = true;
}

void ShogiClock::stopClock()
{
    if (!m_clockRunning) return;

    const qint64 now = m_elapsedTimer.elapsed();
    const qint64 elapsed = now - m_lastTickMs;
    if (elapsed > 0) {
        m_lastTickMs = now;
        if (m_timeLimitSet) {
            if (m_currentPlayer == 1) {
                m_player1TimeMs = qMax<qint64>(0, m_player1TimeMs - elapsed);
                m_player1ConsiderationTimeMs += elapsed;
            } else {
                m_player2TimeMs = qMax<qint64>(0, m_player2TimeMs - elapsed);
                m_player2ConsiderationTimeMs += elapsed;
            }
        } else {
            if (m_currentPlayer == 1) m_player1ConsiderationTimeMs += elapsed;
            else                      m_player2ConsiderationTimeMs += elapsed;
        }
    }

    m_timer->stop();
    m_clockRunning = false;
    emit timeUpdated();
}

// ---- 残り秒（切り上げ） ----
int ShogiClock::remainingDisplaySecP1() const
{
    qint64 ms = qMax<qint64>(0, m_player1TimeMs);
    return static_cast<int>((ms + 999) / 1000);
}
int ShogiClock::remainingDisplaySecP2() const
{
    qint64 ms = qMax<qint64>(0, m_player2TimeMs);
    return static_cast<int>((ms + 999) / 1000);
}

// ---- 直近考慮(秒)の更新（着手確定時に呼ぶ） ----
void ShogiClock::updateShownConsiderationForPlayer(int player)
{
    if (player == 1) {
        // 総考慮ms → 秒（切り捨て）
        const int totalSec = static_cast<int>(qMax<qint64>(0, m_player1TotalConsiderationTimeMs) / 1000);
        const int diff = totalSec - m_p1PrevShownTotalSec;
        m_p1LastMoveShownSec = qMax(0, diff);
        m_p1PrevShownTotalSec = totalSec;
    } else {
        const int totalSec = static_cast<int>(qMax<qint64>(0, m_player2TotalConsiderationTimeMs) / 1000);
        const int diff = totalSec - m_p2PrevShownTotalSec;
        m_p2LastMoveShownSec = qMax(0, diff);
        m_p2PrevShownTotalSec = totalSec;
    }
}

void ShogiClock::applyByoyomiAndResetConsideration1()
{
    // 終局後：秒読み/加算は行わず、表示更新のみ
    if (m_gameOver) {
        m_player1TotalConsiderationTimeMs += m_player1ConsiderationTimeMs;
        updateShownConsiderationForPlayer(1);
        emit timeUpdated();
        return;
    }

    // 総考慮（実測ms）に今手分を加算 → 表示用の直近考慮(秒)を確定
    m_player1TotalConsiderationTimeMs += m_player1ConsiderationTimeMs;
    updateShownConsiderationForPlayer(1);

    // 秒読み or インクリメント適用（先手が指し終えた直後）
    if (m_byoyomi1TimeMs > 0) {
        if (m_player1TimeMs <= 0 || m_byoyomi1Applied) {
            m_player1TimeMs = m_byoyomi1TimeMs;
            m_byoyomi1Applied = true;
        }
    } else if (m_bincMs > 0) {
        if (m_player1TimeMs > 0) m_player1TimeMs += m_bincMs; // 0なら加算しない
    }

    emit timeUpdated();
}

void ShogiClock::applyByoyomiAndResetConsideration2()
{
    if (m_gameOver) {
        m_player2TotalConsiderationTimeMs += m_player2ConsiderationTimeMs;
        updateShownConsiderationForPlayer(2);
        emit timeUpdated();
        return;
    }

    m_player2TotalConsiderationTimeMs += m_player2ConsiderationTimeMs;
    updateShownConsiderationForPlayer(2);

    if (m_byoyomi2TimeMs > 0) {
        if (m_player2TimeMs <= 0 || m_byoyomi2Applied) {
            m_player2TimeMs = m_byoyomi2TimeMs;
            m_byoyomi2Applied = true;
        }
    } else if (m_wincMs > 0) {
        if (m_player2TimeMs > 0) m_player2TimeMs += m_wincMs;
    }

    emit timeUpdated();
}

void ShogiClock::updateClock()
{
    if (!m_clockRunning) return;
    if (m_gameOver)      return;

    const qint64 now = m_elapsedTimer.elapsed();
    const qint64 elapsed = now - m_lastTickMs;
    if (elapsed <= 0) return;
    m_lastTickMs = now;

    if (m_timeLimitSet) {
        auto step = [&](int player)->bool {
            qint64& remMs      = (player == 1) ? m_player1TimeMs : m_player2TimeMs;
            qint64& considerMs = (player == 1) ? m_player1ConsiderationTimeMs : m_player2ConsiderationTimeMs;
            const qint64 byoMs = (player == 1) ? m_byoyomi1TimeMs : m_byoyomi2TimeMs;
            bool& byoApplied   = (player == 1) ? m_byoyomi1Applied : m_byoyomi2Applied;

            remMs      -= elapsed;
            considerMs += elapsed;

            if (remMs <= 0) {
                if (byoMs > 0) {
                    const qint64 overshoot = -remMs;
                    if (!byoApplied) {
                        // メイン→秒読みへ
                        remMs = byoMs - overshoot;
                        byoApplied = true;
                    } else {
                        // 既に秒読み中で0を割った→秒読み尽き
                        remMs = 0;
                    }
                    if (remMs <= 0) {
                        // 秒読みも尽きた
                        if (m_loseOnTimeout) {
                            m_gameOver = true;
                            m_timer->stop();
                            m_clockRunning = false;
                            if (player == 1) emit player1TimeOut();
                            else             emit player2TimeOut();
                            emit resignationTriggered();
                        } else {
                            remMs = 0; // 表示は0のまま継続
                        }
                        emit timeUpdated();
                        return true; // 停止 or 0で維持
                    }
                } else {
                    // 秒読みなし
                    remMs = 0;
                    if (m_loseOnTimeout) {
                        m_gameOver = true;
                        m_timer->stop();
                        m_clockRunning = false;
                        if (player == 1) emit player1TimeOut();
                        else             emit player2TimeOut();
                        emit resignationTriggered();
                        emit timeUpdated();
                        return true;
                    }
                }
            }
            return false;
        };

        if (m_currentPlayer == 1) {
            if (step(1)) return;
        } else {
            if (step(2)) return;
        }
    } else {
        if (m_currentPlayer == 1) m_player1ConsiderationTimeMs += elapsed;
        else                      m_player2ConsiderationTimeMs += elapsed;
    }

    debugCheckInvariants();

    // 秒表示が変わった時のみ通知（残りは切り上げ秒）
    const int sec1 = remainingDisplaySecP1();
    const int sec2 = remainingDisplaySecP2();
    if (sec1 != m_prevShownSecP1 || sec2 != m_prevShownSecP2) {
        m_prevShownSecP1 = sec1;
        m_prevShownSecP2 = sec2;
        emit timeUpdated();
    }
}

// ---- GUI文字列 ----
QString ShogiClock::getPlayer1TimeString() const
{
    const int rs = remainingDisplaySecP1();
    const int h = rs / 3600, m = (rs % 3600) / 60, s = rs % 60;
    return QString::asprintf("%02d:%02d:%02d", h, m, s);
}
QString ShogiClock::getPlayer2TimeString() const
{
    const int rs = remainingDisplaySecP2();
    const int h = rs / 3600, m = (rs % 3600) / 60, s = rs % 60;
    return QString::asprintf("%02d:%02d:%02d", h, m, s);
}

// 直近考慮（MM:SS）＝ 総考慮(秒)差分（切り捨て）
QString ShogiClock::getPlayer1ConsiderationTime() const
{
    int totalSec = static_cast<int>(qMax<qint64>(0, m_player1TotalConsiderationTimeMs) / 1000);
    // m_p1LastMoveShownSec は「直近手の差分(秒)」を保持
    Q_UNUSED(totalSec);
    const int mm = m_p1LastMoveShownSec / 60;
    const int ss = m_p1LastMoveShownSec % 60;
    return QString::asprintf("%02d:%02d", mm, ss);
}
QString ShogiClock::getPlayer2ConsiderationTime() const
{
    int totalSec = static_cast<int>(qMax<qint64>(0, m_player2TotalConsiderationTimeMs) / 1000);
    Q_UNUSED(totalSec);
    const int mm = m_p2LastMoveShownSec / 60;
    const int ss = m_p2LastMoveShownSec % 60;
    return QString::asprintf("%02d:%02d", mm, ss);
}

// 総考慮（HH:MM:SS）＝ 実測総考慮ms → 秒は切り捨て
QString ShogiClock::getPlayer1TotalConsiderationTime() const
{
    const int totalSec = static_cast<int>(qMax<qint64>(0, m_player1TotalConsiderationTimeMs) / 1000);
    const int h = totalSec / 3600, m = (totalSec % 3600) / 60, s = totalSec % 60;
    return QString::asprintf("%02d:%02d:%02d", h, m, s);
}
QString ShogiClock::getPlayer2TotalConsiderationTime() const
{
    const int totalSec = static_cast<int>(qMax<qint64>(0, m_player2TotalConsiderationTimeMs) / 1000);
    const int h = totalSec / 3600, m = (totalSec % 3600) / 60, s = totalSec % 60;
    return QString::asprintf("%02d:%02d:%02d", h, m, s);
}

QString ShogiClock::getPlayer1ConsiderationAndTotalTime() const
{
    return getPlayer1ConsiderationTime() + "/" + getPlayer1TotalConsiderationTime();
}
QString ShogiClock::getPlayer2ConsiderationAndTotalTime() const
{
    return getPlayer2ConsiderationTime() + "/" + getPlayer2TotalConsiderationTime();
}

// ---- undo用 ----
void ShogiClock::saveState()
{
    qCDebug(lcShogiClock) << "saveState p1=" << m_player1TimeMs
                          << "p2=" << m_player2TimeMs
                          << "c1=" << m_player1ConsiderationTimeMs
                          << "c2=" << m_player2ConsiderationTimeMs
                          << "t1=" << m_player1TotalConsiderationTimeMs
                          << "t2=" << m_player2TotalConsiderationTimeMs
                          << "byo1Applied=" << m_byoyomi1Applied
                          << "byo2Applied=" << m_byoyomi2Applied
                          << "p1PrevShownTot=" << m_p1PrevShownTotalSec
                          << "p2PrevShownTot=" << m_p2PrevShownTotalSec
                          << "p1Last=" << m_p1LastMoveShownSec
                          << "p2Last=" << m_p2LastMoveShownSec;

    m_player1TimeHistory.push(m_player1TimeMs);
    m_player2TimeHistory.push(m_player2TimeMs);
    m_player1ConsiderationHistory.push(m_player1ConsiderationTimeMs);
    m_player2ConsiderationHistory.push(m_player2ConsiderationTimeMs);
    m_player1TotalConsiderationHistory.push(m_player1TotalConsiderationTimeMs);
    m_player2TotalConsiderationHistory.push(m_player2TotalConsiderationTimeMs);
    m_byoyomi1AppliedHistory.push(m_byoyomi1Applied);
    m_byoyomi2AppliedHistory.push(m_byoyomi2Applied);
    m_p1PrevShownTotalSecHistory.push(m_p1PrevShownTotalSec);
    m_p2PrevShownTotalSecHistory.push(m_p2PrevShownTotalSec);
    m_p1LastMoveShownSecHistory.push(m_p1LastMoveShownSec);
    m_p2LastMoveShownSecHistory.push(m_p2LastMoveShownSec);
}

void ShogiClock::undo()
{
    // あなたの既存実装に合わせて「2手戻す」
    auto enough = [&]{
        return m_player1TimeHistory.size() >= 3 &&
               m_player2TimeHistory.size() >= 3 &&
               m_player1ConsiderationHistory.size() >= 3 &&
               m_player2ConsiderationHistory.size() >= 3 &&
               m_player1TotalConsiderationHistory.size() >= 3 &&
               m_player2TotalConsiderationHistory.size() >= 3 &&
               m_byoyomi1AppliedHistory.size() >= 3 &&
               m_byoyomi2AppliedHistory.size() >= 3 &&
               m_p1PrevShownTotalSecHistory.size() >= 3 &&
               m_p2PrevShownTotalSecHistory.size() >= 3 &&
               m_p1LastMoveShownSecHistory.size() >= 3 &&
               m_p2LastMoveShownSecHistory.size() >= 3;
    };
    if (!enough()) return;

    auto pop2 = [](auto& st){ st.pop(); st.pop(); };

    pop2(m_player1TimeHistory);
    m_player1TimeMs = m_player1TimeHistory.top();

    pop2(m_player2TimeHistory);
    m_player2TimeMs = m_player2TimeHistory.top();

    pop2(m_player1ConsiderationHistory);
    m_player1ConsiderationTimeMs = m_player1ConsiderationHistory.top();

    pop2(m_player2ConsiderationHistory);
    m_player2ConsiderationTimeMs = m_player2ConsiderationHistory.top();

    pop2(m_player1TotalConsiderationHistory);
    m_player1TotalConsiderationTimeMs = m_player1TotalConsiderationHistory.top();

    pop2(m_player2TotalConsiderationHistory);
    m_player2TotalConsiderationTimeMs = m_player2TotalConsiderationHistory.top();

    pop2(m_byoyomi1AppliedHistory);
    m_byoyomi1Applied = m_byoyomi1AppliedHistory.top();

    pop2(m_byoyomi2AppliedHistory);
    m_byoyomi2Applied = m_byoyomi2AppliedHistory.top();

    pop2(m_p1PrevShownTotalSecHistory);
    m_p1PrevShownTotalSec = m_p1PrevShownTotalSecHistory.top();

    pop2(m_p2PrevShownTotalSecHistory);
    m_p2PrevShownTotalSec = m_p2PrevShownTotalSecHistory.top();

    pop2(m_p1LastMoveShownSecHistory);
    m_p1LastMoveShownSec = m_p1LastMoveShownSecHistory.top();

    pop2(m_p2LastMoveShownSecHistory);
    m_p2LastMoveShownSec = m_p2LastMoveShownSecHistory.top();

    emit timeUpdated();
}

void ShogiClock::debugCheckInvariants() const
{
#ifndef NDEBUG
    Q_ASSERT(m_player1TimeMs >= 0);
    Q_ASSERT(m_player2TimeMs >= 0);
    if (m_byoyomi1TimeMs > 0 || m_byoyomi2TimeMs > 0) {
        Q_ASSERT(m_bincMs == 0 && m_wincMs == 0);
    }
    if (!m_byoyomi1TimeMs) Q_ASSERT(!m_byoyomi1Applied);
    if (!m_byoyomi2TimeMs) Q_ASSERT(!m_byoyomi2Applied);
#endif
}

// ---- 互換API ----
void ShogiClock::setPlayer1ConsiderationTime(int ms)
{
    m_player1ConsiderationTimeMs = static_cast<qint64>(qMax(0, ms));
}
void ShogiClock::setPlayer2ConsiderationTime(int ms)
{
    m_player2ConsiderationTimeMs = static_cast<qint64>(qMax(0, ms));
}
int ShogiClock::getPlayer1ConsiderationTimeMs() const { return static_cast<int>(m_player1ConsiderationTimeMs); }
int ShogiClock::getPlayer2ConsiderationTimeMs() const { return static_cast<int>(m_player2ConsiderationTimeMs); }
#include "shogigamecontroller.h"

#include <QPoint>
#include <QDebug>
#include "shogiboard.h"
#include "shogimove.h"
#include "movevalidator.h"
#include "playmode.h"
#include "shogiutils.h"
#include "legalmovestatus.h"

// 将棋の対局全体を管理し、盤面の初期化、指し手の処理、合法手の検証、対局状態の管理を行うクラス
// コンストラクタ
ShogiGameController::ShogiGameController(QObject* parent)
    : QObject(parent), m_board(nullptr), m_result(NoResult), m_currentPlayer(NoPlayer), m_promote(false)
    , previousFileTo(0)     // 追加：未着手時は 0 に初期化
    , previousRankTo(0)     // 追加：未着手時は 0 に初期化
{
}

// 将棋盤のポインタを取得する。
ShogiBoard* ShogiGameController::board() const
{
    return m_board;
}

// 新規対局の準備
// 将棋盤、駒台を初期化（何も駒がない）し、入力のSFEN文字列の配置に将棋盤、駒台の駒を
// 配置し、対局結果を結果なし、現在の手番がどちらでもない状態に設定する。
void ShogiGameController::newGame(QString& initialSfenString)
{
    // 将棋盤を示すポインタm_boardの作成
    // 将棋盤の81マスに空白を代入し、駒台の駒を0にする。
    setupBoard();

    // 将棋盤と駒台を含むSFEN文字列で将棋盤全体を更新する場合、この関数を使う。
    // 将棋盤に入力で渡されるsfen形式の文字列に文法的に誤りが無いかチェックする。
    // 将棋盤と駒台のSFEN文字列を指定して将棋盤と駒台の駒の更新を行い、再描画する。
    // 入力は、将棋盤と駒台を含むSFEN文字列
    // "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1"
    board()->setSfen(initialSfenString);

    // 対局結果をNoResultに設定する。
    setResult(NoResult);

    // 現在の手番をNoPlayerに設定する。
    setCurrentPlayer(NoPlayer);
}

// 将棋盤を示すポインタm_boardを作成する。
// 将棋盤の81マスに空白を代入し、駒台の駒を0にする。
void ShogiGameController::setupBoard()
{
    // 将棋盤の81マスに空白を代入し、駒台の駒を0にする。
    // 将棋盤を示すポインタm_boardを作成する。
    setBoard(new ShogiBoard(9, 9, this));
}

// 将棋盤のポインタを設定する。
void ShogiGameController::setBoard(ShogiBoard* board)
{
    // ★ 異常ガード：null を渡されたら通知して打ち切り
    if (!board) {
        const QString errorMessage =
            tr("An error occurred in ShogiGameController::setBoard: null board was passed.");
        emit errorOccurred(errorMessage);
        return; // 打ち切り
    }

    // すでに設定されている場合は何もしない。
    if (board == m_board) return;

    // すでに設定されている場合は削除する。
    if (m_board) delete m_board;

    // 新しい将棋盤のポインタを設定する。
    m_board = board;

    // 将棋盤のポインタが設定されたことを通知する。
    emit boardChanged(m_board);
}

// 対局結果を設定する。
void ShogiGameController::setResult(Result value)
{
    // すでに設定されている場合は何もしない。
    if (result() == value) return;

    // 対局結果を設定する。
    if (result() == NoResult) {
        m_result = value;

        emit gameOver(m_result);
    } else {
        m_result = value;
    }
}

// 成り・不成のフラグを返す。
bool ShogiGameController::promote() const
{
    return m_promote;
}

// 成り・不成のフラグを設定する。
void ShogiGameController::setPromote(bool newPromote)
{
    m_promote = newPromote;
}

// 現在の手番を設定する。
void ShogiGameController::setCurrentPlayer(const Player player)
{
    // 現在の手番と同じ手番の場合、何もしない。
    if (currentPlayer() == player) return;

    // 現在の手番を設定する。
    m_currentPlayer = player;

    // 現在の手番が変更されたことを通知する。
    emit currentPlayerChanged(m_currentPlayer);
}

// 指し手を漢字の文字列に変換する。
QString ShogiGameController::convertMoveToKanjiStr(const QString piece, const int fileFrom, const int rankFrom, const int fileTo, const int rankTo)
{
    // ★ 手番未設定はエラーとして打ち切る（"▲/△" が付与できないため）
    if (currentPlayer() != Player1 && currentPlayer() != Player2) {
        const QString errorMessage =
            tr("An error occurred in ShogiGameController::convertMoveToKanjiStr: current player is invalid.");
        emit errorOccurred(errorMessage);
        return QString(); // 打ち切り
    }

    // 駒の漢字表記
    QString pieceKanji;

    // 「全、圭、杏」の場合はそれぞれ「成銀、成桂、成香」とする。
    if (piece == "全") {
        pieceKanji = "成銀";
    } else if (piece == "圭") {
        pieceKanji = "成桂";
    } else if (piece == "杏") {
        pieceKanji = "成香";
    } else {
        pieceKanji = piece;
    }

    // 指し手の漢字文字列
    QString moveStr;

    // 現在の手番に応じて指し手の漢字文字列を設定する。
    if (currentPlayer() == Player1) {
        moveStr = "▲";
    } else { // Player2
        moveStr = "△";
    }

    // 同じマスに駒を移動する場合
    if ((fileTo == previousFileTo) && (rankTo == previousRankTo)) {
        moveStr += "同　" + pieceKanji;
    } else {
        moveStr += ShogiUtils::transFileTo(fileTo) + ShogiUtils::transRankTo(rankTo) + pieceKanji;
    }

    // 成る場合は「成」を追加する。
    if (m_promote) moveStr += "成";

    // 駒台から打つ場合（10は先手の駒台番号、11は後手の駒台番号）
    if ((fileFrom >= 10) && (fileFrom <= 11)) {
        moveStr += "打";
    } else {
        moveStr += "(" + QString::number(fileFrom) + QString::number(rankFrom) + ")";
    }

    // 指した先のマスを１手前の指し手として記憶しておく。
    previousFileTo = fileTo;
    previousRankTo = rankTo;

    return moveStr;
}

// 人間が指した場合に指し手で成る手と不成の手が合法手であるかを判定し、GUIのダイアログで対局者に
// 成るか成らないかを選択させて、その結果をcurrentMove.isPromotionに保存する。
// 指し手が合法であればtrue、不合法であればfalseを返す。
bool ShogiGameController::decidePromotion(PlayMode& playMode, MoveValidator& validator, const MoveValidator::Turn& turnMove,
                                     int& fileFrom, int& rankFrom, int& fileTo, int& rankTo, QChar& piece,  ShogiMove& currentMove)
{
    // 駒台には指せない。
    if (fileTo >= 10) return false;

    if (isCurrentPlayerHumanControlled(playMode)) {
        // 一時的に成らないと設定
        currentMove.isPromotion = false;

        LegalMoveStatus legalMoveStatus = validator.isLegalMove(turnMove, board()->boardData(), board()->getPieceStand(), currentMove);

        // 成らない状態での合法手が存在すればtrueを返す。存在しなければfalseを返す。
        bool canMoveWithoutPromotion = legalMoveStatus.nonPromotingMoveExists;

        // 成る状態での合法手が存在すればtrueを返す。存在しなければfalseを返す。
        bool canMoveWithPromotion = legalMoveStatus.promotingMoveExists;

        // 成る指し手が可能な場合
        if (canMoveWithPromotion) {
            // 成らない指し手も可能な場合
            if (canMoveWithoutPromotion) {
                // 駒台上ではなく盤上の指し手である場合、対局者に成るかどうかを選択させる。
                if (fileFrom <= 9) {
                    // ダイアログを表示して対局者に成るかどうかを選択させる。
                    decidePromotionByDialog(piece, rankFrom, rankTo);

                    // ダイアログでの選択結果をcurrentMove.isPromotionに設定する。
                    currentMove.isPromotion = m_promote;

                    // 指し手が合法であればtrueを返す。
                    return true;
                }
            }
            // 必ず成る必要がある場合
            else {
                // 成らない指し手は不可能なので、trueを返す。
                currentMove.isPromotion = true;
            }
        } else {
            if (canMoveWithoutPromotion) {
                // 不成で指さなければならない。
                currentMove.isPromotion = false;
            } else {
                // どちらの指し手も不可能な場合、falseを返す。
                return false;
            }
        }
    }

    // 成る・不成のフラグを設定する。
    m_promote = currentMove.isPromotion;

    // 指し手が合法であればtrueを返す。
    return true;
}

// 人間が対局者に含まれているかどうかを判定する。
bool ShogiGameController::isCurrentPlayerHumanControlled(PlayMode& playMode)
{
    // 現在の手番を取得する。
    auto player = currentPlayer();

    // 対局者が人間同士であるか
    return (playMode == HumanVsHuman)
           // あるいは、手番が先手あるいは下手であり、かつ平手で人間対エンジンの場合
           || (player == Player1 && playMode == EvenHumanVsEngine)

           // あるいは、手番が後手あるいは上手であり、かつ平手でエンジン対人間の場合
           || (player == Player2 && playMode == EvenEngineVsHuman)

           // あるいは、手番が先手あるいは下手であり、かつ駒落ちで人間対エンジンの場合
           || (player == Player1 && playMode == HandicapHumanVsEngine)

           // あるいは、手番が後手あるいは上手であり、かつ駒落ちでエンジン対人間の場合
           || (player == Player2 && playMode == HandicapEngineVsHuman);
}

// ダイアログを表示して対局者に成るかどうかを選択させる。
void ShogiGameController::decidePromotionByDialog(QChar& piece, int& rankFrom, int& rankTo)
{
    auto player = currentPlayer();

    // 駒が成ることが可能な場合のみ処理を行う。
    if (isPromotablePiece(piece)) {
        // 先手あるいは下手の場合
        if (player == Player1) {
            // 駒が4段目から3段目に到達した場合、またはそれ以外の場合に成るかどうかを選択させる。
            // ただし、駒が4段目以上でかつ3段目を超える場合には選択させない。
            if (rankFrom < 4 || (rankFrom >= 4 && rankTo <= 3)) {
                emit showPromotionDialog();
            }
        }
        // 後手あるいは上手の場合
        else if (player == Player2) {
            // 駒が6段目から7段目に到達した場合、またはそれ以外の場合に成るかどうかを選択させる。
            // ただし、駒が6段目以下でかつ7段目を超える場合には選択させない。
            if (rankFrom > 6 || (rankFrom <= 6 && rankTo >= 7)) {
                emit showPromotionDialog();
            }
        }
    }
}

// 指定された駒が成ることが可能な駒であるかを判定する。
bool ShogiGameController::isPromotablePiece(QChar& piece)
{
    // 成ることが可能な駒のリスト
    static const QString promotablePieces = "PLNSBRplnsbr";

    // 成ることが可能な駒であるかを判定する。
    return promotablePieces.contains(piece);
}

// アルファベットの駒文字を漢字表記にする。
QString ShogiGameController::getPieceKanji(const QChar& piece)
{
    static const QMap<QChar, QString> pieceKanjiNames = {
        {' ', "　"},
        {'P', "歩"}, {'L', "香"}, {'N', "桂"}, {'S', "銀"}, {'G', "金"}, {'B', "角"}, {'R', "飛"}, {'K', "玉"},
        {'Q', "と"}, {'M', "杏"}, {'O', "圭"}, {'T', "全"}, {'C', "馬"}, {'U', "龍"},
        {'p', "歩"}, {'l', "香"}, {'n', "桂"}, {'s', "銀"}, {'g', "金"}, {'b', "角"}, {'r', "飛"}, {'k', "玉"},
        {'q', "と"}, {'m', "杏"}, {'o', "圭"}, {'t', "全"}, {'c', "馬"}, {'u', "龍"}
    };

    // 入力された駒をマップで検索する。
    auto it = pieceKanjiNames.find(piece);

    // 対応する漢字が見つかった場合
    if (it != pieceKanjiNames.end()) {
        // 対応する漢字を返す。
        return it.value();
    }
    // 対応する漢字が見つからなかった場合
    else {
        // エラーメッセージを表示する。
        const QString errorMessage = tr("An error occurred in ShogiGameController::getPieceKanji: The piece %1 is not found.").arg(piece);

        emit errorOccurred(errorMessage);
    }

    return QString();
}

// 相手の手番をSFEN形式の手番bまたはwで取得する。
QString ShogiGameController::getNextPlayerSfen()
{
    QString nextPlayerColorSfen;

    if (currentPlayer() == Player1) {
        nextPlayerColorSfen = QStringLiteral("w");
    } else if (currentPlayer() == Player2) {
        nextPlayerColorSfen = QStringLiteral("b");
    } else {
        const QString errorMessage =
            tr("An error occurred in ShogiGameController::getNextPlayerSfen: Invalid player state.");
        qDebug() << "currentPlayer() =" << currentPlayer();
        emit errorOccurred(errorMessage);
        return QString(); // ★ 打ち切り（不正状態）
    }

    return nextPlayerColorSfen;
}

// 合法手判定に関するクラスで利用するための手番を設定する。
MoveValidator::Turn ShogiGameController::getCurrentTurnForValidator(MoveValidator& validator)
{
    // 現在の手番が先手あるいは下手の場合
    if (currentPlayer() == Player1) {
        return validator.BLACK;
    }
    // 現在の手番が後手あるいは上手の場合
    else {
        return validator.WHITE;
    }
}

bool ShogiGameController::validateAndMove(QPoint& outFrom, QPoint& outTo, QString& record, PlayMode& playMode, int& moveNumber,
                                          QStringList* m_sfenRecord, QVector<ShogiMove>& gameMoves)
{
    // 関数冒頭（最初のreturn系ガードの前に）
    qInfo().noquote() << "[IDX][VAL] enter argMove=" << moveNumber
                      << " recPtr=" << static_cast<const void*>(m_sfenRecord)
                      << " recSize(before)=" << (m_sfenRecord ? m_sfenRecord->size() : -1);

    // ★ 異常ガード：盤未設定
    if (!board()) {
        const QString errorMessage =
            tr("An error occurred in ShogiGameController::validateAndMove: board() is null.");
        emit errorOccurred(errorMessage);
        emit endDragSignal();
        return false; // 打ち切り
    }

    // 指し手の移動元と移動先のマスの筋と段を取得する。
    int fileFrom = outFrom.x();
    int rankFrom = outFrom.y();
    int fileTo   = outTo.x();
    int rankTo   = outTo.y();

    //begin debug
    qDebug() << "in ShogiGameController::validateAndMove";
    qDebug() << "playMode = " << playMode;
    qDebug() << "promote = " << m_promote;
    qDebug() << "fileFrom = " << fileFrom;
    qDebug() << "rankFrom = " << rankFrom;
    qDebug() << "fileTo = " << fileTo;
    qDebug() << "rankTo = " << rankTo;
    qDebug() << "currentPlayer() = " << currentPlayer();
    //end debug

    // 合法手判定に関するクラス
    MoveValidator validator;

    // 合法手判定に関するクラスで利用するための手番を設定する。
    MoveValidator::Turn turn = getCurrentTurnForValidator(validator);

    // 合成手判定で使用する指し手データを生成する。
    QPoint fromPoint(fileFrom - 1, rankFrom - 1);
    QPoint toPoint(fileTo - 1, rankTo - 1);

    // 指した駒文字を取得する。
    QChar movingPiece   = board()->getPieceCharacter(fileFrom, rankFrom);
    QChar capturedPiece = board()->getPieceCharacter(fileTo,   rankTo);

    // ★ 盤上移動のとき、移動元が空白は打ち切り（駒台からの打ちなら fileFrom=10/11 で許可）
    if ((fileFrom >= 1 && fileFrom <= 9) && movingPiece == QLatin1Char(' ')) {
        const QString errorMessage =
            tr("An error occurred in ShogiGameController::validateAndMove: the source square is empty.");
        emit errorOccurred(errorMessage);
        emit endDragSignal();
        return false; // 打ち切り
    }

    // 合法手判定に関するクラスで利用するための指し手データを生成する。
    ShogiMove currentMove(fromPoint, toPoint, movingPiece, capturedPiece, m_promote);

    // 成／不成の決定（人間手のとき）
    if (!decidePromotion(playMode, validator, turn, fileFrom, rankFrom, fileTo, rankTo, movingPiece, currentMove)) {
        emit endDragSignal();
        return false;
    } else {
        emit endDragSignal();
    }

    // ★ 手番SFENの取得を先に行い、異常時は打ち切る（盤更新より前に失敗させる）
    QString nextPlayerColorSfen = getNextPlayerSfen();
    if (nextPlayerColorSfen.isEmpty()) {
        // getNextPlayerSfen 内で emit 済み
        return false; // 打ち切り
    }

    // 現在の指し手を追加保存（ここで確定後の手数が gameMoves.size() になる）
    gameMoves.append(currentMove);

    // 盤面更新
    board()->updateBoardAndPieceStand(movingPiece, capturedPiece, fileFrom, rankFrom, fileTo, rankTo, m_promote);


    // 直前
    qDebug().noquote() << "[GC][pre-add] nextTurn=" << nextPlayerColorSfen
                       << " moveIndex=" << moveNumber
                       << " rec*=" << static_cast<const void*>(m_sfenRecord)
                       << " size(before)=" << (m_sfenRecord ? m_sfenRecord->size() : -1);

    // SFEN 保存
    board()->addSfenRecord(nextPlayerColorSfen, moveNumber, m_sfenRecord);

    // 直後
    qDebug().noquote() << "[GC][post-add] size(after)=" << (m_sfenRecord ? m_sfenRecord->size() : -1)
                       << " head=" << (m_sfenRecord && !m_sfenRecord->isEmpty() ? m_sfenRecord->first() : QString())
                       << " tail=" << (m_sfenRecord && !m_sfenRecord->isEmpty() ? m_sfenRecord->last()  : QString());

    // ←★ここにデバッグ挿入（そのままコピペでOK）
    {
        const int n = m_sfenRecord->size();
        const QString last = (n > 0) ? m_sfenRecord->at(n - 1) : QString();
        const QString preview = (last.size() > 200) ? last.left(200) + " ..." : last;
        qInfo() << "[GC] validateAndMove: sfenRecord size =" << n
                << " moveNumber =" << moveNumber;
        qInfo().noquote() << "[GC] last sfen = " << preview;
        if (last.startsWith(QLatin1String("position "))) {
            qWarning() << "[GC] *** NON-SFEN stored into sfenRecord! (bug)";
        }
    }

    // 棋譜文字列
    QString kanjiPiece = getPieceKanji(movingPiece);
    // （getPieceKanji がエラー時は空を返すが、盤更新済みのためここでは通知済みとして続行）

    record = convertMoveToKanjiStr(kanjiPiece, fileFrom, rankFrom, fileTo, rankTo);
    if (record.isEmpty()) {
        // convertMoveToKanjiStr 内でエラー通知済み。状態は既に更新済みなので、そのまま false 返却。
        return false; // 打ち切り
    }

    // ---- ★ 着手確定シグナル：手番切替の「前」に出す！ ----
    const Player moverBefore   = currentPlayer();     // 着手者（切替前）
    const int confirmedPly     = gameMoves.size();    // 確定後の手数（1始まり）
    qDebug() << "[GC] emit moveCommitted mover=" << moverBefore << "ply=" << confirmedPly;
    emit moveCommitted(moverBefore, confirmedPly);
    // ------------------------------------------------------

    // 手番を変える（ここから先は次手番）
    setCurrentPlayer(currentPlayer() == Player1 ? Player2 : Player1);

    // 関数末尾（trueを返す直前 or SFENをappendした直後の地点がベスト）
    if (m_sfenRecord && !m_sfenRecord->isEmpty()) {
        const QString tail = m_sfenRecord->last();
        qInfo().noquote() << "[IDX][VAL] exit  argMove=" << moveNumber
                          << " recSize(after)=" << m_sfenRecord->size()
                          << " tail='" << tail << "'";
    } else {
        qInfo().noquote() << "[IDX][VAL] exit  argMove=" << moveNumber
                          << " recSize(after)=" << (m_sfenRecord ? m_sfenRecord->size() : -1)
                          << " tail=<empty>";
    }

    return true;
}

// 手番を変える。
void ShogiGameController::changeCurrentPlayer()
{
    setCurrentPlayer(currentPlayer() == Player1 ? Player2 : Player1);
}

// 局面編集で駒移動を行い、局面を更新する。
bool ShogiGameController::editPosition(const QPoint& outFrom, const QPoint& outTo)
{
    // ★ 異常ガード：盤未設定
    if (!board()) {
        const QString errorMessage =
            tr("An error occurred in ShogiGameController::editPosition: board() is null.");
        emit errorOccurred(errorMessage);
        return false; // 打ち切り
    }

    // 指し手の移動元と移動先のマスの筋と段を取得する。
    int fileFrom = outFrom.x();
    int rankFrom = outFrom.y();
    int fileTo = outTo.x();
    int rankTo = outTo.y();

    // 移動元のマスの駒文字を取得する。
    QChar source = board()->getPieceCharacter(fileFrom, rankFrom);

    // 移動先のマスの駒文字を取得する。
    QChar dest = board()->getPieceCharacter(fileTo, rankTo);

    // 手番の設定（移動元の駒の大文字/小文字から推定）
    if (source.isUpper()) {
        setCurrentPlayer(Player1);
    } else {
        setCurrentPlayer(Player2);
    }

    // 禁じ手をチェックする。
    if (!checkMovePiece(source, dest, fileFrom, fileTo)) return false;

    // 歩、桂馬、香車を指した場合に成が必須になる時のフラグの設定
    setMandatoryPromotionFlag(fileTo, rankTo, source);

    // 将棋盤と駒台の駒数を更新する。
    board()->updateBoardAndPieceStand(source, dest, fileFrom, rankFrom, fileTo, rankTo, m_promote);

    return true;
}

// 禁じ手をチェックする。
bool ShogiGameController::checkMovePiece(const QChar source, const QChar dest, const int fileFrom, const int fileTo) const
{
    // 二歩のところには歩は指せない。
    if (!checkTwoPawn(source, fileFrom, fileTo)) return false;

    // 味方の駒があるところには指せない。
    if (!checkWhetherAllyPiece(source, dest, fileFrom, fileTo)) return false;

    // 駒台から指そうとした場合、駒台の駒数が0以下の時は、駒台の駒は無いので指せない。
    if (!checkNumberStandPiece(source, fileFrom)) return false;

    // 先手の駒台の駒から後手の駒台の異種駒には、駒は移せない。
    // また、後手の駒台の駒から先手の駒台の異種駒には、駒は移せない。
    if (!checkFromPieceStandToPieceStand(source, dest, fileFrom, fileTo)) return false;

    // 王、玉は、相手の駒で取ることはできない。
    if (!checkGetKingOpponentPiece(source, dest)) return false;

    // 禁じ手のチェックはOKで指せる。
    return true;
}

// 駒台から指そうとした場合、駒台の駒数が0以下の時は、駒台の駒は無いので指せない。
bool ShogiGameController::checkNumberStandPiece(const QChar source, const int fileFrom) const
{
    return board()->isPieceAvailableOnStand(source, fileFrom);
}

// 指そうとした場所に味方の駒があるかどうかチェックする。
bool ShogiGameController::checkWhetherAllyPiece(const QChar source, const QChar dest, const int fileFrom, const int fileTo) const
{
    if (fileTo < 10) {
        // 選択した駒と指そうとした先のマスの駒が大文字の場合、味方の駒になる。
        if (source.isUpper() && dest.isUpper()) {
            if ((fileFrom < 10) && (fileTo > 9)) {
                return true;
            } else {
                return false;
            }
        }
        // 選択した駒と指そうとした先のマスの駒が小文字の場合、相手にとっては味方の駒になる。
        if (source.isLower() && dest.isLower()) {
            if ((fileFrom < 10) && (fileTo > 9)) {
                return true;
            } else {
                return false;
            }
        }
    }

    // それ以外は指せる。
    return true;
}

// 二歩になるかどうかをチェックする。
bool ShogiGameController::checkTwoPawn(const QChar source, const int fileFrom, const int fileTo) const
{
    // 筋が同じマスに移動させる場合は、二歩にならないので指せる。
    if (fileFrom == fileTo) return true;

    // 移動元の駒が先手あるいは下手の歩である場合
    if (source == 'P') {
        // 移動先が将棋盤内の場合
        if (fileTo < 10) {
            // 段
            for (int rank = 1; rank <= 9; rank++) {
                // 移動先の段に先手あるいは下手の歩が存在している場合は、二歩になるので指せない。
                if (board()->getPieceCharacter(fileTo, rank) == 'P') return false;
            }
        }
    }

    // 移動元の駒が後手あるいは上手の歩である場合
    if (source == 'p') {
        // 移動先が将棋盤内の場合
        if (fileTo < 10) {
            // 段
            for (int rank = 1; rank <= 9; rank++) {
                // 移動先の段に後手あるいは上手の歩が存在している場合は、二歩になるので指せない。
                if (board()->getPieceCharacter(fileTo, rank) == 'p') return false;
            }
        }
    }

    // 二歩にならないので指せる。
    return true;
}

// 歩、桂馬、香車を指した場合に成りが必須になる時のフラグを設定する。
void ShogiGameController::setMandatoryPromotionFlag(const int fileTo, const int rankTo, const QChar source)
{
    // 成る・不成のフラグを初期値として不成に設定する。
    m_promote = false;

    // 指そうとしたところが駒台の場合は不成。
    if (fileTo >= 10) {
        return;
    }

    // 先手あるいは下手の歩を一段目に指す場合は、必ず成る。
    if ((source == 'P' && rankTo == 1) ||
        // 先手あるいは下手の香車を一段目に指す場合は、必ず成る。
        (source == 'L' && rankTo == 1) ||
        // 先手あるいは下手の桂馬を一、二段目に指す場合は、必ず成る。
        (source == 'N' && rankTo <= 2)) {
        m_promote = true;

        return;
    }

    // 後手あるいは上手の歩を九段目に指す場合は、必ず成る。
    if ((source == 'p' && rankTo == 9) ||
        // 後手あるいは上手の香車を九段目に指す場合は、必ず成る。
        (source == 'l' && rankTo == 9) ||
        // 後手あるいは上手の桂馬を八、九段目に指す場合は、必ず成る。
        (source == 'n' && rankTo >= 8)) {
        m_promote = true;

        return;
    }
}

// 対局結果を設定する。
void ShogiGameController::gameResult()
{
    // 後手あるいは上手の場合
    if (currentPlayer() == Player2) {
        // 先手あるいは下手の勝ちに設定する。
        setResult(Player1Wins);
    }
    // 先手あるいは下手の場合
    else if (currentPlayer() == Player1) {
        // 後手あるいは上手の勝ちに設定する。
        setResult(Player2Wins);
    }
}

// 編集局面モードの際、右クリックで駒を成・不成に変換する。
void ShogiGameController::switchPiecePromotionStatusOnRightClick(const int fileFrom, const int rankFrom) const
{
    if (!board()) return;

    // 二歩や段の必成などの禁止形スキップは board 側で一括処理する
    board()->promoteOrDemotePiece(fileFrom, rankFrom);
}


// 駒台から駒台に駒を移動することが可能かどうかをチェックする。
// 先手の駒台の駒から後手の駒台の異種駒には、駒は移せない。
// また、後手の駒台の駒から先手の駒台の異種駒には、駒は移せない。
bool ShogiGameController::checkFromPieceStandToPieceStand(const QChar source, const QChar dest, const int fileFrom, const int fileTo) const
{
    // 先手の駒台から後手の駒台に駒を移す。
    if ((fileFrom == 10) && (fileTo == 11)) {
        // dest を大文字に変換
        QChar c = dest.toUpper();
        // 同じ種類の駒の時
        if (source == c) {
            // 移せる。
            return true;
        // 同じ種類の駒でない時
        } else {
            // 移せない。
            return false;
        }
    }
    // 後手の駒台から先手の駒台に駒を移す。
    if ((fileFrom == 11) && (fileTo == 10)) {
        // dest を小文字に変換
        QChar c = dest.toLower();
        // 同じ種類の駒の時
        if (source == c) {
            // 移せる。
            return true;
        // 同じ種類の駒でない時
        } else {
            // 移せない。
            return false;
        }
    }

    // 移せる。
    return true;
}

// 王、玉は、相手の駒で取ることはできないので、取れない場合はfalseを返す。
bool ShogiGameController::checkGetKingOpponentPiece(const QChar source, const QChar dest) const
{
    // 後手の駒で先手王を取ろうとした場合
    if ((dest == 'K') && source.isLower()) return false;

    // 先手の駒で後手玉を取ろうとした場合
    if ((dest == 'k') && source.isUpper()) return false;

    // 取れる。
    return true;
}

// 局面編集後の局面を SFEN 形式に変換し、リストに 0手局面として追加する。
void ShogiGameController::updateSfenRecordAfterEdit(QStringList* m_sfenRecord)
{
    // ★ 異常ガード：盤/出力が無い
    if (!board()) {
        const QString errorMessage =
            tr("An error occurred in ShogiGameController::updateSfenRecordAfterEdit: board() is null.");
        emit errorOccurred(errorMessage);
        return; // 打ち切り
    }
    if (!m_sfenRecord) {
        const QString errorMessage =
            tr("An error occurred in ShogiGameController::updateSfenRecordAfterEdit: record list is null.");
        emit errorOccurred(errorMessage);
        return; // 打ち切り
    }

    // moveIndex=-1 を渡すと addSfenRecord 側の (+2) で " 1 " になる仕様
    const int moveIndex = -1;

    // 編集メニューの「手番変更」に追従
    const QString nextTurn = (currentPlayer() == ShogiGameController::Player1)
                                 ? QStringLiteral("b") : QStringLiteral("w");

    // 現在の gameBoard を 0手局面として登録
    board()->addSfenRecord(nextTurn, moveIndex, m_sfenRecord);
}

QPoint ShogiGameController::lastMoveTo() const
{
    // previousFileTo/previousRankTo は 1..9（盤上）または 0（未設定）想定
    return QPoint(previousFileTo, previousRankTo);
}

void ShogiGameController::applyTimeoutLossFor(int clockPlayer)
{
    // すでに結果が付いているなら何もしない
    if (m_result != NoResult) return;

    // clockPlayer: 1 or 2（それ以外は無視）
    if (clockPlayer == 1) {
        // 先手（Player1）が時間切れ → 後手（Player2）の勝ち
        setResult(Player2Wins);
    } else if (clockPlayer == 2) {
        // 後手（Player2）が時間切れ → 先手（Player1）の勝ち
        setResult(Player1Wins);
    } else {
        // 不正値は無視（必要ならエラー通知も可）
        // emit errorOccurred(tr("applyTimeoutLossFor: invalid player %1").arg(clockPlayer));
    }
}

void ShogiGameController::applyResignationOfCurrentSide()
{
    // すでに結果が付いているなら何もしない
    if (m_result != NoResult) return;

    // 現在手番側が投了 → 相手の勝ち
    if (m_currentPlayer == Player1) {
        setResult(Player2Wins);
    } else if (m_currentPlayer == Player2) {
        setResult(Player1Wins);
    } else {
        // 手番未設定時は安全側に倒して引き分け扱い（必要に応じて変更可）
        // emit errorOccurred(tr("applyResignationOfCurrentSide: current player is invalid."));
        setResult(Draw);
    }
}

void ShogiGameController::finalizeGameResult()
{
    // 既に確定していれば何もしない
    if (m_result != NoResult) return;

    // ここまで来て未確定なら、currentPlayer に基づく既存の決定ロジックを利用
    // （あなたの既存メソッド：現手番が後手なら先手勝ち、現手番が先手なら後手勝ち）
    gameResult();
}
#include "shogiinforecord.h"

// GUIの思考タブの表に「時間」「深さ」「ノード数」「評価値」「読み筋」をセットするためのクラス
// コンストラクタ
ShogiInfoRecord::ShogiInfoRecord(QObject* parent) : QObject(parent)
{
}

// コンストラクタ
ShogiInfoRecord::ShogiInfoRecord(const QString& time, const QString& depth, const QString& nodes,
                                const QString& score, const QString& pv, QObject* parent)
    : ShogiInfoRecord(parent)
{
    // 時間、深さ、ノード数、評価値、読み筋をセットする。
    m_time = time;
    m_depth = depth;
    m_nodes = nodes;
    m_score = score;
    m_pv = pv;
}

// 思考時間を取得する。
QString ShogiInfoRecord::time() const
{
    return m_time;
}

// 現在思考探索中の手の探索深さを取得する。
QString ShogiInfoRecord::depth() const
{
    return m_depth;
}

// 思考開始から探索したノード数を取得する。
QString ShogiInfoRecord::nodes() const
{
    return m_nodes;
}

// 現在の評価値を取得する。
QString ShogiInfoRecord::score() const
{
    return m_score;
}

// 現在の読み筋を取得する。
QString ShogiInfoRecord::pv() const
{
    return m_pv;
}
#include "shogimove.h"

ShogiMove::ShogiMove()
    : fromSquare(0, 0), toSquare(0, 0), movingPiece(' '), capturedPiece(' '), isPromotion(false) {}

ShogiMove::ShogiMove(const QPoint& from, const QPoint& to, QChar moving, QChar captured, bool promotion)
    : fromSquare(from), toSquare(to), movingPiece(moving), capturedPiece(captured), isPromotion(promotion) {}

// 構造体ShogiMoveの比較演算子定義
// これにより直接"=="で指し手を比較できる。
bool ShogiMove::operator==(const ShogiMove& other) const {
    return fromSquare == other.fromSquare
            && toSquare == other.toSquare
            && movingPiece == other.movingPiece
            && capturedPiece == other.capturedPiece
            && isPromotion == other.isPromotion;
}

// 構造体ShogiMoveのデバッグプリント用演算子"<<"の定義
std::ostream& operator<<(std::ostream& os, const ShogiMove& move) {
    os << "From: (" << move.fromSquare.x() + 1 << ", " << move.fromSquare.y() + 1 << ')';
    os << " To: (" << move.toSquare.x() + 1 << ", " << move.toSquare.y() + 1 << ')';
    os << " Moving Piece: " << move.movingPiece.toLatin1();
    os << " Captured Piece: " << move.capturedPiece.toLatin1();
    os << " Promotion: " << (move.isPromotion ? "true" : "false");
    return os;
}

// ...既存コードの下に追加
QDebug operator<<(QDebug dbg, const ShogiMove& move) {
    QDebugStateSaver saver(dbg);
    auto disp = [](int v) -> int {
        // 盤上(0..8)は +1 表示、駒台(9,10など)はそのまま
        return (0 <= v && v <= 8) ? (v + 1) : v;
    };

    dbg.nospace()
        << "From:(" << disp(move.fromSquare.x()) << "," << disp(move.fromSquare.y()) << ") "
        << "To:("   << disp(move.toSquare.x())   << "," << disp(move.toSquare.y())   << ") "
        << "Moving:"   << move.movingPiece
        << " Captured:" << move.capturedPiece
        << " Promotion:" << (move.isPromotion ? "true" : "false");
    return dbg;
}
#include "shogiutils.h"
#include "errorbus.h"
#include <QStringList>
#include <QDebug>
#include <QAtomicInteger>
#include <QObject>

namespace ShogiUtils {

// 指した先のマスの段を漢字表記で出力する。
QString transRankTo(const int rankTo)
{
    static const QStringList rankStrings = { "", "一", "二", "三", "四", "五", "六", "七", "八", "九" };

    if (rankTo < 1 || rankTo > 9) {
        const QString msg = QObject::tr("The rank must be a value between 1 and 9. (got %1)")
        .arg(rankTo);
        qWarning().noquote() << "[ShogiUtils]" << msg;
        ErrorBus::instance().postError(msg);     // ← ここで通知
        return QString();                        // 呼び出し側で空チェックして早期return
    }
    return rankStrings.at(rankTo);               // 範囲内なので at() でも安全
}

// 指した先のマスの筋を漢字表記で出力する。
QString transFileTo(const int fileTo)
{
    static const QStringList fileStrings = { "", "１", "２", "３", "４", "５", "６", "７", "８", "９" };

    if (fileTo < 1 || fileTo > 9) {
        const QString msg = QObject::tr("The file must be a value between 1 and 9. (got %1)")
        .arg(fileTo);
        qWarning().noquote() << "[ShogiUtils]" << msg;
        ErrorBus::instance().postError(msg);     // ← 通知
        return QString();
    }
    return fileStrings.at(fileTo);
}

} // namespace ShogiUtils

namespace {
QElapsedTimer g_gameEpoch;
QAtomicInteger<bool> g_epochStarted(false);
}

void ShogiUtils::startGameEpoch() {
    g_gameEpoch.start();
    g_epochStarted.storeRelease(true);
}

qint64 ShogiUtils::nowMs() {
    if (!g_epochStarted.loadAcquire()) return 0;
    return g_gameEpoch.elapsed();
}
#include "turnmanager.h"
#include <QString>

TurnManager::TurnManager(QObject* parent)
    : QObject(parent)
    , m_side(ShogiGameController::NoPlayer)
{}

TurnManager::Side TurnManager::side() const {
    return m_side;
}

void TurnManager::set(Side s) {
    const Side norm =
        (s == ShogiGameController::Player2) ? ShogiGameController::Player2 :
            (s == ShogiGameController::Player1) ? ShogiGameController::Player1 :
            ShogiGameController::Player1;

    if (m_side == norm) return;
    m_side = norm;
    emit changed(m_side);
}

void TurnManager::toggle() {
    set(m_side == ShogiGameController::Player1
            ? ShogiGameController::Player2
            : ShogiGameController::Player1);
}

QString TurnManager::toSfenToken() const {
    return (m_side == ShogiGameController::Player2)
    ? QStringLiteral("w")
    : QStringLiteral("b");
}

void TurnManager::setFromSfenToken(const QString& bw) {
    const auto s = (bw.compare(QStringLiteral("w"), Qt::CaseInsensitive) == 0)
    ? ShogiGameController::Player2
    : ShogiGameController::Player1;
    set(s);
}

int TurnManager::toClockPlayer() const {
    return (m_side == ShogiGameController::Player2) ? 2 : 1;
}

void TurnManager::setFromClockPlayer(int p) {
    set(p == 2 ? ShogiGameController::Player2
               : ShogiGameController::Player1);
}

ShogiGameController::Player TurnManager::toGc() const {
    return m_side;
}

void TurnManager::setFromGc(ShogiGameController::Player p) {
    set(p);
}
#include "turnsyncbridge.h"

#include "shogigamecontroller.h"
#include "turnmanager.h"

#include <QObject>

TurnSyncBridge::TurnSyncBridge(QObject* parent)
    : QObject(parent)
{}

void TurnSyncBridge::wire(ShogiGameController* gc, TurnManager* tm, QObject* uiReceiver)
{
    if (!gc || !tm || !uiReceiver) return;

    QObject::connect(gc, &ShogiGameController::currentPlayerChanged,
                     tm, &TurnManager::setFromGc,
                     Qt::UniqueConnection);

    // TurnManager::changed(ShogiGameController::Player) -> MainWindow::onTurnManagerChanged(...)
    QObject::connect(tm, SIGNAL(changed(ShogiGameController::Player)),
                     uiReceiver, SLOT(onTurnManagerChanged(ShogiGameController::Player)),
                     Qt::UniqueConnection);

    // 初期同期
    tm->setFromGc(gc->currentPlayer());
}
﻿#include "changeenginesettingsdialog.h"
#include "enginesettingsconstants.h"
#include "ui_changeenginesettingsdialog.h"
#include <QSettings>
#include <QGroupBox>
#include <QPushButton>
#include <QDir>
#include <QFileDialog>

using namespace EngineSettingsConstants;

// 将棋エンジンの設定を変更するダイアログ
// コンストラクタ
ChangeEngineSettingsDialog::ChangeEngineSettingsDialog(QWidget *parent)
    : QDialog(parent), ui(new Ui::ChangeEngineSettingsDialog)
{
    ui->setupUi(this);
}

// デストラクタ
ChangeEngineSettingsDialog::~ChangeEngineSettingsDialog()
{
    delete ui;
}

// 将棋エンジン番号のsetter
void ChangeEngineSettingsDialog::setEngineNumber(const int& engineNumber)
{
    m_engineNumber = engineNumber;
}

// 将棋エンジン名のsetter
void ChangeEngineSettingsDialog::setEngineName(const QString& engineName)
{
    m_engineName = engineName;
}

// 設定ファイルから選択したエンジンのオプションを読み込む。
void ChangeEngineSettingsDialog::readEngineOptions()
{
    // オプションリストを初期化する。
    m_optionList.clear();

    // 設定ファイルを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // エンジンオプションの数を取得する。
    int size = settings.beginReadArray(m_engineName);

    // エンジンオプションの数だけ繰り返す。
    for (int i = 0; i < size; i++) {
        settings.setArrayIndex(i);

        // オプションリストに読み込んだオプションを追加する。
        m_optionList.append(readOption(settings));
    }

    // エンジン名のグループの配列の読み込みを終了する。
    settings.endArray();
}

// 一つのオプションを読み込む。
EngineOption ChangeEngineSettingsDialog::readOption(const QSettings& settings) const
{
    EngineOption option;

    option.name = settings.value(EngineOptionNameKey).toString();
    option.type = settings.value(EngineOptionTypeKey).toString();
    option.defaultValue = settings.value(EngineOptionDefaultKey).toString();
    option.min = settings.value(EngineOptionMinKey).toString();
    option.max = settings.value(EngineOptionMaxKey).toString();
    option.currentValue = settings.value(EngineOptionValueKey).toString();
    QString valueListStr = settings.value(EngineOptionValueListKey).toString();

    // 空の文字列をスキップ
    option.valueList = valueListStr.split(" ", Qt::SkipEmptyParts);

    return option;
}

// "エンジン設定"ダイアログを作成する。
void ChangeEngineSettingsDialog::setupEngineOptionsDialog()
{
    // 設定ファイルから選択したエンジンのオプションを読み込む。
    readEngineOptions();

    // エンジンオプションを設定する画面を作成する。
    createOptionWidgets();
}

// 各ボタンが押されているかどうかを確認し、ボタンの色を設定する。
void ChangeEngineSettingsDialog::changeStatusColorTypeButton()
{
    // オプション数までループする。
    for (int i = 0; i < m_engineOptionWidgetsList.size(); i++) {
        // オプションタイプが"button"の場合
        if (m_optionList.at(i).type == "button") {
            m_engineOptionWidgetsList.at(i).selectionButton->setProperty("index", i);

            // ボタンが押された場合、ボタンの色を変える。
            connect(m_engineOptionWidgetsList.at(i).selectionButton, &QPushButton::clicked, this, &ChangeEngineSettingsDialog::changeColorTypeButton);
        }
    }
}

// ボタンが押された場合、ボタンの色を変える。
void ChangeEngineSettingsDialog::changeColorTypeButton()
{
    // イベントを送信したオブジェクト（ボタン）へのポインタを取得し、QPushButton型にキャストする。
    QPushButton* pButton = qobject_cast<QPushButton *>(sender());

    // ボタンのプロパティから、どのボタンがクリックされたのかを識別するためのインデックスを取得する。
    int index = qvariant_cast<int>(pButton->property("index"));

    // ボタンが押された状態の場合
    if (m_engineOptionWidgetsList.at(index).selectionButton->isChecked()) {
        m_engineOptionWidgetsList.at(index).selectionButton->setStyleSheet("background-color: #3daee9; color: white");
    }
    // ボタンが押されていない場合
    else {
        m_engineOptionWidgetsList.at(index).selectionButton->setStyleSheet("");
    }
}

// エンジンオプションのためのテキストボックスを作成する。
void ChangeEngineSettingsDialog::createTextBox(const EngineOption& option, QVBoxLayout* layout)
{
    // オプション名でラベルを作成する。
    m_optionWidgets.optionNameLabel = new QLabel(tr("%1（既定値 %2）").arg(option.name, option.defaultValue), this);

    // テキスト入力用のLineEditを作成する。
    m_optionWidgets.lineEdit = new QLineEdit(this);

    // 現在値をセットする。
    m_optionWidgets.lineEdit->setText(option.currentValue);

    // ファイルタイプを判定して対応するボタンを作成する。
    m_optionWidgets.selectionButton = new QPushButton(this);

    // デフォルトをファイルタイプに設定する。
    EngineSettings::FileType fileType = EngineSettings::FileType::File;

    // オプション名に"Dir"もしくは"dir"が含まれるかチェックして、対応するボタンのテキストを設定する。
    if (option.name.contains("Dir", Qt::CaseInsensitive)) {
        m_optionWidgets.selectionButton->setText(tr("フォルダ・ディレクトリの選択"));

        // ディレクトリタイプに設定
        fileType = EngineSettings::FileType::Directory;
    } else {
        m_optionWidgets.selectionButton->setText(tr("ファイルの選択"));

        // ファイルタイプに設定する。
        fileType = EngineSettings::FileType::File;
    }

    // ボタンのプロパティにインデックスとファイルタイプを設定する。
    // layoutに既に追加された要素の数をインデックスとして使用する。
    m_optionWidgets.selectionButton->setProperty("index", layout->count());
    m_optionWidgets.selectionButton->setProperty("fileType", static_cast<int>(fileType));

    // ボタンのクリックイベントに対するスロットを接続
    connect(m_optionWidgets.selectionButton, &QPushButton::clicked, this, &ChangeEngineSettingsDialog::openFile);

    // UI要素を指定されたレイアウトに追加する。
    layout->addWidget(m_optionWidgets.optionNameLabel);
    layout->addWidget(m_optionWidgets.lineEdit);
    layout->addWidget(m_optionWidgets.selectionButton);

    // テキストボックスのオブジェクト名を設定
    m_optionWidgets.lineEdit->setObjectName(option.name);
}

// エンジンオプションのためのスピンボックスを作成する。
void ChangeEngineSettingsDialog::createSpinBox(const EngineOption& option, QVBoxLayout* layout)
{
    m_optionWidgets.optionNameLabel = new QLabel(tr("%1").arg(option.name), this);

    // オプション名が"USI_Hash"の場合、入力値制限についてのラベルを作成する。
    if (option.name == "USI_Hash") {
        m_optionWidgets.optionDescriptionLabel = new QLabel(tr("%1 以上の値を入力してください。（既定値: %2）")
                                    .arg(option.min, option.defaultValue), this);
    } else {
        m_optionWidgets.optionDescriptionLabel = new QLabel(tr("%1 から %2 までの値を入力してください。（既定値: %3）")
                                    .arg(option.min, option.max, option.defaultValue), this);
    }

    // スピンボックスを作成する。
    m_optionWidgets.integerSpinBox = new LongLongSpinBox(this);

    // スタイルシートの確認と修正
    m_optionWidgets.integerSpinBox->setStyleSheet("");

    // スピンボックスの範囲を設定する。オプションのminとmaxを使用する。
    m_optionWidgets.integerSpinBox->setSpinBoxRange(option.min.toLongLong(), option.max.toLongLong());

    // スピンボックスの現在値を設定する。オプションの現在値を使用する。
    m_optionWidgets.integerSpinBox->setSpinBoxValue(option.currentValue.toLongLong());

    // スピンボックスのフォーカスポリシーを設定する。これはマウスクリックによってのみフォーカスされるようにするためである。
    m_optionWidgets.integerSpinBox->setFocusPolicy(Qt::ClickFocus);

    // このダイアログ自体をスピンボックスのイベントフィルタとしてインストールする。これにより、特定のイベントをこのダイアログで処理できるようになる。
    m_optionWidgets.integerSpinBox->installEventFilter(this);

    // オプション名のラベルとスピンボックスをレイアウトに追加する。
    layout->addWidget(m_optionWidgets.optionNameLabel);
    layout->addWidget(m_optionWidgets.optionDescriptionLabel);
    layout->addWidget(m_optionWidgets.integerSpinBox);

    // スピンボックスのオブジェクト名を設定
    m_optionWidgets.integerSpinBox->setObjectName(option.name);
}

// エンジンオプションのためのチェックボックスを作成する。
void ChangeEngineSettingsDialog::createCheckBox(const EngineOption& option, QVBoxLayout* layout)
{
    // チェックボックスを作成
    m_optionWidgets.optionCheckBox = new QCheckBox(this);

    // チェックボックスにオプション名と既定値のテキストをセット
    m_optionWidgets.optionCheckBox->setText(tr("%1（既定値 %2）").arg(option.name, option.defaultValue));

    // 設定ファイルのオプションの現在値に基づいてチェック状態を設定
    m_optionWidgets.optionCheckBox->setChecked(option.currentValue == "true");

    // チェックボックスをレイアウトに追加
    layout->addWidget(m_optionWidgets.optionCheckBox);

    // ここで、チェックボックスのオブジェクト名をオプション名に基づいて設定しておくことで、
    // 後で特定のオプションに対応するチェックボックスを識別できるようにしておく。
    m_optionWidgets.optionCheckBox->setObjectName(option.name);
}

// エンジンオプションのためのボタンを作成する。
void ChangeEngineSettingsDialog::createButton(const EngineOption& option, QVBoxLayout* layout)
{
    // ボタンの作成
    m_optionWidgets.selectionButton = new QPushButton(option.name, this);

    // ボタンのチェック可能状態を設定（オン/オフスイッチのように使用）
    m_optionWidgets.selectionButton->setCheckable(true);

    // ボタンの現在値に基づいてチェック状態を設定
    m_optionWidgets.selectionButton->setChecked(option.currentValue == "on");

    // ボタンのスタイルをチェック状態に応じて設定
    if (m_optionWidgets.selectionButton->isChecked()) {
        m_optionWidgets.selectionButton->setStyleSheet("background-color: #3daee9; color: white");
    } else {
        m_optionWidgets.selectionButton->setStyleSheet("");
    }

    // ボタンをレイアウトに追加
    layout->addWidget(m_optionWidgets.selectionButton);

    // ボタンのオブジェクト名を設定
    m_optionWidgets.selectionButton->setObjectName(option.name);
}

// エンジンオプションのためのコンボボックスを作成する。
void ChangeEngineSettingsDialog::createComboBox(const EngineOption& option, QVBoxLayout* layout)
{
    // オプション名のラベルを作成
    m_optionWidgets.optionNameLabel = new QLabel(tr("%1（既定値 %2）").arg(option.name, option.defaultValue), this);

    // コンボボックスを作成
    m_optionWidgets.comboBox = new QComboBox(this);
    m_optionWidgets.comboBox->setFocusPolicy(Qt::StrongFocus);
    m_optionWidgets.comboBox->installEventFilter(this);

    // コンボボックスに選択肢を追加
    for (const QString& value : option.valueList) {
        m_optionWidgets.comboBox->addItem(value);
    }

    // コンボボックスの現在選択をオプションの現在値に設定
    int currentIndex = m_optionWidgets.comboBox->findText(option.currentValue);
    if (currentIndex != -1) { // 該当する項目が見つかった場合
        m_optionWidgets.comboBox->setCurrentIndex(currentIndex);
    }

    // ラベルとコンボボックスをレイアウトに追加
    layout->addWidget(m_optionWidgets.optionNameLabel);
    layout->addWidget(m_optionWidgets.comboBox);

    // コンボボックスのオブジェクト名を設定
    m_optionWidgets.comboBox->setObjectName(option.name);
}

// オプションのタイプに応じたUIコンポーネントを作成し、レイアウトに追加する。
void ChangeEngineSettingsDialog::createWidgetForOption(const EngineOption& option)
{
    // オプションタイプが"filename"か"string"の場合
    if (option.type == "filename" || option.type == "string") {
        // エンジンオプションのためのテキストボックスを作成する。
        createTextBox(option, optionWidgetsLayout);
    }
    // オプションタイプが"spin"の場合
    else if (option.type == "spin") {
        // エンジンオプションのためのスピンボックスを作成する。
        createSpinBox(option, optionWidgetsLayout);
    }
    // オプションタイプが"check"の場合
    else if (option.type == "check") {
        // エンジンオプションのためのチェックボックスを作成する。
        createCheckBox(option, optionWidgetsLayout);
    }
    // オプションタイプが"button"の場合
    else if (option.type == "button") {
        // エンジンオプションのためのボタンを作成する。
        createButton(option, optionWidgetsLayout);

    }
    // オプションタイプが"combo"の場合
    else if (option.type == "combo") {
        // エンジンオプションのためのコンボボックスを作成する。
        createComboBox(option, optionWidgetsLayout);
    }
}

// エンジンオプションに基づいてUIコンポーネントを作成して配置する。
void ChangeEngineSettingsDialog::createOptionWidgets()
{
    // 設定画面の上部にエンジン名を表示する。
    ui->label->setText(m_engineName);

    // 画面レイアウトを作成する。
    optionWidgetsLayout = new QVBoxLayout;

    // オプション数でループさせる。
    for (const auto& option : std::as_const(m_optionList)) {
        // オプションのタイプに応じたUIコンポーネントを作成し、レイアウトに追加する。
        createWidgetForOption(option);

        // 各オプションの状態をメニューリストに追加する。
        m_engineOptionWidgetsList.append(m_optionWidgets);
    }

    // 各ボタンが押されているかどうかを確認し、ボタンの色を設定する。
    changeStatusColorTypeButton();

    // レイアウトを上部に配置する。
    optionWidgetsLayout->setAlignment(Qt::AlignTop);

    // ダイアログのスクロールアリアのウィジェットにレイアウトをセットする。
    ui->scrollAreaWidgetContents->setLayout(optionWidgetsLayout);
    ui->scrollArea->setWidget(ui->scrollAreaWidgetContents);

    // ダイアログの最後に適用ボタンを表示する。
    ui->buttonBox->button(QDialogButtonBox::Ok)->setText(tr("適用"));

    // "既定値に戻す"ボタンが押された場合、全てのオプションを既定値に戻す。
    connect(ui->restoreButton, &QPushButton::clicked, this, &ChangeEngineSettingsDialog::restoreDefaultOptions);

    // "適用"ボタンが押された場合、全てのオプションの設定を保存してエンジン設定ダイアログを終了する。
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept);
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &ChangeEngineSettingsDialog::writeEngineOptions);

    // "Cancel"ボタンが押された場合、エンジン設定ダイアログを保存せずに終了する。
    connect(ui->buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);

    // ダイアログのサイズをコンテンツに合わせて固定する。
    this->setFixedSize(this->geometry().width(), this->geometry().height());
}

// ファイルまたはディレクトリの選択ダイアログを開き、選択されたパスを返す。
QString ChangeEngineSettingsDialog::openSelectionDialog(QWidget* parent, int fileType, const QString& initialDir)
{
    QString selectedPath;

    // fileTypeに応じて、適切なダイアログを開く
    if (fileType == 1) { // ディレクトリ選択
        selectedPath = QFileDialog::getExistingDirectory(parent, QObject::tr("フォルダ・ディレクトリの選択"), initialDir);
    } else { // ファイル選択
        selectedPath = QFileDialog::getOpenFileName(parent, QObject::tr("ファイルの選択"), initialDir);
    }

    // 選択されたパスが空でない場合にのみ、システムに適したパス形式に変換する。
    if (!selectedPath.isEmpty()) {
        selectedPath = QDir::toNativeSeparators(selectedPath);
    }

    return selectedPath;
}

// 設定画面で"フォルダ・ディレクトリの選択"ボタンあるいは"ファイルの選択"ボタンをクリックした場合にディレクトリ、ファイルを選択する画面を表示する。
void ChangeEngineSettingsDialog::openFile()
{
    // イベントを送信したオブジェクト（ボタン）へのポインタを取得し、QPushButton型にキャストする。
    QPushButton* pButton = qobject_cast<QPushButton*>(sender());

    // ボタンのプロパティから、どのボタンがクリックされたのかを識別するためのインデックスを取得する。
    int index = qvariant_cast<int>(pButton->property("index"));

    // ボタンのプロパティから、ファイル選択かディレクトリ選択かを識別するためのタイプを取得する。
    int fileType = qvariant_cast<int>(pButton->property("filetype"));

    // 汎用の選択ダイアログを使って、ファイルまたはディレクトリのパスを取得する。
    QString selectedPath = openSelectionDialog(this, fileType);

    // 選択されたパスが空ではない場合、対応する設定画面のフィールドにパスを設定する。
    if (!selectedPath.isEmpty()) {
        m_engineOptionWidgetsList.at(index).lineEdit->setText(selectedPath);
    }
}

// エンジンオプションを既定値に戻す。
void ChangeEngineSettingsDialog::restoreDefaultOptions() {
    // エンジンオプションの数だけ繰り返し、各オプションウィジェットに既定値を設定する
    for (int i = 0; i < m_optionList.size(); ++i) {
        const auto& option = m_optionList[i]; // 現在のオプションを参照
        auto& widget = m_engineOptionWidgetsList[i]; // 対応するウィジェットを参照

        // オプションタイプに応じた既定値の設定
        if (option.type == "filename" || option.type == "string") {
            // ファイル名または文字列オプションの場合、LineEditに既定値を設定
            widget.lineEdit->setText(option.defaultValue);
        } else if (option.type == "spin") {
            // 数値オプションの場合、SpinBoxに既定値を設定（文字列を数値に変換）
            widget.integerSpinBox->setSpinBoxValue(option.defaultValue.toLongLong());
        } else if (option.type == "check") {
            // チェックボックスオプションの場合、既定値が"true"ならチェック
            widget.optionCheckBox->setChecked(option.defaultValue == "true");
        } else if (option.type == "button") {
            // ボタンオプションの場合、既定値が"on"ならボタンをチェック状態に
            bool isChecked = option.defaultValue == "on";
            widget.selectionButton->setChecked(isChecked);
            // チェック状態に応じてボタンのスタイルを変更
            widget.selectionButton->setStyleSheet(isChecked ? "background-color: #3daee9; color: white" : "");
        } else if (option.type == "combo") {
            // コンボボックスオプションの場合、既定値に基づいて選択肢を設定
            widget.comboBox->clear(); // 既存の選択肢をクリア
            for (const auto& value : option.valueList) {
                // 選択可能な値を追加
                widget.comboBox->addItem(value);
            }
            // 既定値に対応する選択肢を選択状態に
            int index = widget.comboBox->findText(option.defaultValue);
            if (index != -1) widget.comboBox->setCurrentIndex(index);
        }
    }
}

// 設定ファイルにエンジンのオプション設定を保存する。
void ChangeEngineSettingsDialog::saveOptionsToSettings()
{
    // 設定ファイルを操作するためのQSettingsオブジェクトを作成する。ファイル名とフォーマットを指定。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // 設定ファイル内でエンジン名に基づくオプションの配列の書き込みを開始する。
    settings.beginWriteArray(m_engineName);

    // 配列内の位置を指示するためのインデックス変数。
    int index = 0;

    // オプションリストの各オプションに対してループを実行する。
    for (const auto& option : std::as_const(m_optionList)) {
        // 現在のインデックスで配列の要素を設定する。
        settings.setArrayIndex(index);

        // オプションの現在の値を設定ファイルに保存。
        settings.setValue("value", option.currentValue);

        // 次のオプションのためにインデックスをインクリメント。
        ++index;
    }

    // 配列の書き込みを終了する。
    settings.endArray();
}

// 設定ファイルに追加エンジンのオプションを書き込む。
void ChangeEngineSettingsDialog::writeEngineOptions()
{
    // エンジンオプションの数だけ繰り返す。
    for (int i = 0; i < m_optionList.size(); i++) {
        EngineOption option = m_optionList.at(i);

        if (option.type == "filename" || option.type == "string") {
            option.currentValue = m_engineOptionWidgetsList.at(i).lineEdit->text();
        } else if (option.type == "spin") {
            option.currentValue = QString::number(m_engineOptionWidgetsList.at(i).integerSpinBox->value());
        } else if (option.type == "check") {
            option.currentValue = m_engineOptionWidgetsList.at(i).optionCheckBox->isChecked() ? "true" : "false";
        } else if (option.type == "button") {
            option.currentValue = m_engineOptionWidgetsList.at(i).selectionButton->isChecked() ? "on" : "";
        } else if (option.type == "combo") {
            option.currentValue = m_engineOptionWidgetsList.at(i).comboBox->currentText();
        }

        m_optionList.replace(i, option);
    }

    // 設定ファイルにエンジンのオプション設定を保存する。
    saveOptionsToSettings();
}

// イベントフィルター関数。QObject型のobjとQEvent型のeを引数に取る。
bool ChangeEngineSettingsDialog::eventFilter(QObject* obj, QEvent* e)
{
    // イベントのタイプがマウスホイールの動作（スクロール）であるかどうかを確認する。
    if (e->type() == QEvent::Wheel) {
        // イベントが発生したオブジェクトがQComboBox型かどうかを確認し、QComboBox型へキャストする。
        QComboBox* combo = qobject_cast<QComboBox *>(obj);

        // キャストが成功し、かつQComboBoxがフォーカスを持っていない場合、trueを返してイベントの伝播を止める。
        // これにより、フォーカスがない状態でのマウスホイール操作による不意の値変更を防ぐ。
        if (combo && !combo->hasFocus()) return true;

        // 同様に、イベントが発生したオブジェクトがLongLongSpinBox型かどうかを確認し、LongLongSpinBox型へキャストする。
        LongLongSpinBox* spin = qobject_cast<LongLongSpinBox*>(obj);

        // キャストが成功し、かつLongLongSpinBoxがフォーカスを持っていない場合、trueを返してイベントの伝播を止めます。
        if (spin && !spin->hasFocus()) return true;
    }
    // 上記の条件に当てはまらない場合は、falseを返してイベントの伝播を続行させる。
    return false;
}
#include "considerationdialog.h"
#include "changeenginesettingsdialog.h"
#include "ui_considerationdialog.h"
#include "enginesettingsconstants.h"
#include <QFile>
#include <QTextStream>
#include <QMessageBox>

using namespace EngineSettingsConstants;

// 検討ダイアログを表示する。
// コンストラクタ
ConsiderationDialog::ConsiderationDialog(QWidget *parent)
    : QDialog(parent), ui(new Ui::ConsiderationDialog)
{
    // UIをセットアップする。
    ui->setupUi(this);

    // "開始局面から"にチェックを入れる。
    ui->unlimitedTimeRadioButton->setChecked(true);

    // 設定ファイルからエンジンの名前とディレクトリを読み込む。
    readEngineNameAndDir();

    // エンジン設定ボタンが押されたときの処理
    connect(ui->engineSetting, &QPushButton::clicked, this, &ConsiderationDialog::showEngineSettingsDialog);

    // OKボタンが押された場合、ダイアログを受け入れたとして閉じる動作を行う。
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &ConsiderationDialog::accept);

    // OKボタンが押された場合、エンジン名、エンジン番号、解析局面フラグ、思考時間を取得する。
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &ConsiderationDialog::processEngineSettings);

    // キャンセルボタンが押された場合、ダイアログを拒否する動作を行う。
    connect(ui->buttonBox, &QDialogButtonBox::rejected, this, &ConsiderationDialog::reject);
}

// デストラクタ
ConsiderationDialog::~ConsiderationDialog()
{
    // UIを削除する。
    delete ui;
}

// エンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
void ConsiderationDialog::showEngineSettingsDialog()
{
    // 選択したエンジン番号を取得する。
    m_engineNumber = ui->comboBoxEngine1->currentIndex();

    // 選択したエンジン名を取得する。
    m_engineName = ui->comboBoxEngine1->currentText();

    // エンジン名が空の場合
    if (m_engineName.isEmpty()) {
        // エラーメッセージを表示する。
        QString errorText = "将棋エンジンが選択されていません。";
        QMessageBox::critical(this, "エラー", errorText);
    }
    // エンジン名が空でない場合
    else {
        // エンジン設定ダイアログを表示する。
        ChangeEngineSettingsDialog dialog(this);

        // エンジン名、エンジン番号を設定する。
        dialog.setEngineNumber(m_engineNumber);
        dialog.setEngineName(m_engineName);

        // エンジン設定ダイアログを作成する。
        dialog.setupEngineOptionsDialog();

        // ダイアログがキャンセルされた場合、何もしない。
        if (dialog.exec() == QDialog::Rejected) return;
    }
}

// エンジン名を取得する。
const QString& ConsiderationDialog::getEngineName() const
{
    return m_engineName;
}

// エンジン番号を取得する。
int ConsiderationDialog::getEngineNumber() const
{
    return m_engineNumber;
}

// 1手あたりの思考時間（秒数）を取得する。
int ConsiderationDialog::getByoyomiSec() const
{
    return m_byoyomiSec;
}

// エンジン名、エンジン番号、時間無制限フラグ、検討時間フラグ、検討時間を取得する。
void ConsiderationDialog::processEngineSettings()
{
    // 選択したエンジン名を取得する。
    m_engineName = ui->comboBoxEngine1->currentText();

    // 選択したエンジン番号を取得する。
    m_engineNumber = ui->comboBoxEngine1->currentIndex();

    // "時間無制限"にチェックが入っている場合
    if (ui->unlimitedTimeRadioButton->isChecked()) {
        m_unlimitedTimeFlag = true;
    }
    // "検討時間"にチェックが入っている場合
    else if (ui->considerationTimeRadioButton->isChecked()) {
        m_unlimitedTimeFlag = false;
        m_byoyomiSec = ui->byoyomiSec->text().toInt();
    }
}

// 設定ファイルからエンジンの名前とディレクトリを読み込む。
void ConsiderationDialog::readEngineNameAndDir()
{
    // 現在のディレクトリをアプリケーションのディレクトリに設定する。
    QDir::setCurrent(QApplication::applicationDirPath());

    // 設定ファイルを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // エンジンの数を取得する。
    int size = settings.beginReadArray("Engines");

    // エンジンの数だけループする。
    for (int i = 0; i < size; i++) {
        // 現在のインデックスで配列の要素を設定する。
        settings.setArrayIndex(i);

        // エンジン名とディレクトリを取得する。
        Engine engine;
        engine.name = settings.value("name").toString();
        engine.path = settings.value("path").toString();

        // 棋譜解析ダイアログのエンジン選択リストにエンジン名を追加する。
        ui->comboBoxEngine1->addItem(engine.name);

        // エンジンリストにエンジンを追加する。
        engineList.append(engine);
    }

    // エンジン名のグループの配列の読み込みを終了する。
    settings.endArray();
}

// エンジンの名前とディレクトリを格納するリストを取得する。
const QList<ConsiderationDialog::Engine>& ConsiderationDialog::getEngineList() const
{
    return engineList;
}
#include "engineregistrationdialog.h"
#include "enginesettingsconstants.h"
#include "qdebug.h"
#include "ui_engineregistrationdialog.h"
#include "changeenginesettingsdialog.h"
#include <QDir>
#include <QFileDialog>
#include <QProcess>
#include <QTime>
#include <QFile>
#include <QMessageBox>
#include <QSettings>
#include <QThread>

using namespace EngineSettingsConstants;

// 将棋エンジン登録ダイアログを表示する。
// コンストラクタ
EngineRegistrationDialog::EngineRegistrationDialog(QWidget *parent)
    : QDialog(parent),
    ui(new Ui::EngineRegistrationDialog),
    m_process(nullptr),
    m_errorOccurred(false)
{
    // Qt Designerで作成されたUIをプログラムのウィンドウに読み込み、初期化する。
    ui->setupUi(this);

    // シグナル・スロットの接続を行う。
    initializeSignals();

    // 設定ファイルからエンジン名と絶対パス付きの実行ファイル名を読み込み、GUIのリストウィジェットにエンジン名を追加する。
    loadEnginesFromSettings();
}

// デストラクタ
EngineRegistrationDialog::~EngineRegistrationDialog()
{
    // 既存のプロセスが存在する場合
    if (m_process != nullptr) {
        // プロセスのシグナル・スロットの接続を解除する。
        disconnect(m_process, nullptr, this, nullptr);

        // プロセスの状態が実行中の場合
        if (m_process->state() == QProcess::Running) {
            // プロセスを終了する。
            m_process->terminate();

            // プロセスの終了を待機する。
            if (!m_process->waitForFinished(3000)) {
                // プロセスを強制終了する。
                m_process->kill();
            }
        }

        // プロセスオブジェクトを削除する。
        delete m_process;
    }

    // エンジン登録ダイアログのUIを削除する。
    delete ui;
}

// シグナル・スロットの接続を行う。
void EngineRegistrationDialog::initializeSignals() const
{
    // 追加ボタンが押されたときの処理を接続
    connect(ui->addEngineButton, &QPushButton::clicked, this, &EngineRegistrationDialog::addEngineFromFileSelection);

    // 削除ボタンが押されたときの処理を接続
    connect(ui->removeEngineButton, &QPushButton::clicked, this, &EngineRegistrationDialog::removeEngine);

    // 設定ボタンが押されたときの処理を接続
    connect(ui->configureEngineButton, &QPushButton::clicked, this, &EngineRegistrationDialog::configureEngine);
}

// プロセスの標準エラー出力を処理する。
void EngineRegistrationDialog::processEngineErrorOutput()
{
    // エンジンのプロセスから標準エラー出力を読み込む。
    QByteArray stderrBytes = m_process->readAllStandardError();

    QString stderrString = QString::fromUtf8(stderrBytes).trimmed();

    if (!stderrString.isEmpty()) {
        // エラーメッセージと発生時刻をログに記録
        qDebug() << QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss") << " - Engine Error Output:" << stderrString;

        // エラーメッセージを通知する。
        showErrorMessage(tr("An error occurred in EngineRegistrationDialog::processEngineErrorOutput. Engine error output: %1").arg(stderrString));
    }
}

// QProcessのエラーが発生したときに呼び出されるスロット
void EngineRegistrationDialog::onProcessError(QProcess::ProcessError error)
{
    QString errorMessage;

    switch (error) {
    case QProcess::FailedToStart:
        errorMessage = tr("An error occurred in EngineRegistrationDialog::onProcessError. The process failed to start.");
        break;
    case QProcess::Crashed:
        errorMessage = tr("An error occurred in EngineRegistrationDialog::onProcessError. The process crashed.");
        break;
    case QProcess::Timedout:
        errorMessage = tr("An error occurred in EngineRegistrationDialog::onProcessError. The process timed out.");
        break;
    case QProcess::WriteError:
        errorMessage = tr("An error occurred in EngineRegistrationDialog::onProcessError. An issue occurred while writing data.");
        break;
    case QProcess::ReadError:
        errorMessage = tr("An error occurred in EngineRegistrationDialog::onProcessError. An issue occurred while reading data.");
        break;
    default:
        errorMessage = tr("An error occurred in EngineRegistrationDialog::onProcessError. An unknown error occurred.");
        break;
    }

    // エラーが発生したことを通知する。
    showErrorMessage(errorMessage);
}

// エラーメッセージを表示する。
void EngineRegistrationDialog::showErrorMessage(const QString &errorMessage)
{
    // エラー状態を設定する。
    m_errorOccurred = true;

    // エラーメッセージを表示する。
    QMessageBox::critical(this, "Error", errorMessage);
}

// 設定ファイルからエンジン名と絶対パス付きの実行ファイル名を読み込み、GUIのリストウィジェットにエンジン名を追加する。
void EngineRegistrationDialog::loadEnginesFromSettings()
{
    // 設定ファイルを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // [Engines]セクションからエンジンの数を読み込む。
    int engineCount = settings.beginReadArray(EnginesGroupName);

    // 既存のエンジンリストをクリア
    m_engineList.clear();

    // GUIのリストもクリア
    ui->engineListWidget->clear();

    for (int i = 0; i < engineCount; ++i) {
        settings.setArrayIndex(i);

        // 設定ファイルからエンジン名と絶対パス付きの実行ファイル名を読み込む。
        Engine engine = readEngineFromSettings(settings);

        // 読み込んだエンジンをリストに追加する。
        m_engineList.append(engine);

        // GUIのリストウィジェットにエンジン名を追加する。
        ui->engineListWidget->addItem(engine.name);
    }

    // [Engines]グループの配列の読み込みを終了する。
    settings.endArray();
}

// 設定ファイルからエンジン名と絶対パス付きの実行ファイル名を読み込む。
Engine EngineRegistrationDialog::readEngineFromSettings(const QSettings& settings) const
{
    Engine engine;

    // 将棋エンジンの名前と実行ファイルの絶対パスを設定ファイルから読み込む。
    engine.name = settings.value(EngineNameKey).toString();
    engine.path = settings.value(EnginePathKey).toString();

    return engine;
}

// 追加ボタンが押されたときに呼び出されるスロット
// エンジン登録ダイアログで選択したエンジンを追加する。
void EngineRegistrationDialog::addEngineFromFileSelection()
{
    // ファイルの選択ダイアログのタイトル
    const QString fileSelectionDialogTitle = tr("ファイルの選択");

    // ホームディレクトリの取得
    QString homeDir = QDir::homePath();

    // ファイルの選択ダイアログを表示し、選択されたファイル名を取得する。
    QString fileName = QFileDialog::getOpenFileName(this, fileSelectionDialogTitle, homeDir);

    // fileNameのパス区切りを、実行環境のネイティブな形式に変換する。
    m_fileName = QDir::toNativeSeparators(fileName);

    // ファイルが選択されなかった場合、処理を中断する。
    if (m_fileName.isEmpty()) {
        // ファイルが選択されなかった場合、処理を中断する。
        return;
    }

    // 将棋エンジンのディレクトリを取得する。
    m_engineDir = QDir::currentPath();

    // 既にリストに同じエンジンがあるかどうかをチェック
    foreach (const Engine& engine, m_engineList) {
        if (engine.path == m_fileName) {
            // エンジン登録が重複している場合、重複エラーのメッセージを表示する。
            handleDuplicateEngine(engine.name);

            // 重複が見つかった場合は、処理を中断する。
            return;
        }
    }

    // ファイルのパスが有効でない場合、エラーメッセージを表示し、処理を中断する。
    if (!validateEnginePath(m_fileName)) {
        // エラーメッセージを通知する。
        showErrorMessage(tr("An error occurred in EngineRegistrationDialog::addEngineFromFileSelection. Could not move to %1. Failed to add shogi engine.").arg(QFileInfo(m_fileName).path()));

        // ディレクトリの検証に失敗した場合、処理を中断する。
        return;
    }

    // エンジンを起動し、usiコマンドを送信する。
    startAndInitializeEngine(m_fileName);
}

// エンジン登録が重複している場合、重複エラーのメッセージを表示する。
void EngineRegistrationDialog::handleDuplicateEngine(const QString& engineName)
{
    // 重複エラーのメッセージを通知する。
    showErrorMessage(tr("An error occurred in EngineRegistrationDialog::handleDuplicateEngine. The engine %1 is already added.").arg(engineName));
}

// ファイルのパスが有効かどうかを検証する。
bool EngineRegistrationDialog::validateEnginePath(const QString& filePath) const
{
    // ファイルのパスからディレクトリのパスを取得する。
    QFileInfo fi(filePath);

    // ディレクトリを移動する。
    return QDir::setCurrent(fi.absolutePath());
}

// 将棋エンジンの出力を１行ずつ読み取り、エンジン情報やオプション情報を取得する。
void EngineRegistrationDialog::processEngineOutput()
{
    while (m_process->canReadLine()) {
        QString line = m_process->readLine();

        // 将棋エンジンからの出力を解析する。
        parseEngineOutput(line.trimmed());

        // エラーが発生している場合
        if (m_errorOccurred) return;
    }
}

// 将棋エンジンからの出力を解析する。
void EngineRegistrationDialog::parseEngineOutput(const QString& line)
{
    // "id name"で始まる行の場合
    if (line.startsWith(IdNamePrefix)) {
        // エンジン名と絶対パスでの実行ファイル名を取得する。
        processIdName(line);
    }
    // "option name"で始まる行の場合
    else if (line.startsWith(OptionNamePrefix)) {
        // オプション行をQStringList型の変数に蓄える。
        m_optionLines.append(line);
    }
    // "usiok"で始まる行の場合
    else if (line.startsWith(UsiOkPrefix)) {
        // 将棋エンジンにquitコマンドを送信する。
        sendQuitCommand();

        // 設定ファイルを書き込むディレクトリに移動する。（現時点では実行ファイルと同じディレクトリ）
        QDir::setCurrent(m_engineDir);

        // usiコマンドの出力からエンジンオプションを取り出す。
        getEngineOptions();

        // エラーが発生している場合
        if (m_errorOccurred) return;

        // 設定ファイルにエンジン名と絶対パス付きの実行ファイル名を書き込む。
        saveEnginesToSettingsFile();

        // comboタイプのオプションの文字列を作成する。
        concatenateComboOptionValues();

        // 設定ファイルに追加エンジンのオプションを書き込む。
        saveEngineOptionsToSettings();

        // エンジン名をリストに追加する。
        ui->engineListWidget->addItem(m_engineIdName);
    }
}

// エンジン名と絶対パスでの実行ファイル名を取得する。
void EngineRegistrationDialog::processIdName(const QString& line)
{
    // "id name"を含んだ行
    m_engineIdName = line;

    // "id name"を含んだ行の先頭の"id name "を削除する。
    m_engineIdName.remove(QString(IdNamePrefix) + " ");

    // 登録エンジンの重複チェック
    for (int j = 0; j < m_engineList.size(); j++) {
        if (m_engineIdName == m_engineList.at(j).name) {
            // 登録したいエンジンが既に登録されている場合、重複エラーのメッセージを表示する。
            duplicateEngine();

            return;
        }
    }

    // エンジンリストにエンジン名と絶対パス付きの実行ファイル名を追加する。
    Engine engine;
    engine.name = m_engineIdName;
    engine.path = m_fileName;
    m_engineList.append(engine);
}

// 将棋エンジンを起動し、usiコマンドを送信する。
void EngineRegistrationDialog::startAndInitializeEngine(const QString& engineFile)
{
    // 将棋エンジンを起動する。
    startEngine(engineFile);

    // エラーが発生している場合
    if (m_errorOccurred) return;

    // usiコマンドを将棋エンジンに送信する。
    sendUsiCommand();
}

// 将棋エンジンを起動する。
void EngineRegistrationDialog::startEngine(const QString& engineFile)
{
    // エンジンファイルの存在を確認
    if (engineFile.isEmpty() || !QFile::exists(engineFile)) {
        // エラーメッセージを通知する。
        showErrorMessage(tr("An error occurred in EngineRegistrationDialog::startEngine. The specified engine file does not exist: %1").arg(engineFile));

        return;
    }

    // 旧プロセスが存在する場合
    if (m_process != nullptr) {
        // 旧プロセスのシグナル・スロットの接続を解除する。
        disconnect(m_process, nullptr, this, nullptr);

        // プロセスを終了する。
        m_process->terminate();

        // プロセスの終了を待機する。
        m_process->waitForFinished();

        // プロセスを削除する。
        delete m_process;

        // プロセスをnullptrに設定する。
        m_process = nullptr;
    }

    // 新しいプロセスを作成する。
    m_process = new QProcess;

    // 標準出力が読み取り可能になったときにプロセスの出力を処理するスロットを接続
    connect(m_process, &QProcess::readyReadStandardOutput, this, &EngineRegistrationDialog::processEngineOutput);

    // 標準エラー出力が読み取り可能になったときにプロセスのエラー出力を処理するスロットを接続
    connect(m_process, &QProcess::readyReadStandardError, this, &EngineRegistrationDialog::processEngineErrorOutput);

    // プロセスのエラーが発生したときに呼び出されるスロットを接続
    connect(m_process, &QProcess::errorOccurred, this, &EngineRegistrationDialog::onProcessError);

    // 将棋エンジンの起動引数を設定（必要に応じて）
    QStringList args;

    // 将棋エンジンを起動
    m_process->start(engineFile, args, QIODevice::ReadWrite);

    if (!m_process->waitForStarted()) {
        // エラーメッセージを通知する。
        showErrorMessage(tr("An error occurred in EngineRegistrationDialog::startEngine.　Failed to start the engine： %1").arg(engineFile));

        return;
    }
}

// usiコマンドを将棋エンジンに送信する。
void EngineRegistrationDialog::sendUsiCommand() const
{
    // 将棋エンジンにusiコマンドを送信する。
    m_process->write(UsiCommand);
}

// quitコマンドを将棋エンジンに送信する。
void EngineRegistrationDialog::sendQuitCommand() const
{
    // 将棋エンジンにquitコマンドを送信する。
    m_process->write(QuitCommand);
}

// 削除ボタンが押されたときに呼び出されるスロット
// 選択した登録エンジンを削除する。
void EngineRegistrationDialog::removeEngine()
{
    // 削除エンジン名
    QString removeEngineName;

    // エンジン登録ダイアログの削除エンジン名を削除する。
    removeSelectedEngineFromList(removeEngineName);

    // [Engines]グループを削除する。
    removeEnginesGroup();

    // [Engines]グループを新たに作り直しする。
    saveEnginesToSettingsFile();

    // 削除エンジン名グループの削除
    removeEngineNameGroup(removeEngineName);
}

// 登録したいエンジンが既に登録されている場合、重複エラーのメッセージを表示する。
void EngineRegistrationDialog::duplicateEngine()
{
    // エラーメッセージを通知する。
    showErrorMessage(tr("The shogi engine is already registered. Please delete the previously registered shogi engine first. Please select one shogi engine."));
}

// 設定ボタンが押されたときに呼び出されるスロット
// 選択したエンジンの設定を変更する。
void EngineRegistrationDialog::configureEngine()
{
    QList<QListWidgetItem *> items = ui->engineListWidget->selectedItems();

    // 選択されたアイテムが正確に一つであるかをチェックする。
    if (items.count() != 1) {
        // エラーメッセージを通知する。
        showErrorMessage(tr("An error occurred in EngineRegistrationDialog::startEngine.　Please select one shogi engine."));

        // 一つではない場合は、処理を中断して戻る。
        return;
    }

    // ここからは選択されたアイテムが正確に一つであることが保証されている。
     // 最初（唯一の）アイテムを取得する。
    QListWidgetItem* selectedItem = items.first();

    // 選択されたアイテムのエンジン番号を取得する。
    int engineNumber = ui->engineListWidget->row(selectedItem);

    // 選択されたアイテムのエンジン名を取得する。
    QString engineName = selectedItem->text();

    // 選択されたエンジンの設定変更ダイアログを表示する。
    ChangeEngineSettingsDialog dialog(this);

    dialog.setEngineNumber(engineNumber);
    dialog.setEngineName(engineName);
    dialog.setupEngineOptionsDialog();

    if (dialog.exec() == QDialog::Rejected) return;
}

// 設定ファイルにエンジン名と絶対パス付きの実行ファイル名を書き込む。
void EngineRegistrationDialog::saveEnginesToSettingsFile() const
{
    // 設定ファイルを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // 書き込むグループに[Engines]を指定する。
    settings.beginWriteArray(EnginesGroupName);

    // 登録エンジンの数だけ繰り返す。
    for (int i = 0; i < m_engineList.size(); i++) {
        // 設定ファイルの[Engines]グループの配列のi番目の要素に移動する。
        settings.setArrayIndex(i);

        // 設定ファイルの[Engines]グループの配列のi番目の要素にエンジン名と絶対パス付きの実行ファイル名を書き込む。
        saveEngineToSettings(settings, m_engineList.at(i));
    }

    // [Engines]グループの配列の書き込みを終了する。
    settings.endArray();
}

// 指定されたエンジン情報を設定ファイルに保存する。
void EngineRegistrationDialog::saveEngineToSettings(QSettings& settings, const Engine& engine) const
{
    // 指定されたエンジン情報を設定ファイルに保存する。
    settings.setValue(EngineNameKey, engine.name);

    // エンジンの実行ファイルパスを設定ファイルに書き込む。
    settings.setValue(EnginePathKey, engine.path);
}

// 設定ファイルに追加エンジンのオプションを書き込む。
void EngineRegistrationDialog::saveEngineOptionsToSettings() const
{
    // 設定ファイルを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // 書き込むグループにエンジン名を指定する。
    settings.beginWriteArray(m_engineIdName);

    // エンジンオプションの数だけ繰り返す。
    for (int i = 0; i < m_engineOptions.size(); i++) {
        // 設定ファイルのエンジン名のグループの配列のi番目の要素に移動する。
        settings.setArrayIndex(i);

        // 設定ファイルのエンジン名のグループの配列のi番目の要素にエンジンオプションを書き込む。
        settings.setValue(EngineOptionNameKey, m_engineOptions.at(i).name);
        settings.setValue(EngineOptionTypeKey, m_engineOptions.at(i).type);
        settings.setValue(EngineOptionDefaultKey, m_engineOptions.at(i).defaultValue);
        settings.setValue(EngineOptionMinKey, m_engineOptions.at(i).min);
        settings.setValue(EngineOptionMaxKey, m_engineOptions.at(i).max);
        settings.setValue(EngineOptionValueKey, m_engineOptions.at(i).currentValue);
        settings.setValue(EngineOptionValueListKey, m_concatenatedOptionValuesList.at(i));
    }

    // エンジン名のグループの配列の書き込みを終了する。
    settings.endArray();
}

// usiコマンドの出力からエンジンオプションを取り出す。
void EngineRegistrationDialog::getEngineOptions()
{
    // optionリストを初期化する。これをしないと以前読み込んだエンジンのoptionリストが残ってしまう。
    m_engineOptions.clear();

    // usiコマンドの出力からエンジンオプションを取り出す。
    for (const QString& line : std::as_const(m_optionLines)) {
        parseOptionLine(line);

        // エラーが発生している場合
        if (m_errorOccurred) return;
    }

    // USI_Hashオプションが存在するかを確認する。
    auto usiHashIt = std::find_if(m_engineOptions.begin(), m_engineOptions.end(), [](const EngineOption& option) {
        return option.name == "USI_Hash";
    });

    // USI_Hashオプションが存在しない場合は追加する。
    if (usiHashIt == m_engineOptions.end()) {
        addOption("USI_Hash", "spin", "1024", "1", "2000", "1024");

        qInfo() << tr("USI_Hash option added.");
    }

    // USI_Ponderオプションが存在するかを確認
    auto usiPonderIt = std::find_if(m_engineOptions.begin(), m_engineOptions.end(), [](const EngineOption& option) {
        return option.name == "USI_Ponder";
    });

    // USI_Ponderオプションが存在しない場合は追加する。
    if (usiPonderIt == m_engineOptions.end()) {
        addOption("USI_Ponder", "check", "false", "", "", "false");

        qInfo() <<  tr("USI_Ponder option added.");
    }
}

// エンジンオプション構造体に値を設定する。
void EngineRegistrationDialog::addOption(const QString& name, const QString& type, const QString& defaultValue, const QString& min, const QString& max, const QString& currentValue)
{
    EngineOption option{name, type, defaultValue, min, max, currentValue, QStringList()};
    m_engineOptions.append(option);
    qInfo() << tr("New option added:") << name << ", type:" << type;
}

// optionコマンドの文法が正しいかどうかをチェックする。
EngineRegistrationDialog::ValidationResult EngineRegistrationDialog::checkOptionSyntax(const QString& optionCommand)
{
    // optionコマンドは"option"で始まる必要がある。
    if (!optionCommand.startsWith("option")) {
        return {false, "Command does not start with 'option'"};
    }

    // "option"を除いた部分を取得する。
    QString commandBody = optionCommand.mid(QString("option").length()).trimmed();

    // 静的なQRegularExpressionオブジェクト
    static const QRegularExpression optionRegex(R"(name\s+(\S+)\s+type\s+(\S+)(.*))");
    static const QRegularExpression whitespaceRegex(R"(\s+)");

    // name, type は必須フィールド
    QRegularExpressionMatch match = optionRegex.match(commandBody);

    if (!match.hasMatch()) {
        return {false, "Invalid syntax. Expected 'option name <name> type <type>'"};
    }

    QString type = match.captured(2);
    QString remaining = match.captured(3).trimmed();

    // typeがbuttonの場合、追加オプションがあってはいけない。
    if (type == "button") {
        if (!remaining.isEmpty()) {
            return {false, "No additional options are allowed for type 'button'"};
        }
    } else {
        // 追加オプションをチェックする。
        QStringList tokens = remaining.split(whitespaceRegex);
        QStringList allowedKeywords = {"default", "min", "max", "var"};

        for (int i = 0; i < tokens.size(); ++i) {
            if (allowedKeywords.contains(tokens[i])) {
                if (tokens[i] == "default") {
                    // "type" が "string" であれば、値がなくてもOK。
                    if (type == "string" && (i + 1 >= tokens.size() || allowedKeywords.contains(tokens[i + 1]))) {
                        // 値がなくても続行する。
                        continue;
                    } else if (i + 1 < tokens.size() && !allowedKeywords.contains(tokens[i + 1])) {
                        // 値がある場合は次のトークンに進む。
                        ++i;
                    } else {
                        return {false, QString("Value for '%1' is missing or invalid").arg(tokens[i])};
                    }
                } else if (tokens[i] == "min" || tokens[i] == "max") {
                    if (i + 1 < tokens.size() && !allowedKeywords.contains(tokens[i + 1])) {
                        // 値をスキップする。
                        ++i;
                    } else {
                        return {false, QString("Value for '%1' is missing or invalid").arg(tokens[i])};
                    }
                } else if (tokens[i] == "var") {
                    while (i + 1 < tokens.size() && !allowedKeywords.contains(tokens[i + 1])) {
                        ++i;
                    }
                }
            } else {
                return {false, QString("Unknown keyword or missing value: '%1'").arg(tokens[i])};
            }
        }
    }

    // ここまで来れば文法チェックは成功である。
    return {true, ""};
}

// 将棋エンジンから送信されたオプション行を解析し、エンジンオプションリストに追加する。
void EngineRegistrationDialog::parseOptionLine(const QString& line)
{
    // オプションの文法が正しいかどうかをチェックする。
    ValidationResult result = checkOptionSyntax(line);

    // 文法が正しい場合
    if (result.isValid) {
        qDebug() << "The option command is valid:" << line;
    }
    // 文法が正しくない場合
    else {
        qDebug() << "The option command is invalid:" << line << result.errorMessage;

        // エラーが発生したことを通知する。
        showErrorMessage(tr("An error occurred in EngineRegistrationDialog::parseOptionLine. Invalid option line format."));

        return;
    }

    QStringList parts = line.split(" ");

    QString name = parts.at(2);
    QString type = parts.at(4);
    QString defaultValue = "";
    QString min = "";
    QString max = "";
    QString currentValue = "";
    QStringList valueList;

    int defaultIndex = parts.indexOf(EngineOptionDefaultKey);

    // `defaultIndex + 1 < parts.size()`を追加して、`"default"`の後に値があるかどうかをチェックする。
    if (defaultIndex != -1 && defaultIndex + 1 < parts.size()) {
        defaultValue = parts.at(defaultIndex + 1);
        currentValue = defaultValue;
    }

    if (type == "spin") {
        int minIndex = parts.indexOf("min");
        int maxIndex = parts.indexOf("max");
        if (minIndex != -1 && parts.size() > minIndex) min = parts.at(minIndex + 1);
        if (maxIndex != -1 && parts.size() > maxIndex) max = parts.at(maxIndex + 1);
    } else if (type == "combo") {
        int varIndex = 0;
        while ((varIndex = parts.indexOf("var", varIndex + 1)) != -1) {
            if (parts.size() > varIndex) valueList.append(parts.at(varIndex + 1));
        }
    }

    // 新しいオプションを追加する際、既存のオプションと重複しないことを確認
    auto it = std::find_if(m_engineOptions.begin(), m_engineOptions.end(), [&name](const EngineOption& option) {
        return option.name == name;
    });

    // デバッグ用に既存のオプションを出力
    qDebug() << "現在のエンジンオプション:";
    for (int i = 0; i < m_engineOptions.size(); ++i) {
        const EngineOption& option = m_engineOptions[i];
        qDebug() << "Name:" << option.name << "Type:" << option.type;
    }

    // オプションが最後まで見つからなかった（重複しなかった）場合
    if (it == m_engineOptions.end()) {
        EngineOption option{name, type, defaultValue, min, max, currentValue, valueList};
        m_engineOptions.append(option);

        qInfo() << "New engine option added:" << name << ", type:" << type;
    } else {
         qWarning() << "Duplicate engine option found:" << name;

        // エラーが発生したことを通知する。
        showErrorMessage(tr("An error occurred in EngineRegistrationDialog::parseOptionLine. Duplicate engine option found."));

        return;
    }
}

// 設定ファイルから[Engines]グループを削除する。
void EngineRegistrationDialog::removeEnginesGroup() const
{
    // 設定ファイルを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // [Engines]グループの削除
    settings.beginGroup(EnginesGroupName);
    settings.remove("");
    settings.endGroup();
}

// 設定ファイルからエンジン名グループを削除する。
void EngineRegistrationDialog::removeEngineNameGroup(const QString& removeEngineName) const
{
    // 設定ファイルを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // エンジン名グループの削除
    settings.beginGroup(removeEngineName);
    settings.remove("");
    settings.endGroup();
}

// エンジン登録ダイアログから選択したエンジンを削除する。
void EngineRegistrationDialog::removeSelectedEngineFromList(QString& removeEngineName)
{
    // 選択したエンジン
    QList<QListWidgetItem *> items = ui->engineListWidget->selectedItems();

    // 選択したエンジンが正確に一つであるかをチェックする。
    if (items.count() != 1) {
        // エラーが発生したことを通知する。
        showErrorMessage(tr("An error occurred in EngineRegistrationDialog::removeSelectedEngineFromList. Please select one shogi engine."));

        // 一つではない場合は、処理を中断する。
        return;
    }

    // ここからは選択されたエンジンが正確に一つであることが保証されている。
    QListWidgetItem* selectedItem = items.first();
    int i = ui->engineListWidget->row(selectedItem);
    removeEngineName = ui->engineListWidget->takeItem(i)->text();

    // アイテムの削除
    delete selectedItem;

    m_engineList.removeAt(i);
}

// comboタイプのオプションの文字列を作成する。
void EngineRegistrationDialog::concatenateComboOptionValues()
{
    // 既存のリストをクリアする。
    m_concatenatedOptionValuesList.clear();

    // オプションの文字列リスト分、繰り返す。
    for (const auto& option : std::as_const(m_engineOptions)) {
        // comboタイプのオプションの値を " " で結合する。
        m_concatenatedOptionValuesList.append(option.valueList.join(" "));
    }
}
#include "kifuanalysisdialog.h"
#include "changeenginesettingsdialog.h"
#include "ui_kifuanalysisdialog.h"
#include "enginesettingsconstants.h"
#include "shogiutils.h"

#include <QFile>
#include <QTextStream>
#include <qmessagebox.h>

using namespace EngineSettingsConstants;

// 棋譜解析ダイアログのUIを設定する。
// コンストラクタ
KifuAnalysisDialog::KifuAnalysisDialog(QWidget *parent)
    : QDialog(parent), ui(new Ui::KifuAnalysisDialog), m_engineNumber(0), m_initPosition(true), m_byoyomiSec(0)
{
    // UIをセットアップする。
    ui->setupUi(this);

    // "開始局面から"にチェックを入れる。
    ui->radioButtonInitPosition->setChecked(true);

    // 設定ファイルからエンジンの名前とディレクトリを読み込む。
    readEngineNameAndDir();

    // エンジン設定ボタンが押されたときの処理
    connect(ui->engineSetting, &QPushButton::clicked, this, &KifuAnalysisDialog::showEngineSettingsDialog);

    // OKボタンが押された場合、ダイアログを受け入れたとして閉じる動作を行う。
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &KifuAnalysisDialog::accept);

    // OKボタンが押された場合、エンジン名、エンジン番号、解析局面フラグ、思考時間を取得する。
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &KifuAnalysisDialog::processEngineSettings);

    // キャンセルボタンが押された場合、ダイアログを拒否する動作を行う。
    connect(ui->buttonBox, &QDialogButtonBox::rejected, this, &KifuAnalysisDialog::reject);
}

// エンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
void KifuAnalysisDialog::showEngineSettingsDialog()
{
    // 選択したエンジン番号を取得する。
    m_engineNumber = ui->comboBoxEngine1->currentIndex();

    // 選択したエンジン名を取得する。
    m_engineName = ui->comboBoxEngine1->currentText();

    // エンジン名が空の場合
    if (m_engineName.isEmpty()) {
        // エラーメッセージを表示する。
        const QString errorMessage = tr("An error occurred in KifuAnalysisDialog::showEngineSettingsDialog. The Shogi engine has not been selected.");

        // エラーメッセージを表示する。
        QMessageBox::critical(this, tr("Error"), errorMessage);

        return;
    }
    // エンジン名が空でない場合
    else {
        // エンジン設定ダイアログを表示する。
        ChangeEngineSettingsDialog dialog(this);

        // エンジン名、エンジン番号を設定する。
        dialog.setEngineNumber(m_engineNumber);
        dialog.setEngineName(m_engineName);

        // エンジン設定ダイアログを作成する。
        dialog.setupEngineOptionsDialog();

        // ダイアログがキャンセルされた場合、何もしない。
        if (dialog.exec() == QDialog::Rejected) return;
    }
}

// OKボタンが押された場合、エンジン名、エンジン番号、解析局面フラグ、思考時間を取得する。
void KifuAnalysisDialog::processEngineSettings()
{
    // 選択したエンジン名を取得する。
    m_engineName = ui->comboBoxEngine1->currentText();

    // 選択したエンジン番号を取得する。
    m_engineNumber = ui->comboBoxEngine1->currentIndex();

    // "開始局面から"にチェックが入っている場合
    if (ui->radioButtonInitPosition->isChecked()) {
        m_initPosition = true;
    }
    // "現在局面から"にチェックが入っている場合
    else if (ui->radioButtonCurrentPosition->isChecked()) {
        m_initPosition = false;
    }

    // 1手あたりの思考時間（秒数）を取得する。
    m_byoyomiSec = ui->byoyomiSec->text().toInt();
}

// エンジンの名前とディレクトリを格納するリストを取得する。
QList<KifuAnalysisDialog::Engine> KifuAnalysisDialog::engineList() const
{
    return m_engineList;
}

// エンジン名を取得する。
QString KifuAnalysisDialog::engineName() const
{
    return m_engineName;
}

// エンジン番号を取得する。
int KifuAnalysisDialog::engineNumber() const
{
    return m_engineNumber;
}

// 1手あたりの思考時間（秒数）を取得する。
int KifuAnalysisDialog::byoyomiSec() const
{
    return m_byoyomiSec;
}

// "開始局面から"を選択したかどうかのフラグを取得する。
bool KifuAnalysisDialog::initPosition() const
{
    return m_initPosition;
}

// 設定ファイルからエンジンの名前とディレクトリを読み込む。
void KifuAnalysisDialog::readEngineNameAndDir()
{
    // 現在のディレクトリをアプリケーションのディレクトリに設定する。
    QDir::setCurrent(QApplication::applicationDirPath());

    // 設定ファイルを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // エンジンの数を取得する。
    int size = settings.beginReadArray("Engines");

    // エンジンの数だけループする。
    for (int i = 0; i < size; i++) {
        // 現在のインデックスで配列の要素を設定する。
        settings.setArrayIndex(i);

        // エンジン名とディレクトリを取得する。
        Engine engine;
        engine.name = settings.value("name").toString();
        engine.path = settings.value("path").toString();

        // 棋譜解析ダイアログのエンジン選択リストにエンジン名を追加する。
        ui->comboBoxEngine1->addItem(engine.name);

        // エンジンリストにエンジンを追加する。
        m_engineList.append(engine);
    }

    // エンジン名のグループの配列の読み込みを終了する。
    settings.endArray();
}
#include "promotedialog.h"

#include "ui_promotedialog.h"

// 成る・不成の選択ダイアログを表示するクラス
// コンストラクタ
PromoteDialog::PromoteDialog(QWidget *parent) : QDialog(parent), ui(new Ui::PromoteDialog)
{
    ui->setupUi(this);
}

// デストラクタ
PromoteDialog::~PromoteDialog()
{
    delete ui;
}
#include "startgamedialog.h"
#include "ui_startgamedialog.h"
#include "changeenginesettingsdialog.h"
#include "enginesettingsconstants.h"
#include <QSettings>
#include <QMessageBox>
#include <QDir>

using namespace EngineSettingsConstants;

// コンストラクタ
StartGameDialog::StartGameDialog(QWidget *parent) : QDialog(parent), ui(new Ui::StartGameDialog)
{
    // UIをセットアップする。
    ui->setupUi(this);

    // 設定ファイルからエンジンの名前とディレクトリを読み込む。
    loadEngineConfigurations();

    // GUIにエンジン設定を反映する。
    populateUIWithEngines();

    // 設定ファイルから対局設定を読み込みGUIに反映する。
    loadGameSettings();

    // GUIのシグナルとスロットを接続する。
    connectSignalsAndSlots();
}

// デストラクタ
StartGameDialog::~StartGameDialog()
{
    // UIを削除する。
    delete ui;
}

// UIのシグナルとスロットを接続する。
void StartGameDialog::connectSignalsAndSlots() const
{
    // 先手／下手のエンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
    connect(ui->pushButtonEngineSettings1, &QPushButton::clicked, this,
            &StartGameDialog::onFirstPlayerSettingsClicked);

    // 後手／上手のエンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
    connect(ui->pushButtonEngineSettings2, &QPushButton::clicked, this,
            &StartGameDialog::onSecondPlayerSettingsClicked);

    // 先後入れ替えボタンが押された場合、先後を入れ替える。
    connect(ui->pushButtonSwapSides, &QPushButton::clicked, this, &StartGameDialog::swapSides);

    // 設定を初期値にリセットする。
    connect(ui->pushButtonResetToDefault, &QPushButton::clicked, this, &StartGameDialog::resetSettingsToDefault);

    // 設定を保存する。
    connect(ui->pushButtonSaveSettingsOnly, &QPushButton::clicked, this, &StartGameDialog::saveGameSettings);

    // OKボタンが押された場合、ダイアログを受け入れたとして閉じる動作を行う。
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &StartGameDialog::accept);

    // OKボタンが押された場合、 設定ファイルに対局設定を保存する。
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &StartGameDialog::saveGameSettings);

    // OKボタンが押された場合、対局ダイアログ内の各パラメータを取得する。
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &StartGameDialog::updateGameSettingsFromDialog);

    // キャンセルボタンが押された場合、ダイアログを拒否する動作を行う。
    connect(ui->buttonBox, &QDialogButtonBox::rejected, this, &StartGameDialog::reject);

    // 先手／下手の秒読みの値が変更された場合、1手ごとの加算時間を0に設定する。
    connect(ui->byoyomiSec1, QOverload<int>::of(&QSpinBox::valueChanged),
            this, &StartGameDialog::handleByoyomiSecChanged);

    // 先手／下手の1手ごとの加算時間の値が変更された場合、秒読みを0に設定する。
    connect(ui->addEachMoveSec1, QOverload<int>::of(&QSpinBox::valueChanged),
            this, &StartGameDialog::handleAddEachMoveSecChanged);

    // 後手／上手の秒読みの値が変更された場合、1手ごとの加算時間を0に設定する。
    connect(ui->byoyomiSec2, QOverload<int>::of(&QSpinBox::valueChanged),
            this, &StartGameDialog::handleByoyomiSecChanged);

    // 後手／上手の1手ごとの加算時間の値が変更された場合、秒読みを0に設定する。
    connect(ui->addEachMoveSec2, QOverload<int>::of(&QSpinBox::valueChanged),
            this, &StartGameDialog::handleAddEachMoveSecChanged);
}

// 秒読みの値が変更された場合、1手ごとの加算時間を0に設定する。
void StartGameDialog::handleByoyomiSecChanged(int value)
{
    // 秒読みの値が0より大きい場合
    if (value > 0) {
        // 両対局者の1手ごとの加算時間を0に設定する。
        ui->addEachMoveSec1->setValue(0);
        ui->addEachMoveSec2->setValue(0);
    }
}

// 1手ごとの加算時間の値が変更された場合、秒読みを0に設定する。
void StartGameDialog::handleAddEachMoveSecChanged(int value)
{
    // 1手ごとの加算時間の値が0より大きい場合
    if (value > 0) {
        // 両対局者の秒読みの値を0に設定する。
        ui->byoyomiSec1->setValue(0);
        ui->byoyomiSec2->setValue(0);
    }
}


// 設定ファイルに対局設定を保存する。
void StartGameDialog::saveGameSettings()
{
    // 設定ファイルを操作するためのQSettingsオブジェクトを作成する。ファイル名とフォーマットを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // 設定の書き込みを開始する。
    settings.beginGroup("GameSettings");

    // 先手／下手の設定を保存する。
    settings.setValue("isHuman1", ui->radioButtonHuman1->isChecked());
    settings.setValue("isEngine1", ui->radioButtonEngine1->isChecked());
    settings.setValue("engineName1", ui->comboBoxEngine1->currentText());
    settings.setValue("humanName1", ui->lineEditHumanName1->text());
    settings.setValue("engineNumber1", ui->comboBoxEngine1->currentIndex());
    settings.setValue("basicTimeHour1", ui->basicTimeHour1->value());
    settings.setValue("basicTimeMinutes1", ui->basicTimeMinutes1->value());
    settings.setValue("byoyomiSec1", ui->byoyomiSec1->value());
    settings.setValue("addEachMoveSec1", ui->addEachMoveSec1->value());

    // 後手／上手の設定を保存する。
    settings.setValue("isGroupBoxSecondPlayerTimeSettingsChecked", ui->groupBoxSecondPlayerTimeSettings->isChecked());

    settings.setValue("isHuman2", ui->radioButtonHuman2->isChecked());
    settings.setValue("isEngine2", ui->radioButtonEngine2->isChecked());
    settings.setValue("engineName2", ui->comboBoxEngine2->currentText());
    settings.setValue("humanName2", ui->lineEditHumanName2->text());
    settings.setValue("engineNumber2", ui->comboBoxEngine2->currentIndex());
    settings.setValue("basicTimeHour2", ui->basicTimeHour2->value());
    settings.setValue("basicTimeMinutes2", ui->basicTimeMinutes2->value());
    settings.setValue("byoyomiSec2", ui->byoyomiSec2->value());
    settings.setValue("addEachMoveSec2", ui->addEachMoveSec2->value());

    // 開始局面の設定を保存する。
    settings.setValue("startingPositionName", ui->comboBoxStartingPosition->currentText());
    settings.setValue("startingPositionNumber", ui->comboBoxStartingPosition->currentIndex());

    // 最大手数を保存する。
    settings.setValue("maxMoves", ui->spinBoxMaxMoves->value());

    // 連続対局数を保存する。
    settings.setValue("consecutiveGames", ui->spinBoxConsecutiveGames->value());

    // 人を手前に表示するかどうかのフラグを保存する。
    settings.setValue("isShowHumanInFront", ui->checkBoxShowHumanInFront->isChecked());

    // 棋譜の自動保存フラグを保存する。
    settings.setValue("isAutoSaveKifu", ui->checkBoxAutoSaveKifu->isChecked());

    // 時間切れを負けにするかどうかのフラグを保存する。
    settings.setValue("isLoseOnTimeout", ui->checkBoxLoseOnTimeOut->isChecked());

    // 1局ごとに手番を入れ替えるかどうかのフラグを保存する。
    settings.setValue("isSwitchTurnEachGame", ui->checkBoxSwitchTurnEachGame->isChecked());

    // 設定の書き込みを終了する。
    settings.endGroup();
}

// 設定ファイルから対局設定を読み込みGUIに反映する。
void StartGameDialog::loadGameSettings()
{
    // 設定ファイルを操作するためのQSettingsオブジェクトを作成する。ファイル名とフォーマットを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // 設定の読み込みを開始する。
    settings.beginGroup("GameSettings");

    // 先手／下手の設定を読み込む。
    ui->radioButtonHuman1->setChecked(settings.value("isHuman1", true).toBool());
    ui->radioButtonEngine1->setChecked(settings.value("isEngine1", false).toBool());
    ui->comboBoxEngine1->setCurrentText(settings.value("engineName1", "").toString());
    ui->lineEditHumanName1->setText(settings.value("humanName1", tr("You")).toString());
    ui->comboBoxEngine1->setCurrentIndex(settings.value("engineNumber1", 0).toInt());
    ui->basicTimeHour1->setValue(settings.value("basicTimeHour1", 0).toInt());
    ui->basicTimeMinutes1->setValue(settings.value("basicTimeMinutes1", 0).toInt());
    ui->byoyomiSec1->setValue(settings.value("byoyomiSec1", 0).toInt());
    ui->addEachMoveSec1->setValue(settings.value("addEachMoveSec1", 0).toInt());

    // 後手／上手の設定を読み込む。
    bool isChecked = settings.value("isGroupBoxSecondPlayerTimeSettingsChecked", false).toBool();
    ui->groupBoxSecondPlayerTimeSettings->setChecked(isChecked);

    ui->radioButtonHuman2->setChecked(settings.value("isHuman2", false).toBool());
    ui->radioButtonEngine2->setChecked(settings.value("isEngine2", true).toBool());
    ui->comboBoxEngine2->setCurrentText(settings.value("engineName2", "").toString());
    ui->lineEditHumanName2->setText(settings.value("humanName2", tr("You")).toString());
    ui->comboBoxEngine2->setCurrentIndex(settings.value("engineNumber2", 0).toInt());
    ui->basicTimeHour2->setValue(settings.value("basicTimeHour2", 0).toInt());
    ui->basicTimeMinutes2->setValue(settings.value("basicTimeMinutes2", 0).toInt());
    ui->byoyomiSec2->setValue(settings.value("byoyomiSec2", 0).toInt());
    ui->addEachMoveSec2->setValue(settings.value("addEachMoveSec2", 0).toInt());

    // 開始局面の設定を読み込む。
    ui->comboBoxStartingPosition->setCurrentText(settings.value("startingPositionName", "平手").toString());
    ui->comboBoxStartingPosition->setCurrentIndex(settings.value("startingPositionNumber", 1).toInt());

    // 最大手数を読み込む。
    ui->spinBoxMaxMoves->setValue(settings.value("maxMoves", 1000).toInt());

    // 連続対局数を読み込む。
    ui->spinBoxConsecutiveGames->setValue(settings.value("consecutiveGames", 1).toInt());

    // 人を手前に表示するかどうかのフラグを読み込む。
    ui->checkBoxShowHumanInFront->setChecked(settings.value("isShowHumanInFront", true).toBool());

    // 棋譜の自動保存フラグを読み込む。
    ui->checkBoxAutoSaveKifu->setChecked(settings.value("isAutoSaveKifu", false).toBool());

    // 時間切れを負けにするかどうかのフラグを読み込む。
    ui->checkBoxLoseOnTimeOut->setChecked(settings.value("isLoseOnTimeout", true).toBool());

    // 1局ごとに手番を入れ替えるかどうかのフラグを読み込む。
    ui->checkBoxSwitchTurnEachGame->setChecked(settings.value("isSwitchTurnEachGame", false).toBool());

    // 設定の読み込みを終了する。
    settings.endGroup();
}

// 設定を初期値にリセットする。
void StartGameDialog::resetSettingsToDefault()
{
    // 先手／下手の設定を初期値に戻す。
    // 人間をデフォルトに設定する。
    ui->radioButtonHuman1->setChecked(true);
    ui->radioButtonEngine1->setChecked(false);

    // エンジン1のデフォルト値を設定する。
    ui->comboBoxEngine1->setCurrentIndex(0);

    // 人間の名前をデフォルトに設定する。
    ui->lineEditHumanName1->setText(tr("You"));

    // 持ち時間のデフォルト値を設定する。
    ui->basicTimeHour1->setValue(0);
    ui->basicTimeMinutes1->setValue(30);

    // 秒読みのデフォルト値を設定する。
    ui->byoyomiSec1->setValue(30);

    // 1手ごとの加算時間をデフォルトに設定する。
    ui->addEachMoveSec1->setValue(0);

    // 後手／上手の設定を初期値に戻す。
    // エンジン2をデフォルトに設定する。
    ui->radioButtonHuman2->setChecked(false);
    ui->radioButtonEngine2->setChecked(true);

    // エンジン2のデフォルト値を設定する。
    ui->comboBoxEngine2->setCurrentIndex(0);

    // 人間の名前をデフォルトに設定する。
    ui->lineEditHumanName2->setText(tr("You"));

    // 持ち時間のデフォルト値を設定する。
    ui->basicTimeHour2->setValue(0);
    ui->basicTimeMinutes2->setValue(30);

    // 秒読みのデフォルト値を設定する。
    ui->byoyomiSec2->setValue(30);

    // 1手ごとの加算時間をデフォルトに設定する。
    ui->addEachMoveSec2->setValue(0);

    // 開始局面の設定を初期値に戻す。
    // 平手をデフォルトに設定する。
    ui->comboBoxStartingPosition->setCurrentIndex(1);

    // 最大手数、連続対局数を初期値に戻す。
    ui->spinBoxMaxMoves->setValue(1000);
    ui->spinBoxConsecutiveGames->setValue(1);

    // その他のチェックボックスの初期値を設定する。
    // 人を手前に表示する。
    ui->checkBoxShowHumanInFront->setChecked(true);

    // 棋譜の自動保存はデフォルトでオフにする。
    ui->checkBoxAutoSaveKifu->setChecked(false);

    // 時間切れを負けにする。
    ui->checkBoxLoseOnTimeOut->setChecked(true);

     // 手番の入れ替えはデフォルトでオフにする。
    ui->checkBoxSwitchTurnEachGame->setChecked(false);
}

// 先後入れ替えボタンが押された場合、先後を入れ替える。
void StartGameDialog::swapSides()
{
    // 対局者のラジオボタンを入れ替える。
    bool isHumanTemp = ui->radioButtonHuman2->isChecked();
    bool isEngineTemp = ui->radioButtonEngine2->isChecked();
    ui->radioButtonHuman2->setChecked(ui->radioButtonHuman1->isChecked());
    ui->radioButtonEngine2->setChecked(ui->radioButtonEngine1->isChecked());
    ui->radioButtonHuman1->setChecked(isHumanTemp);
    ui->radioButtonEngine1->setChecked(isEngineTemp);

    // 人間の名前を入れ替える。
    QString temp = ui->lineEditHumanName1->text();
    ui->lineEditHumanName1->setText(ui->lineEditHumanName2->text());
    ui->lineEditHumanName2->setText(temp);

    // エンジン名のインデックスを入れ替える。
    int index = ui->comboBoxEngine1->currentIndex();
    ui->comboBoxEngine1->setCurrentIndex(ui->comboBoxEngine2->currentIndex());
    ui->comboBoxEngine2->setCurrentIndex(index);

    // 「後手／上手に異なる時間を設定」にチェックが入っている場合
    if (ui->groupBoxSecondPlayerTimeSettings->isChecked()) {
        // 持ち時間を入れ替える。
        int temp = ui->basicTimeHour1->value();
        ui->basicTimeHour1->setValue(ui->basicTimeHour2->value());
        ui->basicTimeHour2->setValue(temp);

        temp = ui->basicTimeMinutes1->value();
        ui->basicTimeMinutes1->setValue(ui->basicTimeMinutes2->value());
        ui->basicTimeMinutes2->setValue(temp);

        // 秒読み時間を入れ替える。
        temp = ui->byoyomiSec1->value();
        ui->byoyomiSec1->setValue(ui->byoyomiSec2->value());
        ui->byoyomiSec2->setValue(temp);

        // 1手ごとの時間加算を入れ替える。
        temp = ui->addEachMoveSec1->value();
        ui->addEachMoveSec1->setValue(ui->addEachMoveSec2->value());
        ui->addEachMoveSec2->setValue(temp);
    }
}

// 設定ファイルからエンジンの名前とディレクトリを読み込む。
void StartGameDialog::loadEngineConfigurations()
{
    // 現在のディレクトリをアプリケーションのディレクトリに設定する
    QDir::setCurrent(QApplication::applicationDirPath());

    // 設定ファイルを指定する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    int size = settings.beginReadArray("Engines");
    engineList.clear(); // 現在のエンジンリストをクリア

    // エンジンの数だけループする。
    for (int i = 0; i < size; ++i) {
        // 現在のインデックスで配列の要素を設定する。
        settings.setArrayIndex(i);

        // エンジン名とディレクトリを取得する。
        Engine engine;
        engine.name = settings.value("name").toString();
        engine.path = settings.value("path").toString();

        // 対局ダイアログのエンジン選択リストにエンジン名を追加する。
        engineList.append(engine);
    }

    // エンジン名のグループの配列の読み込みを終了する。
    settings.endArray();
}

// GUIにエンジン設定を反映する。
void StartGameDialog::populateUIWithEngines() const
{
    // コンボボックスをクリアする。
    ui->comboBoxEngine1->clear();
    ui->comboBoxEngine2->clear();

    // エンジンリストの各エンジンをコンボボックスに追加する。
    foreach (const Engine& engine, engineList) {
        ui->comboBoxEngine1->addItem(engine.name);
        ui->comboBoxEngine2->addItem(engine.name);
    }
}

// 先手／下手が人間かエンジンかを示すフラグを取得する。
bool StartGameDialog::isHuman1() const
{
    return m_isHuman1;
}

// 後手／上手が人間かエンジンかを示すフラグを取得する。
bool StartGameDialog::isHuman2() const
{
    return m_isHuman2;
}

// 先手／下手がエンジンかを示すフラグを取得する。
bool StartGameDialog::isEngine1() const
{
    return m_isEngine1;
}

// 後手／上手がエンジンかを示すフラグを取得する。
bool StartGameDialog::isEngine2() const
{
    return m_isEngine2;
}

// 先手／下手のエンジン名を取得する。
const QString& StartGameDialog::engineName1() const
{
    return m_engineName1;
}

// 後手／上手のエンジン名を取得する。
const QString& StartGameDialog::engineName2() const
{
    return m_engineName2;
}

// 先手／下手の人間名を取得する。
const QString& StartGameDialog::humanName1() const
{
    return m_humanName1;
}

// 後手／上手の人間名を取得する。
const QString& StartGameDialog::humanName2() const
{
    return m_humanName2;
}

// 先手／下手のエンジン番号を取得する。
int StartGameDialog::engineNumber1() const
{
    return m_engineNumber1;
}

// 後手／上手のエンジン番号を取得する。
int StartGameDialog::engineNumber2() const
{
    return m_engineNumber2;
}

// 対局者1の持ち時間（時間）を取得する。
int StartGameDialog::basicTimeHour1() const
{
    return m_basicTimeHour1;
}

// 対局者1の持ち時間（分）を取得する。
int StartGameDialog::basicTimeMinutes1() const
{
    return m_basicTimeMinutes1;
}

// 対局者1の1手ごとの加算（秒）を取得する。
int StartGameDialog::addEachMoveSec1() const
{
    return m_addEachMoveSec1;
}

// 対局者1の秒読みの時間（秒）を取得する。
int StartGameDialog::byoyomiSec1() const
{
    return m_byoyomiSec1;
}

// 対局者2の持ち時間（時間）を取得する。
int StartGameDialog::basicTimeHour2() const
{
    return m_basicTimeHour2;
}

// 対局者2の持ち時間（分）を取得する。
int StartGameDialog::basicTimeMinutes2() const
{
    return m_basicTimeMinutes2;
}

// 対局者2の1手ごとの加算（秒）を取得する。
int StartGameDialog::addEachMoveSec2() const
{
    return m_addEachMoveSec2;
}

// 対局者2の秒読みの時間（秒）を取得する。
int StartGameDialog::byoyomiSec2() const
{
    return m_byoyomiSec2;
}

// 対局の初期局面（平手、2枚落ちなど）を取得する。
const QString &StartGameDialog::startingPositionName() const
{
    return m_startingPositionName;
}

// 対局の初期局面番号を取得する。
int StartGameDialog::startingPositionNumber() const
{
    return m_startingPositionNumber;
}

// エンジンリストを取得する。
const QList<StartGameDialog::Engine> &StartGameDialog::getEngineList() const
{
    return engineList;
}

// 最大手数を取得する。
int StartGameDialog::maxMoves() const
{
    return m_maxMoves;
}

// 連続対局数を取得する。
int StartGameDialog::consecutiveGames() const
{
    return m_consecutiveGames;
}

// 人を手前に表示するかどうかのフラグを取得する。
bool StartGameDialog::isShowHumanInFront() const
{
    return m_isShowHumanInFront;
}

// 棋譜の自動保存フラグを取得する。
bool StartGameDialog::isAutoSaveKifu() const
{
    return m_isAutoSaveKifu;
}

// 時間切れを負けにするかどうかのフラグを取得する。
bool StartGameDialog::isLoseOnTimeout() const
{
    return m_isLoseOnTimeout;
}

// 1局ごとに手番を入れ替えるかどうかのフラグを取得する。
bool StartGameDialog::isSwitchTurnEachGame() const
{
    return m_isSwitchTurnEachGame;
}

// OKボタンが押された場合、対局ダイアログ内の各パラメータを取得する。
void StartGameDialog::updateGameSettingsFromDialog()
{
    // 先手／下手が人間である場合
    if (ui->radioButtonHuman1->isChecked()) {
        m_isHuman1 = true;
        m_isEngine1 = false;
    }
    // 先手／下手がエンジンである場合
    else if (ui->radioButtonEngine1->isChecked()) {
        m_isHuman1 = false;
        m_isEngine1 = true;
    }

    m_humanName1 = ui->lineEditHumanName1->text();
    m_engineName1 = ui->comboBoxEngine1->currentText();
    m_engineNumber1 = ui->comboBoxEngine1->currentIndex();

    // 後手／上手が人間である場合
    if (ui->radioButtonHuman2->isChecked()) {
        m_isHuman2 = true;
        m_isEngine2 = false;
    }
    // 後手／上手がエンジンである場合
    else if (ui->radioButtonEngine2->isChecked()) {
        m_isHuman2 = false;
        m_isEngine2 = true;

    }

    m_humanName2 = ui->lineEditHumanName2->text();
    m_engineName2 = ui->comboBoxEngine2->currentText();
    m_engineNumber2 = ui->comboBoxEngine2->currentIndex();

    // 対局者1の持ち時間を取得する。
    m_basicTimeHour1 = ui->basicTimeHour1->text().toInt();
    m_basicTimeMinutes1 = ui->basicTimeMinutes1->text().toInt();

    // 対局者1の秒読み時間（秒）を取得する。
    m_byoyomiSec1 = ui->byoyomiSec1->text().toInt();

    // 対局者1の1手ごとの時間加算（秒）を取得する。
    m_addEachMoveSec1 = ui->addEachMoveSec1->text().toInt();

    // 「後手／上手に異なる時間を設定」にチェックが入っている場合
    if (ui->groupBoxSecondPlayerTimeSettings->isChecked()) {
        // 対局者2の持ち時間を取得する。
        m_basicTimeHour2 = ui->basicTimeHour2->text().toInt();
        m_basicTimeMinutes2 = ui->basicTimeMinutes2->text().toInt();

        // 対局者2の秒読み時間（秒）を取得する。
        m_byoyomiSec2 = ui->byoyomiSec2->text().toInt();

        // 対局者2の1手ごとの時間加算（秒）を取得する。
        m_addEachMoveSec2 = ui->addEachMoveSec2->text().toInt();
    }
    // 「後手／上手に異なる時間を設定」にチェックが入っていない場合
    else {
        // 対局者1の持ち時間を対局者2の持ち時間にコピーする。
        m_basicTimeHour2 = m_basicTimeHour1;
        m_basicTimeMinutes2 = m_basicTimeMinutes1;

        // 対局者1の秒読み時間（秒）を対局者2の秒読み時間にコピーする。
        m_byoyomiSec2 = m_byoyomiSec1;

        // 対局者1の1手ごとの時間加算（秒）を対局者2の1手ごとの時間加算にコピーする。
        m_addEachMoveSec2 = m_addEachMoveSec1;
    }

    // 開始局面を取得する。
    m_startingPositionName = ui->comboBoxStartingPosition->currentText();
    m_startingPositionNumber = ui->comboBoxStartingPosition->currentIndex();

    // 最大手数を取得する。
    m_maxMoves = ui->spinBoxMaxMoves->value();

    // 連続対局数を取得する。
    m_consecutiveGames = ui->spinBoxConsecutiveGames->value();

    // 人を手前に表示するかどうかのフラグを取得する。
    m_isShowHumanInFront = ui->checkBoxShowHumanInFront->isChecked();

    // 棋譜の自動保存フラグを取得する。
    m_isAutoSaveKifu = ui->checkBoxAutoSaveKifu->isChecked();

    // 時間切れを負けにするかどうかのフラグを取得する。
    m_isLoseOnTimeout = ui->checkBoxLoseOnTimeOut->isChecked();

    // 1局ごとに手番を入れ替えるかどうかのフラグを取得する。
    m_isSwitchTurnEachGame = ui->checkBoxSwitchTurnEachGame->isChecked();
}

// エンジン設定ダイアログの共通処理を行う。
void StartGameDialog::showEngineSettingsDialog(QComboBox* comboBox)
{
    // エンジン番号を取得する。
    int engineNumber = comboBox->currentIndex();

    // エンジン名を取得する。
    QString engineName = comboBox->currentText();

    // エンジン名が空の場合
    if (engineName.isEmpty()) {
        QMessageBox::critical(this, "エラー", "将棋エンジンが選択されていません。");
    }
    // エンジン名が空でない場合
    else {
        // エンジン設定ダイアログを表示する。
        ChangeEngineSettingsDialog dialog(this);

        // エンジン名、エンジン番号を設定する。
        dialog.setEngineNumber(engineNumber);
        dialog.setEngineName(engineName);

        // エンジン設定ダイアログを作成する。
        dialog.setupEngineOptionsDialog();

        // ダイアログがキャンセルされた場合、何もしない。
        if (dialog.exec() == QDialog::Rejected) {
            return;
        }
    }
}

// 先手／下手のエンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
void StartGameDialog::onFirstPlayerSettingsClicked()
{
    showEngineSettingsDialog(ui->comboBoxEngine1);
}

 // 後手／上手のエンジン設定ボタンが押された場合、エンジン設定ダイアログを表示する。
void StartGameDialog::onSecondPlayerSettingsClicked()
{
    showEngineSettingsDialog(ui->comboBoxEngine2);
}
#include "tsumeshogisearchdialog.h"

// 詰み探索ダイアログを表示する。
// コンストラクタ
TsumeShogiSearchDialog::TsumeShogiSearchDialog(QWidget *parent)
    : ConsiderationDialog(parent)
{
    // ウィンドウタイトルを「詰み探索」に設定する。
    setWindowTitle(tr("詰み探索"));
}

// デストラクタ
TsumeShogiSearchDialog::~TsumeShogiSearchDialog()
{
}
#include "versiondialog.h"
#include "ui_versiondialog.h"

// バージョンを表示するダイアログ
// コンストラクタ
VersionDialog::VersionDialog(QWidget *parent) : QDialog(parent), ui(new Ui::VersionDialog)
{
    ui->setupUi(this);
}

// デストラクタ
VersionDialog::~VersionDialog()
{
    delete ui;
}
#include "shogiengineinfoparser.h"
#include <QStringList>
#include <QString>
#include <QDebug>
#include <QObject>
#include <QMessageBox>
#include "shogigamecontroller.h"
#include "shogiutils.h"

// エンジンは、infoコマンドによって思考中の情報を返す。
// info行を解析するクラス
// コンストラクタ
ShogiEngineInfoParser::ShogiEngineInfoParser()
{
    // 駒台の段と駒の対応マップ
    m_pieceMap = {{1, 'P'}, {2, 'L'}, {3, 'N'}, {4, 'S'}, {5, 'G'}, {6, 'B'}, {7, 'R'}};

     // 駒台の駒と段の対応マップ
    m_pieceCharToIntMap = {{'P', 1}, {'L', 2}, {'N', 3}, {'S', 4}, {'G', 5}, {'B', 6}, {'R', 7}};

    // 駒とその成駒の対応マップ
    m_promoteMap = {{'P', 'Q'}, {'L', 'M'}, {'N', 'O'}, {'S', 'T'},
                    {'B', 'C'}, {'R', 'U'}, {'p', 'q'}, {'l', 'm'},
                    {'n', 'o'}, {'s', 't'}, {'b', 'c'}, {'r', 'u'}};

    // 駒文字と漢字の駒の対応マップ
    m_pieceMapping = {{'P', "歩"}, {'L', "香"}, {'N', "桂"}, {'S', "銀"}, {'G', "金"}, {'B', "角"},
                      {'R', "飛"}, {'K', "玉"}, {'Q', "と"}, {'M', "成香"}, {'O', "成桂"},
                      {'T', "成銀"}, {'C', "馬"}, {'U', "龍"}};
}

// GUIの「探索手」の欄に表示する読み筋の最初の文字列を取得する。
QString ShogiEngineInfoParser::searchedHand() const
{
    return m_searchedHand;
}

 // エンジンが詰みを発見した場合の詰み手数をセットする。
void ShogiEngineInfoParser::setScoreMate(const QString& newScoremate)
{
    m_scoreMate = newScoremate;
}

// エンジンが現在使用しているハッシュの使用率を取得する。
QString ShogiEngineInfoParser::hashfull() const
{
    return m_hashfull;
}

// 現在の読み筋を漢字表示で表した文字列を取得する。
QString ShogiEngineInfoParser::pvKanjiStr() const
{
    return m_pvKanjiStr;
}

// エンジンが詰みを発見した場合の詰み手数を取得する。
QString ShogiEngineInfoParser::scoreMate() const
{
    return m_scoreMate;
}

// エンジンによる現在の評価値を取得する。
QString ShogiEngineInfoParser::scoreCp() const
{
    return m_scoreCp;
}

// 思考を開始してから経過した時間（単位はミリ秒）を取得する。
QString ShogiEngineInfoParser::time() const
{
    return m_time;
}

// 1秒あたりの探索局面数を取得する。
QString ShogiEngineInfoParser::nps() const
{
    return m_nps;
}

// 思考開始から探索したノード数を取得する。
QString ShogiEngineInfoParser::nodes() const
{
    return m_nodes;
}

// pvで初手の異なる複数の読み筋を返す時、それがn通りあれば、最も良い（評価値の高い）ものを返す。
QString ShogiEngineInfoParser::multipv() const
{
    return m_multipv;
}

// 現在選択的に読んでいる手の探索深さを取得する。
QString ShogiEngineInfoParser::seldepth() const
{
    return m_seldepth;
}

// 現在思考中の手の探索深さを取得する。
QString ShogiEngineInfoParser::depth() const
{
    return m_depth;
}

// 指し手文字列の三角マークを返す。
// 例．「△７八馬(77)▲２五歩(26)△８六歩(85)▲２四歩(25)△同歩(23)▲７七桂(89)△８七歩成(86)」
QString ShogiEngineInfoParser::getMoveSymbol(const int moveIndex, const ShogiGameController* algorithm, const bool isPondering) const
{
    QString symbol;

    bool currentPlayerIsPlayer1 = (algorithm->currentPlayer() == algorithm->Player1);

    // moveIndex:      0 1 2 3 4 5 6 7 8 9
    // moveIndex & 1:  0 1 0 1 0 1 0 1 0 1
    // 偶数の時
    if ((moveIndex & 1) ^ isPondering) {
        symbol = currentPlayerIsPlayer1 ? "△" : "▲";
    // 奇数の時
    } else {
        symbol = currentPlayerIsPlayer1 ? "▲" : "△";
    }

    return symbol;
}

// 直前の指し手と同じマスに指す場合、「同」を付ける。（同歩、同銀など）
QString ShogiEngineInfoParser::getFormattedMove(int fileTo, int rankTo, const QString& kanji) const
{
    if ((fileTo == previousFileTo()) && (rankTo == previousRankTo())) {
        return "同" + kanji;
    }

    return ShogiUtils::transFileTo(fileTo) + ShogiUtils::transRankTo(rankTo) + kanji;
}

// 将棋エンジンから受信した読み筋を将棋の指し手の文字列に変換する。
// 例．
// 「7g7h 2f2e 8e8f 2e2d 2c2d 8i7g 8f8g+」
// 「△７八馬(77)▲２五歩(26)△８六歩(85)▲２四歩(25)△同歩(23)▲７七桂(89)△８七歩成(86)」
QString ShogiEngineInfoParser::convertMoveToShogiString(const QString& kanji, const int fileFrom, const int rankFrom, const int fileTo, const int rankTo,
                                                        const bool promote, const ShogiGameController* algorithm, const int moveIndex, const bool isPondering)
{
    // 指し手の文字列
    QString moveStr;

    // 指し手文字列の三角マークを返す。
    // 例．「△７八馬(77)▲２五歩(26)△８六歩(85)▲２四歩(25)△同歩(23)▲７七桂(89)△８七歩成(86)」
    moveStr += getMoveSymbol(moveIndex, algorithm, isPondering);

    // 直前の指し手と同じマスに指す場合、「同」を付ける。（同歩、同銀など）
    moveStr += getFormattedMove(fileTo, rankTo, kanji);

    // 成る手の場合
    if (promote) moveStr += "成";

    // 駒台から駒を打った場合（5六歩打など）
    if (fileFrom == STAND_FILE) {
        moveStr += "打";
    }
    // 盤内の駒を動かして指した場合
    else {
        //例．「△７八馬(77)」の「(77)」を付加する。
        moveStr += "(" + QString::number(fileFrom) + QString::number(rankFrom) + ")";
    }

    return moveStr;
}

// 段を示す文字を整数に変換する。
// 文字'a'から'i'までを1から9に変換する。
int ShogiEngineInfoParser::convertRankCharToInt(const QChar rankChar)
{
    // アルファベットの文字（A-Zまたはa-z）であるかどうか、
    // かつ'i'またはそれより前（アルファベット順）の文字であることを確認する。
    if (rankChar.isLetter() && rankChar.toLatin1() <= 'i') {
        return rankChar.toLatin1() - 'a' + 1;
    }
    // それ以外の文字の場合
    else {
        // エラーメッセージを表示する。
        QString errorMessage = tr("An error occurred in ShogiEngineInfoParser::convertRankCharToInt. Invalid character conversion %1.").arg(rankChar);

        emit errorOccurred(errorMessage);

        return -1;
    }
}

// 駒文字を駒台の段番号に変換する。
int ShogiEngineInfoParser::convertPieceToStandRank(const QChar pieceChar)
{
    if (m_pieceCharToIntMap.contains(pieceChar)) {
        return m_pieceCharToIntMap.value(pieceChar);
    } else {
        // 駒文字に対応する段番号が存在しない場合、-1を返す。
        return -1;
    }
}

// 引数で与えられた文字が将棋盤のランクを表す文字（'a'から'i'）であるかどうかをチェックする。
bool ShogiEngineInfoParser::isBoardRankChar(const QChar rankChar) const
{
    return rankChar.isLetter() && rankChar.toLatin1() <= 'i';
}

// 指し手を表す文字列から指し手のマスの座標と成るかどうかのフラグを取得する。
int ShogiEngineInfoParser::parseMoveString(const QString& moveStr, int& fileFrom, int& rankFrom, int& fileTo, int& rankTo, bool& promote)
{
    // 初期化
    fileFrom = rankFrom = fileTo = rankTo = 0;
    promote = false;

    // 指し手を表す文字列が4文字未満ならばエラー処理を行い、打ち切り
    if (moveStr.length() < 4) {
        const QString errorMessage =
            tr("An error occurred in ShogiEngineInfoParser::parseMoveString. The length of the move string %1 is insufficient.").arg(moveStr);
        emit errorOccurred(errorMessage);
        return -1; // ★ 打ち切り
    }

    // 指し手を表す文字列の最初の文字を指すQChar型のポインタ
    const QChar* moveChars = moveStr.data();

    // fileFrom を取得
    if (moveChars[0].isDigit()) {
        // 盤上の駒
        fileFrom = moveChars[0].digitValue();
    } else {
        // 駒台の駒（例: "G*5b"）
        const int standPieceNumber = convertPieceToStandRank(moveChars[0]); // 1..7 or -1
        if (standPieceNumber >= 1 && standPieceNumber <= 7) {
            fileFrom = STAND_FILE; // 盤外（駒台）を示す特別値
        } else {
            // 指し手以外（例: "(57.54%)"）→ 特別ケース
            fileFrom = rankFrom = fileTo = rankTo = 0;
            promote = false;
            return INFO_STRING_SPECIAL_CASE;
        }
    }

    // rankFrom を取得
    if (isBoardRankChar(moveChars[1])) {
        rankFrom = convertRankCharToInt(moveChars[1]);
        if (rankFrom <= 0) {
            const QString errorMessage =
                tr("An error occurred in ShogiEngineInfoParser::parseMoveString. Failed to convert source rank.");
            emit errorOccurred(errorMessage);
            return -1; // ★ 打ち切り
        }
    } else if (moveChars[1] == QLatin1Char('*')) {
        // 駒打ち："G*5b" のようなケース
        const int standPieceNumber = convertPieceToStandRank(moveChars[0]); // 1..7 or -1
        if (standPieceNumber >= 1 && standPieceNumber <= 7) {
            rankFrom = standPieceNumber;
        } else {
            const QString errorMessage =
                tr("An error occurred in ShogiEngineInfoParser::parseMoveString. Invalid stand piece specification.");
            emit errorOccurred(errorMessage);
            return -1; // ★ 打ち切り
        }
    } else {
        const QString errorMessage =
            tr("An error occurred in ShogiEngineInfoParser::parseMoveString. The coordinates of the source square are invalid.");
        emit errorOccurred(errorMessage);
        return -1; // ★ 打ち切り
    }

    // fileTo を取得
    if (moveChars[2].isDigit()) {
        fileTo = moveChars[2].digitValue();
    } else {
        const QString errorMessage =
            tr("An error occurred in ShogiEngineInfoParser::parseMoveString. The coordinates of the destination file are invalid.");
        emit errorOccurred(errorMessage);
        return -1; // ★ 打ち切り
    }

    // rankTo を取得
    if (isBoardRankChar(moveChars[3])) {
        rankTo = convertRankCharToInt(moveChars[3]);
        if (rankTo <= 0) {
            const QString errorMessage =
                tr("An error occurred in ShogiEngineInfoParser::parseMoveString. Failed to convert destination rank.");
            emit errorOccurred(errorMessage);
            return -1; // ★ 打ち切り
        }
    } else {
        const QString errorMessage =
            tr("An error occurred in ShogiEngineInfoParser::parseMoveString. The coordinates of the destination square are invalid.");
        qDebug() << "moveChars[3] = " << moveChars[3];
        emit errorOccurred(errorMessage);
        return -1; // ★ 打ち切り
    }

    // 成/不成フラグ（5文字目が '+' のとき）
    promote = (moveStr.size() > 4 && moveChars[4] == QLatin1Char('+'));

    return 0;
}

// 直前の指し手の筋を返す。
int ShogiEngineInfoParser::previousFileTo() const
{
    return m_previousFileTo;
}

// 直前の指し手の筋を設定する。
void ShogiEngineInfoParser::setPreviousFileTo(int newPreviousFileTo)
{
    m_previousFileTo = newPreviousFileTo;
}

// 直前の指し手の段を返す。
int ShogiEngineInfoParser::previousRankTo() const
{
    return m_previousRankTo;
}

// 直前の指し手の段を設定する。
void ShogiEngineInfoParser::setPreviousRankTo(int newPreviousRankTo)
{
    m_previousRankTo = newPreviousRankTo;
}

// 駒文字から漢字の駒を返す。
QString ShogiEngineInfoParser::getPieceKanjiName(QChar symbol)
{
    // 駒文字を大文字に変換する。
    symbol = symbol.toUpper();

    // 駒文字が対応する漢字の駒のマッピングに存在する場合
    if (m_pieceMapping.contains(symbol)) {
        // 駒文字に対応する漢字の駒を返す。
        return m_pieceMapping[symbol];
    }
    // 駒文字が対応する漢字の駒のマッピングに存在しない場合
    else {
        // 無効な文字が検出された場合、エラーメッセージを表示する。
        QString errorMessage = tr("An error occurred in ShogiEngineInfoParser::getPieceKanjiName. The piece character '%1' does not exist.").arg(symbol);

        emit errorOccurred(errorMessage);

        return QString();
    }
}

// 指定した位置の駒を表す文字を返す。
QChar ShogiEngineInfoParser::getPieceCharacter(const QVector<QChar>& boardData, const int file, const int rank)
{
    // 盤上の駒の場合
    if ((file >= 1) && (file <= 9)) {
        // 盤上の駒文字を返す。
        return boardData.at((rank - 1) * BOARD_SIZE + (file - 1));
    }
    // 駒台の駒の場合
    else if (file == STAND_FILE) {
        // 駒台の段に対応する駒文字を取得する。
        auto iter = m_pieceMap.find(rank);

        // 対応する駒文字が存在する場合
        if (iter != m_pieceMap.end()) {
            // 駒台の段に対応する駒文字を返す。
            return iter.value();
        } else {
            // 無効な文字が検出された場合、エラーメッセージを表示する。
            QString errorMessage = tr("An error occurred in ShogiEngineInfoParser::getPieceCharacter. The rank value is invalid.");

            qDebug() << "rank = " << rank;

            emit errorOccurred(errorMessage);

            return QChar();
        }
    }
    // 筋番号が範囲外の場合
    else {
        // 不正な筋番号file値に対するエラーメッセージを表示する
        QString errorMessage = tr("An error occurred in ShogiEngineInfoParser::getPieceCharacter. The file value is invalid.");

        qDebug() << "file = " << file;

        emit errorOccurred(errorMessage);

        return QChar();
    }
}

// 将棋盤のマスに駒を配置する。
bool ShogiEngineInfoParser::setData(QVector<QChar>& boardData, const int file, const int rank, const QChar piece) const
{
    int index = (rank - 1) * BOARD_SIZE + (file - 1);

    if (boardData.at(index) == piece) return false;

    boardData[index] = piece;

    return true;
}

// 駒を指定したマスへ移動する。配置データのみを更新する。
void ShogiEngineInfoParser::movePieceToSquare(QVector<QChar>& boardData, QChar movingPiece, int fileFrom, int rankFrom,
                                              int fileTo, int rankTo, bool promote) const
{
    // 駒が成る場合
    if (promote) {
        QChar promotedPiece;

        // 成り駒の文字を取得する。
        if (m_promoteMap.contains(movingPiece)) {
            promotedPiece = m_promoteMap[movingPiece];
        }

        // 指した先に成った駒を設定し、元の位置を空白にする。
        setData(boardData, fileTo, rankTo, promotedPiece);
        setData(boardData, fileFrom, rankFrom, ' ');
    }
    // 不成の場合
    else {
        // 盤上の駒を動かす場合、元の位置を空白にする。
        if ((fileFrom >= 1) && (fileFrom <= 9)) {
            setData(boardData, fileFrom, rankFrom, ' ');
        }

        // 新しい位置に駒を配置する
        setData(boardData, fileTo, rankTo, movingPiece);
    }
}

// 将棋エンジンからinfo currmove <move>が返された場合、その漢字の指し手に変換する。
// 将棋エンジンからbestmove相当の現在指し手を漢字表記へ（currmove）
QString ShogiEngineInfoParser::convertCurrMoveToKanjiNotation(const QString& str, const ShogiGameController* algorithm, QVector<QChar>& clonedBoardData,
                                                              const bool isPondering)
{
    int fileFrom = 0, rankFrom = 0, fileTo = 0, rankTo = 0;
    bool promote = false;

    const int rc = parseMoveString(str, fileFrom, rankFrom, fileTo, rankTo, promote);
    if (rc < 0) {
        // 既に parseMoveString 内で emit しているのでここで打ち切る
        return QString(); // ★ 打ち切り
    }
    if (rc == INFO_STRING_SPECIAL_CASE) {
        return QString(); // currmoveでこのケースは通常来ないが保険
    }

    const QChar movingPiece = getPieceCharacter(clonedBoardData, fileFrom, rankFrom);
    const QString kanjiMovePiece = getPieceKanjiName(movingPiece);
    if (kanjiMovePiece.isEmpty()) {
        return QString(); // ★ 打ち切り（エラー通知済み）
    }

    return convertMoveToShogiString(kanjiMovePiece, fileFrom, rankFrom, fileTo, rankTo, promote, algorithm, 0, isPondering);
}

// 将棋エンジンから受信したinfo行を解析し、depthなどのサブコマンドの値を取得する。
void ShogiEngineInfoParser::parseEngineInfoTokens(const QStringList& tokens, const ShogiGameController* algorithm, QVector<QChar>& clonedBoardData,
                                                  const bool isPondering)
{
    for (int i = 0; i < tokens.count() - 1; i++) {
        const QString& token = tokens.at(i);
        const QString& nextToken = tokens.at(i + 1);

        if (token == "depth") {
            m_depth = nextToken;
        } else if (token == "seldepth") {
            m_seldepth = nextToken;
        } else if (token == "multipv") {
            m_multipv = nextToken;
        } else if (token == "nodes") {
            m_nodes = nextToken;
        } else if (token == "nps") {
            m_nps = nextToken;
        } else if (token == "time") {
            m_time = nextToken;
        } else if (token == "hashfull") {
            m_hashfull = nextToken;
        } else if (token == "currmove") {
            m_searchedHand =  convertCurrMoveToKanjiNotation(nextToken, algorithm, clonedBoardData, isPondering);
        } else if (token == "score") {
            parseScore(tokens, i);
        }
    }
}

// scoreサブコマンドの解析を行う。
// score cp、score mate、およびそれらに関連する lowerbound、upperbound の処理を行う。
void ShogiEngineInfoParser::parseScore(const QStringList &tokens, int index)
{
    const QString& type = tokens.at(index + 1);
    const QString& value = tokens.at(index + 2);

    if (type == "cp") {
        m_scoreCp = value;
        m_evaluationBound = EvaluationBound::None;
        if (index + 3 < tokens.count()) {
            const QString& boundType = tokens.at(index + 3);
            if (boundType == "lowerbound") {
                setEvaluationBound(EvaluationBound::LowerBound);
            } else if (boundType == "upperbound") {
                setEvaluationBound(EvaluationBound::UpperBound);
            }
        }
    } else if (type == "mate") {
        m_scoreMate = value;
    }
}

// lowerbound 評価値が下限値（実際にはその値を上回る可能性がある）
// upperbound 評価値が上限値（実際にはその値を下回る可能性がある）
// 評価値の境界を取得する。
ShogiEngineInfoParser::EvaluationBound ShogiEngineInfoParser::evaluationBound() const
{
    return m_evaluationBound;
}

// 評価値の境界を設定する。
void ShogiEngineInfoParser::setEvaluationBound(EvaluationBound newEvaluationBound)
{
    m_evaluationBound = newEvaluationBound;
}

// pv の情報を解析し、それに基づいて盤面を更新する。
int ShogiEngineInfoParser::parsePvAndSimulateMoves(const QStringList& pvTokens, const ShogiGameController* algorithm, QVector<QChar> clonedBoardData,
                                                   const bool isPondering)
{
    int fileFrom = 0, rankFrom = 0, fileTo = 0, rankTo = 0;
    bool promote = false;

    m_pvKanjiStr.clear();

    for (int i = 0; i < pvTokens.size(); ++i) {
        const QString token = pvTokens.at(i).trimmed();

        const int rc = parseMoveString(token, fileFrom, rankFrom, fileTo, rankTo, promote);
        if (rc == INFO_STRING_SPECIAL_CASE) {
            if (i == pvTokens.size() - 1) {
                // 末尾の "(57.54%)" 等はそのまま付加して終了
                m_pvKanjiStr += " " + token;
                return 0;
            }
            // 途中に来るのは想定外だが、打ち切り
            return -1; // ★ 打ち切り
        }
        if (rc < 0) {
            // parse 内で emit 済み
            return -1; // ★ 打ち切り
        }

        const QChar movingPiece = getPieceCharacter(clonedBoardData, fileFrom, rankFrom);
        const QString kanjiMovePiece = getPieceKanjiName(movingPiece);
        if (kanjiMovePiece.isEmpty()) {
            return -1; // ★ 打ち切り（通知済み）
        }

        const QString shogiStr = convertMoveToShogiString(kanjiMovePiece, fileFrom, rankFrom, fileTo, rankTo, promote,
                                                          algorithm, i, isPondering);

        setPreviousFileTo(fileTo);
        setPreviousRankTo(rankTo);

        m_pvKanjiStr += shogiStr;

        if (i == 0) m_searchedHand = shogiStr;

        // 盤面に 1 手適用
        movePieceToSquare(clonedBoardData, movingPiece, fileFrom, rankFrom, fileTo, rankTo, promote);
    }

    return 0;
}

// 指し手を解析し、その指し手に基づいてコピーした盤面データを更新する。
void ShogiEngineInfoParser::parseAndApplyMoveToClonedBoard(const QString& str, QVector<QChar>& clonedBoardData)
{
    int fileFrom = 0, rankFrom = 0, fileTo = 0, rankTo = 0;
    bool promote = false;

    const int rc = parseMoveString(str, fileFrom, rankFrom, fileTo, rankTo, promote);
    if (rc < 0) {
        // 既にエラー通知済み
        return; // ★ 打ち切り
    }
    if (rc == INFO_STRING_SPECIAL_CASE) {
        return; // 指し手ではないので無視
    }

    const QChar movingPiece = getPieceCharacter(clonedBoardData, fileFrom, rankFrom);
    // getPieceKanjiName は不要（盤更新のみ）
    movePieceToSquare(clonedBoardData, movingPiece, fileFrom, rankFrom, fileTo, rankTo, promote);
}

// 将棋エンジンから受信したinfo行の読み筋を日本語に変換する。info行であることは確約されている。
// 例．
// 「7g7h 2f2e 8e8f 2e2d 2c2d 8i7g 8f8g+」
// 「△７八馬(77)▲２五歩(26)△８六歩(85)▲２四歩(25)△同歩(23)▲７七桂(89)△８七歩成(86)」
void ShogiEngineInfoParser::parseEngineOutputAndUpdateState(QString& line, const ShogiGameController* algorithm, QVector<QChar>& clonedBoardData,
                                                           const bool isPondering)
{
    // 将棋エンジンから受信したinfo行から改行を除去する。
    line.remove('\n');

    // 以下のようなinfo行を空白文字を区切り文字として各文字列に分割する。
    // 例．info depth 4 seldepth 4 time 4 nodes 12510 nps 3127500 hashfull 0 score cp 218 multipv 1 pv 8e8f 8g8f 8b8f P*8g
    QStringList tokens = line.split(" ");

    // 将棋エンジンから受信したinfo行を解析し、depthなどのサブコマンドの値を取得する。
    parseEngineInfoTokens(tokens, algorithm, clonedBoardData, isPondering);

    // pvの値を取得するためinfo行を" pv "で区切る。
    QStringList pvLineTokens = line.split(" pv ");

    // info行を" pv "で区切った場合、pvLineTokens.size()は2になるはずだが、それ以外の値の場合は、info行にpvが含まれていない。
    if (pvLineTokens.size() != 2) {
        // info行にpvが含まれていない場合、stringサブコマンドの値を取得する。
        QStringList stringTokens = line.split(" string ", Qt::KeepEmptyParts);

        // stringサブコマンドの値がある場合
        if (stringTokens.size() == 2) {
            // stringサブコマンドの値を読み筋の文字列に設定する。
            // 漢字の文字列ではないが、読み筋の文字列として設定する。
            m_pvKanjiStr = stringTokens.at(1).trimmed();
        }

        // pvを含まないinfo行だった。
        return;
    }

    // info行のサブコマンドpv以降の文字列を空白文字で区切り各文字列を取得する。
    // 例．pv 8e8f 8g8f 8b8f P*8g
    QStringList pvTokens = pvLineTokens.at(1).split(" ");

    // pvの情報を解析し、それに基づいて盤面を更新する。
    parsePvAndSimulateMoves(pvTokens, algorithm, clonedBoardData, isPondering);

    // pvを含むinfo行だった。
    return;
}

// 将棋エンジンから受信した対局相手の予想手を漢字の指し手文字列に変換する。
QString ShogiEngineInfoParser::convertPredictedMoveToKanjiString(const ShogiGameController* algorithm, QString& predictedOpponentMove, QVector<QChar>& clonedBoardData)
{
    int fileFrom = 0, rankFrom = 0, fileTo = 0, rankTo = 0;
    bool promote = false;

    const int rc = parseMoveString(predictedOpponentMove, fileFrom, rankFrom, fileTo, rankTo, promote);
    if (rc < 0 || rc == INFO_STRING_SPECIAL_CASE) {
        // 既にエラー通知済み or 指し手以外
        return QString(); // ★ 打ち切り
    }

    const QChar movingPiece = getPieceCharacter(clonedBoardData, fileFrom, rankFrom);
    const QString kanjiMovePiece = getPieceKanjiName(movingPiece);
    if (kanjiMovePiece.isEmpty()) {
        return QString(); // ★ 打ち切り（通知済み）
    }

    const bool isPondering = true;
    const int i = 0;

    const QString shogiStr =
        convertMoveToShogiString(kanjiMovePiece, fileFrom, rankFrom, fileTo, rankTo, promote, algorithm, i, isPondering);

    setPreviousFileTo(fileTo);
    setPreviousRankTo(rankTo);

    return shogiStr;
}

// 盤面データを9x9のマスに表示する。
void ShogiEngineInfoParser::printShogiBoard(const QVector<QChar>& boardData) const
{
    if (boardData.size() != NUM_BOARD_SQUARES) {
        qDebug() << "無効な盤面データ";
        return;
    }

    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        QString row;
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            QChar piece = boardData[rank * BOARD_SIZE + file];
            if (piece == ' ') {
                row.append("  ");
            } else {
                row.append(piece.toLatin1()).append(' ');
            }
        }
        qDebug() << row;
    }
    qDebug() << "----------------------------------------";
}

// 評価値の文字列を設定する。
void ShogiEngineInfoParser::setScore(const QString &newScore)
{
    m_score = newScore;
}

// 評価値の文字列を取得する。
QString ShogiEngineInfoParser::score() const
{
    return m_score;
}
#include "shogienginethinkingmodel.h"

// 将棋エンジンの思考結果をGUI上で表示するためのクラス
// コンストラクタ
ShogiEngineThinkingModel::ShogiEngineThinkingModel(QObject *parent) : AbstractListModel<ShogiInfoRecord>(parent)
{
}

// 列数を返す。
int ShogiEngineThinkingModel::columnCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent)

    // 「時間」「深さ」「ノード数」「評価値」「読み筋」の5列を返す。
    return 5;
}

// データを返す。
QVariant ShogiEngineThinkingModel::data(const QModelIndex &index, int role) const
{
    // indexが無効またはroleが表示用のデータを要求していない場合、空のQVariantを返す。
    if (!index.isValid() || role != Qt::DisplayRole) {
        return QVariant();
    }

    // 列番号によって処理を分岐する。
    switch (index.column()) {
    case 0:
        // 時間を返す。
        return list[index.row()]->time();
    case 1:        
        // 深さを返す。
        return list[index.row()]->depth();
    case 2:
        // ノード数を返す。
        return list[index.row()]->nodes();
    case 3:
        // 評価値を返す。
        return list[index.row()]->score();
    case 4:
        // 読み筋を返す。
        return list[index.row()]->pv();
    default:
        // それ以外の場合は空のQVariantを返す。
        return QVariant();
    }
}

// ヘッダを返す。
QVariant ShogiEngineThinkingModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    // roleが表示用のデータを要求していない場合、空のQVariantを返す。
    if (role != Qt::DisplayRole) {
        return QVariant();
    }

    // 横方向のヘッダが要求された場合
    if (orientation == Qt::Horizontal) {
        switch (section) {
        case 0:
            // 時間
            return "Time";
        case 1:
            // 深さ
            return "Depth";
        case 2:
            // ノード数
            return "Nodes";
        case 3:
            // 評価値
            return "Score";
        case 4:
            // 読み筋
            return "PV";
        default:
            // それ以外の場合は空のQVariantを返す。
            return QVariant();
        }
    } else {
        // 縦方向のヘッダが要求された場合、セクション番号を返す。
        return QVariant(section + 1);
    }
}
﻿#include <QProcess>
#include <iostream>
#include <QString>
#include <QTime>
#include <QFileInfo>
#include <QDir>
#include <QTextStream>
#include <QtCharts/QChartView>
#include <QtCharts/QLineSeries>
#include <QValueAxis>
#include <QLineEdit>
#include <QApplication>
#include <QSettings>
#include <QLocale>
#include <QMessageBox>
#include <QMap>
#include <QElapsedTimer>
#include <QThread>
#include <QDateTime>
#include <QDebug>
#include <QTimer>
#include <QRegularExpression>

#include "usi.h"
#include "shogiengineinfoparser.h"
#include "shogigamecontroller.h"
#include "shogiboard.h"
#include "shogienginethinkingmodel.h"
#include "playmode.h"
#include "enginesettingsconstants.h"
#include "shogiutils.h"

using namespace EngineSettingsConstants;

// QRegularExpression の関数ローカル static 版（clazy 警告回避）
static const QRegularExpression& whitespaceRe()
{
    static const QRegularExpression re(QStringLiteral("\\s+"));
    return re;
}

static inline QString nowIso()
{
    return QDateTime::currentDateTime().toString(Qt::ISODateWithMs);
}

static inline QString fmtMs(qint64 ms)
{
    if (ms < 0) return QStringLiteral("n/a");
    const qint64 s   = ms / 1000;
    const qint64 rem = ms % 1000;
    return QString("%1.%2s").arg(s).arg(rem, 3, 10, QChar('0')); // 例: "1.234s"
}

// usi.cpp（ファイル先頭の他ヘルパ定義付近に追加）
static inline void ensureMovesKeyword(QString& s) {
    // 既に " moves" が含まれていなければ挿入
    if (!s.contains(QStringLiteral(" moves"))) {
        s = s.trimmed();
        s += QStringLiteral(" moves");
    }
}

// USIプロトコル通信により、将棋エンジンと通信を行うクラス
// コンストラクタ
Usi::Usi(UsiCommLogModel* model, ShogiEngineThinkingModel* modelThinking, ShogiGameController* gameController, PlayMode& playMode, QObject* parent)
    : QObject(parent),
    m_locale(QLocale::English),
    m_process(nullptr),
    m_model(model),
    m_modelThinking(modelThinking),
    m_gameController(gameController),
    m_playMode(playMode),
    m_usiThread(nullptr),
    m_isResignMove(false),
    m_isWinMove(false),
    m_analysisMode(false)
{
    m_shutdownState = ShutdownState::Running;      // NEW
    m_postQuitInfoStringLinesLeft = 0;             // NEW
    m_gameoverSent = false;
    m_quitSent     = false;
}

// デストラクタ
Usi::~Usi()
{
    cleanupEngineProcessAndThread();
}

// 将棋エンジンプロセスを終了し、プロセスとスレッドを削除する。
void Usi::cleanupEngineProcessAndThread()
{
    // --- 1) エンジンプロセスの終了 ---
    if (m_process) {
        // 起動中ならまず quit を送り、段階的に待つ → terminate → kill
        if (m_process->state() == QProcess::Running) {
            // 将棋エンジンに quit コマンドを送信
            sendQuitCommand();

            // 通常はここで終了を待つ
            if (!m_process->waitForFinished(3000)) {
                // 閉じない場合は terminate
                m_process->terminate();
                if (!m_process->waitForFinished(1000)) {
                    // それでも閉じない場合は kill（最終手段）
                    m_process->kill();
                    // kill 後は確実に終了を待つ
                    m_process->waitForFinished(-1);
                }
            }
        }

        // 念のためすべての接続を切断してから破棄
        disconnect(m_process, nullptr, this, nullptr);
        delete m_process;
        m_process = nullptr;
    }

    // --- 2) USI スレッドの後始末 ---
    if (m_usiThread) {
        // ★ UsiThread::run() 側で QEventLoop の終了待ちになっている可能性があるため
        //    stop / ponderhit 相当の合図を emit して確実にループを抜けさせる
        emit stopOrPonderhitCommandSent();

        // 協調的停止のお願い（run() がこれを見るなら有効）
        m_usiThread->requestInterruption();

        // まずは短時間だけ待ってみる
        if (!m_usiThread->wait(500)) {
            // run() 内で QThread::exec() を使っている場合のために quit() も投げる
            m_usiThread->quit();

            // それでも止まらない場合は、段階的に強く止める
            if (!m_usiThread->wait(1000)) {
                qWarning() << "[USI] UsiThread did not stop after quit(); forcing termination.";
                // 最終手段：terminate（本来は避けたいが、アプリ終了時のハング回避を優先）
                m_usiThread->terminate();
                m_usiThread->wait(1000);
            }
        }

        delete m_usiThread;
        m_usiThread = nullptr;
    }
}

// 評価値の文字列を返す。
QString Usi::scoreStr() const
{
    return m_scoreStr;
}

// QProcessのエラーが発生したときに呼び出されるスロット
void Usi::onProcessError(QProcess::ProcessError error)
{
    QString errorMessage;

    switch (error) {
    case QProcess::FailedToStart:
        errorMessage = tr("An error occurred in Usi::onProcessError. The process failed to start.");
        break;
    case QProcess::Crashed:
        errorMessage = tr("An error occurred in Usi::onProcessError. The process crashed.");
        break;
    case QProcess::Timedout:
        errorMessage = tr("An error occurred in Usi::onProcessError. The process timed out.");
        break;
    case QProcess::WriteError:
        errorMessage = tr("An error occurred in Usi::onProcessError. An issue occurred while writing data.");
        break;
    case QProcess::ReadError:
        errorMessage = tr("An error occurred in Usi::onProcessError. An issue occurred while reading data.");
        break;
    default:
        errorMessage = tr("An error occurred in Usi::onProcessError. An unknown error occurred.");
        break;
    }

    // 安全に後片付け（プロセス/スレッド終了・切断）
    cleanupEngineProcessAndThread();

    // 例外は投げず、上位（MainWindow 等）へ通知して終了
    emit errorOccurred(errorMessage);

    // ★ ここで“打ち切り”を確定：オペ用コンテキストを破棄して以降の継続処理を無効化
    cancelCurrentOperation();
    return;
}

// 将棋エンジンプロセスを起動し、対局を開始するUSIコマンドを送受信する。
void Usi::initializeAndStartEngineCommunication(QString& engineFile, QString& enginename)
{
    // 将棋エンジンのファイルパスが空の場合
    if (engineFile.isEmpty()) {
        // 安全に後片付け（プロセス/スレッド終了・切断）
        cleanupEngineProcessAndThread();

        // エラーメッセージ通知 → 以後の処理を打ち切り
        QString errorMessage = tr("An error occurred in Usi::initializeAndStartEngineCommunication. Engine file path is empty.");
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }

    // エンジンのあるディレクトリへ移動（失敗時は当該関数内でemit→打ち切り）
    changeDirectoryToEnginePath(engineFile);

    // 将棋エンジンを起動し、初期化
    startAndInitializeEngine(engineFile, enginename);
}

// カレントディレクトリをエンジンファイルのあるディレクトリに移動する。
void Usi::changeDirectoryToEnginePath(const QString& engineFile)
{
    const QFileInfo fileInfo(engineFile);

    // カレントディレクトリの切り替えに失敗した場合は即打ち切り
    if (!QDir::setCurrent(fileInfo.path())) {
        cleanupEngineProcessAndThread();

        const QString errorMessage =
            tr("An error occurred in Usi::changeDirectoryToEnginePath. Failed to change current directory to %1 for the shogi engine %2.")
                .arg(fileInfo.path(), fileInfo.baseName());
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }
}

// 将棋エンジンを起動し、対局開始に関するコマンドを送信する。
void Usi::startAndInitializeEngine(const QString& engineFile, const QString& enginename)
{
    // 将棋エンジンを起動する。
    startEngine(engineFile);

    // 将棋エンジンに対局開始に関するコマンドを送信する。
    sendInitialCommands(enginename);
}

// 将棋エンジンに対局開始に関するコマンドを送信する。
void Usi::sendInitialCommands(const QString& enginename)
{
    // 設定ファイルから将棋エンジンオプションを読み込み、setoptionコマンドの文字列を生成する。
    generateSetOptionCommands(enginename);

    // usiコマンドを将棋エンジンに送り、usiokを待機する。
    sendUsiCommandAndWaitForUsiOk();

    // setoptionコマンドを将棋エンジンに送信する。
    sendSetOptionCommands();

    // isreadyコマンドを将棋エンジンに送り、readyokを待機する。
    sendIsReadyCommandAndWaitForReadyOk();

    // usinewgameコマンドを将棋エンジンに送る。
    sendUsiNewGameCommand();
}

// usiコマンドを将棋エンジンに送り、usiokを待機する。
void Usi::sendUsiCommandAndWaitForUsiOk()
{
    sendUsiCommand();

    // 5秒待っても usiok が来なければ打ち切り
    if (!waitForUsiOK(5000)) {
        cleanupEngineProcessAndThread();

        const QString errorMessage =
            tr("An error occurred in Usi::sendUsiCommandAndWaitForUsiOk. Timeout waiting for usiok.");
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }
}

// isreadyコマンドを将棋エンジンに送り、readyokを待機する。
void Usi::sendIsReadyCommandAndWaitForReadyOk()
{
    sendIsReadyCommand();

    // 5秒待っても readyok が来なければ打ち切り
    if (!waitForReadyOk(5000)) {
        cleanupEngineProcessAndThread();

        const QString errorMessage =
            tr("An error occurred in Usi::sendIsReadyCommandAndWaitForReadyOk. Timeout waiting for readyok.");
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }
}

// 先手が持ち駒を打つときの駒を文字列に変換する。
// rankFromは持ち駒の駒番号
QString Usi::convertFirstPlayerPieceNumberToSymbol(const int rankFrom) const
{
    static const QMap<int, QString> firstPlayerPieceMap {
        {1, "P*"},
        {2, "L*"},
        {3, "N*"},
        {4, "S*"},
        {5, "G*"},
        {6, "B*"},
        {7, "R*"}
    };

    return firstPlayerPieceMap.value(rankFrom, "");
}

// 後手が持ち駒を打つときの駒を文字列に変換する。
// rankFromは持ち駒の駒番号
QString Usi::convertSecondPlayerPieceNumberToSymbol(const int rankFrom) const
{
    static const QMap<int, QString> secondPlayerPieceMap {
        {3, "R*"},
        {4, "B*"},
        {5, "G*"},
        {6, "S*"},
        {7, "N*"},
        {8, "L*"},
        {9, "P*"}
    };

    return secondPlayerPieceMap.value(rankFrom, "");
}

// 盤上の駒を動かす場合の指し手をUSI形式に変換する。
QString Usi::convertBoardMoveToUsi(int fileFrom, int rankFrom, int fileTo, int rankTo, bool promote) const
{
    // 動かす駒の筋と段からbestmoveの文字列を作成する。
    QString bestMove = QString::number(fileFrom) + rankToAlphabet(rankFrom);

    bestMove += QString::number(fileTo) + rankToAlphabet(rankTo);

    // 成る場合は"+"を付ける。
    if (promote) bestMove += "+";

    return bestMove;
}

// 持ち駒を打つ場合の指し手をUSI形式に変換する。
QString Usi::convertDropMoveToUsi(int fileFrom, int rankFrom, int fileTo, int rankTo) const
{
    QString bestMove;

    if (fileFrom == 10) {
        // 先手の持ち駒を打った場合の文字列に変換する。（例．銀を打つ場合はS*）
        bestMove = convertFirstPlayerPieceNumberToSymbol(rankFrom);
    } else if (fileFrom == 11) {
        // 後手の持ち駒を打った場合の文字列に変換する。（例．銀を打つ場合はS*）
        bestMove = convertSecondPlayerPieceNumberToSymbol(rankFrom);
    }

    // 指した先の筋と段からbestmoveの文字列を作成する。
    bestMove += QString::number(fileTo) + rankToAlphabet(rankTo);

    return bestMove;
}

// 人間の指し手をUSI形式の指し手に直す。
QString Usi::convertHumanMoveToUsiFormat(const QPoint& outFrom, const QPoint& outTo, bool promote)
{
    const int fileFrom = outFrom.x();
    const int rankFrom = outFrom.y();
    const int fileTo   = outTo.x();
    const int rankTo   = outTo.y();

    QString bestMove;

    if (fileFrom >= 1 && fileFrom <= 9) {
        bestMove = convertBoardMoveToUsi(fileFrom, rankFrom, fileTo, rankTo, promote);
    } else if (fileFrom == 10 || fileFrom == 11) {
        bestMove = convertDropMoveToUsi(fileFrom, rankFrom, fileTo, rankTo);
    } else {
        cleanupEngineProcessAndThread();

        const QString errorMessage =
            tr("An error occurred in Usi::convertHumanMoveToUsiFormat. Invalid fileFrom.");
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return QString();
    }

    return bestMove;
}

// bestmove文字列（例: "7g7f", "P*5e"など）から移動元の座標（盤上の駒の場合）または持ち駒の種類（持ち駒を打つ場合）を解析する。
void Usi::parseMoveFrom(const QString& move, int& fileFrom, int& rankFrom)
{
    if (QStringLiteral("123456789").contains(move[0])) {
        fileFrom = move[0].digitValue();
        rankFrom = alphabetToRank(move[1]);
        return;
    }

    if (QStringLiteral("PLNSGBR").contains(move[0]) && move[1] == '*') {
        if (m_gameController->currentPlayer() == ShogiGameController::Player1) {
            fileFrom = 10; rankFrom = pieceToRankBlack(move[0]);
        } else {
            fileFrom = 11; rankFrom = pieceToRankWhite(move[0]);
        }
        return;
    }

    // 不正
    cleanupEngineProcessAndThread();
    const QString errorMessage =
        tr("An error occurred in Usi::parseMoveFrom. Invalid move format in moveFrom.");
    emit errorOccurred(errorMessage);
    cancelCurrentOperation();
    return;
}

// bestmove文字列（例: "7g7f", "P*5e"など）から移動先の座標を解析する。
void Usi::parseMoveTo(const QString& move, int& fileTo, int& rankTo)
{
    if (!move[2].isDigit() || !move[3].isLetter()) {
        cleanupEngineProcessAndThread();

        const QString errorMessage =
            tr("An error occurred in Usi::parseMoveTo. Invalid move format in moveTo.");
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }

    fileTo = move[2].digitValue();
    rankTo = alphabetToRank(move[3]);
}

// 将棋エンジンがbestmove文字列で返した最善手から移動元の筋と段、移動先の筋と段を取得する。
// USIのbestmove（例: "7g7f", "7g7f+", "P*7f", "resign" など）を分解し、
// m_gameController->setPromote(...) を必ず設定してから from/to 座標を返す。
// エラー時はUIへ通知して打ち切り（座標は -1 に初期化）。
void Usi::parseMoveCoordinates(int& fileFrom, int& rankFrom, int& fileTo, int& rankTo)
{
    // デフォルト（エラー/特殊トークン時はこの値のまま戻す）
    fileFrom = rankFrom = fileTo = rankTo = -1;

    const QString move = m_bestMove.trimmed();
    const QString lmove = move.toLower();

    // 特殊トークン（勝敗/引き分けなど）
    if (lmove == QLatin1String("resign") ||
        lmove == QLatin1String("win")    ||
        lmove == QLatin1String("draw"))
    {
        if (m_gameController) m_gameController->setPromote(false);
        return;
    }

    // 最低長チェック（"7g7f" や "P*7f" で4文字。昇格なら5文字 "7g7f+"）
    if (move.size() < 4) {
        cleanupEngineProcessAndThread();
        const QString errorMessage =
            tr("An error occurred in Usi::parseMoveCoordinates. Invalid bestmove format: \"%1\"").arg(move);
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }

    // ★ 昇格フラグを先に決めておく（末尾が '+' なら昇格）
    const bool promote = (move.size() >= 5 && move.at(4) == QLatin1Char('+'));
    if (m_gameController) m_gameController->setPromote(promote);

    // from/to を分解（各関数は不正時に emit 済み・早期return）
    // ここでは初期値 -1 のままかどうかで失敗を判断できるようにしている。
    parseMoveFrom(move, fileFrom, rankFrom);
    if (fileFrom < 0 || rankFrom < 0) return;  // 既にエラー通知＆打ち切り済み

    parseMoveTo(move, fileTo, rankTo);
    if (fileTo < 0 || rankTo < 0) return;      // 既にエラー通知＆打ち切り済み
}

// bestmoveを指定した時間内に受信するまで待機する。
// 指定した時間内に受信できなかった場合、エラーメッセージを表示して例外をスローする。
void Usi::waitAndCheckForBestMove(const int time)
{
    if (!waitForBestMove(time)) {
        const QString errorMessage =
            tr("An error occurred in Usi::waitAndCheckForBestMove. Timeout waiting for bestmove.");
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }
}

// 将棋エンジンからの「bestmove」受信後に予想手を考慮した以下の処理を開始する。
// 1. 「bestmove」と「ponder」の情報をもとに駒配置を更新。
// 2. 予想される相手の指し手をposition文字列に追加。
// 3. 更新したpositionコマンドをエンジンに送信。
// 4. ponderモードをセット。
// 5. エンジンに「go ponder」コマンドを送信。
// 6. "stop"または"ponderhit"コマンドの待機のため新しいスレッドを生成。
void Usi::startPonderingAfterBestMove(QString& positionStr, QString& positionPonderStr)
{
    // ponderモードで相手の指し手が予想できた場合
    if (!m_predictedOpponentMove.isEmpty() && m_isPonderEnabled) {
        // 将棋エンジンから返された「bestmove A ponder B」の情報をもとに、将棋盤内の駒配置を更新する。
        applyMovesToBoardFromBestMoveAndPonder();

        // position文字列に予想した相手の指し手を追加する。
        ensureMovesKeyword(positionStr);
        positionPonderStr = positionStr + " " + m_predictedOpponentMove;

        // positionコマンドを将棋エンジンに送信する。
        sendPositionCommand(positionPonderStr);

        // go ponderコマンドを将棋エンジンに送信する。
        sendGoPonderCommand();

        // 新しいスレッドを生成し、GUIが将棋エンジンにstopまたはponderhitコマンドを送信するまで待つ。
        // start関数が実行されることでrun関数が実行され、その中でwaitForStopOrPonderhitCommand関数が実行される。
        startUsiThread();
    }
}

// 将棋エンジンからの最善手をposition文字列に追加し、予想手を考慮した処理を開始する。
// @param positionStr position文字列
// @param positionPonderStr position文字列に予想手を追加したもの
void Usi::appendBestMoveAndStartPondering(QString& positionStr, QString& positionPonderStr)
{
    // position文字列に将棋エンジンが返した最善手の文字列を追加する。
    ensureMovesKeyword(positionStr);
    positionStr += " " + m_bestMove;

    // 相手の指し手が予想できた場合、予想手を考慮した処理を開始する。
    startPonderingAfterBestMove(positionStr, positionPonderStr);
}

// positionコマンドを送信し、ponderモードをオフにして、goコマンドを送信し、
// bestmoveを受信して予想手を考慮した処理を開始する。
// @param positionStr positionコマンドの文字列
// @param byoyomiMilliSec bestmoveを待機する時間（ミリ秒単位）
// @param btime 黒の残り時間
// @param wtime 白の残り時間
// @param positionPonderStr position文字列に予想手を追加したもの
void Usi::sendCommandsAndProcess(
    int byoyomiMilliSec, QString& positionStr, const QString& btime, const QString& wtime,
    QString& positionPonderStr, int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi)
{
    // ★ このセット（position→go→bestmove）専用の ctx/ID を開始
    const quint64 opId = beginOperationContext();

    //begin
    const QString posPreview = (positionStr.size() > 200)
                                   ? (positionStr.left(200) + QStringLiteral(" ..."))
                                   : positionStr;
    qInfo() << "[USI] send position+go"
            << "opId=" << opId
            << "position=" << posPreview
            << "byoyomiMs=" << byoyomiMilliSec
            << "btime=" << btime << "wtime=" << wtime
            << "inc1=" << addEachMoveMilliSec1 << "inc2=" << addEachMoveMilliSec2
            << "useByoyomi=" << useByoyomi;
    //end

    // position → go
    sendPositionCommand(positionStr);
    cloneCurrentBoardData();
    sendGoCommand(byoyomiMilliSec, btime, wtime, addEachMoveMilliSec1, addEachMoveMilliSec2, useByoyomi);

    // 待機（内部で “IDが変わったら離脱” を判定）
    waitAndCheckForBestMoveRemainingTime(byoyomiMilliSec, btime, wtime, useByoyomi);

    if (m_isResignMove) return;

    // bestmove 受信後の処理（ここで opId と m_seq が食い違っていたら
    // bestmoveReceived 側で弾かれているため、通常通り続行してOK）
    appendBestMoveAndStartPondering(positionStr, positionPonderStr);
}

// positionコマンドとgoコマンドを送信し、bestmoveを受信するまで待機する。
void Usi::sendPositionAndGoCommands(int byoyomiMilliSec, QString& positionStr)
{
    // positionコマンドを将棋エンジンに送信する。
    sendPositionCommand(positionStr);

    // goコマンドを将棋エンジンに送信し、bestmoveを受信するまで待機する。
    sendGoCommandByAnalysys(byoyomiMilliSec);
}

// 盤面データを9x9のマスに表示する。
void Usi::printShogiBoard(const QVector<QChar>& boardData) const
{
    if (boardData.size() != NUM_BOARD_SQUARES) {
        qDebug() << "無効な盤面データ";

        return;
    }

    for (int rank = 0; rank < BOARD_SIZE; ++rank) {
        for (int file = BOARD_SIZE - 1; file >= 0; --file) {
            QChar piece = boardData[rank * BOARD_SIZE + file];
            if (piece == ' ') {
                std::cout << "  ";
            } else {
                std::cout << piece.toLatin1() << ' ';
            }
        }
        std::cout << std::endl;
    }
    std::cout << "----------------------------------------" << std::endl;
}

// 残り時間になるまでbestmoveを待機する。
void Usi::waitAndCheckForBestMoveRemainingTime(int byoyomiMilliSec,
                                               const QString& btime,
                                               const QString& wtime,
                                               bool useByoyomi)
{
    if (shouldAbortWait()) {
        qDebug().nospace() << logPrefix() << " [wait-abort] timeout/ignore declared";
        return;
    }

    const bool p1turn = (m_gameController->currentPlayer() == ShogiGameController::Player1);
    const int  mainMs = p1turn ? btime.toInt() : wtime.toInt();
    int capMs = useByoyomi ? (mainMs + byoyomiMilliSec) : mainMs;
    if (capMs >= 200) capMs -= 100;

    qDebug().nospace()
        << "[USI] waitBestmove  turn=" << (p1turn ? "P1" : "P2")
        << " cap=" << capMs << "ms"
        << " (main=" << mainMs
        << ", byoyomi=" << byoyomiMilliSec
        << ", mode=" << (useByoyomi ? "byoyomi" : "increment") << ")";

    // ★ ここで ID も監視（waitForBestMoveWithGrace 内で expectedId をチェック）
    const bool got = waitForBestMoveWithGrace(capMs, kBestmoveGraceMs);

    if (!got) {
        if (shouldAbortWait()) {
            qDebug().nospace() << logPrefix() << " [wait-abort-2] timeout/quit during wait";
            return;
        }
        const QString errorMessage =
            tr("An error occurred in Usi::waitAndCheckForBestMoveRemainingTime. Timeout waiting for bestmove.");
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }
}

bool Usi::waitForBestMoveWithGrace(int capMs, int graceMs)
{
    QElapsedTimer t; t.start();
    const qint64 hard = capMs + qMax(0, graceMs);

    m_bestMoveSignalReceived = false;

    // ★ この待機が属するオペの “期待ID”
    const quint64 expectedId = m_seq;

    while (t.elapsed() < hard) {
        // ★ オペがキャンセル/切替されたら即離脱（旧bestmoveは採用しない）
        if (m_seq != expectedId || shouldAbortWait()) return false;

        QCoreApplication::processEvents(QEventLoop::AllEvents, 5);
        if (m_bestMoveSignalReceived) return true;

        QThread::msleep(1);
    }
    return m_bestMoveSignalReceived;
}

// 将棋エンジンからのレスポンスに基づいて、適切なコマンドを送信し、必要に応じて処理を行う。
void Usi::processEngineResponse(QString& positionStr, QString& positionPonderStr, int byoyomiMilliSec,
                                const QString& btime, const QString& wtime,
                                int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi)
{
    if (m_predictedOpponentMove.isEmpty() || !m_isPonderEnabled) {
        sendCommandsAndProcess(byoyomiMilliSec, positionStr, btime, wtime,
                               positionPonderStr, addEachMoveMilliSec1, addEachMoveMilliSec2, useByoyomi);
        if (m_isResignMove) return;
    } else {
        if (m_bestMove == m_predictedOpponentMove) {
            cloneCurrentBoardData();
            sendPonderHitCommand();

            if (byoyomiMilliSec == 0) {
                keepWaitingForBestMove();
            } else {
                waitAndCheckForBestMoveRemainingTime(byoyomiMilliSec, btime, wtime, useByoyomi);
            }
            if (m_isResignMove) return;

            appendBestMoveAndStartPondering(positionStr, positionPonderStr);
        } else {
            // ★ ミスマッチを明示
            qDebug().nospace() << logPrefix()
                               << " PONDER MISMATCH → send stop"
                               << " predicted=" << m_predictedOpponentMove
                               << " actual="    << m_bestMove;

            sendStopCommand();

            if (byoyomiMilliSec == 0) {
                keepWaitingForBestMove();
            } else {
                waitAndCheckForBestMoveRemainingTime(byoyomiMilliSec, btime, wtime, useByoyomi);
            }
            if (m_isResignMove) return;

            sendCommandsAndProcess(byoyomiMilliSec, positionStr, btime, wtime,
                                   positionPonderStr, addEachMoveMilliSec1, addEachMoveMilliSec2, useByoyomi);
            if (m_isResignMove) return;
        }
    }
}

// 将棋エンジンとのUSIプロトコルに基づく通信を処理するための共通関数
// 人間対エンジン、エンジン対人間、およびエンジン同士の対局で共通して使用される。
void Usi::executeEngineCommunication(QString& positionStr, QString& positionPonderStr, QPoint& outFrom,
                                     QPoint& outTo, int byoyomiMilliSec, const QString& btime, const QString& wtime,
                                     int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi)
{
    // 将棋エンジンからのレスポンスに基づいて、適切なコマンドを送信し、必要に応じて処理を行う。
    processEngineResponse(positionStr, positionPonderStr, byoyomiMilliSec, btime, wtime, addEachMoveMilliSec1, addEachMoveMilliSec2, useByoyomi);

    // bestmove resignを受信した場合
    if (m_isResignMove) return;

    int fileFrom, rankFrom, fileTo, rankTo;

    // 将棋エンジンがbestmove文字列で返した最善手から移動元の筋と段、移動先の筋と段を取得する。
    parseMoveCoordinates(fileFrom, rankFrom, fileTo, rankTo);

    // 移動元と移動先の筋と段をQPoint型のoutFrom、outToに代入する。
    outFrom = QPoint(fileFrom, rankFrom);
    outTo = QPoint(fileTo, rankTo);
}

// 人間対将棋エンジンの対局で将棋エンジンとUSIプロトコル通信を行う。
/*
void Usi::handleHumanVsEngineCommunication(QString& positionStr, QString& positionPonderStr, QPoint& outFrom, QPoint& outTo,
                                          int byoyomiMilliSec, const QString& btime, const QString& wtime, QStringList& positionStrList,
                                          int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi)
{
    //begin
    qDebug() << "in Usi::handleHumanVsEngineCommunication";
    qDebug() << "byoyomiMilliSec: " << byoyomiMilliSec;
    qDebug() << "btime: " << btime;
    qDebug() << "wtime: " << wtime;
    //end

    // bestmove文字列の作成
    m_bestMove = convertHumanMoveToUsiFormat(outFrom, outTo, m_gameController->promote());

    ensureMovesKeyword(positionStr);

    // position文字列にbestmoveの文字列を追加する。
    positionStr += " " + m_bestMove;

    // position文字列をリストに追加する。
    positionStrList.append(positionStr);

    // 共通のエンジン通信処理を実行する。
    executeEngineCommunication(positionStr, positionPonderStr, outFrom, outTo, byoyomiMilliSec, btime, wtime,
                               addEachMoveMilliSec1, addEachMoveMilliSec2, useByoyomi);
}
*/

void Usi::handleHumanVsEngineCommunication(QString& positionStr, QString& positionPonderStr,
                                           QPoint& outFrom, QPoint& outTo,
                                           int byoyomiMilliSec, const QString& btime, const QString& wtime,
                                           QStringList& positionStrList, int addEachMoveMilliSec1,
                                           int addEachMoveMilliSec2, bool useByoyomi)
{
    qDebug() << "[USI][HvE] enter handleHumanVsEngineCommunication"
             << "byoyomiMs=" << byoyomiMilliSec
             << "btime=" << btime << "wtime=" << wtime;

    // 送信前の position をプレビュー
    const QString prePreview = (positionStr.size() > 200)
                                   ? (positionStr.left(200) + QStringLiteral(" ..."))
                                   : positionStr;
    qDebug() << "[USI][HvE] position(before ensureMoves/bestmove) =" << prePreview;

    // bestmove 生成（人間手）
    m_bestMove = convertHumanMoveToUsiFormat(outFrom, outTo, m_gameController->promote());

    ensureMovesKeyword(positionStr);   // "moves" を必ず含める
    positionStr += " " + m_bestMove;   // 人間手を末尾に追加
    positionStrList.append(positionStr);

    const QString postPreview = (positionStr.size() > 200)
                                    ? (positionStr.left(200) + QStringLiteral(" ..."))
                                    : positionStr;
    qDebug() << "[USI][HvE] position(after append bestmove) =" << postPreview;

    executeEngineCommunication(positionStr, positionPonderStr, outFrom, outTo,
                               byoyomiMilliSec, btime, wtime,
                               addEachMoveMilliSec1, addEachMoveMilliSec2, useByoyomi);
}

// 将棋エンジン対人間および将棋エンジン同士の対局で将棋エンジンとUSIプロトコル通信を行う。
void Usi::handleEngineVsHumanOrEngineMatchCommunication(QString& positionStr, QString& positionPonderStr, QPoint& outFrom, QPoint& outTo,
                                                        int byoyomiMilliSec, const QString& btime, const QString& wtime,
                                                        int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi)
{
    // 共通のエンジン通信処理を実行する。
    executeEngineCommunication(positionStr, positionPonderStr, outFrom, outTo, byoyomiMilliSec, btime, wtime,
                               addEachMoveMilliSec1, addEachMoveMilliSec2, useByoyomi);
}

// 将棋エンジンからのレスポンスに基づいて、適切なコマンドを送信し、必要に応じて処理を行う。
void Usi::executeAnalysisCommunication(QString& positionStr, int byoyomiMilliSec)
{
    // 現在の局面（盤内のみ）をコピーする。
    cloneCurrentBoardData();

    // positionコマンドとgoコマンドを送信し、bestmoveを受信するまで待機する。
    sendPositionAndGoCommands(byoyomiMilliSec, positionStr);
}

// 漢字の指し手に変換したpv文字列を設定する。
void Usi::setPvKanjiStr(const QString& newPvKanjiStr)
{
    m_pvKanjiStr = newPvKanjiStr;
}

// GUIの「探索手」欄を更新する。
void Usi::updateSearchedHand(const ShogiEngineInfoParser* info)
{
    m_model->setSearchedMove(info->searchedHand());
}

// GUIの「深さ」欄を更新する。
void Usi::updateDepth(const ShogiEngineInfoParser* info)
{
    // 選択的に読んだ手の深さseldepthの値が何も無い時
    if (info->seldepth().isEmpty()) {
        // GUIの「深さ」欄に基本深さの値をセットする。
        m_model->setSearchDepth(info->depth());
    } else {
        // GUIの「深さ」欄に基本深さと選択的に読んだ手の深さをセットする。
        m_model->setSearchDepth(info->depth() + "/" + info->seldepth());
    }
}

// GUIの「ノード数」欄を更新する。
void Usi::updateNodes(const ShogiEngineInfoParser* info)
{
    // ノード数の情報を取得してGUIを更新する。
    unsigned long long nodes = info->nodes().toULongLong();

    // QLocaleを使用して3桁ごとにカンマを挿入する。
    m_model->setNodeCount(m_locale.toString(nodes));
}

// GUIの「局面探索数」欄を更新する。
void Usi::updateNps(const ShogiEngineInfoParser* info)
{
    // 探索局面数の情報を取得してGUIを更新する。
    unsigned long long nps = info->nps().toULongLong();

    // QLocaleを使用して3桁ごとにカンマを挿入する。
    m_model->setNodesPerSecond(m_locale.toString(nps));
}

// GUIの「ハッシュ使用率」欄を更新する。
void Usi::updateHashfull(const ShogiEngineInfoParser* info)
{
    // ハッシュの使用率hashfullの値が何も無い時
    if (info->hashfull().isEmpty()) {
        // GUIの「ハッシュ使用率」に空文字をセットする。
        m_model->setHashUsage("");
    } else {
        // hashfullの値を10で割って%表示にする。
        unsigned long long hash = info->hashfull().toULongLong() / 10;

        // GUIの「ハッシュ使用率」に%表示の値をセットする。
        m_model->setHashUsage(QString::number(hash) + "%");
    }
}

// 評価値を計算する。
int Usi::calculateScoreInt(const ShogiEngineInfoParser* info) const
{
    // 評価値を0で初期化
    int scoreInt = 0;

    // 詰み手数scoremateが正の時
    if ((info->scoreMate().toLongLong() > 0) || (info->scoreMate() == "+")) {
        // 最大評価値2000に設定
        scoreInt = 2000;
    }
    // 詰み手数scoremateが負の時
    else if ((info->scoreMate().toLongLong() < 0) || (info->scoreMate() == "-")) {
        // マイナスの評価値-2000に設定
        scoreInt = -2000;
    }
    // 詰み手数scoremateが0の時
    else {
        // 評価値を0に設定
        scoreInt = 0;
    }

    // 設定した評価値を返す。
    return scoreInt;
}

// 詰み手数（scoreMate）と最終評価値（lastScore）の更新を行う。
void Usi::updateScoreMateAndLastScore(ShogiEngineInfoParser* info, int& scoreInt)
{
    // 詰み手数scoremateの値が何も無い時
    if (info->scoreMate().isEmpty()) {
        // 最終評価値の値を0にする。
        m_lastScoreCp = 0;
    }
    // 詰み手数scoremateに値がある時
    else {
        scoreInt = calculateScoreInt(info);

        QString scoreMate = info->scoreMate();

        if ((scoreMate == "+") || (scoreMate == "-")) {
            scoreMate = "詰";
        } else {
            scoreMate += "手詰";
        }

        info->setScore(scoreMate);

        // 評価値の文字列に詰み手数を代入
        m_scoreStr = info->scoreMate();

        // 評価値の値を保存する。
        m_lastScoreCp = scoreInt;
    }
}

// 棋譜解析モードにより、評価値の処理を行う。
void Usi::updateAnalysisModeAndScore(const ShogiEngineInfoParser* info, int& scoreInt)
{
    // 棋譜解析モードの時
    if (m_analysisMode) {
        // 手番がPlayer1の時
        if (m_gameController->currentPlayer() == ShogiGameController::Player1) {
            // 評価値の文字列を整数に変換
            scoreInt = info->scoreCp().toInt();

            // 評価値の文字列を取得
            m_scoreStr = info->scoreCp();
        }
        // 手番がPlayer2の時
        else if (m_gameController->currentPlayer() == ShogiGameController::Player2) {
            // 評価値の文字列を整数に変換し、符号を反転させる。
            scoreInt = -info->scoreCp().toInt();

            // 評価値の文字列を取得
            m_scoreStr = QString::number(scoreInt);
        }
    }
    // 棋譜解析モード以外の時
    else {
        // 評価値の文字列を取得
        m_scoreStr = info->scoreCp();

        // 評価値の文字列を整数に変換
        scoreInt = m_scoreStr.toInt();

        if (info->evaluationBound() == ShogiEngineInfoParser::EvaluationBound::LowerBound) {
            m_scoreStr += "++";
        } else if (info->evaluationBound() == ShogiEngineInfoParser::EvaluationBound::UpperBound) {
            m_scoreStr += "--";
        }
    }
}

// 入力された評価値（scoreint）を範囲内（-2000〜2000）に制限して、その値をm_lastScorecpに設定する。
void Usi::updateLastScore(const int scoreInt)
{
    // 評価値が2000より大きいとき
    if (scoreInt > 2000) {
        // GUIの評価値グラフの上限値2000をm_lastScorecpに設定
        m_lastScoreCp = 2000;
    }
    // 評価値が-2000より小さいとき
    else if (scoreInt < -2000) {
        // GUIの評価値グラフの下限値2000をm_lastScorecpに設定
        m_lastScoreCp = -2000;
    }
    // 評価値が-2000〜2000の範囲の時
    else {
        // そのままの評価値をm_lastScorecpに設定
        m_lastScoreCp = scoreInt;
    }
}

// 現在の評価値（scoreCp）が存在するかどうかに基づき、詰み手数（scoremate）と最終評価値（lastScore）を更新する。
// scorecpが存在する場合は、棋譜解析モードに基づいた評価値の処理を行い、その他の情報（時間、深さ、ノード数、評価値、読み筋）をセットする。
// さらに、評価値を範囲内（-2000〜2000）に制限した上で、最終評価値を更新する。
void Usi::updateEvaluationInfo(ShogiEngineInfoParser* info, int& scoreInt)
{
    // 現在の評価値scorecpの値が何も無い時
    if (info->scoreCp().isEmpty()) {
        // 詰み手数（scoremate）と最終評価値（lastScore）の更新を行う。
        updateScoreMateAndLastScore(info, scoreInt);
    }
    // 現在の評価値scorecpに値がある時
    else {
        // 棋譜解析モードにより、評価値の処理を行う。
        updateAnalysisModeAndScore(info, scoreInt);

        info->setScore(m_scoreStr);

        // 漢字表記の読み筋を取得する。
        setPvKanjiStr(info->pvKanjiStr());

        // 入力された評価値（scoreInt）を範囲内（-2000〜2000）に制限して、その値をm_lastScorecpに設定する。
        updateLastScore(scoreInt);
    }
}

// 1手前に指した移動先の筋を設定する。
void Usi::setPreviousFileTo(int newPreviousFileTo)
{
    m_previousFileTo = newPreviousFileTo;
}

// 1手前に指した移動先の段を設定する。
void Usi::setPreviousRankTo(int newPreviousRankTo)
{
    m_previousRankTo = newPreviousRankTo;
}

// 漢字表記の読み筋を取得する。
QString Usi::pvKanjiStr() const
{
    return m_pvKanjiStr;
}

// 一番最後に受信した指し手の評価値を返す。
int Usi::lastScoreCp() const
{
    return m_lastScoreCp;
}

// GUIがbestmove resignを受信したかどうかのフラグを返す。
bool Usi::isResignMove() const
{
    return m_isResignMove;
}

// 将棋エンジンからinfoを受信した時にinfo行を解析し、GUIの「思考」タブに表示する。
// 将棋エンジンから受信したinfo行の読み筋を日本語に変換し、GUIの「探索手」「深さ」「ノード数」
// 「局面探索数」「ハッシュ使用率」「思考タブ」欄を更新する。
void Usi::infoReceived(QString& line)
{
    // 停止中は何もしない（従来互換）
    if (m_shutdownState != ShutdownState::Running) return;

    // ──────────────────────────────────────────────────────────────
    // バッファリング＆合成反映（最小改修：QObjectの動的プロパティを利用、ヘッダ変更なし）
    //   - "_infoBuf"        : QVariantList に QString を詰める
    //   - "_infoScheduled"  : bool フラグ（flush 予約済みか）
    // 50ms ごとにまとめて UI 反映し、イベントループ占有を抑える
    // ──────────────────────────────────────────────────────────────

    // 1) 行をバッファに積む
    {
        QVariantList buf = this->property("_infoBuf").toList();
        buf.append(line); // コピーして保持
        this->setProperty("_infoBuf", buf);
    }

    // 2) まだ flush が予約されていなければ予約する（50ms後に実行）
    if (!this->property("_infoScheduled").toBool()) {
        this->setProperty("_infoScheduled", true);

        // この Usi インスタンスをコンテキストに、50ms 後まとめて処理
        QTimer::singleShot(50, this, [this]() {
            // 予約フラグを解除
            this->setProperty("_infoScheduled", false);

            // 状態が既に停止していたら捨てる
            if (m_shutdownState != ShutdownState::Running) {
                this->setProperty("_infoBuf", QVariantList());
                return;
            }

            // 3) バッファを取り出してクリア（swap 的に）
            QVariantList batch;
            {
                batch = this->property("_infoBuf").toList();
                this->setProperty("_infoBuf", QVariantList());
            }
            if (batch.isEmpty()) return;

            // 4) まとめて処理（元の per-line ロジックをそのままループ内で実行）
            //    ※ ここで「UI更新を1行ずつ」行っても、readyRead 直列処理よりは
            //       スライスされるためイベントループが回りやすくなります。
            for (const QVariant& v : batch) {
                if (m_shutdownState != ShutdownState::Running) break; // 途中停止安全弁
                const QString ln = v.toString();
                if (ln.isEmpty()) continue;

                // ───────────── 以降、従来 infoReceived(line) の中身 ─────────────
                int scoreInt = 0;

                // info行を解析するクラス
                ShogiEngineInfoParser* info = new ShogiEngineInfoParser;

                // 前回の指し手の筋・段
                info->setPreviousFileTo(m_previousFileTo);
                info->setPreviousRankTo(m_previousRankTo);

                // 読み筋を日本語に変換＋内部状態更新
                info->parseEngineOutputAndUpdateState(
                    const_cast<QString&>(ln), // 既存シグネチャ互換のため const_cast
                    m_gameController,
                    m_clonedBoardData,
                    m_isPonderEnabled
                    );

                // 各種GUI項目の更新
                updateSearchedHand(info);
                updateDepth(info);
                updateNodes(info);
                updateNps(info);
                updateHashfull(info);

                // 評価値/詰み手数/最終評価値の更新
                updateEvaluationInfo(info, scoreInt);

                // 何かしら更新がある場合は思考タブへ追記
                if (!info->time().isEmpty() || !info->depth().isEmpty() ||
                    !info->nodes().isEmpty() || !info->score().isEmpty() ||
                    !info->pvKanjiStr().isEmpty()) {
                    if (m_modelThinking) {
                        m_modelThinking->prependItem(
                            new ShogiInfoRecord(info->time(),
                                                info->depth(),
                                                info->nodes(),
                                                info->score(),
                                                info->pvKanjiStr()));
                    }
                }

                delete info;
                // ───────────── ここまで従来ロジック ─────────────
            }
        });
    }
}

void Usi::sendGameOverLoseAndQuitCommands()
{
    if (!m_process || m_process->state() != QProcess::Running) return;

    if (!m_gameoverSent) {                               // ★ 2重送信ガード
        sendGameOverCommand(QStringLiteral("lose"));
        m_gameoverSent = true;
    }

    sendQuitCommand();                                   // ★ 中で m_quitSent を確認

    // 以降は以前のとおり（info string だけ許可／バッファ廃棄／EOF）
    m_shutdownState = ShutdownState::IgnoreAllExceptInfoString;
    m_postQuitInfoStringLinesLeft = 1;
    (void)m_process->readAllStandardOutput();
    (void)m_process->readAllStandardError();
    m_process->closeWriteChannel();
}

void Usi::sendGameOverWinAndQuitCommands()
{
    if (!m_process || m_process->state() != QProcess::Running) return;

    if (!m_gameoverSent) {
        sendGameOverCommand(QStringLiteral("win"));
        m_gameoverSent = true;
    }

    sendQuitCommand();

    m_shutdownState = ShutdownState::IgnoreAllExceptInfoString;
    m_postQuitInfoStringLinesLeft = 1;
    (void)m_process->readAllStandardOutput();
    (void)m_process->readAllStandardError();
    m_process->closeWriteChannel();
}

// 将棋エンジンから受信したデータを1行ごとにm_linesに貯え、GUIに受信データをログ出力する。
// 標準出力からの受信
void Usi::readFromEngine()
{
    // スロット内で例外を投げるとアプリが死にやすいので、警告に留めて戻る
    if (!m_process) {
        qWarning() << "[USI] readFromEngine called but m_process is null; ignoring.";
        return;
    }

    // 1回の呼び出しで処理する最大行数（イベントループ占有を避けるための上限）
    static constexpr int kMaxLinesPerChunk = 64;
    int processed = 0;

    while (m_process && m_process->canReadLine() && processed < kMaxLinesPerChunk) {
        const QByteArray data = m_process->readLine();
        QString line = QString::fromUtf8(data).trimmed();
        if (line.isEmpty()) { ++processed; continue; }

        // 起動直後のみエンジン名を確定（ログ接頭辞に使う）
        if (line.startsWith(QStringLiteral("id name "))) {
            const QString n = line.mid(8).trimmed();
            if (!n.isEmpty() && m_logEngineName.isEmpty())
                m_logEngineName = n;
        }

        // ---- 終局/終了後の遮断ロジック ---------------------------------------
        if (m_timeoutDeclared) {
            qDebug().nospace() << logPrefix() << " [drop-after-timeout] " << line;
            ++processed;
            continue;
        }
        if (m_shutdownState == ShutdownState::IgnoreAllExceptInfoString) {
            if (line.startsWith(QStringLiteral("info string")) &&
                m_postQuitInfoStringLinesLeft > 0) {
                const QString pfx = logPrefix();
                if (m_model) {
                    m_model->appendUsiCommLog(pfx + " < " + line);
                } else {
                    qWarning().noquote() << pfx << " usidebug< (no-log-model) " << line;
                }
                qDebug().nospace() << pfx << " usidebug< " << line;
                --m_postQuitInfoStringLinesLeft;
            } else {
                qDebug().nospace() << logPrefix() << " [drop-after-quit] " << line;
            }
            ++processed;
            continue;
        }
        if (m_shutdownState == ShutdownState::IgnoreAll) {
            qDebug().nospace() << logPrefix() << " [drop-ignore-all] " << line;
            ++processed;
            continue;
        }
        // ---------------------------------------------------------------------

        // === 通常処理 ===
        const QString pfx = logPrefix();
        m_lines.append(line);

        // ★ 受信ログのヌルガード（EvEでcommモデル未配線でも落とさない）
        if (m_model) {
            m_model->appendUsiCommLog(pfx + " < " + line);
        } else {
            qWarning().noquote() << pfx << " usidebug< (no-log-model) " << line;
        }
        qDebug().nospace() << pfx << " usidebug< " << line;

        // ───────── 詰将棋の最終結果は最優先で処理 ─────────
        if (line.startsWith(QStringLiteral("checkmate"))) {
            handleCheckmateLine(line);
            ++processed;
            continue;
        }

        // ───────── 既存のbestmove/infoなど ─────────
        if (line.startsWith(QStringLiteral("bestmove"))) {
            m_bestMoveSignalReceived = true;
            bestMoveReceived(line);
        } else if (line.startsWith(QStringLiteral("info"))) {
            m_infoSignalReceived = true;
            infoReceived(line);
        } else if (line.contains(QStringLiteral("readyok"))) {
            m_readyOkSignalReceived = true;
        } else if (line.contains(QStringLiteral("usiok"))) {
            m_usiOkSignalReceived = true;
        }

        ++processed;
    }

    // まだ読み残しがある場合は、イベントループに返してから続きを処理
    if (m_process && m_process->canReadLine()) {
        QTimer::singleShot(0, this, &Usi::readFromEngine);
    }
}

// 標準エラーからの受信（新規）
void Usi::readFromEngineStderr()
{
    if (!m_process) return;

    // 完全遮断ならまとめて読み捨て
    if (m_shutdownState == ShutdownState::IgnoreAll) {
        (void)m_process->readAllStandardError();
        return;
    }

    while (m_process->bytesAvailable() || m_process->canReadLine()) {
        const QByteArray data = m_process->readAllStandardError();
        if (data.isEmpty()) break;
        const QStringList lines = QString::fromUtf8(data).split('\n', Qt::SkipEmptyParts);

        for (const QString& l : lines) {
            const QString line = l.trimmed();
            if (line.isEmpty()) continue;

            // --- NEW: 終了状態のフィルタ ---
            if (m_shutdownState == ShutdownState::IgnoreAllExceptInfoString) {
                if (m_postQuitInfoStringLinesLeft > 0 && shouldLogAfterQuit(line)) {
                    const QString pfx = logPrefix();
                    m_model->appendUsiCommLog(pfx + " <stderr> " + line);
                    qDebug().nospace() << pfx << " usidebug<stderr> " << line;

                    if (--m_postQuitInfoStringLinesLeft <= 0) {
                        m_shutdownState = ShutdownState::IgnoreAll;
                    }
                }
                continue; // 許可しない行は捨てる
            }

            // --- 通常時のみ stderr をログ ---
            const QString pfx = logPrefix();
            m_model->appendUsiCommLog(pfx + " <stderr> " + line);
            qDebug().nospace() << pfx << " usidebug<stderr> " << line;
        }
    }
}

// 将棋エンジンを起動する。
void Usi::startEngine(const QString& engineFile)
{
    // エンジンファイル存在チェック
    if (engineFile.isEmpty() || !QFile::exists(engineFile)) {
        const QString errorMessage =
            tr("An error occurred in Usi::startEngine. The specified engine file does not exist: %1").arg(engineFile);
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }

    QStringList args;

    // 旧プロセスが生きていたら念のため終了（重複起動防止）
    if (m_process) {
        disconnect(m_process, nullptr, this, nullptr);
        if (m_process->state() != QProcess::NotRunning) {
            sendQuitCommand();
            m_process->waitForFinished(1000);
        }
        m_process->deleteLater();
        m_process = nullptr;
    }

    // 新規 QProcess 準備
    m_process = new QProcess(this);

    // 起動
    m_process->start(engineFile, args, QIODevice::ReadWrite);

    // 起動失敗 → 打ち切り
    if (!m_process->waitForStarted()) {
        cleanupEngineProcessAndThread();
        const QString errorMessage =
            tr("An error occurred in Usi::startEngine. Failed to start the engine: %1").arg(engineFile);
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }

    // コールバック接続
    connect(m_process, &QProcess::readyReadStandardOutput, this, &Usi::readFromEngine);
    connect(m_process, &QProcess::readyReadStandardError,  this, &Usi::readFromEngineStderr);
    connect(m_process, &QProcess::errorOccurred,           this, &Usi::onProcessError);
    connect(m_process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            this, &Usi::onProcessFinished);
}

// 将棋エンジンにコマンドを送信し、GUIのUSIプロトコル通信ログに表示する。
void Usi::sendCommand(const QString& command) const
{
    if (!m_process || (m_process->state() != QProcess::Running && m_process->state() != QProcess::Starting)) {
        qWarning() << "[USI] process not ready; command ignored:" << command;
        return;
    }

    m_process->write((command + "\n").toUtf8());

    const QString pfx = logPrefix();
    if (m_model) {
        m_model->appendUsiCommLog(pfx + " > " + command);
    }
    qDebug().nospace() << pfx << " usidebug> " << command;
}

// 将棋エンジンからデータを受信して保管した行リストをクリアする。
void Usi::clearResponseData()
{
    // 行リストのクリア
    m_lines.clear();

    // エラーチェック
    if (!m_lines.isEmpty()) {
        // 将棋エンジンプロセスを終了し、プロセスとスレッドを削除する。
        cleanupEngineProcessAndThread();

        // 行リストのクリアに失敗したことを表示する。
        QString errorMessage = tr("An error occurred in Usi::clearResponseData. Failed to clear the line list.");

        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }
}

void Usi::sendQuitCommand()
{
    if (!m_process) return;

    // ★ 現行オペをキャンセル（ctx破棄＋ID進め）
    cancelCurrentOperation();

    m_shutdownState = ShutdownState::IgnoreAllExceptInfoString;
    m_postQuitInfoStringLinesLeft = 1;

    sendCommand(QStringLiteral("quit"));

    (void)m_process->readAllStandardOutput();
    (void)m_process->readAllStandardError();
    m_process->closeWriteChannel();
}

// usinewgameコマンドを将棋エンジンに送信する。
void Usi::sendUsiNewGameCommand()
{
    // 将棋エンジンにコマンドを送信する。
    sendCommand("usinewgame");
}

// positionコマンドを将棋エンジンに送信する。
void Usi::sendPositionCommand(QString& positionStr)
{
    // 将棋エンジンにコマンドを送信する。
    sendCommand(positionStr);
}

// 設定ファイルから将棋エンジンオプションを読み込み、
// setoptionコマンドの文字列を生成する。
void Usi::generateSetOptionCommands(const QString& engineName)
{
    // 実行パスをGUIと同じディレクトリに設定
    QDir::setCurrent(QApplication::applicationDirPath());

    // 設定ファイルから設定を読み込むためのQSettingsオブジェクトを作成する。
    QSettings settings(SettingsFileName, QSettings::IniFormat);

    // エンジン名に関連する設定の数を取得する。
    int settingCount = settings.beginReadArray(engineName);

    // ponderモードが有効かどうかのフラグを無効にする。
    m_isPonderEnabled = false;

     // 各設定をループで処理する。
    for (int i = 0; i < settingCount; ++i) {
        // 現在のインデックスを設定する。
        settings.setArrayIndex(i);

        // 設定の名前、値、タイプを取得する。
        QString settingName = settings.value("name").toString();
        QString settingValue = settings.value("value").toString();
        QString settingType = settings.value("type").toString();

        // タイプがボタンで、値が"on"の場合
        if (settingType == "button" && settingValue == "on") {
            // 名前だけのsetoptionコマンドを生成する。
            m_setOptionCommandList.append("setoption name " + settingName);
        }
        // それ以外の場合
        else {
            // 名前と値を持つsetoptionコマンドを生成する。
            m_setOptionCommandList.append("setoption name " + settingName + " value " + settingValue);

            // オプションがUSI_Ponderの場合
            if (settingName == "USI_Ponder") {
                // ponderモードが有効かどうかを設定する。
                m_isPonderEnabled = (settingValue == "true") ? true : false;
            }
        }
    }

    // 配列の読み取りを終了する。
    settings.endArray();
}

// setoptionコマンドを将棋エンジンに送信する。
void Usi::sendSetOptionCommands()
{
    // setoptionコマンドの個数分、繰り返す。
    for (int i = 0; i < m_setOptionCommandList.size(); i++) {
        // 各setoptionコマンドを取得する。
        QString command = m_setOptionCommandList.at(i);

        // 将棋エンジンにコマンドを送信する。
        sendCommand(command);
    }
}

// info行を全て削除する。
void Usi::infoRecordClear()
{
    if (m_modelThinking) m_modelThinking->clearAllItems();
}

// go ponderコマンドを将棋エンジンに送信する。
void Usi::sendGoPonderCommand()
{
    infoRecordClear();

    m_phase = SearchPhase::Ponder;
    ++m_ponderSession;

    qDebug().nospace() << logPrefix()
                       << " start at go ponder  predicted="
                       << (m_predictedOpponentMove.isEmpty() ? "-" : m_predictedOpponentMove);

    sendCommand("go ponder");
    clearResponseData();
}

// stopコマンドを将棋エンジンに送信する。
void Usi::sendStopCommand()
{
    // 将棋エンジンにコマンドを送信する。
    sendCommand("stop");

    // ★ これが無いと UsiThread が wait している QEventLoop が抜けられません
    emit stopOrPonderhitCommandSent();
}

// ponderhitコマンドを将棋エンジンに送信する。
void Usi::sendPonderHitCommand()
{
    // ここから“自分の手番の思考時間”
    m_lastGoToBestmoveMs = 0;
    m_goTimer.start();

    qDebug().nospace() << logPrefix()
                       << " PONDERHIT session=" << m_ponderSession
                       << " predicted=" << (m_predictedOpponentMove.isEmpty() ? "-" : m_predictedOpponentMove)
                       << " prevTo=(" << m_previousFileTo << "," << m_previousRankTo << ")";

    sendCommand("ponderhit");

    // ★ これも wait 中の QEventLoop を必ず抜けさせる
    emit stopOrPonderhitCommandSent();

    // 以後は通常思考フェーズ
    m_phase = SearchPhase::Main;
}

// gameoverコマンドを将棋エンジンに送信する。
void Usi::sendGameOverCommand(const QString& result)
{
    // 将棋エンジンにコマンドを送信する。
    sendCommand("gameover " + result);

    // 将棋エンジンからデータを受信して保管した行リストをクリアする。
    clearResponseData();
}

// 将棋の段（1～9）をアルファベット表記（a～i）に変換する。
QChar Usi::rankToAlphabet(const int rank) const
{
    // 'a'はASCIIで97なので、rank-1を足すことで望む文字に変換する。
    return QChar('a' + rank - 1);
}

// 将棋のアルファベット表記（a～i）を段（1～9）に変換する。
int Usi::alphabetToRank(QChar c)
{
    // 'a'を引くことで、a〜iを1〜9に変換する。
    return int(c.toLatin1() - 'a' + 1);
}

// 白（後手）の駒を表すアルファベットから持ち駒の段に変換する。
int Usi::pieceToRankWhite(QChar c)
{
    // 駒とその持ち駒段のマッピング
    static const QMap<QChar, int> m_pieceRankWhite = {{'P', 9}, {'L', 8}, {'N', 7}, {'S', 6}, {'G', 5}, {'B', 4}, {'R', 3}};

    // マップに存在するか確認し、存在すればその値を返す。
    if (m_pieceRankWhite.contains(c)) return m_pieceRankWhite[c];

    // マップに存在しない場合は0を返す。
    return 0;
}

// 黒（先手）の駒を表すアルファベットから持ち駒の段に変換する。
int Usi::pieceToRankBlack(QChar c)
{
    // 駒とその持ち駒段のマッピング
    static const QMap<QChar, int> m_pieceRankBlack = {{'P', 1}, {'L', 2}, {'N', 3}, {'S', 4}, {'G', 5}, {'B', 6}, {'R', 7}};

    // マップに存在するか確認し、存在すればその値を返す。
    if (m_pieceRankBlack.contains(c)) return m_pieceRankBlack[c];

    // マップに存在しない場合は0を返す。
    return 0;
}

// usiコマンドを将棋エンジンに送信する。
void Usi::sendUsiCommand()
{
    sendCommand("usi");
}

// isreadyコマンドを将棋エンジンに送信する。
void Usi::sendIsReadyCommand()
{
    sendCommand("isready");
}

// 将棋エンジンからusiokを受信するまで待つ。
bool Usi::waitForUsiOK(const int timeoutMilliseconds)
{
    // タイマーの作成
    QElapsedTimer timer;

    // タイマーを開始する。
    timer.start();

    // usiokを受信したかどうかのフラグをfalseにする。
    m_usiOkSignalReceived = false;

    // usiokを受信するまで繰り返す。
    while (!m_usiOkSignalReceived) {
        // この関数を呼び出すことで、長い計算やタスクを行っている間でも、アプリケーションのGUIがフリーズすることなく、
        // ユーザーからの入力を継続的に受け付けることができる。
        // GUIのメニューが反応しなくなるのを防いでいる。
        qApp->processEvents();

        // タイムアウトした時
        if (timer.elapsed() > timeoutMilliseconds) {
            // usiokを受信しなかった。
            return false;
        }

        // CPUリソースの過度な使用を防ぐためにスリープ
        QThread::msleep(10);
    }

    // usiokを受信した。
    return true;
}

// 将棋エンジンからreadyokを受信するまで待つ。
bool Usi::waitForReadyOk(const int timeoutMilliseconds)
{
    // タイマーの作成
    QElapsedTimer timer;

    // タイマーを開始する。
    timer.start();

    // readyokを受信したかどうかのフラグをfalseにする。
    m_readyOkSignalReceived = false;

    // readyokを受信するまで繰り返す。
    while (!m_readyOkSignalReceived) {
        // この関数を呼び出すことで、長い計算やタスクを行っている間でも、アプリケーションのGUIがフリーズすることなく、
        // ユーザーからの入力を継続的に受け付けることができる。
        // GUIのメニューが反応しなくなるのを防いでいる。
        qApp->processEvents();

        // タイムアウトした時
        if (timer.elapsed() > timeoutMilliseconds) {
            // readyokを受信しなかった。
            return false;
        }

        // CPUリソースの過度な使用を防ぐためにスリープ
        QThread::msleep(10);
    }

    // readyokを受信した。
    return true;
}

// goコマンドを将棋エンジンに送信する。
void Usi::sendGoCommand(int byoyomiMilliSec, const QString& btime, const QString& wtime,
                        int addEachMoveMilliSec1, int addEachMoveMilliSec2, bool useByoyomi)
{
    infoRecordClear();

    QString command;
    if (useByoyomi) {
        command = "go btime " + btime + " wtime " + wtime + " byoyomi " + QString::number(byoyomiMilliSec);
    } else {
        command = "go btime " + btime + " wtime " + wtime
                  + " binc " + QString::number(addEachMoveMilliSec1)
                  + " winc " + QString::number(addEachMoveMilliSec2);
    }

    // 計測＆フェーズ
    m_lastGoToBestmoveMs = 0;
    m_goTimer.start();
    m_phase = SearchPhase::Main;

    qDebug().nospace() << logPrefix()
                       << " start at go  btime=" << btime
                       << " wtime=" << wtime
                       << " byoyomi=" << byoyomiMilliSec << "ms";

    sendCommand(command);
}

// 棋譜解析モードで go コマンドを将棋エンジンに送信する。
// （以降の後処理は既存フローに任せる）
void Usi::sendGoCommandByAnalysys(int byoyomiMilliSec)
{
    // ★ 解析オペ開始（ctx+ID）
    const quint64 opId = beginOperationContext();

    infoRecordClear();
    sendCommand("go infinite");

    if (byoyomiMilliSec <= 0) {
        keepWaitingForBestMove(); // 無制限：従来どおり。ただし bestmoveReceived 側でIDガード
        return;
    }

    // ★ QTimer を ctx にぶら下げて stop を投げる
    auto* timer = new QTimer(m_opCtx);
    timer->setSingleShot(true);
    connect(timer, &QTimer::timeout, m_opCtx, [this]() {
        sendCommand("stop");
    });
    timer->start(byoyomiMilliSec);

    // stop 後の余裕時間も待つ（IDミスマッチ/終了宣言で即離脱）
    static constexpr int kPostStopGraceMs = 4000;
    const int waitBudget = qMax(byoyomiMilliSec + kPostStopGraceMs, 2500);

    if (!waitForBestMove(waitBudget)) {
        // 最終保険：短く追い待ち（ctx配下で再度stop）
        auto* chase = new QTimer(m_opCtx);
        chase->setSingleShot(true);
        connect(chase, &QTimer::timeout, m_opCtx, [this](){ sendCommand("stop"); });
        chase->start(0); // すぐ投げる

        if (!waitForBestMove(2000)) {
            qWarning() << "[USI][Analysis] bestmove timeout (non-fatal). waited(ms)="
                       << (waitBudget + 2000);
            return;
        }
    }
}

// 将棋エンジンからbestmoveを受信するまで待つ。
bool Usi::waitForBestMove(const int timeoutMilliseconds)
{
    // GUIスレッドを止めない待機方式（msleepを使わない）
    // - 10msごとのネストイベントループで通常イベント(QTimer/readyReadなど)を回す
    // - ShogiClock等のタイマ遅延を起こしにくい

    if (m_bestMoveSignalReceived) return true;           // 既に届いていれば即完了
    if (timeoutMilliseconds <= 0) return false;          // 無効なタイムアウト

    m_bestMoveSignalReceived = false;

    QElapsedTimer timer;
    timer.start();

    static constexpr int kSliceMs = 10;                  // 1スライスの長さ

    while (!m_bestMoveSignalReceived) {
        // タイムアウト判定
        if (timer.elapsed() >= timeoutMilliseconds) {
            return false; // bestmoveを受信しなかった
        }
        // 停止中は待機を打ち切る（安全弁）
        if (m_shutdownState != ShutdownState::Running) {
            return false;
        }

        // 10msだけイベントを回す（readyRead / タイマ / 入力 など）
        QEventLoop spin;
        QTimer tick;
        tick.setSingleShot(true);
        tick.setInterval(kSliceMs);
        QObject::connect(&tick, &QTimer::timeout, &spin, &QEventLoop::quit);
        tick.start();

        // ここで通常イベントが処理され、readyReadStandardOutput → readFromEngine() → bestmove処理
        // が進む。bestmove受信中でも最大で kSliceMs 程度でループに戻る。
        spin.exec(QEventLoop::AllEvents);
    }

    // bestmoveを受信した
    return true;
}

// 将棋エンジンからbestmoveを受信するまで待つ。
bool Usi::keepWaitingForBestMove()
{
    // bestmoveを受信したかどうかのフラグをfalseにする。
    m_bestMoveSignalReceived = false;

    // bestmoveを受信するまで繰り返す。
    while (!m_bestMoveSignalReceived) {
        // この関数を呼び出すことで、長い計算やタスクを行っている間でも、アプリケーションのGUIがフリーズすることなく、
        // ユーザーからの入力を継続的に受け付けることができる。
        // GUIのメニューが反応しなくなるのを防いでいる。
        qApp->processEvents();

        // CPUリソースの過度な使用を防ぐためにスリープ
        QThread::msleep(10);
    }

    // bestmoveを受信した。
    return true;
}

// 将棋エンジンからbestmoveを受信した時に最善手を取得する。
void Usi::bestMoveReceived(const QString& line)
{
    // ★ この受信が属する（と見なす）IDを入口でキャプチャ
    const quint64 observedId = m_seq;

    if (m_timeoutDeclared || m_shutdownState != ShutdownState::Running) {
        qDebug().nospace() << logPrefix() << " [drop-bestmove] (inactive-state) " << line;
        return;
    }

    const QStringList tokens = line.split(whitespaceRe(), Qt::SkipEmptyParts);
    const int bestMoveIndex  = tokens.indexOf(QStringLiteral("bestmove"));

    if (bestMoveIndex == -1 || bestMoveIndex + 1 >= tokens.size()) {
        const QString msg = tr("An error occurred in Usi::bestMoveReceived. bestmove or its succeeding string not found.");
        qWarning().noquote() << logPrefix() << " " << msg << " line=" << line;
        emit errorOccurred(msg);
        // ★ ここで“打ち切り”を確定（以降の継続処理を無効化）
        cancelCurrentOperation();
        return;
    }

    // ★ オペが切り替わっていたら旧bestmoveは採用しない
    if (observedId != m_seq) {
        qDebug().nospace() << logPrefix() << " [drop-bestmove] (op-id-mismatch) " << line;
        return;
    }

    m_bestMove = tokens.at(bestMoveIndex + 1);

    qint64 elapsed = m_goTimer.isValid() ? m_goTimer.elapsed() : -1;
    m_lastGoToBestmoveMs     = (elapsed >= 0) ? elapsed : 0;
    m_bestMoveSignalReceived = true;

    if (m_bestMove.compare(QStringLiteral("resign"), Qt::CaseInsensitive) == 0) {
        if (m_resignNotified) {
            qDebug().nospace() << logPrefix() << " [dup-resign-ignored]";
            return;
        }
        m_resignNotified = true;
        qDebug().nospace() << logPrefix() << " [TRACE] resign-detected t+" << ShogiUtils::nowMs() << "ms";
        emit bestMoveResignReceived();
        return;
    }

    const int ponderIdx = tokens.indexOf(QStringLiteral("ponder"));
    if (ponderIdx != -1 && ponderIdx + 1 < tokens.size()) {
        const QString ponderStr = tokens.at(ponderIdx + 1);
        qDebug().nospace() << logPrefix() << " [ponder] " << ponderStr;
    }
}

void Usi::startUsiThread()
{
    // 既存スレッドがあれば確実に終了させてから破棄
    if (m_usiThread) {
        emit stopOrPonderhitCommandSent();
        m_usiThread->wait();
        delete m_usiThread;
        m_usiThread = nullptr;
    }

    // 新しいスレッドを生成
    m_usiThread = new UsiThread(this, this);

    // 実行
    m_usiThread->start();
}

// GUIが将棋エンジンにstopまたはponderhitコマンドを送信するまで待つ。
void Usi::waitForStopOrPonderhitCommand()
{
    QEventLoop loop;

    // GUIがstopまたはponderhitコマンドを送信したら、イベントループを終了する。
    connect(this, &Usi::stopOrPonderhitCommandSent, &loop, &QEventLoop::quit);

    // イベントループの開始（stopまたはponderhitコマンドが送られるまでブロック）
    loop.exec();
}

// 現在の局面（盤内のみ）をコピーする。
void Usi::cloneCurrentBoardData()
{
    m_clonedBoardData = m_gameController->board()->boardData();
}

// 将棋エンジンから返された「bestmove A ponder B」の情報をもとに、将棋盤内の駒配置を更新する。
void Usi::applyMovesToBoardFromBestMoveAndPonder()
{
    // info行を解析するクラス
    ShogiEngineInfoParser info;

    info.parseAndApplyMoveToClonedBoard(m_bestMove, m_clonedBoardData);

    info.parseAndApplyMoveToClonedBoard(m_predictedOpponentMove, m_clonedBoardData);
}

void Usi::setLogIdentity(const QString& engineTag, const QString& sideTag, const QString& engineName)
{
    m_logEngineTag = engineTag;
    m_logSideTag   = sideTag;
    m_logEngineName = engineName;
}

QString Usi::phaseTag() const
{
    switch (m_phase) {
    case SearchPhase::Ponder: return QString("[PONDER#%1]").arg(m_ponderSession);
    case SearchPhase::Main:   return QString("[MAIN]");
    default:                  return QString();
    }
}

QString Usi::logPrefix() const
{
    // "[E1]" → "[E1/P1]" に整形
    QString within = m_logEngineTag.isEmpty() ? "[E?]" : m_logEngineTag;
    if (!m_logSideTag.isEmpty())
        within.insert(within.size()-1, "/" + m_logSideTag);

    // エンジン名を括弧外に付ける
    QString head = within + (m_logEngineName.isEmpty() ? "" : " " + m_logEngineName);

    const QString ph = phaseTag();
    return ph.isEmpty() ? head : (head + " " + ph);
}

bool Usi::shouldLogAfterQuit(const QString& line) const
{
    // 「info string」から始まる行だけを許可（完全一致の先頭判定）
    return line.startsWith(QStringLiteral("info string"));
}

void Usi::setSquelchResignLogging(bool on)
{
    m_squelchResignLogs = on;
}

bool Usi::shouldAbortWait() const
{
    // 1) GUI側で旗落ち確定などにより「もう採用しない」と宣言済み
    if (m_timeoutDeclared) return true;

    // 2) quit 送信後の受信抑止モード（info string だけ許可など）
    if (m_shutdownState != ShutdownState::Running) return true;

    // 3) プロセスが既に死んでいる/書き込み終了後など
    if (!m_process || m_process->state() != QProcess::Running) return true;

    return false;
}

void Usi::sendRaw(const QString& command) const
{
    if (!m_process) {
        qWarning() << "Usi::sendRaw called but m_process is null.";
        return;
    }
    sendCommand(command);
}

void Usi::onProcessFinished(int /*exitCode*/, QProcess::ExitStatus /*status*/)
{
    if (!m_process) return;

    const QByteArray outTail = m_process->readAllStandardOutput();
    const QByteArray errTail = m_process->readAllStandardError();

    auto flushTail = [this](const QByteArray& data, bool isStderr) {
        if (data.isEmpty()) return;

        const QStringList lines = QString::fromUtf8(data).split('\n', Qt::SkipEmptyParts);
        for (const QString& raw : lines) {
            const QString line = raw.trimmed();
            if (line.isEmpty()) continue;

            // --- 送信後の遮断ポリシー ---
            if (m_shutdownState == ShutdownState::IgnoreAllExceptInfoString) {
                // 「info string …」だけ許可（指定行数まで）
                if (line.startsWith(QStringLiteral("info string")) &&
                    m_postQuitInfoStringLinesLeft > 0) {

                    const QString pfx = logPrefix();
                    if (m_model) {
                        m_model->appendUsiCommLog(pfx + " < " + line);
                    }
                    --m_postQuitInfoStringLinesLeft;

                    // 取り切ったら完全遮断へ
                    if (m_postQuitInfoStringLinesLeft <= 0) {
                        m_shutdownState = ShutdownState::IgnoreAll;
                    }
                }
                continue; // それ以外は捨てる
            }

            if (m_shutdownState == ShutdownState::IgnoreAll) {
                // 念のため "info string" は救済してもよい（不要なら丸ごとcontinueでOK）
                if (line.startsWith(QStringLiteral("info string"))) {
                    const QString pfx = logPrefix();
                    if (m_model) m_model->appendUsiCommLog(pfx + " < " + line);
                }
                continue;
            }

            // --- 通常時：そのままログ ---
            const QString pfx = logPrefix();
            if (m_model) {
                if (isStderr) m_model->appendUsiCommLog(pfx + " <stderr> " + line);
                else          m_model->appendUsiCommLog(pfx + " < "       + line);
            }
        }
    };

    flushTail(outTail, /*stderr=*/false);
    flushTail(errTail, /*stderr=*/true);

    // 最終的には完全遮断に移行
    m_shutdownState = ShutdownState::IgnoreAll;
}

// 【新規】詰み探索用：position→go mate
void Usi::sendPositionAndGoMate(const QString& sfen, int timeMs, bool infinite)
{
    if (!m_process || m_process->state() != QProcess::Running) {
        const QString errorMessage = tr("USI engine is not running.");
        emit errorOccurred(errorMessage);
        cancelCurrentOperation();
        return;
    }

    // "position sfen <SFEN>"
    sendCommand(QStringLiteral("position sfen %1").arg(sfen.trimmed()));

    // "go mate <ms>" または "go mate infinite"
    if (infinite || timeMs <= 0) {
        sendCommand(QStringLiteral("go mate infinite"));
    } else {
        sendCommand(QStringLiteral("go mate %1").arg(timeMs)); // 単位: ms
    }

    m_modeTsume = true;
}

// 【新規】詰み探索の停止
void Usi::sendStopForMate()
{
    if (!m_process || m_process->state() != QProcess::Running) return;
    // 既存の停止APIがあるならそれを使ってもOK（sendStopCommand() 等）
    sendCommand(QStringLiteral("stop"));
}

// 詰み探索用の実行（position → go mate）
void Usi::executeTsumeCommunication(QString& positionStr, int mateLimitMilliSec)
{
    // 現在の局面（盤内のみ）をコピー（描画や後続処理に合わせて従来仕様を踏襲）
    cloneCurrentBoardData();

    // position → go mate の送信
    sendPositionAndGoMateCommands(mateLimitMilliSec, positionStr);
}

// "position ..." を送ってから "go mate ..." を送る
void Usi::sendPositionAndGoMateCommands(int mateLimitMilliSec, QString& positionStr)
{
    // positionコマンドを将棋エンジンに送信
    sendPositionCommand(positionStr);

    // go mate <ms|infinite> を送信（無制限なら infinite）
    if (mateLimitMilliSec <= 0) {
        sendCommand(QStringLiteral("go mate infinite"));
    } else {
        sendCommand(QStringLiteral("go mate %1").arg(mateLimitMilliSec));
    }

    // ※解析時のような「bestmove待ち」は行わない。
    //   詰み探索は最終結果として "checkmate ..." が返ってくるので、
    //   受信側（readFromEngine）で処理する。
}

// "checkmate ..." の行を解析してシグナルを発火
void Usi::handleCheckmateLine(const QString& line)
{
    const QString rest = line.mid(QStringLiteral("checkmate").size()).trimmed();

    if (rest.compare(QStringLiteral("nomate"), Qt::CaseInsensitive) == 0) {
        emit checkmateNoMate();
        return;
    }
    if (rest.compare(QStringLiteral("notimplemented"), Qt::CaseInsensitive) == 0) {
        emit checkmateNotImplemented();
        return;
    }
    if (rest.isEmpty() || rest.compare(QStringLiteral("unknown"), Qt::CaseInsensitive) == 0) {
        emit checkmateUnknown();
        return;
    }

    // 以降は USI の手列
    const QStringList pv = rest.split(QLatin1Char(' '), Qt::SkipEmptyParts);
    if (pv.isEmpty()) {
        emit checkmateUnknown();
        return;
    }
    emit checkmateSolved(pv);
}

// 【新規】オペレーション用の一時コンテキストを開始（auto-disconnect/auto-delete用）
// 返り値：このオペに対応するID（リクエストID）
quint64 Usi::beginOperationContext()
{
    // 旧オペを破棄（ぶら下がる QTimer なども一括で消える）
    if (m_opCtx) {
        m_opCtx->deleteLater();
        m_opCtx = nullptr;
    }
    m_opCtx = new QObject(this); // この ctx を connect の受け側に使う

    // リクエストIDを進めて「旧オペのシグナルは無視」状態にする
    return ++m_seq;
}

// 【新規】現在のオペレーションをキャンセル
void Usi::cancelCurrentOperation()
{
    if (m_opCtx) {
        m_opCtx->deleteLater();
        m_opCtx = nullptr;
    }
    // ID を進めることで、旧オペ経由の bestmove/info はすべて無視される
    ++m_seq;
}
#include "kifuanalysislistmodel.h"

//将棋の棋譜解析結果をGUI上で表示するためのモデルクラス
// コンストラクタ
KifuAnalysisListModel::KifuAnalysisListModel(QObject *parent) : AbstractListModel<KifuAnalysisResultsDisplay>(parent)
{
}

// 列数を返す。
int KifuAnalysisListModel::columnCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent)

    // 「指し手」「評価値」「差」「読み筋」の4列を返す。
    return 4;
}

// データを返す。
QVariant KifuAnalysisListModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid())
        return QVariant();

    // 右寄せ：Evaluation / Difference 列は常に右寄せ（デリゲートが無い場面でも崩れないように）
    if (role == Qt::TextAlignmentRole) {
        if (index.column() == 1 || index.column() == 2) {
            return QVariant::fromValue<int>(Qt::AlignRight | Qt::AlignVCenter);
        }
        return QVariant();
    }

    if (role != Qt::DisplayRole)
        return QVariant();

    switch (index.column()) {
    case 0: // 指し手
        return list[index.row()]->currentMove();
    case 1: // 評価値
        return list[index.row()]->evaluationValue();
    case 2: // 差
        return list[index.row()]->evaluationDifference();
    case 3: // 読み筋
        return list[index.row()]->principalVariation();
    default:
        return QVariant();
    }
}

// ヘッダを返す。
QVariant KifuAnalysisListModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    // roleが表示用のデータを要求していない場合、空のQVariantを返す。
    if (role != Qt::DisplayRole) {
        return QVariant();
    }

    // // 横方向のヘッダが要求された場合
    if (orientation == Qt::Horizontal) {
        switch (section) {
        case 0:
            // 指し手
            return tr("Move");
        case 1:
            // 評価値
            return tr("Evaluation Value");
        case 2:
            // 差
            return tr("Difference");
        case 3:
            // 読み筋
            return tr("Principal Variation");
        default:
            // それ以外の場合、空のQVariantを返す。
            return QVariant();
        }
    } else {
        // 縦方向のヘッダが要求された場合、セクション番号を返す。
        return QVariant(section + 1);
    }
}
#include "kifubranchlistmodel.h"
#include <QBrush>
#include <QColor>
#include <QFont>
#include <QRegularExpression>

KifuBranchListModel::KifuBranchListModel(QObject *parent)
    : AbstractListModel<KifuBranchDisplay>(parent)
{
}

int KifuBranchListModel::columnCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent)
    return 1; // 「分岐」の1列
}

int KifuBranchListModel::rowCount(const QModelIndex &parent) const
{
    if (parent.isValid()) return 0;
    // 通常候補数 + 末尾の「本譜へ戻る」1行（有効時）
    return list.size() + (m_hasBackToMainRow ? 1 : 0);
}

QVariant KifuBranchListModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid()) return QVariant();

    const bool isBackRow = (m_hasBackToMainRow && index.row() == list.size());

    // --- カスタムロール: この行(分岐)の最大手数 ---
    if (role == DispCountRole) {
        // 「本譜へ戻る」行は 0 を返しておく（呼び出し側でクランプされる前提）
        if (isBackRow) return 0;
        return rowMaxPly_(index.row());
    }

    if (role == Qt::DisplayRole) {
        if (isBackRow) {
            return tr("本譜へ戻る");
        }
        if (index.column() == 0) {
            if (index.row() >= 0 && index.row() < list.size() && list[index.row()]) {
                return list[index.row()]->currentMove();
            }
        }
        return QVariant();
    }

    // 体裁（任意）
    if (role == Qt::TextAlignmentRole && isBackRow) {
        return Qt::AlignCenter;
    }
    if (role == Qt::FontRole && isBackRow) {
        QFont f; f.setBold(true); return f;
    }

    return QVariant();
}

QVariant KifuBranchListModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (role != Qt::DisplayRole) return QVariant();

    if (orientation == Qt::Horizontal) {
        switch (section) {
        case 0:  return tr("分岐候補");
        default: return QVariant();
        }
    } else {
        return QVariant(section + 1);
    }
}

void KifuBranchListModel::clearBranchCandidates()
{
    beginResetModel();
    qDeleteAll(list);
    list.clear();
    m_hasBackToMainRow = false;
    endResetModel();
}

void KifuBranchListModel::setBranchCandidatesFromKif(const QList<KifDisplayItem>& rows)
{
#ifdef SHOGIBOARDQ_DEBUG_KIF
    QStringList s; s.reserve(rows.size());
    for (int i=0;i<rows.size();++i) s << rows[i].prettyMove;
    qDebug().noquote() << "[BRANCH-MODEL] set" << rows.size() << ":" << s.join(", ");
#endif

    beginResetModel();
    qDeleteAll(list);
    list.clear();

    // 先頭に「手数（半角/全角）+空白」が付いていたら落とす
    static const QRegularExpression kDropHeadNumber(
        QStringLiteral(R"(^\s*[0-9０-９]+\s*)"));

    list.reserve(rows.size());
    for (const auto& k : rows) {
        auto* b = new KifuBranchDisplay();

        QString label = k.prettyMove;       // 例: "3 ▲２六歩(27)" or "▲２六歩(27)"
        label.replace(kDropHeadNumber, QString());
        label = label.trimmed();            // 念のため前後の空白を除去

        b->setCurrentMove(label);
        list.push_back(b);
    }
    endResetModel();
}

void KifuBranchListModel::setHasBackToMainRow(bool enabled)
{
    if (m_hasBackToMainRow == enabled) return;
    beginResetModel();
    m_hasBackToMainRow = enabled;
    endResetModel();
}

bool KifuBranchListModel::hasBackToMainRow() const
{
    return m_hasBackToMainRow;
}

bool KifuBranchListModel::isBackToMainRow(int row) const
{
    return m_hasBackToMainRow && (row == list.size());
}

int KifuBranchListModel::backToMainRowIndex() const
{
    return m_hasBackToMainRow ? list.size() : -1;
}

void KifuBranchListModel::setActiveNode_(int nodeId)
{
    if (nodeId < 0 || nodeId >= m_nodes.size()) return;
    if (m_activeNodeId == nodeId) return;

    m_activeNodeId = nodeId;

    // ここでビュー再描画（全体 or 必要範囲）を促す
    // ※あなたの実装に合わせて適切な index 範囲を渡してください。
    emit dataChanged(index(0,0), index(rowCount()-1, columnCount()-1));
    emit activeNodeChanged(nodeId);

    const auto& n = m_nodes[nodeId];
    qDebug().nospace()
        << "[BRANCH-MODEL] active nodeId=" << nodeId
        << " vid=" << n.vid << " ply=" << n.ply
        << " row=" << n.row << " prev=" << n.prevId
        << " nexts=" << n.nextIds.size();
}

// 罫線（前後エッジ）だけで targetPly を探すフォールバック。
// preferPrev=true のとき、まず prev を見て一致すれば採用、だめなら next 側を探す。
bool KifuBranchListModel::graphFallbackToPly_(int targetPly, bool preferPrev)
{
    if (m_activeNodeId < 0) return false;

    const auto tryPrev = [&]()->bool{
        const int p = m_nodes[m_activeNodeId].prevId;
        if (p >= 0 && m_nodes[p].ply == targetPly) {
            setActiveNode_(p); return true;
        }
        return false;
    };
    const auto tryNext = [&]()->bool{
        const auto& nx = m_nodes[m_activeNodeId].nextIds;
        for (int id : nx) if (m_nodes[id].ply == targetPly) {
                setActiveNode_(id); return true;
            }
        return false;
    };

    if (preferPrev) {
        if (tryPrev()) return true;
        if (tryNext()) return true;
    } else {
        if (tryNext()) return true;
        if (tryPrev()) return true;
    }
    return false;
}

QHash<int, QByteArray> KifuBranchListModel::roleNames() const
{
    QHash<int, QByteArray> r = QAbstractItemModel::roleNames();
    r[DispCountRole] = "dispCount";
    return r;
}

int KifuBranchListModel::rowMaxPly_(int row) const
{
    if (row < 0) return 0;

    int maxPly = 0;
    // m_nodes に { row, ply, ... } が入っている前提で、同 row の ply 最大値を求める
    for (const auto& n : m_nodes) {
        if (n.row == row && n.ply > maxPly) {
            maxPly = n.ply;
        }
    }
    return maxPly;
}

void KifuBranchListModel::clear()
{
    // ビューに一括リセットを通知
    beginResetModel();

    // 候補行（所有権あり）を削除
    qDeleteAll(list);
    list.clear();

    // 「本譜へ戻る」行フラグも初期化
    m_hasBackToMainRow = false;

    // 分岐グラフの状態を初期化
    m_nodes.clear();
    m_activeNodeId = -1;

    endResetModel();

    // アクティブノードの変更（無効化）を通知
    emit activeNodeChanged(-1);
}
#include "kifurecordlistmodel.h"
#include <QDebug> // 必要なら
#include <QColor>
#include <QBrush>

KifuRecordListModel::KifuRecordListModel(QObject *parent)
    : AbstractListModel<KifuDisplay>(parent)
{
}

int KifuRecordListModel::columnCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent)
    // 「指し手」「消費時間」の2列
    return 2;
}

QVariant KifuRecordListModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid()) return QVariant();

    const int row = index.row();
    const int col = index.column();

    // 背景色：分岐ありの手は行全体をオレンジ系で強調
    if (role == Qt::BackgroundRole) {
        if (row > 0 && m_branchPlySet.contains(row)) {
            static const QBrush kOrangeBg(QColor(255, 224, 178));
            return kOrangeBg;
        }
        return QVariant();
    }

    if (role != Qt::DisplayRole) return QVariant();

    switch (col) {
    case 0: {
        // 指し手列：分岐ありなら末尾に '+' を付与（表示上のみ）
        QString s = list[row]->currentMove();
        if (row > 0 && m_branchPlySet.contains(row) && !s.endsWith(QLatin1Char('+'))) {
            s.append(QLatin1Char('+'));
        }
        return s;
    }
    case 1:
        // 消費時間列
        return list[row]->timeSpent();
    default:
        return QVariant();
    }
}

QVariant KifuRecordListModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (role != Qt::DisplayRole) return QVariant();

    if (orientation == Qt::Horizontal) {
        switch (section) {
        case 0: return tr("指し手");
        case 1: return tr("消費時間");
        default: return QVariant();
        }
    } else {
        return QVariant(section + 1);
    }
}

// 先頭に1件追加
bool KifuRecordListModel::prependItem(KifuDisplay* item)
{
    if (!item) return false;

    beginInsertRows(QModelIndex(), 0, 0);
    list.insert(0, item);      // 先頭へ
    endInsertRows();
    return true;
}

// 末尾の1手（=1行）を削除
bool KifuRecordListModel::removeLastItem()
{
    if (list.isEmpty()) return false;

    const int last = list.size() - 1;
    beginRemoveRows(QModelIndex(), last, last);

    // 所有モデルで生ポインタ管理の場合
    auto *ptr = list.takeLast();
    endRemoveRows();

    delete ptr; // 所有権がモデル側にある前提

    return true;
}

// 末尾から n 手（=n行）を一括削除
bool KifuRecordListModel::removeLastItems(int n)
{
    if (n <= 0 || list.isEmpty()) return false;

    const int toRemove = qMin(n, list.size());
    const int first = list.size() - toRemove;
    const int last  = list.size() - 1;

    beginRemoveRows(QModelIndex(), first, last);

    for (int i = 0; i < toRemove; ++i) {
        auto *ptr = list.takeLast();
        delete ptr; // 所有権がモデル側にある前提
    }

    endRemoveRows();
    return true;
}

// 分岐あり手の集合をセットし、表示更新
void KifuRecordListModel::setBranchPlyMarks(const QSet<int>& ply1Set)
{
    m_branchPlySet = ply1Set;

    if (rowCount() > 0) {
        const QModelIndex tl = index(0, 0);
        const QModelIndex br = index(rowCount() - 1, 1);
        // 指し手の ‘+’ 付与と背景色の両方を更新
        emit dataChanged(tl, br, { Qt::DisplayRole, Qt::BackgroundRole });
    }
}
#include "usicommlogmodel.h"

// エンジン名、予想手、探索手、深さ、ノード数、局面探索数、ハッシュ使用率の更新に関するクラス
// コンストラクタ
UsiCommLogModel::UsiCommLogModel(QObject* parent) : QObject(parent) {}

// 将棋エンジン名を取得する。
QString UsiCommLogModel::engineName() const
{
    return m_engineName;
}

// 予想手を取得する。
QString UsiCommLogModel::predictiveMove() const
{
    return m_predictiveMove;
}

// 探索手を取得する。
QString UsiCommLogModel::searchedMove() const
{
    return m_searchedMove;
}

// 深さを取得する。
QString UsiCommLogModel::searchDepth() const
{
    return m_searchDepth;
}

// ノード数を取得する。
QString UsiCommLogModel::nodeCount() const
{
    return m_nodeCount;
}

// 探索局面数を取得する。
QString UsiCommLogModel::nodesPerSecond() const
{
    return m_nodesPerSecond;
}

// ハッシュ使用率を取得する。
QString UsiCommLogModel::hashUsage() const
{
    return m_hashUsage;
}

// 将棋GUIと将棋エンジン間のUSIプロトコル通信コマンド行を取得する。
QString UsiCommLogModel::usiCommLog() const
{
    return m_usiCommLog;
}

// 将棋エンジン名をセットし、GUIの表示を更新する。
void UsiCommLogModel::setEngineName(const QString& engineName)
{
    if (m_engineName != engineName)
    {
        m_engineName = engineName;
        emit engineNameChanged();
    }
}

// 予想手をセットし、GUIの表示を更新する。
void UsiCommLogModel::setPredictiveMove(const QString& predictiveMove)
{
    if (m_predictiveMove != predictiveMove)
    {
        m_predictiveMove = predictiveMove;
        emit predictiveMoveChanged();
    }
}

// 探索手をセットし、GUIの表示を更新する。
void UsiCommLogModel::setSearchedMove(const QString& searchedMove)
{
    if (m_searchedMove != searchedMove)
    {
        m_searchedMove = searchedMove;
        emit searchedMoveChanged();
    }
}

// 深さをセットし、GUIの表示を更新する。
void UsiCommLogModel::setSearchDepth(const QString& searchDepth)
{
    if (m_searchDepth != searchDepth)
    {
        m_searchDepth = searchDepth;
        emit searchDepthChanged();
    }
}

// ノード数をセットし、GUIの表示を更新する。
void UsiCommLogModel::setNodeCount(const QString& nodeCount)
{
    if (m_nodeCount != nodeCount)
    {
        m_nodeCount = nodeCount;
        emit nodeCountChanged();
    }
}

// 探索局面数をセットし、GUIの表示を更新する。
void UsiCommLogModel::setNodesPerSecond(const QString& nodesPerSecond)
{
    if (m_nodesPerSecond != nodesPerSecond)
    {
        m_nodesPerSecond = nodesPerSecond;
        emit nodesPerSecondChanged();
    }
}

// ハッシュ使用率をセットし、GUIの表示を更新する。
void UsiCommLogModel::setHashUsage(const QString& hashUsage)
{
    if (m_hashUsage != hashUsage)
    {
        m_hashUsage = hashUsage;
        emit hashUsageChanged();
    }
}

// 将棋GUIと将棋エンジン間のUSIプロトコル通信コマンド行をセットし、GUIに追記する。
void UsiCommLogModel::appendUsiCommLog(const QString& usiCommLog)
{
    m_usiCommLog = usiCommLog;
    emit usiCommLogChanged();
}

void UsiCommLogModel::clear()
{
    // それぞれ値が非空のときのみ変更＆シグナル発火
    if (!m_engineName.isEmpty())       { m_engineName.clear();       emit engineNameChanged(); }
    if (!m_predictiveMove.isEmpty())   { m_predictiveMove.clear();   emit predictiveMoveChanged(); }
    if (!m_searchedMove.isEmpty())     { m_searchedMove.clear();     emit searchedMoveChanged(); }
    if (!m_searchDepth.isEmpty())      { m_searchDepth.clear();      emit searchDepthChanged(); }
    if (!m_nodeCount.isEmpty())        { m_nodeCount.clear();        emit nodeCountChanged(); }
    if (!m_nodesPerSecond.isEmpty())   { m_nodesPerSecond.clear();   emit nodesPerSecondChanged(); }
    if (!m_hashUsage.isEmpty())        { m_hashUsage.clear();        emit hashUsageChanged(); }
    if (!m_usiCommLog.isEmpty())       { m_usiCommLog.clear();       emit usiCommLogChanged(); }
}
#include "kifuioservice.h"

#include <QFile>
#include <QTextStream>
#include <QDateTime>
#include <QDir>
#include <QFileInfo>
#include <QRegularExpression>

namespace {

// ファイル名に使えない/避けたい文字を置換し、空ならプレースホルダを返す
QString sanitizeForFileName(const QString& s, const QString& placeholder)
{
    QString t = s;
    if (t.isEmpty()) return placeholder;

    static const QRegularExpression badChars(R"([\\/:*?"<>|\r\n\t])");
    t.replace(badChars, QStringLiteral("_"));
    t = t.simplified();
    t.replace(QLatin1Char(' '), QLatin1Char('_'));
    return t;
}

} // namespace

QString KifuIoService::makeDefaultSaveFileName(PlayMode mode,
                                               const QString& human1,
                                               const QString& human2,
                                               const QString& engine1,
                                               const QString& engine2,
                                               const QDateTime& now)
{
    const QDateTime ts = now.isValid() ? now : QDateTime::currentDateTime();
    const QString stamp = ts.toString(QStringLiteral("yyyyMMdd_HHmmss"));

    auto mk = [&](const QString& p1, const QString& p2, const QString& tag) -> QString {
        const QString a = sanitizeForFileName(p1, QStringLiteral("P1"));
        const QString b = sanitizeForFileName(p2, QStringLiteral("P2"));
        return QStringLiteral("%1_%2_%3vs%4.kifu").arg(stamp, tag, a, b);
    };

    switch (mode) {
    case HumanVsHuman:
        return mk(human1, human2, QStringLiteral("HvH"));
    case EvenHumanVsEngine:      // 平手 P1: Human, P2: Engine
        return mk(human1, engine2, QStringLiteral("HvE"));
    case EvenEngineVsHuman:      // 平手 P1: Engine, P2: Human
        return mk(engine1, human2, QStringLiteral("EvH"));
    case EvenEngineVsEngine:     // 平手/駒落ち P1: Engine, P2: Engine
        return mk(engine1, engine2, QStringLiteral("EvE"));
    case HandicapEngineVsHuman:  // 駒落ち P1: Engine(下手), P2: Human(上手)
        return mk(engine1, human2, QStringLiteral("Handi_EvH"));
    case HandicapHumanVsEngine:  // 駒落ち P1: Human(下手), P2: Engine(上手)
        return mk(human1, engine2, QStringLiteral("Handi_HvE"));
    case HandicapEngineVsEngine: // 駒落ち P1: Engine(下手), P2: Engine(上手)
        return mk(engine1, engine2, QStringLiteral("Handi_EvE"));
    case AnalysisMode:
        return QStringLiteral("%1_Analysis.kifu").arg(stamp);
    case ConsidarationMode:
        return QStringLiteral("%1_Consideration.kifu").arg(stamp);
    case TsumiSearchMode:
        return QStringLiteral("%1_TsumiSearch.kifu").arg(stamp);
    case NotStarted:
    case PlayModeError:
    default:
        return QStringLiteral("%1_Session.kifu").arg(stamp);
    }
}

bool KifuIoService::writeKifuFile(const QString& filePath,
                                  const QStringList& kifuLines,
                                  QString* errorText)
{
    if (filePath.isEmpty()) {
        if (errorText) *errorText = QObject::tr("File path is empty.");
        return false;
    }

    const QFileInfo fi(filePath);
    if (!fi.absolutePath().isEmpty()) {
        QDir dir;
        if (!dir.mkpath(fi.absolutePath())) {
            if (errorText) {
                *errorText = QObject::tr("Failed to create directory: %1").arg(fi.absolutePath());
            }
            return false;
        }
    }

    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text)) {
        if (errorText) {
            *errorText = QObject::tr("Could not open the file for writing: %1").arg(file.errorString());
        }
        return false;
    }

    QTextStream out(&file);
    // Qt6 の QTextStream は既定で UTF-8。特に設定不要。
    for (const QString& line : kifuLines) {
        out << line << QLatin1Char('\n');
    }
    out.flush();
    file.close();
    return true;
}
#include "kifusavecoordinator.h"

#include <QFileDialog>
#include <QApplication>
#include <QDir>
#include <QDateTime>

#include "kifuioservice.h"   // writeKifuFile / makeDefaultSaveFileName
#include "playmode.h"

namespace KifuSaveCoordinator {

QString saveViaDialog(QWidget* parent,
                      const QStringList& kifuLines,
                      PlayMode mode,
                      const QString& human1,
                      const QString& human2,
                      const QString& engine1,
                      const QString& engine2,
                      QString* outError)
{
    // 既定ファイル名を生成
    QString defaultName = KifuIoService::makeDefaultSaveFileName(
        mode, human1, human2, engine1, engine2, QDateTime::currentDateTime());
    if (defaultName.isEmpty() || defaultName == "_vs.kifu")
        defaultName = "untitled.kifu";

    // ダイアログのカレントを実行ディレクトリへ
    QDir::setCurrent(QApplication::applicationDirPath());

    const QString path = QFileDialog::getSaveFileName(
        parent, QObject::tr("Save File"), defaultName, QObject::tr("Kif(*.kifu)"));
    if (path.isEmpty()) return QString();

    QString err;
    if (!KifuIoService::writeKifuFile(path, kifuLines, &err)) {
        if (outError) *outError = err;
        return QString();
    }
    return path;
}

bool overwriteExisting(const QString& path,
                       const QStringList& kifuLines,
                       QString* outError)
{
    QString err;
    const bool ok = KifuIoService::writeKifuFile(path, kifuLines, &err);
    if (!ok && outError) *outError = err;
    return ok;
}

} // namespace KifuSaveCoordinator
#include "playernameservice.h"

PlayerNameMapping PlayerNameService::computePlayers(PlayMode mode,
                                                    const QString& human1,
                                                    const QString& human2,
                                                    const QString& engine1,
                                                    const QString& engine2)
{
    PlayerNameMapping out;

    switch (mode) {
    case HumanVsHuman:
        out.p1 = human1;
        out.p2 = human2;
        break;

    case EvenHumanVsEngine:
        out.p1 = human1;
        out.p2 = engine2;
        break;

    case EvenEngineVsHuman:
        out.p1 = engine1;
        out.p2 = human2;
        break;

    case EvenEngineVsEngine:
        out.p1 = engine1;
        out.p2 = engine2;
        break;

    case HandicapHumanVsEngine: // 下手=Human(P1), 上手=Engine(P2)
        out.p1 = human1;
        out.p2 = engine2;
        break;

    case HandicapEngineVsHuman: // 下手=Engine(P1), 上手=Human(P2)
        out.p1 = engine1;
        out.p2 = human2;
        break;

    case HandicapEngineVsEngine: // 下手=Engine(P1), 上手=Engine(P2)
        out.p1 = engine1;
        out.p2 = engine2;
        break;

    // 解析/検討/詰み探索などは既存実装と同じくデフォルトラベル
    case AnalysisMode:
    case ConsidarationMode:
    case TsumiSearchMode:
    case NotStarted:
    case PlayModeError:
    default:
        out.p1 = QStringLiteral("先手");
        out.p2 = QStringLiteral("後手");
        break;
    }

    return out;
}

EngineNameMapping PlayerNameService::computeEngineModels(PlayMode mode,
                                                         const QString& engine1,
                                                         const QString& engine2)
{
    EngineNameMapping out;

    switch (mode) {
    case EvenHumanVsEngine:
    case HandicapHumanVsEngine:
        // P2 がエンジン。モデル1側に「使うエンジン」を表示（既存のMainWindow実装に合わせる）
        out.model1 = engine2;
        out.model2.clear();
        break;

    case EvenEngineVsHuman:
    case HandicapEngineVsHuman:
        // P1 がエンジン
        out.model1 = engine1;
        out.model2.clear();
        break;

    case EvenEngineVsEngine:
        out.model1 = engine1;
        out.model2 = engine2;
        break;

    case HandicapEngineVsEngine:
        // 既存実装は入れ替え（model1=engine2, model2=engine1）
        out.model1 = engine2;
        out.model2 = engine1;
        break;

    default:
        out.model1.clear();
        out.model2.clear();
        break;
    }

    return out;
}
#include <QSettings>
#include <QApplication>
#include <QDir>
#include <QWidget>
#include "shogiview.h"

namespace SettingsService {

static const char* kIniName = "ShogiBoardQ.ini";

void loadWindowSize(QWidget* mainWindow)
{
    if (!mainWindow) return;
    QDir::setCurrent(QApplication::applicationDirPath());
    QSettings s(kIniName, QSettings::IniFormat);
    const QSize sz = s.value("SizeRelated/mainWindowSize", QSize(1100, 720)).toSize();
    if (sz.isValid() && sz.width() > 100 && sz.height() > 100)
        mainWindow->resize(sz);
}

void saveWindowAndBoard(QWidget* mainWindow, ShogiView* view)
{
    if (!mainWindow || !view) return;
    QDir::setCurrent(QApplication::applicationDirPath());
    QSettings s(kIniName, QSettings::IniFormat);
    s.beginGroup("SizeRelated");
    s.setValue("mainWindowSize", mainWindow->size());
    s.setValue("squareSize",     view->squareSize());
    s.endGroup();
}

} // namespace SettingsService
#include "timecontrolutil.h"
#include "gamestartcoordinator.h"
#include "shogiclock.h"
#include <QTime>

namespace TimeControlUtil {

static inline int msToSecFloor(qint64 ms) { return (ms <= 0) ? 0 : int(ms / 1000); }

void applyToClock(
    ShogiClock* clock,
    const GameStartCoordinator::TimeControl& tc,
    const QString& startSfenStr,
    const QString& currentSfenStr)
{
    if (!clock) return;

    auto msToSecFloor = [](qint64 ms)->int { return (ms <= 0) ? 0 : int(ms / 1000); };

    // tc.enabled が false でも、どれかに値が入っていれば limited を true 扱い
    const bool hasAny =
        (tc.p1.baseMs > 0) || (tc.p2.baseMs > 0) ||
        (tc.p1.byoyomiMs > 0) || (tc.p2.byoyomiMs > 0) ||
        (tc.p1.incrementMs > 0) || (tc.p2.incrementMs > 0);

    const bool limited = tc.enabled || hasAny;

    const int p1BaseSec = limited ? msToSecFloor(tc.p1.baseMs) : 0;
    const int p2BaseSec = limited ? msToSecFloor(tc.p2.baseMs) : 0;

    // byoyomi 指定があれば byoyomi 優先（inc は 0 扱い）
    const int byo1Sec = msToSecFloor(tc.p1.byoyomiMs);
    const int byo2Sec = msToSecFloor(tc.p2.byoyomiMs);
    const int inc1Sec = msToSecFloor(tc.p1.incrementMs);
    const int inc2Sec = msToSecFloor(tc.p2.incrementMs);

    const bool useByoyomi = (byo1Sec > 0) || (byo2Sec > 0);
    const int finalByo1 = useByoyomi ? byo1Sec : 0;
    const int finalByo2 = useByoyomi ? byo2Sec : 0;
    const int finalInc1 = useByoyomi ? 0       : inc1Sec;
    const int finalInc2 = useByoyomi ? 0       : inc2Sec;

    qDebug().noquote()
        << "[TC] applyToClock:"
        << " limited=" << limited
        << " P1{baseSec=" << p1BaseSec << " byoSec=" << finalByo1 << " incSec=" << finalInc1 << "}"
        << " P2{baseSec=" << p2BaseSec << " byoSec=" << finalByo2 << " incSec=" << finalInc2 << "}";

    clock->setLoseOnTimeout(limited);
    clock->setPlayerTimes(
        p1BaseSec, p2BaseSec,
        finalByo1, finalByo2,
        finalInc1, finalInc2,
        /*isLimitedTime=*/limited);

    // --- 初期手番を SFEN から 1/2 で渡す（bool は渡さない！） ---
    auto sideFromSfen = [](const QString& sfen)->int {
        // " b " → 先手(1) / " w " → 後手(2)
        const int b = sfen.indexOf(QLatin1String(" b "));
        const int w = sfen.indexOf(QLatin1String(" w "));
        if (b >= 0 && w < 0) return 1;
        if (w >= 0 && b < 0) return 2;
        return 1; // fallback は先手
    };

    const QString sfenForStart =
        !startSfenStr.isEmpty() ? startSfenStr :
            (!currentSfenStr.isEmpty() ? currentSfenStr : QString());

    const int initialPlayer = sfenForStart.isEmpty()
                                  ? 1
                                  : sideFromSfen(sfenForStart);

    clock->setCurrentPlayer(initialPlayer);
}

} // namespace TimeControlUtil
#include "timekeepingservice.h"
#include "shogiclock.h"
#include "shogigamecontroller.h"
#include "matchcoordinator.h"

QString TimekeepingService::applyByoyomiAndCollectElapsed(ShogiClock* clock, bool nextIsP1)
{
    if (!clock) return QString();

    // 直前に指した側へ適用し、今回手の経過/累計文字列を取得
    if (nextIsP1) {
        clock->applyByoyomiAndResetConsideration2();
        const QString elapsed = clock->getPlayer2ConsiderationAndTotalTime();
        clock->setPlayer2ConsiderationTime(0);
        return elapsed;
    } else {
        clock->applyByoyomiAndResetConsideration1();
        const QString elapsed = clock->getPlayer1ConsiderationAndTotalTime();
        clock->setPlayer1ConsiderationTime(0);
        return elapsed;
    }
}

void TimekeepingService::finalizeTurnPresentation(ShogiClock* clock,
                                                  MatchCoordinator* match,
                                                  ShogiGameController* gc,
                                                  bool nextIsP1,
                                                  bool isReplayMode)
{
    if (match) match->pokeTimeUpdateNow();

    // 手番表示（UI側は MainWindow 側で別途実施してOK）
    if (!isReplayMode && clock) {
        clock->startClock();
    }

    if (match) {
        match->markTurnEpochNowFor(nextIsP1 ? MatchCoordinator::P1 : MatchCoordinator::P2);
        // HvH は共通、HvE は人間側のみ計測
        const bool humanTurn =
            gc && ((gc->currentPlayer() == ShogiGameController::Player1) ||
                   (gc->currentPlayer() == ShogiGameController::Player2)); // MainWindow 側の isHumanTurn に合わせてもOK
        if (humanTurn) {
            // プレイモードの分岐は司令塔側ユーティリティで吸収
            match->armHumanTimerIfNeeded();
            match->armTurnTimerIfNeeded();
        } else {
            match->disarmHumanTimerIfNeeded();
        }
    }
}

void TimekeepingService::updateTurnAndTimekeepingDisplay(
    ShogiClock* clock,
    MatchCoordinator* match,
    ShogiGameController* gc,
    bool isReplayMode,
    const std::function<void(const QString&)>& appendElapsedLine,
    const std::function<void(int)>& updateTurnStatus)
{
    // 1) KIF再生中は時計を動かさない（統一）
    if (isReplayMode) {
        if (clock) clock->stopClock();
        if (match) match->pokeTimeUpdateNow();
        return;
    }

    // 2) 終局後は時計を止めて整えるのみ
    const bool gameOver = (match && match->gameOverState().isOver);
    if (gameOver) {
        if (clock) clock->stopClock();
        if (match) match->pokeTimeUpdateNow();
        return;
    }

    // 次に指すのは誰か（UIの次手番＝ now から見た next）
    const bool nextIsP1 = (gc && gc->currentPlayer() == ShogiGameController::Player2);

    // 3) 直前手の byoyomi/increment を適用し、消費/累計テキストを返す
    const QString elapsed = TimekeepingService::applyByoyomiAndCollectElapsed(clock, nextIsP1);
    if (!elapsed.isEmpty() && appendElapsedLine) {
        appendElapsedLine(elapsed); // 「mm:ss/HH:MM:SS」を棋譜欄へ
    }

    // 4) UIの手番表示（1:先手, 2:後手）
    if (updateTurnStatus) {
        updateTurnStatus(nextIsP1 ? 1 : 2);
    }

    // 5) 時計/司令塔の後処理（poke, start, epoch 記録、人間タイマのアーム/解除）
    TimekeepingService::finalizeTurnPresentation(clock, match, gc, nextIsP1, isReplayMode);
}
#include "tsumepositionutil.h"
#include <QtGlobal>
#include <QStringList>
#include "shogiview.h"
#include "shogiboard.h"
#include "enginesettingsconstants.h"
#include "elidelabel.h"
#include "globaltooltip.h"
#include "shogigamecontroller.h"

#include <QColor>
#include <QMouseEvent>
#include <QPainter>
#include <QSettings>
#include <QDir>
#include <QApplication>
#include <QHelpEvent>
#include <QFont>
#include <QFontMetrics>
#include <QDebug>
#include <QSizePolicy>
#include <QLayout>
#include <QFontDatabase>
#include <QRegularExpression>
#include <QPushButton>

// 角丸(border-radius)を 0px に強制するユーティリティ
static QString ensureNoBorderRadiusStyle(const QString& base)
{
    QString s = base;
    QRegularExpression re(R"(border-radius\s*:\s*[^;]+;?)",
                          QRegularExpression::CaseInsensitiveOption);
    if (re.match(s).hasMatch()) {
        s.replace(re, "border-radius:0px;");
    } else {
        if (!s.isEmpty() && !s.trimmed().endsWith(';')) s.append(';');
        s.append("border-radius:0px;");
    }
    return s;
}

static void enforceSquareCorners(QLabel* lab)
{
    if (!lab) return;
    lab->setStyleSheet(ensureNoBorderRadiusStyle(lab->styleSheet()));
}

Q_LOGGING_CATEGORY(ClockLog, "clock")

using namespace EngineSettingsConstants;

// コンストラクタ
// ・描画/レイアウトに関わる初期値をメンバ初期化子で明示
// ・設定ファイルからマス（square）サイズを読み込み
// ・盤・駒台・時計/名前ラベルを生成し、見た目と挙動を初期化する
ShogiView::ShogiView(QWidget *parent)
    // 親ウィジェットを基底クラスに渡す（Qt のオブジェクト階層に参加させる）
    : QWidget(parent),
    // 直前の処理でエラーが発生したかどうかのフラグ（初期状態はエラーなし）
    m_errorOccurred(false),
    // 盤面の反転モード。0=通常、1=反転 など（初期値は通常）
    m_flipMode(0),
    // マウスの操作モード。クリック選択を有効化
    m_mouseClickMode(true),
    // 局面編集モードの有効/無効（初期は通常対局モード）
    m_positionEditMode(false),
    // ドラッグ中かどうかのフラグ（初期は未ドラッグ）
    m_dragging(false),
    // 将棋盤データ（ボード）へのポインタ（まだ未接続のため nullptr）
    m_board(nullptr),
    // 「駒台からつまんだドラッグ」かどうかのフラグ（初期は盤上から想定）
    m_dragFromStand(false)
{
    // 【入出力の基準パスを明確化】
    // 実行中のアプリケーションのディレクトリをカレントディレクトリに設定。
    // 相対パスでの画像/設定ファイル読み込みを安定させるため。
    QDir::setCurrent(QApplication::applicationDirPath());

    // 【UIスケールの取得】
    // 設定ファイル（INI）からマス（square）のピクセルサイズを読み込む。
    // キー "SizeRelated/squareSize" が無い場合は既定値 50 を採用。
    QSettings settings(SettingsFileName, QSettings::IniFormat);
    m_squareSize = settings.value("SizeRelated/squareSize", 50).toInt();

    // 【レイアウト算出】
    // 盤や駒台など、表示に必要な各種寸法/座標を m_squareSize に基づいて再計算する。
    recalcLayoutParams();
    // 先後の駒台と盤のあいだの水平ギャップを「0.5マスぶん」に設定。
    // 視認性（詰まり感の緩和）とレイアウトの均整をとる目的。
    setStandGapCols(0.5);

    // 【盤面の縦位置調整】
    // ウィジェット上で盤の描画原点を下方向に 20px オフセット。
    // 上部に時計/名前ラベルの「視覚的な呼吸（余白）」を確保する。
    m_offsetY = 20;

    // 【マウストラッキング】
    // ボタン未押下でも mouseMoveEvent を受け取れるようにする。
    // ホバー中のハイライトやドラッグ中の追従描画に必要。
    setMouseTracking(true);

    // ───────────────────────────────── 時計・名前ラベル（先手：黒） ─────────────────────────────────

    // 先手（黒）の時計ラベルを生成し、初期表示を "00:00:00" にする。
    m_blackClockLabel = new QLabel(QStringLiteral("00:00:00"), this);
    // オブジェクト名。スタイルシートやUIテストで特定しやすくするため。
    m_blackClockLabel->setObjectName(QStringLiteral("blackClockLabel"));
    // 表示位置は中央揃え（時計としての視認性を優先）
    m_blackClockLabel->setAlignment(Qt::AlignCenter);
    // マウスイベントをスルー。盤の操作を阻害しないようヒットテスト対象外にする。
    m_blackClockLabel->setAttribute(Qt::WA_TransparentForMouseEvents, true);
    // 背景は透過・文字色は黒。盤や背景との干渉を避けつつ読みやすさを確保。
    m_blackClockLabel->setStyleSheet(QStringLiteral("background: transparent; color: black;"));
    {
        // 時計ラベルのフォントを太字にし、マスサイズに比例して可変。
        // 最低でも 8pt は確保して、小サイズ盤でも可読性を担保。
        QFont f = font();
        f.setBold(true);
        f.setPointSizeF(qMax(8.0, m_squareSize * 0.45));
        m_blackClockLabel->setFont(f);
    }

    // 先手（黒）の名前ラベル（長い名前を省略表示できる特殊ラベル）を生成。
    m_blackNameLabel = new ElideLabel(this);
    // 長いテキストは末尾を省略（…）して収める。
    m_blackNameLabel->setElideMode(Qt::ElideRight);
    // 左寄せ・垂直中央。名前と時計の並びを整える。
    m_blackNameLabel->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);
    // ホバー時に自動スクロール（スライド）でフルテキストを見せる。
    m_blackNameLabel->setSlideOnHover(true);
    // 手動パンも有効。ドラッグ操作でテキストを左右に移動できる。
    m_blackNameLabel->setManualPanEnabled(true);
    // スクロール速度（大きいほど速い）
    m_blackNameLabel->setSlideSpeed(2);
    // スクロールの更新間隔（ミリ秒）。16ms ≒ 60fps で滑らかに。
    m_blackNameLabel->setSlideInterval(16);

    // ───────────────────────────────── 名前ラベル（後手：白） ─────────────────────────────────

    // 後手（白）の名前ラベルを生成。先手側と同じ見た目/挙動を設定。
    m_whiteNameLabel = new ElideLabel(this);
    m_whiteNameLabel->setElideMode(Qt::ElideRight);
    m_whiteNameLabel->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);
    m_whiteNameLabel->setSlideOnHover(true);
    m_whiteNameLabel->setManualPanEnabled(true);
    m_whiteNameLabel->setSlideSpeed(2);
    m_whiteNameLabel->setSlideInterval(16);

    // ───────────────────────────────── 時計ラベル（後手：白） ─────────────────────────────────

    // 後手（白）の時計ラベルを生成し、初期表示を "00:00:00" にする。
    m_whiteClockLabel = new QLabel(QStringLiteral("00:00:00"), this);
    m_whiteClockLabel->setObjectName(QStringLiteral("whiteClockLabel"));
    m_whiteClockLabel->setAlignment(Qt::AlignCenter);
    m_whiteClockLabel->setAttribute(Qt::WA_TransparentForMouseEvents, true);
    m_whiteClockLabel->setStyleSheet(QStringLiteral("background: transparent; color: black;"));
    {
        // 先手側と同じ方針でフォントを設定（太字 + マスサイズ連動 + 最小 8pt）
        QFont f = font();
        f.setBold(true);
        f.setPointSizeF(qMax(8.0, m_squareSize * 0.45));
        m_whiteClockLabel->setFont(f);
    }

    // 【初期配置の反映】
    // 現在のレイアウトパラメータに基づき、時計ラベルの位置・サイズを更新。
    // ここで呼んでおくことで、初回描画前に正しいジオメトリにしておく。
    updateBlackClockLabelGeometry();
    updateWhiteClockLabelGeometry();

    // ★ 起動直後の見た目を整える（両側とも font-weight:400）
    applyStartupTypography();

    // 【イベントフック】
    // 名前ラベルにイベントフィルタを装着。
    // ホバー時のスライド/手動パンの管理や、将来的なツールチップ制御拡張に備える。
    m_blackNameLabel->installEventFilter(this);
    m_whiteNameLabel->installEventFilter(this);
}

// このビューに関連付ける盤データ（ShogiBoard）を設定/差し替えする。
// 役割：
//  - 同一ポインタの再設定は無駄な接続増殖を避けて即 return
//  - 旧ボードがあれば、本ビューへの全シグナル接続を一括解除（重複更新/メモリリーク回避）
//  - 新ボードを保持し、状態変化（dataChanged/boardReset）で update() を起動して再描画を依頼
//  - sizeHint 等が変わる可能性に備え、updateGeometry() で親レイアウトに再配置を要求
void ShogiView::setBoard(ShogiBoard* board)
{
    // 【無駄な再設定の回避】
    // すでに同じ ShogiBoard を保持しているなら処理不要。
    if (m_board == board) return;

    // 【旧接続のクリーンアップ】
    // 以前のボードが存在する場合、そのボード -> このビュー への全接続を解除。
    // QObject::disconnect(m_board, nullptr, this, nullptr) 相当で、安全に差し替え可能にする。
    if (m_board) {
        m_board->disconnect(this);
    }

    // 【差し替え本体】
    // 新しいボード（nullptr 可）を保持。
    m_board = board;

    // 【新接続の確立】
    // 新しいボードが有効なら、表示に影響するイベントで再描画を依頼する。
    if (board) {
        // 盤データが変更されたら、次のイベントループで再描画（update は非同期・差分指向）
        connect(board, &ShogiBoard::dataChanged, this, [this]{ update(); });
        // 盤がリセットされたら、全体を再描画
        connect(board, &ShogiBoard::boardReset,  this, [this]{ update(); });
        // ※ 第3引数に this を渡しているため、このビュー破棄時に自動で接続解除される。
    }

    // 【レイアウト再評価のトリガ】
    // sizeHint() の結果がボードの状態に依存する場合に備え、ジオメトリ更新を通知。
    // 親レイアウトに再レイアウトを促し、必要ならば再配置/再サイズを行う。
    updateGeometry();
}

// イベントフィルタ
// 役割：
//  - 名前ラベル（先手/後手）に対して、標準QToolTipではなくカスタムの GlobalToolTip を用いた
//    遅延生成＆表示制御を行う
//  - ツールチップ要求（QEvent::ToolTip）でフルのベース名を表示、ウィジェット離脱（QEvent::Leave）で非表示
//  - 該当しないオブジェクト/イベントは既定の処理にフォールバック
bool ShogiView::eventFilter(QObject* obj, QEvent* ev)
{
    // 【遅延初期化：ツールチップのシングルトン的利用】
    // パフォーマンスとリソース節約のため、最初の要求時にのみインスタンス化する。
    if (!m_tooltip) {
        m_tooltip = new GlobalToolTip(this);   // 親を this にして破棄を自動化
        m_tooltip->setCompact(true);          // 余白を詰めたコンパクト表示
        m_tooltip->setPointSizeF(12.0);       // ベースとなるフォントサイズ
    }

    // 【対象オブジェクトの限定】
    // 先手/後手の「名前ラベル」に対するイベントのみカスタム処理を行う。
    if (obj == m_blackNameLabel || obj == m_whiteNameLabel) {
        // ツールチップ要求イベント：
        // マウスオーバー位置（グローバル座標）に、フルのベース名を提示する。
        if (ev->type() == QEvent::ToolTip) {
            auto* he = static_cast<QHelpEvent*>(ev); // QEvent -> QHelpEvent への安全なダウンキャスト
            // どちらのラベルかで表示テキスト（ベース名）を切り替える。
            const QString text = (obj == m_blackNameLabel) ? m_blackNameBase : m_whiteNameBase;
            // 画面上のカレントマウス位置（globalPos）付近にカスタムツールチップを表示。
            m_tooltip->showText(he->globalPos(), text);
            return true; // 【重要】標準の QToolTip を抑止し、二重表示/ちらつきを防止
        }
        // ラベルからマウスが離れたらツールチップを隠す（確実に消すためLeaveで制御）
        else if (ev->type() == QEvent::Leave) {
            m_tooltip->hideTip();
        }
    }

    // 【フォールバック】
    // ここで処理しなかったイベントは QWidget 側の既定処理に委譲。
    return QWidget::eventFilter(obj, ev);
}

// 現在ビューに紐づく盤データ（ShogiBoard）を読み出すゲッター。
// nullptr の可能性もある点に注意（未セット時など）。
ShogiBoard* ShogiView::board() const
{
    return m_board;
}

// 1マス（square）の描画サイズ（幅・高さ）を返すゲッター。
// 盤や駒台のレイアウト計算の基本単位として各所で利用される。
QSize ShogiView::fieldSize() const
{
    return m_fieldSize;
}

// 1マスの描画サイズをセットするセッター。
// 役割：値の変化検知 → シグナル発行 → レイアウト再計算/再配置 → 付随UI（時計ラベル）のジオメトリ更新
void ShogiView::setFieldSize(QSize fieldSize)
{
    // 【無駄な再計算回避】 同一サイズなら何もしない。
    if (m_fieldSize == fieldSize) return;

    // 内部状態を更新。
    m_fieldSize = fieldSize;

    // この変更を関心のある外部へ通知（例えばスライダー連動のUIなど）。
    emit fieldSizeChanged(fieldSize);

    // sizeHint() の変化を親レイアウトに伝え、必要ならば再レイアウトを促す。
    updateGeometry();

    // 1マスのサイズが変われば時計ラベルの位置・大きさも影響を受けるため、個別に再配置。
    updateBlackClockLabelGeometry();
    updateWhiteClockLabelGeometry();
}

// レイアウト計算に用いられる推奨サイズ（sizeHint）を返す。
// 親レイアウトがこの値を参考にウィジェットを配置する。
// 盤未設定の場合は最低限の保険値（100x100）を返す。
QSize ShogiView::sizeHint() const
{
    if (!m_board) {
        return QSize(100, 100);
    }

    // 1マスのサイズ
    const QSize squareSize = fieldSize();

    // 全マス分の幅・高さに、左右/上下のオフセット（余白）を加算。
    // m_offsetX, m_offsetY は盤の見た目の「呼吸（余白）」や上部ラベル分の調整に使用。
    int totalWidth  = squareSize.width()  * m_board->files() + m_offsetX * 2;
    int totalHeight = squareSize.height() * m_board->ranks() + m_offsetY * 2;

    return QSize(totalWidth, totalHeight);
}

// 盤状態（反転の有無・段筋数）に基づき、指定された(file, rank)のマスの矩形領域を算出。
// file: 筋（1..m_board->files()）/ rank: 段（1..m_board->ranks()）を前提。
// 返り値はウィジェット座標系（左上原点）の QRect（幅=fs.width(), 高さ=fs.height()）。
QRect ShogiView::calculateSquareRectangleBasedOnBoardState(const int file, const int rank) const
{
    // 盤未設定なら空矩形を返す（呼び出し側で無視できるように）。
    if (!m_board) return QRect();

    const QSize fs = fieldSize();
    int xPosition, yPosition;

    // 【座標系の切替】反転モードのときは上下/左右の向きを入れ替える。
    if (m_flipMode) {
        // 反転時：左から右へ file=1.. の順で配置、縦は上から rank を逆順に敷き詰める。
        xPosition = (file - 1) * fs.width();
        yPosition = (m_board->ranks() - rank) * fs.height();
    } else {
        // 通常時：右から左へ file を反転配置、縦は下から上へ rank=1.. の順で配置。
        xPosition = (m_board->files() - file) * fs.width();
        yPosition = (rank - 1) * fs.height();
    }

    // 指定マス一個分の矩形を返す（位置：x/y, サイズ：fs）。
    return QRect(xPosition, yPosition, fs.width(), fs.height());
}

// 段番号/筋番号などのラベル描画に用いる矩形領域を算出。
// 盤の反転状態に合わせてYのみ上下を切替。Xは左→右の自然順で配置し、最後にUI都合で +30px 平行移動。
// ※ +30px はラベルの視認性/余白確保のための固定オフセット（デザイン調整値）。
QRect ShogiView::calculateRectangleForRankOrFileLabel(const int file, const int rank) const
{
    if (!m_board) return QRect();

    const QSize fs = fieldSize();

    // ラベルは左→右の自然順で扱うため X は (file - 1) を素直に採用。
    int adjustedX = (file - 1) * fs.width();

    int adjustedY;
    if (m_flipMode) {
        // 反転時は段を逆順に変換（盤面の上下関係に合わせる）
        adjustedY = (m_board->ranks() - rank) * fs.height();
    } else {
        // 通常時は rank=1 を最上段（0オリジン）とする
        adjustedY = (rank - 1) * fs.height();
    }

    // ラベル領域の基本矩形を作り、UI上の意図的な余白として X に +30px 平行移動して返す。
    return QRect(adjustedX, adjustedY, fs.width(), fs.height()).translated(30, 0);
}

// 駒タイプと描画用アイコン（QIcon）を関連付けて登録する。
// 役割：駒文字（例：'P','L','N','B','R','G','S','K','p',...）に対応するアイコンをセットし、再描画を依頼。
// 備考：update() は非同期に再描画イベントを発行（即座にpaintEventを呼ばない）。
void ShogiView::setPiece(char type, const QIcon &icon)
{
    // 駒タイプ→アイコン のマップに挿入/上書き
    m_pieces.insert(type, icon);

    // 駒画像が更新されたのでビューの再描画を要求
    update();
}

// 駒タイプに対応するアイコンを取得するゲッター。
// 見つからない場合はデフォルト構築の QIcon（空）を返す。
// 役割：描画時に、盤上/駒台の駒アイコンを取り出すのに使用。
QIcon ShogiView::piece(QChar type) const
{
    return m_pieces.value(type, QIcon());
}

// 段番号（rank）の描画エントリポイント。
// 役割：
//  - 盤が未設定なら何もしない安全弁
//  - 共通の描画状態（ここでは文字色＝QPalette::WindowText）を一度だけ設定
//  - 1..ranks() を走査して各段の描画を drawRank() に委譲
// 前提：drawRank() は QPainter の永続状態（ペン/ブラシ/変換/クリップ等）を汚さないこと。
//       もし一時的に変更する場合は drawRank() 内部で局所 save()/restore() を使う。
void ShogiView::drawRanks(QPainter* painter)
{
    // 【安全弁】盤が無ければ段ラベルは描けない
    if (!m_board) return;

    // 【共通状態設定】段ラベル用の文字色（パレットに従う）
    painter->setPen(palette().color(QPalette::WindowText));

    // 【描画ループ】1段目から最終段まで順に描画
    for (int r = 1; r <= m_board->ranks(); ++r) {
        drawRank(painter, r);
    }
}

// 筋番号（file）の描画エントリポイント。
// 役割：
//  - 盤が未設定なら何もしない安全弁
//  - 共通の描画状態（文字色など）を一度だけ設定
//  - 1..files() を走査して各筋の描画を drawFile() に委譲
// 備考：フォントサイズ等を変更する場合は、ここでまとめて setFont しておくと効率的。
// 前提：drawFile() は QPainter の永続状態を汚さない（必要時のみ局所 save()/restore()）。
void ShogiView::drawFiles(QPainter* painter)
{
    // 【安全弁】盤が無ければ筋ラベルは描けない
    if (!m_board) return;

    // 【共通状態設定】筋ラベル用の文字色（パレットに従う）
    painter->setPen(palette().color(QPalette::WindowText));

    // 例：フォントサイズを調整したい場合（必要になったら有効化）
    // QFont f = painter->font();
    // f.setPointSize(...)
    // painter->setFont(f);

    // 【描画ループ】1筋目から最終筋まで順に描画
    for (int c = 1; c <= m_board->files(); ++c) {
        drawFile(painter, c);
    }
}

// 盤の各マス（field）を描画するエントリポイント。
// 最適化方針を適用：セルごとの save()/restore() を撤去し、共通状態は外側で一度だけ設定。
// 前提：drawField() は QPainter の永続状態（ペン/ブラシ/変換/クリップ等）を汚さないこと。
// 　　（もし一時的に変更する必要がある場合は、drawField() 内でその箇所だけ局所的に save()/restore() を行う）
void ShogiView::drawBoardFields(QPainter* painter)
{
    // 【安全弁】盤が未設定なら何もしない
    if (!m_board) return;

    // 【共通状態の一括設定】
    // 例：マスの境界線などで使うペン色を一度だけセットして、以降は drawField() が恒久変更しない前提にする。
    // ※ 個々のマスでブラシ（塗り）を切り替える場合、ブラシは drawField() 内で一時的に設定する。
    painter->setPen(palette().color(QPalette::Dark));
    // 必要に応じて他の共通設定もここで行う：
    // painter->setRenderHint(QPainter::Antialiasing, false);
    // painter->setBrush(Qt::NoBrush);

    // 【描画ループ】段（r）× 筋（c）で全マスを走査し、個々の描画は drawField() に委譲
    for (int r = 1; r <= m_board->ranks(); ++r) {
        for (int c = 1; c <= m_board->files(); ++c) {
            // セルごとの save/restore は行わない（コスト削減）。
            // drawField() 側は必要箇所のみ局所 save/restore で自己完結させる契約。
            drawField(painter, c, r);
        }
    }
}

void ShogiView::drawBlackNormalModeStand(QPainter* painter)
{
    painter->setPen(palette().color(QPalette::Dark));
    // ★ r=3..9 → r=6..9（4行）に短縮
    for (int r = 6; r <= 9; ++r) {
        for (int c = 1; c <= 2; ++c) {
            drawBlackStandField(painter, c, r);
        }
    }
}

void ShogiView::drawWhiteNormalModeStand(QPainter* painter)
{
    painter->setPen(palette().color(QPalette::Dark));
    // ★ r=1..7 → r=1..4（4行）に短縮
    for (int r = 1; r <= 4; ++r) {
        for (int c = 1; c <= 2; ++c) {
            drawWhiteStandField(painter, c, r);
        }
    }
}

// 通常対局モードにおける「駒台」描画の統括エントリポイント。
// 役割：先手（黒）→ 後手（白）の順に、通常モード用の駒台マスを描画する関数へ委譲する。
// 方針：共通の描画状態（ペン/ブラシ等）の設定は各サブ関数側で一括設定済みとし、ここでは状態を変更しない。
// 前提：drawBlackNormalModeStand()/drawWhiteNormalModeStand() は QPainter の永続状態を汚さない
//      （必要箇所のみ局所 save()/restore() を用いる契約）。
// 備考：描画順は重なり順（zオーダ）や視覚効果に影響し得るため、UI要件に応じて入れ替え可能。
void ShogiView::drawNormalModeStand(QPainter* painter)
{
    // 先手（黒）側の通常モード駒台を描画
    drawBlackNormalModeStand(painter);

    // 後手（白）側の通常モード駒台を描画
    drawWhiteNormalModeStand(painter);
}

// 盤上の全ての駒を描画するエントリポイント。
// 最適化方針：セル（マス）ごとの save()/restore() を撤去し、共通状態は外側で必要に応じて一度だけ設定。
// 前提：drawPiece() は QPainter の永続状態（ペン/ブラシ/変換/クリップ等）を汚さないこと。
//       もし一時的な状態変更（座標変換やクリッピング等）が必要な場合は、drawPiece() 内で
//       その箇所だけ局所的に save()/restore() を行う契約とする。
// 備考：段は ranks() から 1 へ向かって降順に走査。
//       （必要に応じて、重なり順やドロップシャドウなどの視覚効果に合わせて順序を変えられる）
void ShogiView::drawPieces(QPainter* painter)
{
    // 【安全弁】盤が未設定なら何もしない
    if (!m_board) return;

    // 【共通状態の一括設定（必要なら）】
    // 駒アイコンをスケーリング描画する際の画質を上げたい場合に有効化。
    // painter->setRenderHint(QPainter::SmoothPixmapTransform, true);

    // 【描画ループ】段（r）を降順、筋（c）を昇順に走査し、各マスの駒を描画
    for (int r = m_board->ranks(); r > 0; --r) {
        for (int c = 1; c <= m_board->files(); ++c) {
            // セルごとの save/restore は行わない（コスト削減）。
            // drawPiece() 側は必要箇所のみ局所保護する契約。
            drawPiece(painter, c, r);

            // 【エラーハンドリング】
            // 描画中に致命的な条件が発生した場合（フォント/画像読み込み失敗など想定）、
            // フラグを見て素早く中断。セル単位の save() を使っていないため、
            // ここでの早期 return でも painter 状態リークの懸念はない。
            if (m_errorOccurred) return;
        }
    }
}

// 【通常対局モード：先手（左側）駒台のアイコンを 4×2 で描画】
void ShogiView::drawPiecesBlackStandInNormalMode(QPainter* painter)
{
    // 左列：R, G, N, P （= 飛, 金, 桂, 歩）
    // 右列：K, B, S, L （= 王, 角, 銀, 香）
    const int ranks [4] = { 6, 7, 8, 9 };

    // 左列は file=2、右列は file=1（このコードの座標系では file=2 の方が左寄り）
    for (int row = 0; row < 4; ++row) {
        for (int file = 1; file <= 2; ++file) {
            drawBlackStandPiece(painter, file, ranks[row]);
        }
    }
}

// 【通常対局モード：後手（右側）駒台のアイコンを 4×2 で描画】
void ShogiView::drawPiecesWhiteStandInNormalMode(QPainter* painter)
{
    // 左列：r, g, n, p（= 飛, 金, 桂, 歩）
    // 右列：k, b, s, l（= 王, 角, 銀, 香）
    const int ranks [4] = { 4, 3, 2, 1 };

    // 右側駒台でも相対的な“左列”は file=2、“右列”は file=1 が自然に並ぶ
    for (int row = 0; row < 4; ++row) {
        for (int file = 1; file <= 2; ++file) {
            drawWhiteStandPiece(painter, file, ranks[row]);
        }
    }
}

void ShogiView::drawPiecesStandFeatures(QPainter* painter)
{
    // 先手/後手の駒台にある「駒」と「枚数」を描画
    drawPiecesBlackStandInNormalMode(painter);
    drawPiecesWhiteStandInNormalMode(painter);
}

// 画面全体の描画エントリポイント（paintEvent）。
// 方針：
//  - 最適化後の契約に基づき、セルごとの save()/restore() は各描画関数の内部で
//    「必要箇所のみ局所的に」行う（外側での大量反復はしない）。
//  - ここでは共通のレンダリングヒント等を一度だけ設定し、以降のサブ関数は
//    QPainter の永続状態（ペン/ブラシ/変換/クリップ）を汚さない前提で呼び出す。
//  - 描画順序は背面→前面のレイヤ構造を明確にし、重ね合わせを安定化させる。
void ShogiView::paintEvent(QPaintEvent *)
{
    // 【安全弁】盤未設定、またはエラーフラグが立っている場合は描画を行わない。
    if (!m_board || m_errorOccurred) return;

    // 【ペインタ開始】このスコープでのみ QPainter を有効化。
    QPainter painter(this);

    // 【共通描画状態の一括設定】
    // 盤の格子線などはジャギーの少ない直線を優先するためアンチエイリアスは基本OFF。
    // テキストは可読性重視でON、駒アイコンの拡縮品質を上げるため SmoothPixmapTransform をON。
    painter.setRenderHint(QPainter::Antialiasing, false);
    painter.setRenderHint(QPainter::TextAntialiasing, true);
    painter.setRenderHint(QPainter::SmoothPixmapTransform, true);

    // 【描画順序：背面 → 前面】
    // 1) 盤面（マスの背景・枠など）
    drawBoardFields(&painter);

    // 2) 局面編集/通常に応じた周辺（駒台グリッドなどのフィールド）
    drawNormalModeStand(&painter);

    // 3) 盤の星（目印）
    drawFourStars(&painter);

    // 4) ハイライト（選択/移動可能マスなど）
    drawHighlights(&painter);

    // 5) 盤上の駒
    drawPieces(&painter);

    // 描画中に致命的な異常が検知された場合はここで打ち切る。
    if (m_errorOccurred) return;

    // 6) 先手/後手の駒台にある「駒」と「枚数」を描画
    drawPiecesStandFeatures(&painter);

    // 7) 段・筋ラベル（最前面に近いレイヤに載せる）
    drawRanks(&painter);
    drawFiles(&painter);

    // 8) 最前面：ドラッグ中の駒（マウス追従）。盤やラベルより上に重ねる。
    //    ※ 重要：drawDraggingPiece() の内部で新たに QPainter を begin しないこと。
    //            （この paintEvent 中は既に painter がアクティブなため競合する）
    drawDraggingPiece(&painter);
}

// 【ドラッグ中の駒を描画】（最適化適用版）
// 方針：paintEvent で開始済みの QPainter を使い回すため、ここで新たに QPainter を生成しない。
// 前提：本関数は QPainter の永続状態（ペン/ブラシ/変換/クリップ等）を汚さない。
// 備考：ドラッグ位置 m_dragPos の中心に、1マス分（squareSize）でアイコンを描画する。
void ShogiView::drawDraggingPiece(QPainter* painter)
{
    // 【前提確認】ドラッグ中でなければ何もしない／駒種が空白なら描かない
    if (!m_dragging || m_dragPiece == ' ') return;

    // 【アイコン取得】該当駒のアイコンが無ければ描かない（安全弁）
    const QIcon icon = piece(QChar(m_dragPiece));
    if (icon.isNull()) return;

    // 【描画矩形算出】ドラッグ座標を矩形の中心に据える（正方形：1マス）
    const int s = squareSize();
    const QRect r(m_dragPos.x() - s / 2, m_dragPos.y() - s / 2, s, s);

    // 【描画】既存の painter を用いて中央揃えでペイント（状態は汚さない）
    icon.paint(painter, r, Qt::AlignCenter);
}

// 将棋盤の「四隅の星（3,3）（6,3）（3,6）（6,6）」を描画する。
// 最適化方針：この関数内でのみブラシ/ペン等の状態を一時変更し、終了時に必ず元へ戻す（局所 save/restore）。
// 役割：盤面上の 4 箇所に小さな点（塗りつぶし円）を打ち、視覚的な基準点を提供する。
// 座標系：各星の中心は「マスサイズ×(3 or 6) ＋ オフセット(m_offsetX/Y)」で求める。
void ShogiView::drawFourStars(QPainter* painter)
{
    // 【状態の局所保護】このブロックでのみ描画状態を変更し、外へ影響させない
    painter->save();

    // 【描画スタイル】星は塗りつぶし円で表現（縁取り色は現状維持：必要なら NoPen を設定）
    painter->setBrush(palette().color(QPalette::Dark));
    // 例：縁取りを消したい場合は以下を有効化
    // painter->setPen(Qt::NoPen);

    // 【サイズ/基準点】
    const int starRadius = 4;             // 星（点）の半径（px）。必要に応じてマス比率に連動させてもよい。
    const int basePoint3 = m_squareSize * 3; // 3マス分
    const int basePoint6 = m_squareSize * 6; // 6マス分

    // 【描画】（x, y）はウィジェット座標。盤の原点シフトに m_offsetX/Y を加味。
    painter->drawEllipse(QPoint(basePoint3 + m_offsetX, basePoint3 + m_offsetY), starRadius, starRadius);
    painter->drawEllipse(QPoint(basePoint6 + m_offsetX, basePoint3 + m_offsetY), starRadius, starRadius);
    painter->drawEllipse(QPoint(basePoint3 + m_offsetX, basePoint6 + m_offsetY), starRadius, starRadius);
    painter->drawEllipse(QPoint(basePoint6 + m_offsetX, basePoint6 + m_offsetY), starRadius, starRadius);

    // 【状態復元】外側の描画に影響を残さない
    painter->restore();
}

// 盤の左端（X座標, px）を返すゲッター。
// 役割：盤の描画/ヒットテスト/ラベル配置の基準となる「左側の外側境界」を返す。
// 備考：反転（m_flipMode）の有無に関わらず、盤の左端Xは m_offsetX で一定。
int ShogiView::boardLeftPx() const { return m_offsetX; }

// 盤の右端（X座標, px）を返すゲッター。
// 役割：盤の横幅（files × 1マス幅）を左端に加算し、右側の外側境界（exclusive）を返す。
//  - files は盤の筋数。盤未設定時は将棋の標準 9 筋を仮定（安全なフォールバック）。
//  - 戻り値は「右端の外側境界（exclusive）」：左端 <= x < 右端 の右端に相当。
//    ヒットテスト等で矩形幅を計算する際に扱いやすい表現。
int ShogiView::boardRightPx() const {
    const int files = m_board ? m_board->files() : 9;                 // 未設定時は 9×9 を前提
    return m_offsetX + m_squareSize * files;                           // 左端 + 盤の総幅
}


// 指定された (file, rank) のマス（1 マス分の矩形）を描画する。
// 最適化方針：本関数内でのみペン/ブラシ状態を一時変更するため、局所的に save()/restore() を行う。
// 役割：
//  - 盤の反転状態も考慮したマス矩形を算出（calculateSquareRectangleBasedOnBoardState）
//  - 盤の描画原点シフト（m_offsetX/m_offsetY）を加味して実座標へ変換
//  - 木目風の塗り色と枠線色で 1 マスを描画
void ShogiView::drawField(QPainter* painter, const int file, const int rank) const
{
    // 【盤座標 → ウィジェット座標】
    const QRect fieldRect = calculateSquareRectangleBasedOnBoardState(file, rank);
    QRect adjustedRect(fieldRect.left() + m_offsetX,
                       fieldRect.top()  + m_offsetY,
                       fieldRect.width(),
                       fieldRect.height());

    // 【状態の局所保護】このマスの描画で変更するペン/ブラシを外に漏らさない
    painter->save();

    // 【描画スタイル】
    // マスの塗り（木目系の色味）。必要に応じてパレット依存や明度調整に置き換え可。
    const QColor fillColor(222, 196, 99, 255);
    painter->setBrush(fillColor);

    // マスの枠線色（やや暗いグレー）。デザインポリシーに合わせて QPalette::Dark も可。
    painter->setPen(QColor(30, 30, 30));

    // 【描画本体】
    painter->drawRect(adjustedRect);

    // 【状態復元】以降の描画に影響を残さない
    painter->restore();
}

// 駒台セル（1マス）の描画矩形を算出するユーティリティ。
// 役割：
//  - 盤上の基準マス矩形（fieldRect）から、先手/後手の駒台側に水平オフセットした矩形を返す。
//  - 盤の反転状態（flip）と、どちら側の駒台か（leftSide）に応じて、左右どちらへ寄せるかを切り替える。
// 引数：
//  - flip    : 盤の反転状態。true=反転（上下左右が入れ替わる前提）、false=通常。
//  - param   : 駒台セルを盤の基準矩形からどれだけ水平方向にずらすか（px, 正値）。
//  - offsetX : 盤全体のX方向オフセット（描画原点シフト）。
//  - offsetY : 盤全体のY方向オフセット（描画原点シフト）。
//  - fieldRect : 盤の基準マス矩形（この左上・サイズを基準に駒台セルを配置する）。
//  - leftSide  : 「左側の駒台か」を示すフラグ。true=左側、false=右側。
// 戻り値：調整後（オフセット適用後）の駒台セル矩形。
// 視点：
//  - flip==true のとき「先手は左／後手は右」へ寄せる（左右関係が反転）
//  - flip==false のとき「先手は右／後手は左」へ寄せる（通常の左右関係）
static inline QRect makeStandCellRect(bool flip, int param, int offsetX, int offsetY, const QRect& fieldRect, bool leftSide)
{
    QRect adjustedRect;

    if (flip) {
        // 【反転時】先手は左、後手は右に配置。
        // leftSide==true（左側の駒台）のときは基準から -param、右側は +param 側へシフト。
        adjustedRect.setRect(fieldRect.left() + (leftSide ? -param : +param) + offsetX,
                             fieldRect.top()  + offsetY,
                             fieldRect.width(),
                             fieldRect.height());
    } else {
        // 【通常時】先手は右、後手は左に配置。
        // leftSide==true（左側の駒台）のときは基準から +param、右側は -param 側へシフト。
        adjustedRect.setRect(fieldRect.left() + (leftSide ? +param : -param) + offsetX,
                             fieldRect.top()  + offsetY,
                             fieldRect.width(),
                             fieldRect.height());
    }

    return adjustedRect;
}

// 先手（黒）側の駒台セル（1マス）を描画する。
// 最適化方針：この関数内のみでペン/ブラシを一時変更するため、局所的に save()/restore() を行う。
// 手順：
//  1) 盤の(file, rank)に対応する基準マス矩形を取得（反転含む）
//  2) 基準マスから「左側の駒台」方向へ水平シフトして駒台セル矩形を算出
//  3) 木目系の塗り色で矩形を描画（枠線も同色で目立たせない）
void ShogiView::drawBlackStandField(QPainter* painter, const int file, const int rank) const
{
    // (1) 盤座標→基準マス矩形
    const QRect fieldRect = calculateSquareRectangleBasedOnBoardState(file, rank);

    // (2) 先手は「左側の駒台」へ寄せる想定。m_param1 は水平シフト量（px）。
    QRect adjustedRect = makeStandCellRect(
        m_flipMode,               // 反転有無
        m_param1,                 // 水平方向の寄せ量（先手用パラメータ）
        m_offsetX, m_offsetY,     // 盤全体の原点シフト
        fieldRect,
        /*leftSide=*/true         // 左側の駒台へ配置
        );

    // (3) 状態の局所保護と描画
    painter->save();

    const QColor fillColor(228, 167, 46, 255); // 駒台の塗り（木目系）
    painter->setPen(fillColor);                // 枠線も同色にして目立たせない
    painter->setBrush(fillColor);
    painter->drawRect(adjustedRect);

    painter->restore();
}

// 後手（白）側の駒台セル（1マス）を描画する。
// 最適化方針：本関数内のみで状態を変更し、終了時に元へ戻す（局所 save()/restore()）。
// 手順：基準マス→「右側の駒台」方向へ水平シフト→木目系の塗りで矩形描画。
void ShogiView::drawWhiteStandField(QPainter* painter, const int file, const int rank) const
{
    // 盤座標→基準マス矩形
    const QRect fieldRect = calculateSquareRectangleBasedOnBoardState(file, rank);

    // 後手は「右側の駒台」へ寄せる想定。m_param2 は後手用の水平シフト量（px）。
    QRect adjustedRect = makeStandCellRect(
        m_flipMode,               // 反転有無
        m_param2,                 // 水平方向の寄せ量（後手用パラメータ）
        m_offsetX, m_offsetY,     // 盤全体の原点シフト
        fieldRect,
        /*leftSide=*/false        // 右側の駒台へ配置
        );

    // 状態の局所保護と描画
    painter->save();

    const QColor fillColor(228, 167, 46, 255); // 駒台の塗り（木目系）
    painter->setPen(fillColor);                // 枠線も同色に
    painter->setBrush(fillColor);
    painter->drawRect(adjustedRect);

    painter->restore();
}

// 指定された (file, rank) のマスに存在する「駒」を描画する。
// 方針：この関数では QPainter の永続状態（ペン/ブラシ/変換/クリップ等）を変更しない。
//       アイコン描画のみを行うため、save()/restore() は不要（最適化適用）。
// 前提：呼び出し側（例：drawPieces）が m_board の非 nullptr を保証している。
void ShogiView::drawPiece(QPainter* painter, const int file, const int rank)
{
    // 【ドラッグ中の元マスは描かない】
    // ドラッグ中の駒は最前面で drawDraggingPiece() により別途描画するため、
    // 元いたマスの駒は二重描画を避ける目的でスキップする。
    if (m_dragging && file == m_dragFrom.x() && rank == m_dragFrom.y()) {
        return;
    }

    // 【盤座標 → ウィジェット座標】
    // 反転状態を考慮したマス矩形を取得し、盤の原点シフト（m_offsetX/Y）を加味して実座標へ。
    const QRect fieldRect = calculateSquareRectangleBasedOnBoardState(file, rank);
    QRect adjustedRect(fieldRect.left() + m_offsetX,
                       fieldRect.top()  + m_offsetY,
                       fieldRect.width(),
                       fieldRect.height());

    // 【盤から駒種を取得】
    QChar value = m_board->getPieceCharacter(file, rank);

    // 【アイコン描画】
    // 空白でなければ駒に対応する QIcon を取得し、存在する場合のみ中央揃えで描く。
    if (value != ' ') {
        const QIcon icon = piece(value);
        if (!icon.isNull()) {
            // SmoothPixmapTransform は paintEvent 側の共通設定で有効化済みを想定。
            icon.paint(painter, adjustedRect, Qt::AlignCenter);
        }
    }
}

/**
 * @brief 駒台セル内に「等倍」の駒アイコンを重ね描きする（最大2段＝最大3枚表示）。
 *
 * @param painter       描画先 QPainter（外側で begin() されている前提）
 * @param adjustedRect  駒台の 1 セル矩形（この矩形で clip してセル外は不可視）
 * @param value         駒種キー（piece(value) から QIcon を取得）
 *
 * @details
 * - アイコンはセル等倍（拡大縮小なし）。重ね全体の“中心”が常にセル中心に来るよう配置します。
 * - 枚数に応じて「後ろ（奥）」の駒ほど左にオフセットして重ねます。
 * - 見せる重なりは最大2段（= 表示するアイコンは最大3枚）。4枚目以降は描画せず、バッジのみ総数表示。
 * - 右下の枚数バッジは自動的にサイズ調整し、必要に応じて基準位置を少し左へ寄せてセル内に収めます。
 *
 * @note 調整パラメータ
 *   - maxOverlapSteps … 重なり段数の上限（既定 2）。表示最大枚数は maxOverlapSteps+1。
 *   - perStep         … 1 段あたりの横オフセット量（アイコン幅に対する比率、既定 0.05）。
 *   - hardMax         … 左方向への総広がりの上限（見栄え用、既定 iconW * 0.85）。
 */
void ShogiView::drawStandPieceIcon(QPainter* painter, const QRect& adjustedRect, QChar value) const
{
    const int count = (m_dragging && m_tempPieceStandCounts.contains(value))
    ? m_tempPieceStandCounts[value]
    : m_board->m_pieceStand.value(value);
    if (count <= 0 || value == QLatin1Char(' ')) return;

    const QIcon icon = piece(value);

    // === 等倍（セルいっぱい） ===
    const int cellW = adjustedRect.width();
    const int cellH = adjustedRect.height();
    const int iconW = cellW;
    const int iconH = cellH;

    // ▼ここで“見せる重なり段数”と“最大表示枚数”をハードキャップ
    const int maxOverlapSteps = 2;                 // 最大重なり段数（= 左への段差は2段まで）
    const int maxVisibleIcons = maxOverlapSteps + 1; // 最大表示枚数（前面含め最大3枚）
    const int visible = qMin(count, maxVisibleIcons);
    const int stepsEff = qMax(0, visible - 1);     // 0..5

    // 重なり幅（横広がり）。※必要なら係数だけ調整（例: 0.05）
    const qreal perStep = iconW * 0.05;
    const qreal hardMax = iconW * 0.85;
    const qreal totalSpread = qMin(hardMax, perStep * qreal(stepsEff));

    // 最前面ベースを「重ね全体センター=マス中心」に配置
    QRect base(0, 0, iconW, iconH);
    base.moveCenter(QPoint(adjustedRect.center().x() + int(totalSpread / 2.0),
                           adjustedRect.center().y()));

    // バッジ右端のはみ出しを微修正
    int margin = qMax(2, iconW / 40);
    int overflowRight = base.right() - (adjustedRect.right() - margin);
    if (overflowRight > 0) base.translate(-overflowRight, 0);

    painter->save();
    painter->setClipRect(adjustedRect);
    painter->setRenderHint(QPainter::SmoothPixmapTransform, true);
    painter->setRenderHint(QPainter::Antialiasing, true);

    QPixmap pm = icon.pixmap(QSize(iconW, iconH), QIcon::Normal, QIcon::On);
    const bool iconOk = !pm.isNull();

    // 奥(左)→手前(右)。表示は最大 visible 枚に限定（4枚目以降は描かない）
    for (int i = 0; i < visible; ++i) {
        const qreal t = (stepsEff > 0) ? (qreal(i) / qreal(stepsEff)) : 1.0; // 0..1
        const qreal shiftX = -totalSpread * (1.0 - t);                        // -spread..0
        const QRect r = base.translated(int(shiftX), 0);

        if (iconOk) painter->drawPixmap(r, pm);
        else {
            QFont f = painter->font();
            f.setPixelSize(qMax(8, int(iconH * 0.7)));
            painter->setFont(f);
            painter->drawText(r, Qt::AlignCenter, QString(value));
        }
    }

    // 右下バッジ（総数表示）はそのまま
    if (count >= 2) {
        const QRect topRect = base;
        QFont f = painter->font();
        int px = qBound(9, int(iconH * 0.34), 48);
        f.setPixelSize(px);
        f.setBold(true);
        painter->setFont(f);

        const QString text = QString::number(count);
        QFontMetrics fm(f);
        int padX = qMax(3, iconW / 18);
        int padY = qMax(2, iconH / 22);
        QSize tsz = fm.size(Qt::TextSingleLine, text);

        const int maxBadgeW = qMax(8, iconW - 2 * margin);
        const int maxBadgeH = qMax(8, iconH - 2 * margin);
        const int needW = tsz.width() + padX * 2;
        const int needH = tsz.height() + padY * 2;
        const qreal scale = qMin<qreal>(1.0, qMin(qreal(maxBadgeW)/needW, qreal(maxBadgeH)/needH));
        if (scale < 1.0) {
            px   = qMax(8, int(px   * scale));
            padX = qMax(2, int(padX * scale));
            padY = qMax(2, int(padY * scale));
            f.setPixelSize(px);
            painter->setFont(f);
            fm  = QFontMetrics(f);
            tsz = fm.size(Qt::TextSingleLine, text);
        }

        QRect badge(0, 0, qMin(maxBadgeW, tsz.width() + padX * 2),
                    qMin(maxBadgeH, tsz.height() + padY * 2));
        badge.moveBottomRight(QPoint(topRect.right() - margin, topRect.bottom() - margin));

        const qreal radius = qMin(badge.width(), badge.height()) * 0.35;
        QPen outline(QColor(255, 255, 255, 220), qMax(1, iconW / 60));
        painter->setPen(Qt::NoPen);
        painter->setBrush(QColor(0, 0, 0, 170));
        painter->drawRoundedRect(badge, radius, radius);

        painter->setPen(outline);
        painter->setBrush(Qt::NoBrush);
        painter->drawRoundedRect(badge, radius, radius);

        painter->setPen(Qt::white);
        painter->drawText(badge, Qt::AlignCenter, text);
    }

    painter->restore();
}

// 先手（黒）側の名前ラベル（ElideLabel）を返すゲッター。
// 役割：テキスト設定・ツールチップ・スクロール挙動（スライド）等の制御に利用。
// 備考：本ビュー（this）を親にもつ子ウィジェットへの生ポインタを返す（所有権は移動しない）。
ElideLabel* ShogiView::blackNameLabel() const { return m_blackNameLabel; }

// 先手（黒）側の時計ラベル（QLabel）を返すゲッター。
// 役割：残り時間表示・フォント/スタイル調整・配置制御に利用。
// 備考：所有権は本ビュー側。呼び出し側で delete 等は不要。
QLabel* ShogiView::blackClockLabel() const { return m_blackClockLabel; }

// 後手（白）側の名前ラベル（ElideLabel）を返すゲッター。
// 役割：長い名前の省略表示（エリプシス）、ホバー時スライド、手動パン等の制御に利用。
ElideLabel* ShogiView::whiteNameLabel() const { return m_whiteNameLabel; }

// 後手（白）側の時計ラベル（QLabel）を返すゲッター。
// 役割：残り時間の描画・スタイル変更・レイアウト調整に利用。
// 注意：いずれのゲッターもヌルを返さない想定（コンストラクタで生成済み）。
QLabel* ShogiView::whiteClockLabel() const { return m_whiteClockLabel; }

// 先手（黒）側の駒台セルに対応する「駒アイコン」を描画する。
// 方針：この関数自身は QPainter の永続状態（ペン/ブラシ/変換/クリップ等）を変更しない。
// 手順：
//  1) (file, rank) に対応する基準マス矩形を取得（反転状態を考慮）
//  2) 基準マスから「左側の駒台」方向へ水平シフトして、駒台セルの描画矩形を算出
//  3) rank を先手用の駒種にマッピング（rankToBlackShogiPiece）
//  4) 枚数/ドラッグ一時枚数を考慮する描画ヘルパ（drawStandPieceIcon）に委譲
void ShogiView::drawBlackStandPiece(QPainter* painter, const int file, const int rank) const
{
    // (1) 盤座標 → 基準マス矩形
    const QRect fieldRect = calculateSquareRectangleBasedOnBoardState(file, rank);

    // (2) 先手は「左側の駒台」へ寄せる想定。m_param1 は水平シフト量（px）。
    QRect adjustedRect = makeStandCellRect(
        m_flipMode,               // 反転有無
        m_param1,                 // 先手側の寄せ量
        m_offsetX, m_offsetY,     // 盤全体の原点シフト
        fieldRect,
        /*leftSide=*/true         // 左側の駒台へ配置
        );

    // (3) 段番号→先手の駒種（駒文字）へのマッピング
    //     例：歩・香・桂・銀・金・角・飛・玉…などの並びを rank に応じて返す想定。
    QChar value = rankToBlackShogiPiece(file, rank);

    // (4) 駒台セル内へアイコン描画（枚数 0 なら描かない、ドラッグ中は一時枚数を優先）
    //     ※ drawStandPieceIcon は painter の状態を汚さない前提。
    drawStandPieceIcon(painter, adjustedRect, value);
}

// 後手（白）側の駒台セルに対応する「駒アイコン」を描画する。
// 方針：この関数自身は QPainter の永続状態（ペン/ブラシ/変換/クリップ等）を変更しない。
// 手順：
//  1) (file, rank) に対応する基準マス矩形を取得（反転状態を考慮）
//  2) 基準マスから「右側の駒台」方向へ水平シフトして、駒台セルの描画矩形を算出
//  3) rank を後手用の駒種にマッピング（rankToWhiteShogiPiece）
//  4) 枚数/ドラッグ一時枚数を考慮する描画ヘルパ（drawStandPieceIcon）に委譲
void ShogiView::drawWhiteStandPiece(QPainter* painter, const int file, const int rank) const
{
    // (1) 盤座標 → 基準マス矩形（反転モード m_flipMode を内部で考慮）
    const QRect fieldRect = calculateSquareRectangleBasedOnBoardState(file, rank);

    // (2) 後手は「右側の駒台」へ寄せる想定。m_param2 は後手用の水平シフト量（px）。
    QRect adjustedRect = makeStandCellRect(
        m_flipMode,               // 反転有無
        m_param2,                 // 後手側の寄せ量
        m_offsetX, m_offsetY,     // 盤全体の原点シフト
        fieldRect,
        /*leftSide=*/false        // 右側の駒台へ配置
        );

    // (3) 段番号 → 後手の駒種（駒文字）へのマッピング
    QChar value = rankToWhiteShogiPiece(file, rank);

    // (4) 駒台セル内へアイコン描画（枚数0なら描かない／ドラッグ中は一時枚数を優先）
    //     ※ drawStandPieceIcon は painter の状態を汚さない前提。
    drawStandPieceIcon(painter, adjustedRect, value);
}

// 盤上および駒台（疑似座標 file=10/11）のハイライト矩形を塗る。
// 方針：盤上/駒台とも「駒アイコンと同じ算出経路」で矩形を作る。
//   1) 盤上 … calculateSquareRectangleBasedOnBoardState() の結果に m_offsetX/Y を足す
//   2) 駒台 … 疑似座標(file=10/11, rank=1..9) → 基準盤マス(file=1/2, rank=6..9 or 4..1)へ変換
//              → calculateSquareRectangleBasedOnBoardState() → makeStandCellRect() で駒台側へ水平シフト
// これにより、反転(m_flipMode)や左右の寄せ(m_param1/m_param2)、全体オフセット(m_offsetX/Y)が
// 駒描画と完全一致し、クリック位置とハイライト位置のズレが解消される。
void ShogiView::drawHighlights(QPainter* painter)
{
    if (!m_board) return;

    // 駒台の疑似座標 (10/11, 1..9) → 駒台描画で使う基準盤マス(file=1/2, rank=...) へ変換
    // 返り値：{ok, baseFile(=1/2), baseRank(黒:6..9 / 白:4..1), useBlackStand(true=先手駒台)}
    const auto standPseudoToBase = [&](int pseudoFile, int pseudoRank)
        -> std::tuple<bool,int,int,bool> {
        // 先手（黒）駒台：file==10
        if (pseudoFile == 10) {
            // 左列(=file=2)：R,G,N,P → rank 7,5,3,1 → 盤rank 6,7,8,9
            if (pseudoRank == 7 || pseudoRank == 5 || pseudoRank == 3 || pseudoRank == 1) {
                const int baseFile = 2;
                const int baseRank = 6 + ((7 - pseudoRank) / 2); // 7→6, 5→7, 3→8, 1→9
                return {true, baseFile, baseRank, true};
            }
            // 右列(=file=1)：K,B,S,L → rank 8,6,4,2 → 盤rank 6,7,8,9
            if (pseudoRank == 8 || pseudoRank == 6 || pseudoRank == 4 || pseudoRank == 2) {
                const int baseFile = 1;
                const int baseRank = 6 + ((8 - pseudoRank) / 2); // 8→6, 6→7, 4→8, 2→9
                return {true, baseFile, baseRank, true};
            }
            return {false, 0, 0, true};
        }

        // 後手（白）駒台：file==11
        if (pseudoFile == 11) {
            // 左列(=file=1)：r,g,n,p → rank 3,5,7,9 → 盤rank 4,3,2,1
            if (pseudoRank == 3 || pseudoRank == 5 || pseudoRank == 7 || pseudoRank == 9) {
                const int baseFile = 1;
                const int baseRank = (11 - pseudoRank) / 2;      // 3→4, 5→3, 7→2, 9→1
                return {true, baseFile, baseRank, false};
            }
            // 右列(=file=2)：k,b,s,l → rank 2,4,6,8 → 盤rank 4,3,2,1
            if (pseudoRank == 2 || pseudoRank == 4 || pseudoRank == 6 || pseudoRank == 8) {
                const int baseFile = 2;
                const int baseRank = (10 - pseudoRank) / 2;      // 2→4, 4→3, 6→2, 8→1
                return {true, baseFile, baseRank, false};
            }
            return {false, 0, 0, false};
        }

        // 盤上（疑似ではない）
        return {false, 0, 0, false};
    };

    // 盤/駒台共通：ハイライト矩形を算出
    const auto makeHighlightRect = [&](const FieldHighlight* fhl) -> QRect {
        const int f = fhl->file();
        const int r = fhl->rank();

        // 駒台の疑似座標（file=10/11）
        if (f == 10 || f == 11) {
            auto [ok, baseFile, baseRank, isBlackStand] = standPseudoToBase(f, r);
            if (!ok) return QRect(); // 変換不可はスキップ

            // 基準盤マス矩形 → 駒台側へ水平シフト
            const QRect base = calculateSquareRectangleBasedOnBoardState(baseFile, baseRank);
            const int   param = isBlackStand ? m_param1 : m_param2;
            const bool  leftSide = isBlackStand; // 先手駒台=左側, 後手駒台=右側
            const QRect adjusted = makeStandCellRect(m_flipMode, param, m_offsetX, m_offsetY,
                                                     base, leftSide);
            return adjusted;
        }

        // 通常の盤マス（file=1..9, rank=1..9）
        const QRect base = calculateSquareRectangleBasedOnBoardState(f, r);
        return QRect(base.left() + m_offsetX,
                     base.top()  + m_offsetY,
                     base.width(), base.height());
    };

    // 描画
    for (int i = 0; i < highlightCount(); ++i) {
        Highlight* hl = highlight(i);
        if (!hl || hl->type() != FieldHighlight::Type) continue;

        const auto* fhl = static_cast<FieldHighlight*>(hl);
        const QRect rect = makeHighlightRect(fhl);
        if (!rect.isNull()) {
            painter->fillRect(rect, fhl->color());
        }
    }
}

// クリック位置（ウィジェット座標）から、盤上のマス座標（file=x, rank=y）を求めるエントリポイント。
// 役割：
//  - 盤の反転状態（m_flipMode）に応じて、専用の変換関数へ委譲して座標を算出する。
//  - 戻り値は QPoint(file, rank)。盤外や無効の場合は実装側の規約に従い QPoint() などを返す想定。
// 注意：オフセット（m_offsetX/m_offsetY）やマスサイズ（m_squareSize）の考慮は
//       getClickedSquareIn*State() 側で行う。
QPoint ShogiView::getClickedSquare(const QPoint &clickPosition) const
{
    // 【反転時】上下左右が入れ替わるため、反転用の座標変換を使用
    if (m_flipMode) {
        return getClickedSquareInFlippedState(clickPosition);
    } else {
        // 【通常時】デフォルトの座標変換を使用
        return getClickedSquareInDefaultState(clickPosition);
    }
}

QPoint ShogiView::getClickedSquareInDefaultState(const QPoint& pos) const
{
    // 成駒を元の駒種に正規化（P/L/N/S/B/R/K/G の小文字を返す）
    auto baseFrom = [](QChar ch) -> QChar {
        const QChar l = ch.toLower();
        if      (l == 'q') return QChar('p'); // と金 -> 歩
        else if (l == 'm') return QChar('l'); // 成香 -> 香
        else if (l == 'o') return QChar('n'); // 成桂 -> 桂
        else if (l == 't') return QChar('s'); // 成銀 -> 銀
        else if (l == 'c') return QChar('b'); // 馬   -> 角
        else if (l == 'u') return QChar('r'); // 龍   -> 飛
        return l; // 金/玉/未成はそのまま
    };

    if (!m_board) return QPoint();

    const QSize fs = fieldSize().isValid() ? fieldSize()
                                           : QSize(m_squareSize, m_squareSize);
    const int w = fs.width();
    const int h = fs.height();

    // 盤の外形
    const QRect boardRect(m_offsetX, m_offsetY,
                          w * m_board->files(), h * m_board->ranks());

    // 1) 盤内クリック（デフォルト向き）
    if (boardRect.contains(pos)) {
        const int xIn = pos.x() - boardRect.left();
        const int yIn = pos.y() - boardRect.top();
        const int colFromLeft = xIn / w;             // 0..8
        const int rowFromTop  = yIn / h;             // 0..8
        const int file = m_board->files() - colFromLeft; // 9..1
        const int rank = rowFromTop + 1;                 // 1..9
        return QPoint(file, rank);
    }

    // 2) 駒台の外接矩形（正しい左右・上下に修正）
    //   先手（file=10）：右側 m_param2 基準、下帯 rank 5..8
    const QRect senteStandRect(m_offsetX + static_cast<int>(m_param2),
                               m_offsetY + 5 * h, 2 * w, 4 * h);
    //   後手（file=11）：左側 m_param1 基準、上帯 rank 0..3
    const QRect goteStandRect (m_offsetX - static_cast<int>(m_param1),
                              m_offsetY + 0 * h, 2 * w, 4 * h);

    // 3) 局面編集モード中のドラッグドロップ先（駒種でセル固定）
    if (m_positionEditMode && m_dragging) {
        if (senteStandRect.contains(pos)) {
            const QChar p = m_dragPiece;
            if (p != QChar(' ')) {
                const QChar up = baseFrom(p).toUpper(); // 成→未成→大文字
                if      (up == 'P') return QPoint(10, 1);
                else if (up == 'L') return QPoint(10, 2);
                else if (up == 'N') return QPoint(10, 3);
                else if (up == 'S') return QPoint(10, 4);
                else if (up == 'G') return QPoint(10, 5);
                else if (up == 'B') return QPoint(10, 6);
                else if (up == 'R') return QPoint(10, 7);
                else if (up == 'K') return QPoint(10, 8);
            }
            return QPoint();
        }
        if (goteStandRect.contains(pos)) {
            const QChar p = m_dragPiece;
            if (p != QChar(' ')) {
                const QChar low = baseFrom(p); // 成→未成（小文字）
                if      (low == 'p') return QPoint(11, 9);
                else if (low == 'l') return QPoint(11, 8);
                else if (low == 'n') return QPoint(11, 7);
                else if (low == 's') return QPoint(11, 6);
                else if (low == 'g') return QPoint(11, 5);
                else if (low == 'b') return QPoint(11, 4);
                else if (low == 'r') return QPoint(11, 3);
                else if (low == 'k') return QPoint(11, 2);
            }
            return QPoint();
        }
        // 盤外かつ駒台外
        return QPoint();
    }

    // 4) （1stクリック）従来の駒台セル判定はそのまま
    {
        // 先手（右側＝m_param2 側） rank 5..8
        float tempFile = (pos.x() - m_param2 - m_offsetX) / float(w);
        float tempRank = (pos.y() - m_offsetY) / float(h);
        int   file     = static_cast<int>(tempFile);
        int   rank     = static_cast<int>(tempRank);

        if (file == 0) {
            if (rank == 8) return QPoint(10, 1); // 歩 P
            if (rank == 7) return QPoint(10, 3); // 桂 N
            if (rank == 6) return QPoint(10, 5); // 金 G
            if (rank == 5) return QPoint(10, 7); // 飛 R
        } else if (file == 1) {
            if (rank == 8) return QPoint(10, 2); // 香 L
            if (rank == 7) return QPoint(10, 4); // 銀 S
            if (rank == 6) return QPoint(10, 6); // 角 B
            if (rank == 5) return QPoint(10, 8); // 玉 K
        }
    }
    {
        // 後手（左側＝m_param1 側） rank 0..3
        float tempFile = (pos.x() + m_param1 - m_offsetX) / float(w);
        float tempRank = (pos.y() - m_offsetY) / float(h);
        int   file     = static_cast<int>(tempFile);
        int   rank     = static_cast<int>(tempRank);

        if (file == 1) {
            if (rank == 0) return QPoint(11, 9); // 歩 p
            if (rank == 1) return QPoint(11, 7); // 桂 n
            if (rank == 2) return QPoint(11, 5); // 金 g
            if (rank == 3) return QPoint(11, 3); // 飛 r
        } else if (file == 0) {
            if (rank == 0) return QPoint(11, 8); // 香 l
            if (rank == 1) return QPoint(11, 6); // 銀 s
            if (rank == 2) return QPoint(11, 4); // 角 b
            if (rank == 3) return QPoint(11, 2); // 玉 k
        }
    }

    return QPoint();
}

QPoint ShogiView::getClickedSquareInFlippedState(const QPoint& pos) const
{
    auto baseFrom = [](QChar ch) -> QChar {
        const QChar l = ch.toLower();
        if      (l == 'q') return QChar('p');
        else if (l == 'm') return QChar('l');
        else if (l == 'o') return QChar('n');
        else if (l == 't') return QChar('s');
        else if (l == 'c') return QChar('b');
        else if (l == 'u') return QChar('r');
        return l;
    };

    if (!m_board) return QPoint();

    const QSize fs = fieldSize().isValid() ? fieldSize()
                                           : QSize(m_squareSize, m_squareSize);
    const int w = fs.width();
    const int h = fs.height();

    const QRect boardRect(m_offsetX, m_offsetY,
                          w * m_board->files(), h * m_board->ranks());

    // 1) 盤内クリック（反転：file 左→右、rank 上→下で逆）
    if (boardRect.contains(pos)) {
        const int xIn = pos.x() - boardRect.left();
        const int yIn = pos.y() - boardRect.top();
        const int colFromLeft = xIn / w;
        const int rowFromTop  = yIn / h;

        const int file = colFromLeft + 1;               // 1..9
        const int rank = m_board->ranks() - rowFromTop; // 9..1
        return QPoint(file, rank);
    }

    // 2) 駒台の外接矩形（デフォルト向きと同じ帯で判定）
    const QRect senteStandRect(m_offsetX + static_cast<int>(m_param2),
                               m_offsetY + 5 * h, 2 * w, 4 * h); // 先手（右・下帯）
    const QRect goteStandRect (m_offsetX - static_cast<int>(m_param1),
                              m_offsetY + 0 * h, 2 * w, 4 * h); // 後手（左・上帯）

    // 3) ドラッグ中の駒台ドロップ
    if (m_positionEditMode && m_dragging) {
        if (senteStandRect.contains(pos)) {
            const QChar p = m_dragPiece;
            if (p != QChar(' ')) {
                const QChar up = baseFrom(p).toUpper();
                if      (up == 'P') return QPoint(10, 1);
                else if (up == 'L') return QPoint(10, 2);
                else if (up == 'N') return QPoint(10, 3);
                else if (up == 'S') return QPoint(10, 4);
                else if (up == 'G') return QPoint(10, 5);
                else if (up == 'B') return QPoint(10, 6);
                else if (up == 'R') return QPoint(10, 7);
                else if (up == 'K') return QPoint(10, 8);
            }
            return QPoint();
        }
        if (goteStandRect.contains(pos)) {
            const QChar p = m_dragPiece;
            if (p != QChar(' ')) {
                const QChar low = baseFrom(p);
                if      (low == 'p') return QPoint(11, 9);
                else if (low == 'l') return QPoint(11, 8);
                else if (low == 'n') return QPoint(11, 7);
                else if (low == 's') return QPoint(11, 6);
                else if (low == 'g') return QPoint(11, 5);
                else if (low == 'b') return QPoint(11, 4);
                else if (low == 'r') return QPoint(11, 3);
                else if (low == 'k') return QPoint(11, 2);
            }
            return QPoint();
        }
        return QPoint();
    }

    // 4) （1stクリック）従来の駒台セル判定はそのまま
    {
        // ここは元の実装方針に合わせています（必要なら後で一体化可能）
        float tempFile = (pos.x() - m_param2 - m_offsetX) / float(w);
        float tempRank = (pos.y() - m_offsetY) / float(h);
        int   file     = static_cast<int>(tempFile);
        int   rank     = static_cast<int>(tempRank);

        if (file == 0) {
            if (rank == 8) return QPoint(10, 1);
            if (rank == 7) return QPoint(10, 3);
            if (rank == 6) return QPoint(10, 5);
            if (rank == 5) return QPoint(10, 7);
        } else if (file == 1) {
            if (rank == 8) return QPoint(10, 2);
            if (rank == 7) return QPoint(10, 4);
            if (rank == 6) return QPoint(10, 6);
            if (rank == 5) return QPoint(10, 8);
        }
    }
    {
        float tempFile = (pos.x() + m_param1 - m_offsetX) / float(w);
        float tempRank = (pos.y() - m_offsetY) / float(h);
        int   file     = static_cast<int>(tempFile);
        int   rank     = static_cast<int>(tempRank);

        if (file == 1) {
            if (rank == 0) return QPoint(11, 9);
            if (rank == 1) return QPoint(11, 7);
            if (rank == 2) return QPoint(11, 5);
            if (rank == 3) return QPoint(11, 3);
        } else if (file == 0) {
            if (rank == 0) return QPoint(11, 8);
            if (rank == 1) return QPoint(11, 6);
            if (rank == 2) return QPoint(11, 4);
            if (rank == 3) return QPoint(11, 2);
        }
    }

    return QPoint();
}

// マウスボタン解放時のイベント処理。
// 役割：
//  - 右ドラッグ中に右ボタンを離した場合は「ドラッグキャンセル」として処理し、rightClicked を通知
//  - 左ボタン解放：盤/駒台上のクリック位置を算出して clicked を通知（無効/エラー時は無視）
//  - 右ボタン解放（非ドラッグ時）：同様に rightClicked を通知（無効なら無視）
// ポイント：
//  - getClickedSquare() は盤上(1..9,1..9)に加え、駒台の疑似座標 (file=10/11) も返し得る
//  - endDrag() はドラッグ中の一時状態（カーソル追従や一時カウント等）を確実に解除するため、シグナル送出前に呼ぶ
void ShogiView::mouseReleaseEvent(QMouseEvent *event)
{
    // 【右ボタン解放 × ドラッグ中】→ ドラッグのキャンセル扱い
    if (m_dragging && event->button() == Qt::RightButton) {
        endDrag();                                      // 一時状態を解除（描画も含めて正しい静止状態へ）
        QPoint pt = getClickedSquare(event->pos());     // 右クリック位置（盤 or 駒台）
        emit rightClicked(pt);                          // キャンセル/コンテキスト用途として通知
        return;                                         // 以降の分岐に入らない
    }

    // 【左ボタン解放】
    if (event->button() == Qt::LeftButton) {
        QPoint pt = getClickedSquare(event->pos());     // クリック位置を盤/駒台のマス座標に変換

        //begin
        qDebug() << "----mouseReleaseEvent: pos=" << event->pos() << " -> square=" << pt;
        qDebug() << "pt.x()=" << pt.x() << ", pt.y()=" << pt.y();
        //end

        if (pt.isNull()) return;                        // 盤外等は無視
        if (m_errorOccurred) return;                    // 異常時はシグナル送出を抑止
        emit clicked(pt);                               // 左クリック通知（選択/移動確定など呼び出し側で処理）
    }
    // 【右ボタン解放（非ドラッグ時）】
    else if (event->button() == Qt::RightButton) {
        QPoint pt = getClickedSquare(event->pos());     // 右クリック位置（盤/駒台）
        if (pt.isNull()) return;                        // 盤外等は無視
        emit rightClicked(pt);                          // 右クリック通知（ハイライト解除/メニュー等は呼び出し側）
    }
}

// ハイライト（選択マス・指し手候補などの視覚効果）を追加する。
// 役割：コンテナに追加 → 再描画要求（非同期 update()）。
// 注意：ここでは所有権の移動/破棄は行わないため、new で生成した場合の delete 管理は呼び出し側の設計に依存。
//       QObject 継承やスマートポインタ（std::unique_ptr 等）での所有権管理を検討すると安全。
void ShogiView::addHighlight(ShogiView::Highlight* hl)
{
    m_highlights.append(hl); // 末尾に追加（同一要素の重複は許容）
    update();                // 非同期に再描画イベントをポスト（即時 repaint はしない）
}

// 指定のハイライトを 1 件だけ取り除く。
// 役割：removeOne は一致する最初の要素を削除（見つからなければ何もしない）→ 再描画要求。
// 注意：ポインタの remove であり delete は行わない。所有権の取り扱いに注意。
void ShogiView::removeHighlight(ShogiView::Highlight* hl)
{
    m_highlights.removeOne(hl); // 最初に一致した要素を除去
    update();                   // 変更を描画に反映
}

// すべてのハイライトを削除する（コンテナを空にする）。
// 役割：クリア → 再描画要求。
// 注意：clear() はポインタを捨てるだけで delete はしない。
//       ハイライトの所有権が本ビュー側にある設計なら、qDeleteAll(m_highlights); m_highlights.clear();
//       として実体破棄を行うことを検討（ダングリングポインタ/リーク対策）。
void ShogiView::removeHighlightAllData()
{
    m_highlights.clear(); // 全要素を除去（ポインタの所有権/破棄は別途の設計に依存）
    update();             // 反映のため再描画を要求
}

// 駒文字 → アイコン（QIcon）を一括で登録する初期化関数。
// 役割：Qt リソース（":/pieces/..."）から各駒の SVG を読み込み、
//       setPiece() で内部マップ（m_pieces）に関連付ける。
// 規約：大文字＝先手（Sente）、小文字＝後手（Gote）。
//       昇格駒は以下の対応（慣例的アルファベット）を使用：
//         Q=と金(と)、M=成香、O=成桂、T=成銀、C=馬（角成）、U=龍（飛成）
// 備考：setPiece() は update() を呼ぶが、同一イベントループ内では描画要求は合流されるため
//       パフォーマンス上の影響は通常軽微（必要ならバッチ登録に最適化可）。
void ShogiView::setPieces()
{
    // ── 先手（大文字） ──
    setPiece('P', QIcon(":/pieces/Sente_fu45.svg"));       // 歩
    setPiece('L', QIcon(":/pieces/Sente_kyou45.svg"));     // 香
    setPiece('N', QIcon(":/pieces/Sente_kei45.svg"));      // 桂
    setPiece('S', QIcon(":/pieces/Sente_gin45.svg"));      // 銀
    setPiece('G', QIcon(":/pieces/Sente_kin45.svg"));      // 金
    setPiece('B', QIcon(":/pieces/Sente_kaku45.svg"));     // 角
    setPiece('R', QIcon(":/pieces/Sente_hi45.svg"));       // 飛
    setPiece('K', QIcon(":/pieces/Sente_ou45.svg"));       // 王/玉（先手側）

    // 昇格駒（先手）
    setPiece('Q', QIcon(":/pieces/Sente_to45.svg"));       // と金（歩成）
    setPiece('M', QIcon(":/pieces/Sente_narikyou45.svg")); // 成香
    setPiece('O', QIcon(":/pieces/Sente_narikei45.svg"));  // 成桂
    setPiece('T', QIcon(":/pieces/Sente_narigin45.svg"));  // 成銀
    setPiece('C', QIcon(":/pieces/Sente_uma45.svg"));      // 馬（角成）
    setPiece('U', QIcon(":/pieces/Sente_ryuu45.svg"));     // 龍（飛成）

    // ── 後手（小文字） ──
    setPiece('p', QIcon(":/pieces/Gote_fu45.svg"));        // 歩
    setPiece('l', QIcon(":/pieces/Gote_kyou45.svg"));      // 香
    setPiece('n', QIcon(":/pieces/Gote_kei45.svg"));       // 桂
    setPiece('s', QIcon(":/pieces/Gote_gin45.svg"));       // 銀
    setPiece('g', QIcon(":/pieces/Gote_kin45.svg"));       // 金
    setPiece('b', QIcon(":/pieces/Gote_kaku45.svg"));      // 角
    setPiece('r', QIcon(":/pieces/Gote_hi45.svg"));        // 飛
    setPiece('k', QIcon(":/pieces/Gote_gyoku45.svg"));     // 玉（後手側）

    // 昇格駒（後手）
    setPiece('q', QIcon(":/pieces/Gote_to45.svg"));        // と金（歩成）
    setPiece('m', QIcon(":/pieces/Gote_narikyou45.svg"));  // 成香
    setPiece('o', QIcon(":/pieces/Gote_narikei45.svg"));   // 成桂
    setPiece('t', QIcon(":/pieces/Gote_narigin45.svg"));   // 成銀
    setPiece('c', QIcon(":/pieces/Gote_uma45.svg"));       // 馬（角成）
    setPiece('u', QIcon(":/pieces/Gote_ryuu45.svg"));      // 龍（飛成）
}

// 反転表示用の「駒文字 → アイコン」マッピングを一括登録する。
// 役割：盤の向きを反転した際に、先手/後手の見た目（面の向き）を入れ替えるため、
//       小文字（後手の駒文字）に先手用の画像を、大文字（先手の駒文字）に後手用の画像を割り当てる。
// 規約：通常は「大文字＝先手」「小文字＝後手」だが、flip 用では見た目の整合を保つために画像を逆転。
//       昇格駒の対応は setPieces() と同じ（Q=と金, M=成香, O=成桂, T=成銀, C=馬, U=龍）。
// 注意：setPiece() は内部で update() を呼ぶため多数回呼び出すと再描画要求が重なるが、
//       イベントループ内で合流されるため通常は問題ない（必要ならバッチ化の最適化を検討）。
void ShogiView::setPiecesFlip()
{
    // ── flip 時：小文字（元・後手）に先手の画像を割り当て ──
    setPiece('p', QIcon(":/pieces/Sente_fu45.svg"));        // 歩
    setPiece('l', QIcon(":/pieces/Sente_kyou45.svg"));      // 香
    setPiece('n', QIcon(":/pieces/Sente_kei45.svg"));       // 桂
    setPiece('s', QIcon(":/pieces/Sente_gin45.svg"));       // 銀
    setPiece('g', QIcon(":/pieces/Sente_kin45.svg"));       // 金
    setPiece('b', QIcon(":/pieces/Sente_kaku45.svg"));      // 角
    setPiece('r', QIcon(":/pieces/Sente_hi45.svg"));        // 飛
    setPiece('k', QIcon(":/pieces/Sente_gyoku45.svg"));     // 玉（先手側の意匠）

    // 昇格駒（flip：小文字→先手画像）
    setPiece('q', QIcon(":/pieces/Sente_to45.svg"));        // と金
    setPiece('m', QIcon(":/pieces/Sente_narikyou45.svg"));  // 成香
    setPiece('o', QIcon(":/pieces/Sente_narikei45.svg"));   // 成桂
    setPiece('t', QIcon(":/pieces/Sente_narigin45.svg"));   // 成銀
    setPiece('c', QIcon(":/pieces/Sente_uma45.svg"));       // 馬（角成）
    setPiece('u', QIcon(":/pieces/Sente_ryuu45.svg"));      // 龍（飛成）

    // ── flip 時：大文字（元・先手）に後手の画像を割り当て ──
    setPiece('P', QIcon(":/pieces/Gote_fu45.svg"));         // 歩
    setPiece('L', QIcon(":/pieces/Gote_kyou45.svg"));       // 香
    setPiece('N', QIcon(":/pieces/Gote_kei45.svg"));        // 桂
    setPiece('S', QIcon(":/pieces/Gote_gin45.svg"));        // 銀
    setPiece('G', QIcon(":/pieces/Gote_kin45.svg"));        // 金
    setPiece('B', QIcon(":/pieces/Gote_kaku45.svg"));       // 角
    setPiece('R', QIcon(":/pieces/Gote_hi45.svg"));         // 飛
    setPiece('K', QIcon(":/pieces/Gote_ou45.svg"));         // 王（後手側の意匠）

    // 昇格駒（flip：大文字→後手画像）
    setPiece('Q', QIcon(":/pieces/Gote_to45.svg"));         // と金
    setPiece('M', QIcon(":/pieces/Gote_narikyou45.svg"));   // 成香
    setPiece('O', QIcon(":/pieces/Gote_narikei45.svg"));    // 成桂
    setPiece('T', QIcon(":/pieces/Gote_narigin45.svg"));    // 成銀
    setPiece('C', QIcon(":/pieces/Gote_uma45.svg"));        // 馬（角成）
    setPiece('U', QIcon(":/pieces/Gote_ryuu45.svg"));       // 龍（飛成）
}

// マウス操作の入力モードを設定するセッター。
// 役割：クリックでの選択/移動（true）か、それ以外の操作方針（false）かを切り替えるためのフラグ。
// 注意：ここでは描画やシグナル送出は行わない。実際の挙動はマウスイベント処理側で参照される。
void ShogiView::setMouseClickMode(bool mouseClickMode)
{
    m_mouseClickMode = mouseClickMode;
}

// 1マスの基準サイズ（px）を返すゲッター。
// 役割：ドラッグ中の駒の描画サイズなど、単一のスカラー値が欲しい場面で使用。
// 備考：レイアウト計算には QSize を返す fieldSize() も存在する。
//       非正方表示等の可能性を考慮する場合は fieldSize() の利用も検討。
int ShogiView::squareSize() const
{
    return m_squareSize;
}

// 盤の表示スケールを 1px 分だけ拡大する。
// 手順：
//  1) m_squareSize をインクリメント（1マスの基準サイズを +1）
//  2) 依存しているレイアウトパラメータを再計算（recalcLayoutParams）
//  3) fieldSize を更新（setFieldSize）→ シグナル発行／updateGeometry／時計ラベル位置再計算（※内部で実施）
//  4) 念のため時計ラベルのジオメトリを再更新（※ setFieldSize 内で既に行っているため重複だが無害）
//  5) 再描画要求（update）
// 注意：極端に大きくし過ぎないように上限クリップを設けると安全（TODO）。
void ShogiView::enlargeBoard()
{
    m_squareSize++;                                    // (1) 1px 拡大
    recalcLayoutParams();                              // (2) レイアウト関連の再計算
    setFieldSize(QSize(m_squareSize, m_squareSize));   // (3) マスサイズ更新（シグナル/再レイアウト含む）

    // (4) 冗長だが安全側の再配置（setFieldSize 内でも呼ばれている想定）
    updateBlackClockLabelGeometry();
    updateWhiteClockLabelGeometry();

    update();                                          // (5) 再描画
}

// 盤の表示スケールを 1px 分だけ縮小する。
// 手順は enlargeBoard と同じだが、サイズをデクリメントする点のみ異なる。
// 注意：0 以下や小さ過ぎる値を避けるため、下限クリップ（例：最小 8〜16px 程度）を入れると安全（TODO）。
void ShogiView::reduceBoard()
{
    m_squareSize--;                                    // 1px 縮小
    recalcLayoutParams();                              // レイアウト関連の再計算
    setFieldSize(QSize(m_squareSize, m_squareSize));   // マスサイズ更新（シグナル/再レイアウト含む）

    // 冗長だが安全側の再配置
    updateBlackClockLabelGeometry();
    updateWhiteClockLabelGeometry();

    update();                                          // 再描画
}

// エラーフラグのセッター。
// 役割：内部状態 m_errorOccurred を更新し、描画処理やイベント処理側での早期リターン判定に用いる。
// 備考：この関数自体は再描画要求やシグナル送出を行わない。
//       必要に応じて、エラー遷移時にログ出力やユーザー通知を別途行う設計も検討。
void ShogiView::setErrorOccurred(bool newErrorOccurred)
{
    m_errorOccurred = newErrorOccurred;
}

void ShogiView::setPositionEditMode(bool positionEditMode)
{
    // 変更なしなら何もしない
    if (m_positionEditMode == positionEditMode) return;

    // 手番ラベルの可視状態を退避（再レイアウト後に復元する）
    QLabel* tlBlack = this->findChild<QLabel*>(QStringLiteral("turnLabelBlack"));
    QLabel* tlWhite = this->findChild<QLabel*>(QStringLiteral("turnLabelWhite"));
    const bool blackTurnShown = (tlBlack && tlBlack->isVisible());
    const bool whiteTurnShown = (tlWhite && tlWhite->isVisible());

    // 内部状態更新
    m_positionEditMode = positionEditMode;

    // ── ここが肝 ──────────────────────────────────────────────
    // 名前・時計・手番の三者を同一ロジックで一括再配置する
    // （updateBlack/White... だけだと手番ラベルとズレる）
    relayoutTurnLabels_();
    // ────────────────────────────────────────────────────────

    // 手番ラベルの可視状態を復元して前面へ
    if (tlBlack) { tlBlack->setVisible(blackTurnShown); tlBlack->raise(); }
    if (tlWhite) { tlWhite->setVisible(whiteTurnShown); tlWhite->raise(); }

    // 再描画
    update();
}

// 駒台（スタンド）と盤の横方向ギャップを「何マスぶん（列数）」で設定するセッター。
// 役割：
//  - 入力 cols を [0.0, 2.0] の範囲にクランプ（qBound）して m_standGapCols に反映
//  - ギャップ変更に伴い、レイアウト関連パラメータを再計算（駒台の位置や各種オフセットが変化し得る）
//  - sizeHint などの変更を親レイアウトに通知（updateGeometry）
//  - 時計ラベルのジオメトリを再配置（ギャップに合わせた見栄えを保つ）
//  - 最後に再描画要求（update）
// 備考：範囲上限/下限はUIデザイン上の安全域。必要なら定数化して同一ポリシーで運用すると良い。
void ShogiView::setStandGapCols(double cols)
{
    // 【入力値のクランプ】負値や大きすぎる値を抑止（0.0〜2.0 の間に丸める）
    m_standGapCols = qBound(0.0, cols, 2.0);

    // 【レイアウト再計算】駒台オフセット等、内部の配置パラメータを最新化
    recalcLayoutParams();

    // 【レイアウト通知】sizeHint の変化を親レイアウトに伝える
    updateGeometry();

    // 【関連UIの再配置】時計ラベル等の位置/サイズを反映
    updateBlackClockLabelGeometry();
    updateWhiteClockLabelGeometry();

    // 【再描画要求】変更内容を画面に反映
    update();
}

void ShogiView::setFlipMode(bool newFlipMode)
{
    // 変化なしなら何もしない（無駄な再配置を避ける）
    if (m_flipMode == newFlipMode) return;

    // いま表示中の手番ラベルを記録しておく（反転後に可視状態を維持するため）
    QLabel* tlBlack = this->findChild<QLabel*>(QStringLiteral("turnLabelBlack"));
    QLabel* tlWhite = this->findChild<QLabel*>(QStringLiteral("turnLabelWhite"));
    const bool blackShown = (tlBlack && tlBlack->isVisible());
    const bool whiteShown = (tlWhite && tlWhite->isVisible());

    // 反転状態を更新
    m_flipMode = newFlipMode;

    // ▲/▼/▽/△ の付け替えなど、名前表示を反転状態に同期
    refreshNameLabels();

    // 先手/後手の時計・名前ラベルのジオメトリを反転後の座標系で確定
    updateBlackClockLabelGeometry();
    updateWhiteClockLabelGeometry();

    // ★ 手番ラベルも「反転後の名前/時計の最終ジオメトリ」に追従させる
    //    （フォント/スタイルのコピーと角丸無効化も relayout 内で同期されます）
    relayoutTurnLabels_();

    // 反転前の可視状態を復元（「次の手番」が見えなくなる問題を防ぐ）
    if (tlBlack) { tlBlack->setVisible(blackShown); tlBlack->raise(); }
    if (tlWhite) { tlWhite->setVisible(whiteShown); tlWhite->raise(); }

    // 再描画
    update();
}

// 反転モードの現在値を取得するゲッター。
// true=反転表示、false=通常表示。
bool ShogiView::getFlipMode() const
{
    return m_flipMode;
}

// 盤面と駒台（スタンド）を初期状態に戻すユーティリティ。
// 役割：
//  1) 既存のハイライト（選択・候補表示など）を全消去
//  2) 盤オブジェクトにゲーム初期化を指示（ShogiBoard::resetGameBoard）
//     ※ 駒配置や駒台の枚数リセット／均し（equalize）が必要なら、その具体処理は ShogiBoard 側の実装に委譲
//  3) 再描画要求（update）で UI を最新状態に反映
// 前提：board() が有効（nullptr でない）であること。
// 注意：必要に応じてエラーハンドリング（board() の空チェック）を追加してもよい。
void ShogiView::resetAndEqualizePiecesOnStands()
{
    removeHighlightAllData();     // (1) ハイライトを全消去

    board()->resetGameBoard();    // (2) 盤と駒台を初期化（具体的挙動は ShogiBoard 側の責務）

    update();                     // (3) 画面を再描画
}

// 平手初期局面（先手後手の持駒なし）に初期化する。
// 役割：
//  1) 既存ハイライトを全消去
//  2) SFEN 文字列（盤面/手番/持駒/手数）を ShogiBoard に適用
//  3) 駒台（持駒）を初期化（平手＝空）
//  4) 再描画要求
// SFEN 例：
//   "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1"
//    └ 盤面9段を'/'区切りで上段から：小文字=後手, 大文字=先手, 数字=空マス連続数
//      " b " = 手番（b=先手, w=後手） / " - " = 持駒なし / " 1 " = 手数
void ShogiView::initializeToFlatStartingPosition()
{
    removeHighlightAllData();  // (1)

    QString flatInitialSFENStr =
        "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1";
    board()->setSfen(flatInitialSFENStr);  // (2)

    board()->initStand();  // (3) 平手なので駒台を空に
    update();              // (4)
}

// 詰将棋などの問題用初期局面に初期化する。
// 役割：
//  1) 既存ハイライトを全消去
//  2) 問題用の SFEN を適用（持駒あり）
//  3) 追加で先手の持駒 'K'（※実装依存：ここでは ShogiBoard の仕様に準拠）を1枚増やす
//  4) 再描画要求
// SFEN 例：
//  "5+r1kl/6p2/6Bpn/9/7P1/9/9/9/9 b RSb4g3s3n3l15p 1"
//   └ 盤面：'+'付きは成駒、" b " は先手番、持駒は連記（例：R,S,b,... と枚数）
// 注意：board() が nullptr でない前提。必要なら安全弁の null チェックを追加。
void ShogiView::shogiProblemInitialPosition()
{
    removeHighlightAllData();  // (1)

    QString shogiProblemInitialSFENStr =
        "5+r1kl/6p2/6Bpn/9/7P1/9/9/9/9 b RSb4g3s3n3l15p 1";
    board()->setSfen(shogiProblemInitialSFENStr);  // (2)

    board()->incrementPieceOnStand('K');  // (3) 先手持駒に K を1枚追加（仕様は ShogiBoard に依存）
    update();                              // (4)
}
// 盤面の先後を入れ替える（左右/上下の反転や先後の立場入替を ShogiBoard 側に依頼）。
// 役割：
//  1) 現在のハイライトを一旦すべて消去（反転後の座標と不整合になるのを防ぐ）
//  2) 盤オブジェクトに対して flipSides() を呼び、内部局面を反転
//     ※ 具体的な反転内容（駒配置の反転、持駒の入替、手番の扱い等）は ShogiBoard の実装に委譲
//  3) 再描画要求（update）で UI を最新状態に反映
// 前提：board() が有効（nullptr でない）であること。
void ShogiView::flipBoardSides()
{
    removeHighlightAllData();  // (1) ハイライトをクリア

    board()->flipSides();      // (2) 盤側で先後入替・反転処理を実施

    update();                  // (3) 画面再描画
}

QChar ShogiView::rankToBlackShogiPiece(const int file, const int rank) const
{
    // 右列(file=1): K, B, S, L
    if (file == 1) {
        switch (rank) {
        case 6: return 'K';
        case 7: return 'B';
        case 8: return 'S';
        case 9: return 'L';
        default: return ' '; // 想定外の段は空
        }
    }
    // 左列(file=2): R, G, N, P
    else if (file == 2) {
        switch (rank) {
        case 6: return 'R';
        case 7: return 'G';
        case 8: return 'N';
        case 9: return 'P';
        default: return ' '; // 想定外の段は空
        }
    }
    else {
        return ' '; // file が 1/2 以外なら空
    }
}

QChar ShogiView::rankToWhiteShogiPiece(const int file, const int rank) const
{
    // 左列(file=1): r, g, n, p
    if (file == 1) {
        switch (rank) {
        case 4: return 'r';
        case 3: return 'g';
        case 2: return 'n';
        case 1: return 'p';
        default: return ' '; // 想定外の段は空
        }
    }
    // 右列(file=2): k, b, s, l
    else if (file == 2) {
        switch (rank) {
        case 4: return 'k';
        case 3: return 'b';
        case 2: return 's';
        case 1: return 'l';
        default: return ' '; // 想定外の段は空
        }
    }
    else {
        return ' '; // file が 1/2 以外なら空
    }
}

// ドラッグ操作の開始処理。
// 役割：
//  - つまみ上げ元（from）の位置からドラッグ対象の駒文字を取得し、ドラッグ用の一時状態をセット
//  - 駒台（file=10/11）からのドラッグでは在庫（枚数）が 1 以上あることを確認してから開始
//  - 駒台表示更新のため、一時カウント（m_tempPieceStandCounts）を作成し、つまみ上げた分を減算
//  - 現在のマウス位置（ウィジェット座標）を記録して、paintEvent内の drawDraggingPiece で追従描画
void ShogiView::startDrag(const QPoint &from)
{
    // 【駒台からのドラッグ可否チェック】
    // file=10/11 は駒台。対象駒の在庫が 0 以下ならドラッグ開始しない。
    if ((from.x() == 10 || from.x() == 11)) {
        QChar piece = board()->getPieceCharacter(from.x(), from.y());
        if (board()->m_pieceStand.value(piece) <= 0) return;
    }

    // 【ドラッグ状態の確立】
    m_dragging  = true;                               // ドラッグ中フラグ
    m_dragFrom  = from;                               // つまみ上げ元（盤/駒台の座標）
    m_dragPiece = m_board->getPieceCharacter(from.x(), from.y()); // 対象駒
    m_dragPos   = mapFromGlobal(QCursor::pos());      // 現在のポインタ位置（ウィジェット座標）

    // 【駒台の一時枚数マップを作成】
    // 画面上はドラッグで 1 枚減った見え方にするため、つまみ上げた分をデクリメント。
    m_tempPieceStandCounts = m_board->m_pieceStand;
    if (from.x() == 10 || from.x() == 11) {
        m_dragFromStand = true;                       // 駒台からのドラッグ
        m_tempPieceStandCounts[m_dragPiece]--;        // 一時的に在庫を減らす
    } else {
        m_dragFromStand = false;                      // 盤上からのドラッグ
    }

    update(); // 再描画（ドラッグ中の駒・駒台枚数の見た目を反映）
}

// ドラッグ操作の終了/キャンセル処理。
// 役割：ドラッグ中フラグを落とし、一時枚数マップを破棄して表示を元に戻す。
// 備考：実際のドロップ適用（駒の移動/配置反映）は、呼び出し側のロジックで行う想定。
void ShogiView::endDrag()
{
    m_dragging = false;                // ドラッグ終了
    m_tempPieceStandCounts.clear();    // 一時的な駒台枚数をクリア（表示を通常状態へ）
    update();                          // 再描画
}

// マウス移動時のイベント処理。
// 役割：
//  - ドラッグ中であれば、現在位置を記録（m_dragPos）して再描画を要求（ドラッグ中の駒を追従表示）
//  - その後、基底クラスの mouseMoveEvent を呼んで他ハンドラ（ツールチップ等）に伝搬
// 注意：setMouseTracking(true) によりボタン未押下でも move が届く設計。
//       頻繁な update() はイベントループで合流されるが、必要なら将来的にスロットリングを検討。
void ShogiView::mouseMoveEvent(QMouseEvent* event)
{
    if (m_dragging) {
        m_dragPos = event->pos();  // 現在のポインタ位置（ウィジェット座標）を更新
        update();                  // 再描画（paintEvent→drawDraggingPiece で追従描画）
    }
    QWidget::mouseMoveEvent(event); // 既定処理・他のイベントフィルタへ伝搬
}

// 局面編集モードの現在状態を返すゲッター。
// 戻り値：true＝編集モード、false＝通常モード。
// 各描画/入力ハンドラはこのフラグを参照して挙動を切り替える。
bool ShogiView::positionEditMode() const
{
    return m_positionEditMode;
}

void ShogiView::resizeEvent(QResizeEvent* e)
{
    // 既定のレイアウト更新など
    QWidget::resizeEvent(e);

    // 既存のジオメトリ更新
    updateBlackClockLabelGeometry();
    updateWhiteClockLabelGeometry();

    // ★ 手番ラベルの再配置（名前/時計の確定ジオメトリに追従）
    relayoutTurnLabels_();
}

// 先手（黒）側の駒台全体を覆う境界矩形（バウンディングボックス）を算出して返す。
// 用途：ヒットテスト、再描画領域の最小化、ドラッグ中の当たり判定など。
// 仕様：
//  - 行数(rows)：編集モード=8 行（rank 2..9）、通常=7 行（rank 3..9）
//  - 基準セル：flip の有無とモードに応じて「左上セル」を (leftCol, topRank) で選ぶ
//  - X/Y：基準セルの左上に盤オフセット(m_offsetX/Y)を加算し、さらに横シフト(m_param1)を適用
//  - 幅/高さ：マス幅×2 列、マス高×rows 行
QRect ShogiView::blackStandBoundingRect() const
{
    if (!m_board) return {};

    // マスサイズ（無効時は m_squareSize で補完）
    const QSize fs = fieldSize().isValid() ? fieldSize()
                                           : QSize(m_squareSize, m_squareSize);

    // 行数はモードで変化
    const int rows     = 4;

    // 左上セル（基準セル）の rank / file を決定
    //  非反転：編集=rank 2, 通常=rank 6 / 反転：rank 9
    const int topRank  = m_flipMode ? 9 : 6;
    // 左列の column：反転=1、通常=2（駒台は2列ぶん想定）
    const int leftCol  = m_flipMode ? 1 : 2;

    // 基準セルの矩形（盤座標→ウィジェット座標は後で加算）
    const QRect cell = calculateSquareRectangleBasedOnBoardState(leftCol, topRank);

    // X は左右方向のシフト量 m_param1 の符号が flip で反転
    const int x = (m_flipMode ? (cell.left() - m_param1 + m_offsetX)
                              : (cell.left() + m_param1 + m_offsetX));
    const int y = cell.top() + m_offsetY;

    // 2 列 × rows 行
    const int w = fs.width() * 2;
    const int h = fs.height() * rows;

    return QRect(x, y, w, h);
}

// 後手（白）側の駒台全体を覆う境界矩形（バウンディングボックス）を算出して返す。
// 仕様・考え方は黒側と同様だが、基準 rank と横シフトに用いるパラメータが異なる（m_param2）。
QRect ShogiView::whiteStandBoundingRect() const
{
    if (!m_board) return {};

    // マスサイズ（無効時は m_squareSize で補完）
    const QSize fs = fieldSize().isValid() ? fieldSize()
                                           : QSize(m_squareSize, m_squareSize);

    // 行数はモードで変化
    const int rows    = 4;

    // 左上セル（基準セル）の rank / file を決定
    const int topRank = m_flipMode ? 4 : 1;
    const int leftCol = m_flipMode ? 1 : 2;

    // 基準セルの矩形
    const QRect cell = calculateSquareRectangleBasedOnBoardState(leftCol, topRank);

    // X は左右方向のシフト量 m_param2（flip で符号反転）
    const int x = (m_flipMode ? (cell.left() + m_param2 + m_offsetX)
                              : (cell.left() - m_param2 + m_offsetX));
    const int y = cell.top() + m_offsetY;

    // 2 列 × rows 行
    const int w = fs.width() * 2;
    const int h = fs.height() * rows;

    return QRect(x, y, w, h);
}

// 先手（黒）側：名前・時計ラベルの位置とサイズを更新する。
// 役割：
//  - 編集モード中はラベルを非表示にして早期 return
//  - 駒台のバウンディング矩形（blackStandBoundingRect）を基準に、
//    「上に置く → 下に置く → 重なっても駒台内に押し込む」の順で最適配置を決定
//  - ラベルのフォントサイズを矩形に合わせて調整（時計は fitLabelFontToRect、名前はスケール係数）
// ポイント：
//  - nameH/clockH はマス高さ fs.height() に比例（最小でも1マス分を確保）
//  - マージンは外側 marginOuter と名前・時計間 marginInner を使用
void ShogiView::updateBlackClockLabelGeometry()
{
    // ラベル未生成なら何もしない
    if (!m_blackClockLabel || !m_blackNameLabel) return;

    // 駒台の基準矩形が無効なら非表示
    const QRect stand = blackStandBoundingRect();
    if (!stand.isValid()) {
        m_blackClockLabel->hide();
        m_blackNameLabel->hide();
        return;
    }

    // マス寸法（無効時はフォールバック）
    const QSize fs = fieldSize().isValid() ? fieldSize()
                                           : QSize(m_squareSize, m_squareSize);

    // 配置用パラメータ
    const int marginOuter = 4;  // 駒台との外側マージン
    const int marginInner = 2;  // 名前と時計の間のマージン
    const int nameH  = qMax(int(fs.height() * 0.8), fs.height()); // 名前はやや小さめだが最低1マス分
    const int clockH = qMax(int(fs.height() * 0.9), fs.height()); // 時計はやや大きめだが最低1マス分

    // 左端は駒台に合わせる。Y は上側 or 下側 or 内側の順で決定。
    const int x = stand.left();
    const int yAbove = stand.top() - (nameH + marginInner + clockH) - marginOuter;  // 駒台の上
    const int yBelow = stand.bottom() + 1 + marginOuter;                            // 駒台の下

    QRect nameRect, clockRect;

    if (yAbove >= 0) {
        // 1) 盤の上端より上にはみ出さないなら上に配置
        nameRect  = QRect(x, yAbove, stand.width(), nameH);
        clockRect = QRect(x, nameRect.bottom() + 1 + marginInner, stand.width(), clockH);
    } else if (yBelow + nameH + marginInner + clockH <= height()) {
        // 2) 下側に十分なスペースがあれば下に配置
        nameRect  = QRect(x, yBelow, stand.width(), nameH);
        clockRect = QRect(x, nameRect.bottom() + 1 + marginInner, stand.width(), clockH);
    } else {
        // 3) どちらも無理なら、駒台の内側に縦に積んで配置し、下端オーバー分だけ上に押し上げる
        nameRect  = QRect(x, stand.top() + marginOuter, stand.width(), nameH);
        clockRect = QRect(x, nameRect.bottom() + 1 + marginInner, stand.width(), clockH);
        int overflow = (clockRect.bottom() + marginOuter) - stand.bottom();
        if (overflow > 0) {
            nameRect.translate(0, -overflow);
            clockRect.translate(0, -overflow);
        }
    }

    // ジオメトリ反映
    m_blackNameLabel->setGeometry(nameRect);
    m_blackClockLabel->setGeometry(clockRect);

    // フォント調整：時計は矩形にフィット、名前はスケール係数で調整
    fitLabelFontToRect(m_blackClockLabel, m_blackClockLabel->text(), clockRect, 2);
    QFont f = m_blackNameLabel->font();
    f.setPointSizeF(qMax(8.0, fs.height() * m_nameFontScale));
    m_blackNameLabel->setFont(f);

    // 前面に出して表示
    m_blackNameLabel->raise();
    m_blackClockLabel->raise();
    m_blackNameLabel->show();
    m_blackClockLabel->show();
}

// 後手（白）側：名前・時計ラベルの位置とサイズを更新する。
// 役割・手順は黒側と同一。基準矩形は whiteStandBoundingRect() を用いる。
// 備考：名前ラベルのフォントベースとして黒側のフォントを流用している（デザイン統一のため）。
void ShogiView::updateWhiteClockLabelGeometry()
{
    // ラベル未生成なら何もしない
    if (!m_whiteClockLabel || !m_whiteNameLabel) return;

    // 駒台の基準矩形が無効なら非表示
    const QRect stand = whiteStandBoundingRect();
    if (!stand.isValid()) {
        m_whiteClockLabel->hide();
        m_whiteNameLabel->hide();
        return;
    }

    // マス寸法（無効時はフォールバック）
    const QSize fs = fieldSize().isValid() ? fieldSize()
                                           : QSize(m_squareSize, m_squareSize);

    // 配置用パラメータ
    const int marginOuter = 4;
    const int marginInner = 2;
    const int nameH  = qMax(int(fs.height() * 0.8), fs.height());
    const int clockH = qMax(int(fs.height() * 0.9), fs.height());

    const int x      = stand.left();
    const int yAbove = stand.top() - (nameH + marginInner + clockH) - marginOuter;
    const int yBelow = stand.bottom() + 1 + marginOuter;

    QRect nameRect, clockRect;

    if (yAbove >= 0) {
        // 上に配置
        nameRect  = QRect(x, yAbove, stand.width(), nameH);
        clockRect = QRect(x, nameRect.bottom() + 1 + marginInner, stand.width(), clockH);
    } else if (yBelow + nameH + marginInner + clockH <= height()) {
        // 下に配置
        nameRect  = QRect(x, yBelow, stand.width(), nameH);
        clockRect = QRect(x, nameRect.bottom() + 1 + marginInner, stand.width(), clockH);
    } else {
        // 駒台内に押し込む（オーバー分だけ上へシフト）
        nameRect  = QRect(x, stand.top() + marginOuter, stand.width(), nameH);
        clockRect = QRect(x, nameRect.bottom() + 1 + marginInner, stand.width(), clockH);
        int overflow = (clockRect.bottom() + marginOuter) - stand.bottom();
        if (overflow > 0) {
            nameRect.translate(0, -overflow);
            clockRect.translate(0, -overflow);
        }
    }

    // ジオメトリ反映
    m_whiteNameLabel->setGeometry(nameRect);
    m_whiteClockLabel->setGeometry(clockRect);

    // フォント調整：時計はフィット、名前はスケール係数
    fitLabelFontToRect(m_whiteClockLabel, m_whiteClockLabel->text(), clockRect, 2);
    QFont f = m_blackNameLabel->font(); // 黒側の設定をベースに統一感を保つ
    f.setPointSizeF(qMax(8.0, fs.height() * m_nameFontScale));
    m_whiteNameLabel->setFont(f);

    // 前面に出して表示
    m_whiteNameLabel->raise();
    m_whiteClockLabel->raise();
    m_whiteNameLabel->show();
    m_whiteClockLabel->show();
}

// ラベルの表示矩形（rect）にテキスト（text）が収まるよう、フォントサイズを自動調整する。
// アルゴリズム：二分探索（lo..hi の範囲で 18 回反復）により、収まる最大ポイントサイズ ≒ lo を求める。
// 手順：
//  1) null チェック後、paddingPx 分だけ内側に縮めた評価用矩形 inner を作成
//  2) lo=6pt, hi=200pt を初期範囲として二分探索
//     - mid を仮サイズにセット → QFontMetrics で text の幅/高さを測定
//     - inner に収まれば lo=mid（さらに大きくできる）、収まらなければ hi=mid（小さくする）
//  3) 最終的に lo を採用して label->setFont()
// 備考：
//  - QFontMetrics::horizontalAdvance は文字列の描画幅をピクセルで返す（タブ/改行は想定外）。
//  - ラベル側の word-wrap や elide が有効な場合は実測と差異が出ることがあるため、必要に応じて調整。
//  - 18 回の反復で十分な精度（約 2^-18 の範囲）を得られる一方でコストも低い。
void ShogiView::fitLabelFontToRect(QLabel* label, const QString& text,
                                   const QRect& rect, int paddingPx)
{
    // (0) ラベルが無ければ何もしない
    if (!label) return;

    // (1) 内側にパディングを設けた評価矩形を作成
    const QRect inner = rect.adjusted(paddingPx, paddingPx, -paddingPx, -paddingPx);

    // (2) フォントサイズの探索範囲 [lo, hi]
    double lo = 6.0;
    double hi = 200.0;

    QFont f = label->font();

    // (3) 二分探索で「収まる最大サイズ」を求める
    for (int i = 0; i < 18; ++i) {
        const double mid = (lo + hi) * 0.5;
        f.setPointSizeF(mid);

        // 現在のフォントでテキスト寸法を取得
        QFontMetrics fm(f);
        const int w = fm.horizontalAdvance(text); // テキスト幅
        const int h = fm.height();                // テキスト高さ（ascent+descent）

        // inner 内に収まっていれば、さらに大きくできる余地がある
        if (w <= inner.width() && h <= inner.height()) {
            lo = mid;
        } else {
            hi = mid;
        }
    }

    // (4) 収まる最大サイズを適用
    f.setPointSizeF(lo);
    label->setFont(f);
}

// 先手（黒）側の時計表示テキストを設定する。
// 役割：
//  - ラベルの存在チェック
//  - テキストをセット
//  - 現在のラベル矩形（geometry）に収まるようフォントサイズを自動調整
void ShogiView::setBlackClockText(const QString& text)
{
    if (!m_blackClockLabel) return;
    m_blackClockLabel->setText(text);
    // ラベルの現在ジオメトリを基準に、内側 2px パディングでフィットさせる
    fitLabelFontToRect(m_blackClockLabel, text, m_blackClockLabel->geometry(), 2);
}

// 後手（白）側の時計表示テキストを設定する。
// 役割は黒側と同様。テキスト反映後に矩形へフォントをフィットさせる。
void ShogiView::setWhiteClockText(const QString& text)
{
    if (!m_whiteClockLabel) return;
    m_whiteClockLabel->setText(text);
    fitLabelFontToRect(m_whiteClockLabel, text, m_whiteClockLabel->geometry(), 2);
}

// 名前ラベル用のフォント倍率（スケール）を設定する。
// 役割：
//  - 入力スケールを [0.2, 1.0] にクランプ（極端な小さ過ぎ／大き過ぎを防止）
//  - 黒側ラベルのジオメトリ再計算をトリガし、フォントサイズ反映まで行う
// メモ：白側も同様に即時反映したい場合は updateWhiteClockLabelGeometry() の呼び出しを追加検討。
void ShogiView::setNameFontScale(double scale)
{
    m_nameFontScale = std::clamp(scale, 0.2, 1.0);
    updateBlackClockLabelGeometry();
}

// 文字列から特定のマーク（▲▼▽△）をすべて除去し、前後の空白をトリムして返す。
// 役割：名前ラベル等に付加される向き・状態表示用の三角記号を取り除いて、
//       純粋な表示名/テキストを得るヘルパ。
// 手順：
//  1) 入力文字列 s を作業用にコピー（t）
//  2) 対象マーク配列（U+25B2▲, U+25BC▼, U+25BD▽, U+25B3△）を順に remove（全出現を削除）
//  3) 最後に trimmed() で前後空白を除去し、返却
QString ShogiView::stripMarks(const QString& s)
{
    QString t = s;

    // 除去対象のマーク（黒/白の上下三角）
    static const QChar marks[] = {
        QChar(0x25B2), // ▲ BLACK UP-POINTING TRIANGLE
        QChar(0x25BC), // ▼ BLACK DOWN-POINTING TRIANGLE
        QChar(0x25BD), // ▽ WHITE DOWN-POINTING TRIANGLE
        QChar(0x25B3)  // △ WHITE UP-POINTING TRIANGLE
    };

    // すべての該当記号を削除
    for (QChar m : marks)
        t.remove(m);

    // 仕上げに前後の空白をトリム
    return t.trimmed();
}

// 先手（黒）側のプレイヤー名を設定する。
// 役割：
//  - 入力名から▲▼▽△などの装飾マークを除去（stripMarks）して基底文字列 m_blackNameBase に保持
//  - 表示用ラベル（向き/手番/反転などに依存）を refreshNameLabels() で更新
void ShogiView::setBlackPlayerName(const QString& name)
{
    m_blackNameBase = stripMarks(name);  // 装飾を除いた素の名前を保存
    refreshNameLabels();                 // ラベル表示を更新（向き/手番表示などは内部で決定）
}

// 後手（白）側のプレイヤー名を設定する。
// 役割は黒側と同様：装飾マークを除去して m_whiteNameBase に保存し、表示を更新。
void ShogiView::setWhitePlayerName(const QString& name)
{
    m_whiteNameBase = stripMarks(name);
    refreshNameLabels();
}

// プレイヤー名ラベル（先手/後手）の表示内容とツールチップを最新状態に更新する。
// 役割：
//  - 反転状態（m_flipMode）に応じて、名前の先頭に付ける向きマークを切り替える
//      * 非反転：先手=▲ / 後手=▽
//      * 反転　：先手=▼ / 後手=△
//  - ElideLabel に対して fullText を設定（省略表示時の元テキスト）
//  - ツールチップはプレーンな名前（装飾なし）を HTML エスケープし、簡易スタイルを付与して設定
// 注意：
//  - 本関数はラベルが生成済み（nullptr でない）場合のみ更新を行う
//  - stripMarks() 済みの素の名前（m_blackNameBase / m_whiteNameBase）を用いる
void ShogiView::refreshNameLabels()
{
    // ── 先手（黒）側 ──
    if (m_blackNameLabel) {
        // 向きマークを反転状態で切り替え
        const QString markBlack = m_flipMode ? QStringLiteral("▼") : QStringLiteral("▲");

        // 省略表示用ラベルに完全なテキスト（マーク + 素の名前）を設定
        m_blackNameLabel->setFullText(markBlack + m_blackNameBase);

        // ツールチップ生成用のローカルラムダ（HTML エスケープ＋簡易スタイル）
        auto mkTip = [](const QString& plain) {
            return QStringLiteral(
                       "<div style='background-color:#FFF9C4; color:#333;"
                       "border:1px solid #C49B00; padding:6px; white-space:nowrap;'>%1</div>")
                .arg(plain.toHtmlEscaped());
        };
        // 装飾のない素の名前をツールチップとして設定
        m_blackNameLabel->setToolTip(mkTip(m_blackNameBase));
    }

    // ── 後手（白）側 ──
    if (m_whiteNameLabel) {
        // 向きマークを反転状態で切り替え
        const QString markWhite = m_flipMode ? QStringLiteral("△") : QStringLiteral("▽");

        // 省略表示用ラベルに完全なテキスト（マーク + 素の名前）を設定
        m_whiteNameLabel->setFullText(markWhite + m_whiteNameBase);

        // 同じく簡易スタイルのツールチップ（プレーン名をエスケープして安全に表示）
        auto mkTip = [](const QString& plain) {
            return QStringLiteral(
                       "<div style='background-color:#FFF9C4; color:#333;"
                       "border:1px solid #C49B00; padding:6px; white-space:nowrap;'>%1</div>")
                .arg(plain.toHtmlEscaped());
        };
        m_whiteNameLabel->setToolTip(mkTip(m_whiteNameBase));
    }
}

// 盤・駒台・ラベルの相対配置に用いる内部パラメータを再計算する。
// 役割：
//  - マスサイズ（m_squareSize）とユーザー指定の駒台ギャップ（m_standGapCols）から、
//    ラベル帯や駒台の水平オフセット（m_param1/m_param2）、盤のXオフセット（m_offsetX）などを更新。
//  - 段/筋ラベルの描画に最低限必要な隙間（needGapPx）を満たすように、ユーザー指定よりも広い
//    実効ギャップ（effGapPx/effCols）を採用する（ラベルの食い込み防止）。
// 各値の意味：
//  - m_labelBandPx : 段・筋ラベル帯の高さ（px）
//  - m_labelFontPt : ラベル用フォントサイズ（pt）
//  - m_labelGapPx  : 盤とラベルのすき間（px）
//  - m_param1      : 先手側（黒）駒台列の水平基準オフセット（px）
//  - m_param2      : 後手側（白）駒台列の水平基準オフセット（px）
//  - m_offsetX     : 盤の左端X（boardLeftPx）に相当する水平オフセット（px）
//  - m_standGapPx  : 実効的な駒台ギャップ（px）
// メモ：tweak は微調整用の定数（将来的に 1px のズレ補正等を行いたい場合に使用）。
void ShogiView::recalcLayoutParams()
{
    // 【微調整係数】現状0。必要に応じて±1〜2px程度の補正に使う想定。
    constexpr int tweak = 0;

    // 【ラベル関連の基本サイズ】マスサイズに比例し、下限/上限を設けて視認性を担保
    m_labelBandPx = std::max(10, int(m_squareSize * 0.68));     // ラベル帯の高さ（px）
    m_labelFontPt = std::clamp(m_squareSize * 0.26, 5.0, 18.0); // ラベルフォントのポイントサイズ
    m_labelGapPx  = std::max(2,  int(m_squareSize * 0.12));     // 盤とラベルのすき間（px）

    // 【駒台の実効ギャップ算出】
    // ユーザー指定の列数（m_standGapCols：0.0〜2.0）を px に換算
    const int userGapPx = qRound(m_squareSize * m_standGapCols);

    // 段ラベルを描くのに最低限必要なギャップ（px）を確保
    const int needGapPx = minGapForRankLabelsPx();

    // 実効ギャップ＝ユーザー指定と必要量の大きい方
    const int effGapPx   = std::max(userGapPx, needGapPx);

    // 実効ギャップを「何マス分か（列数）」に換算（浮動小数）
    const double effCols = double(effGapPx) / double(m_squareSize);

    // 【水平方向の主要オフセットを計算】
    // 盤の左に 2 列、右に 9 列（標準の将棋盤の幅）を置き、その外側に実効ギャップ列（effCols）を付与するイメージ。
    // m_param1：先手（黒）側の駒台寄せ量（左側列の基準）
    m_param1     = qRound((2.0 + effCols) * m_squareSize) - tweak;

    // m_param2：後手（白）側の駒台寄せ量（右側列の基準）
    m_param2     = qRound((9.0 + effCols) * m_squareSize) - tweak;

    // 盤の左端X座標（boardLeftPx）＝先手側の寄せ量を基準に設定
    m_offsetX    = m_param1 + tweak;

    // 実効ギャップの px 値（後続の計算や描画に利用）
    m_standGapPx = qRound(effCols * m_squareSize);

    // ★ 手番ラベルも最新レイアウトに追従
    relayoutTurnLabels_();
}

// 指定段（rank）に対応する「段ラベル（漢数字）」を、盤の外縁と駒台の内縁のあいだに描画する。
// 方針：
//  - ペン色などの共通状態は上位（drawRanks）で設定済みを前提に、本関数ではフォントのみ調整。
//  - フォント設定による状態汚染を避けるため、局所的に save()/restore() を用いる（9回程度の呼び出しでコストは軽微）。
// 手順：
//  1) rank 行の基準セル矩形を取得し、y 座標とセル高さ h を決定
//  2) 反転状態に応じて、段ラベル帯を描く側（右側 or 左側）を選択
//  3) 盤の外縁（boardEdge）と駒台の内縁（innerEdge）の中点を xCenter とし、そこにラベル帯を配置
//  4) ラベル帯の幅 w は m_labelBandPx を基本に、利用可能な隙間（gapPx）内に収まるようクリップ
//  5) フォントサイズを m_labelFontPt × m_rankFontScale を基準に、セル高さの 90% を上限に調整
//  6) rank（1..9）に対応する漢数字を中央揃えで描画
void ShogiView::drawRank(QPainter* painter, const int rank) const
{
    if (!m_board) return;

    // (1) 指定段の基準セル（file=1）を取り、Y と高さを決める
    const QRect cell = calculateSquareRectangleBasedOnBoardState(1, rank);
    const int h = cell.height();
    const int y = cell.top() + m_offsetY;

    // (2) 反転していなければ右側に段ラベル、反転時は左側に段ラベル
    const bool rightSide = !m_flipMode;

    // 盤の外縁（右側 or 左側の外端）と、駒台の内縁（盤寄りの端）を取得
    const int boardEdge  = rightSide ? boardRightPx() : boardLeftPx();
    const int innerEdge  = standInnerEdgePx(rightSide);

    // (3) その中点を段ラベル帯の中心 X とする
    const int xCenter    = (boardEdge + innerEdge) / 2;

    // (4) ラベル帯の幅を決定（隙間が狭い場合はクリップ）
    int w = m_labelBandPx;
    const int gapPx = std::abs(innerEdge - boardEdge);
    if (w > gapPx - 2) w = std::max(12, gapPx - 2);

    // ラベル帯の描画矩形
    const QRect rankRect(xCenter - w/2, y, w, h);

    // (5) フォントを段ラベル用に調整（局所的に保存/復元）
    painter->save();
    QFont f = painter->font();
    double pt = m_labelFontPt * m_rankFontScale;
    pt = std::min(pt, h * 0.9);   // セル高さの 90% を上限に
    f.setPointSizeF(pt);
    painter->setFont(f);

    // (6) 1..9 段に対応する漢数字を中央揃えで描画
    static const QStringList rankTexts = { "一","二","三","四","五","六","七","八","九" };
    if (rank >= 1 && rank <= rankTexts.size()) {
        painter->drawText(rankRect, Qt::AlignCenter, rankTexts.at(rank - 1));
    }
    painter->restore();
}

// 指定筋（file）に対応する「筋ラベル（全角数字）」を、盤の上端または下端に描画する。
// 方針：
//  - ペン色などの共通状態は上位（drawFiles）で設定済み。本関数ではフォントのみを調整。
//  - フォント設定による状態汚染を避けるため、局所的に save()/restore() を用いる。
// 手順：
//  1) file 列の基準セル（rank=1）から X と幅 w を取得（盤オフセットを加味）
//  2) 反転状態に応じて、ラベル帯の配置先を決定
//      * 非反転：盤の「上側」空き領域に配置
//      * 反転　：盤の「下側」空き領域に配置
//     利用可能な空き高さ avail を求め、ラベル帯高さ h を m_labelBandPx を上限に調整
//  3) フォントサイズは m_labelFontPt を基準に、帯高さの 75% を上限に設定
//  4) file（1..9）に対応する全角数字を中央揃えで描画
void ShogiView::drawFile(QPainter* painter, const int file) const
{
    if (!m_board) return;

    // (1) 指定筋の基準セル（rank=1）から X と幅を算出（盤の左オフセットを反映）
    const QRect cell = calculateSquareRectangleBasedOnBoardState(file, 1);
    const int x = cell.left() + m_offsetX;
    const int w = cell.width();

    // ラベル帯の初期高さ（必要に応じて後でクリップ）
    int h = m_labelBandPx;
    int y = 0;

    // (2) 配置先の決定（反転時は下側、非反転時は上側）
    if (m_flipMode) {
        const int boardBottom = m_offsetY + m_squareSize * m_board->ranks(); // 盤の下端Y
        int avail = height() - boardBottom - 2;                              // 下側の空き
        if (avail <= 0) return;                                              // 余白なし
        h = std::min(h, std::max(8, avail - m_labelGapPx));                  // ギャップ分を差し引いて高さ確保
        y = boardBottom + m_labelGapPx;                                      // 盤下からギャップ分だけ離す
        if (y + h > height() - 1) y = height() - 1 - h;                      // 最下端を越えないよう補正
    } else {
        int avail = m_offsetY - 2;                                           // 上側の空き
        if (avail <= 0) return;
        h = std::min(h, std::max(8, avail - m_labelGapPx));                  // ギャップ分を差し引いて高さ確保
        y = m_offsetY - m_labelGapPx - h;                                    // 盤上からギャップ分だけ上へ
    }

    const QRect fileRect(x, y, w, h);

    // (3) フォント調整（局所保護）
    painter->save();
    QFont f = painter->font();
    f.setPointSizeF(std::min(m_labelFontPt, h * 0.75));  // 帯高さの 75% を上限に
    painter->setFont(f);

    // (4) 全角数字 １..９ を中央描画
    static const QStringList fileTexts = { "１","２","３","４","５","６","７","８","９" };
    if (file >= 1 && file <= fileTexts.size())
        painter->drawText(fileRect, Qt::AlignHCenter | Qt::AlignVCenter, fileTexts.at(file - 1));

    painter->restore();
}

// 段ラベル（漢数字）を盤の外縁と駒台の内縁の間に収めるために必要な
// 「最小の横方向ギャップ（px）」を見積もって返すヘルパ。
// 使途：recalcLayoutParams() でユーザー指定ギャップと比較し、不足分を補う。
// 手順：
//  1) ラベル帯の想定高さ bandH をマスサイズから算出（下限10px）
//  2) ラベル用フォントサイズを bandH を上限として設定し、QFontMetrics で文字幅を計測
//  3) 段ラベル候補（「一」〜「九」）の中で最大幅 wMax を求める
//  4) 左右パディング（padding×2）を加えて必要総幅を返す
int ShogiView::minGapForRankLabelsPx() const
{
    // (1) ラベル帯の高さ
    const int bandH = std::max(10, int(m_squareSize * 0.68));

    // (2) フォント準備：ポイントサイズは [5pt, bandH] にクリップ
    QFont f = this->font();
    f.setPointSizeF(std::clamp(m_labelFontPt, 5.0, double(bandH)));
    QFontMetrics fm(f);

    // (3) 漢数字 1..9 段の候補
    static const QStringList ranks = { "一","二","三","四","五","六","七","八","九" };

    // 最も幅の広い文字の幅を取得
    int wMax = 0;
    for (const QString& s : ranks)
        wMax = std::max(wMax, fm.horizontalAdvance(s));

    // (4) 左右パディング（最低 2px、通常は m_labelGapPx を採用）を加えた合計幅を返す
    const int padding = std::max(2, m_labelGapPx);
    return wMax + padding * 2;
}

// 駒台の「盤側の内縁」X座標を返すユーティリティ。
// 役割：段ラベルの配置計算などで、盤外の空き領域（駒台との間）の境界を知るために使用。
// 引数：rightSide=true  → 盤の右側の内縁（boardRightPx のさらに右にギャップ）
//       rightSide=false → 盤の左側の内縁（boardLeftPx のさらに左にギャップ）
// 備考：m_standGapPx は recalcLayoutParams() で算出される実効ギャップ幅（px）。
int ShogiView::standInnerEdgePx(bool rightSide) const
{
    const int gap = m_standGapPx;
    return rightSide ? (boardRightPx() + gap)  // 右側は盤の外側へ +gap
                     : (boardLeftPx()  - gap); // 左側は盤の外側へ -gap
}

// 段ラベル用フォントのスケールを設定するセッター。
// 役割：drawRank() 内で用いるフォントサイズを倍率で調整（見やすさの個人差に対応）。
// 処理：入力 scale を [0.5, 1.2] にクランプして m_rankFontScale に反映し、再描画を要求。
void ShogiView::setRankFontScale(double scale)
{
    m_rankFontScale = std::clamp(scale, 0.5, 1.2);
    update(); // スケール変更を即時反映
}

void ShogiView::applyTurnHighlight(bool blackIsActive)
{
    // 手番を更新
    m_blackActive = blackIsActive;

    // 手番切替直後はいったん「通常配色（Normal）」を適用
    // → 次の timeUpdated で applyClockUrgency() が Warn10/Warn5 に上書きします
    m_urgency = Urgency::Normal;

    // setUrgencyVisuals() 内で手番側を通常配色に、非手番側を font-weight=400 に統一
    setUrgencyVisuals(Urgency::Normal);
}

// 手番（アクティブサイド）を設定するセッター。
// 役割：内部フラグを更新し、名前/時計ラベルに手番ハイライトを反映。
void ShogiView::setActiveSide(bool blackTurn)
{
    m_blackActive = blackTurn;              // 先手が手番なら true
    applyTurnHighlight(m_blackActive);      // 背景/前景色を手番に合わせて適用
}

// 手番ハイライトの配色スタイルを設定する。
// 役割：背景色（ON 時）、文字色（ON/ OFF 時）を更新し、現手番に即時再適用。
// 注意：applyTurnHighlight はラベルが存在する場合にのみ安全に反映する。
void ShogiView::setHighlightStyle(const QColor& bgOn, const QColor& fgOn, const QColor& fgOff)
{
    m_highlightBg    = bgOn;    // アクティブ時の背景色
    m_highlightFgOn  = fgOn;    // アクティブ時の文字色
    m_highlightFgOff = fgOff;   // 非アクティブ時の文字色
    applyTurnHighlight(m_blackActive);  // 現在の手番にスタイルを再適用
}

// 盤（1 マス）のピクセルサイズ変更をレイアウトに反映するユーティリティ。
// 役割：fieldSize を m_squareSize の正方に設定し、レイアウトへ通知。
// 備考：setFieldSize() 側で updateGeometry() と時計ラベルジオメトリ更新を既に行っているため、
//       ここでの updateGeometry() は冗長だが無害（将来的に削除検討可）。
void ShogiView::updateBoardSize()
{
    setFieldSize(QSize(m_squareSize, m_squareSize)); // 1 マスのサイズを更新（内部で再レイアウトも行う）
    updateGeometry();                                // 冗長だが安全側の再通知

    // ★ 盤マスサイズ変更に伴い、手番ラベルの位置/フォントも追従
    relayoutTurnLabels_();
}

QString ShogiView::toRgb(const QColor& c)
{
    return QStringLiteral("rgb(%1,%2,%3)")
    .arg(QString::number(c.red()),
         QString::number(c.green()),
         QString::number(c.blue()));
}

void ShogiView::setLabelStyle(QLabel* lbl,
                              const QColor& fg, const QColor& bg,
                              int borderPx, const QColor& borderColor,
                              bool bold)
{
    if (!lbl) return;

    // ★ 角丸を 0px に
    const QString css = QStringLiteral(
                            "color:%1; background:%2; border:%3px solid %4; font-weight:%5; "
                            "padding:2px; border-radius:0px;")
                            .arg(
                                toRgb(fg),                         // %1
                                toRgb(bg),                         // %2
                                QString::number(borderPx),         // %3
                                toRgb(borderColor),                // %4
                                (bold ? QStringLiteral("700")
                                      : QStringLiteral("400"))     // %5
                                );

    lbl->setStyleSheet(css);
}

void ShogiView::setUrgencyVisuals(Urgency u)
{
    QLabel* actName    = m_blackActive ? m_blackNameLabel  : m_whiteNameLabel;
    QLabel* actClock   = m_blackActive ? m_blackClockLabel : m_whiteClockLabel;
    QLabel* inactName  = m_blackActive ? m_whiteNameLabel  : m_blackNameLabel;
    QLabel* inactClock = m_blackActive ? m_whiteClockLabel : m_blackClockLabel;

    // 非手番は font-weight=400 固定
    auto setInactive = [&](QLabel* name, QLabel* clock){
        const QColor inactiveFg(51, 51, 51);
        const QColor inactiveBg(239, 240, 241);
        setLabelStyle(name,  inactiveFg, inactiveBg, 0, QColor(0,0,0,0), /*bold=*/false);
        setLabelStyle(clock, inactiveFg, inactiveBg, 0, QColor(0,0,0,0), /*bold=*/false);
    };

    switch (u) {
    case Urgency::Normal:
        // 旧仕様：手番は黄背景＋青文字、枠なし、太字
        setLabelStyle(actName,  kTurnFg,   kTurnBg,   0, QColor(0,0,0,0), /*bold=*/true);
        setLabelStyle(actClock, kTurnFg,   kTurnBg,   0, QColor(0,0,0,0), /*bold=*/true);
        setInactive(inactName, inactClock);
        break;

    case Urgency::Warn10:
        // 旧仕様：10秒以下は黄色地＋枠無し＋太字
        // ※ kWarn10Border を青 (0,0,255) にしておくこと
        setLabelStyle(actName,  kWarn10Fg, kWarn10Bg, 0, kWarn10Border, /*bold=*/true);
        setLabelStyle(actClock, kWarn10Fg, kWarn10Bg, 0, kWarn10Border, /*bold=*/true);
        setInactive(inactName, inactClock);
        break;

    case Urgency::Warn5:
        // 旧仕様：5秒以下は黄色地＋枠無し＋太字
        // ※ kWarn5Border を赤 (255,0,0) にしておくこと
        setLabelStyle(actName,  kWarn5Fg,  kWarn5Bg,  0, kWarn5Border,  /*bold=*/true);
        setLabelStyle(actClock, kWarn5Fg,  kWarn5Bg,  0, kWarn5Border,  /*bold=*/true);
        setInactive(inactName, inactClock);
        break;
    }
}

void ShogiView::applyStartupTypography()
{
    m_urgency = Urgency::Normal;

    // 両側を「非手番スタイル（font-weight:400）」で統一
    const QColor inactiveFg(51, 51, 51);
    const QColor inactiveBg(239, 240, 241);
    auto setInactive = [&](QLabel* name, QLabel* clock){
        setLabelStyle(name,  inactiveFg, inactiveBg, /*borderPx=*/0, QColor(0,0,0,0), /*bold=*/false); // 400
        setLabelStyle(clock, inactiveFg, inactiveBg, /*borderPx=*/0, QColor(0,0,0,0), /*bold=*/false); // 400
    };

    setInactive(m_blackNameLabel,  m_blackClockLabel);
    setInactive(m_whiteNameLabel,  m_whiteClockLabel);
}

void ShogiView::setBlackTimeMs(qint64 ms) { m_blackTimeMs = ms; }
void ShogiView::setWhiteTimeMs(qint64 ms) { m_whiteTimeMs = ms; }

QImage ShogiView::toImage(qreal scale)
{
    QPixmap pm = this->grab(rect());        // 背景＋子ウィジェット込み
    QImage img = pm.toImage();
    if (!qFuzzyCompare(scale, 1.0)) {
        img = img.scaled(img.size() * scale,
                         Qt::IgnoreAspectRatio,
                         Qt::SmoothTransformation);
    }
    return img;
}

void ShogiView::applyBoardAndRender(ShogiBoard* board)
{
    if (!board) return;

    // 1) 駒アイコンの用意：現在の反転状態に合わせて読込
    if (m_flipMode) setPiecesFlip();
    else            setPieces();

    // 2) 盤データの適用
    setBoard(board);

    // 3) マスサイズの再適用（必要なら）
    setFieldSize(QSize(squareSize(), squareSize()));

    // 4) 再描画
    update();
}

void ShogiView::configureFixedSizing(int squarePx)
{
    setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    const int s = (squarePx > 0) ? squarePx : squareSize();
    setFieldSize(QSize(s, s));
    update();
}

void ShogiView::applyClockUrgency(qint64 activeRemainMs)
{
    Urgency next = Urgency::Normal;
    if      (activeRemainMs <= kWarn5Ms)  next = Urgency::Warn5;
    else if (activeRemainMs <= kWarn10Ms) next = Urgency::Warn10;

    if (next != m_urgency) {
        m_urgency = next;
        setUrgencyVisuals(m_urgency);
    }
}

void ShogiView::clearTurnHighlight()
{
    // 非手番配色（薄いグレー背景/通常フォント）を両陣営へ適用
    const QColor fg(51, 51, 51);
    const QColor bg(239, 240, 241);
    setLabelStyle(m_blackNameLabel,  fg, bg, 0, QColor(0,0,0,0), /*bold=*/false);
    setLabelStyle(m_blackClockLabel, fg, bg, 0, QColor(0,0,0,0), /*bold=*/false);
    setLabelStyle(m_whiteNameLabel,  fg, bg, 0, QColor(0,0,0,0), /*bold=*/false);
    setLabelStyle(m_whiteClockLabel, fg, bg, 0, QColor(0,0,0,0), /*bold=*/false);

    // 内部状態も「通常」に戻す（念のため）
    m_urgency = Urgency::Normal;
}

void ShogiView::setUiMuted(bool on) {
    m_uiMuted = on;
}

void ShogiView::setActiveIsBlack(bool activeIsBlack)
{
    m_blackActive = activeIsBlack;
}

// 手番ラベルを（無ければ）生成して初期設定する。
// ・参照元（黒=名前／白=時計）からフォント/色/背景をコピー
// ・角丸を無効化（border-radius:0）して四角い枠に統一
// ・内部マージンやラップを無効化して文字欠けを抑制
void ShogiView::ensureTurnLabels_()
{
    // 先手用
    QLabel* tlBlack = this->findChild<QLabel*>(QStringLiteral("turnLabelBlack"));
    if (!tlBlack) {
        tlBlack = new QLabel(tr("次の手番"), this);
        tlBlack->setObjectName(QStringLiteral("turnLabelBlack"));
        tlBlack->setAlignment(Qt::AlignCenter);
        tlBlack->setAttribute(Qt::WA_TransparentForMouseEvents, true);
        tlBlack->setContentsMargins(0, 0, 0, 0);
        tlBlack->setMargin(0);
        tlBlack->setWordWrap(false);
        tlBlack->setTextFormat(Qt::PlainText);
        tlBlack->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
        tlBlack->hide();
    }

    // 後手用
    QLabel* tlWhite = this->findChild<QLabel*>(QStringLiteral("turnLabelWhite"));
    if (!tlWhite) {
        tlWhite = new QLabel(tr("次の手番"), this);
        tlWhite->setObjectName(QStringLiteral("turnLabelWhite"));
        tlWhite->setAlignment(Qt::AlignCenter);
        tlWhite->setAttribute(Qt::WA_TransparentForMouseEvents, true);
        tlWhite->setContentsMargins(0, 0, 0, 0);
        tlWhite->setMargin(0);
        tlWhite->setWordWrap(false);
        tlWhite->setTextFormat(Qt::PlainText);
        tlWhite->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
        tlWhite->hide();
    }

    // 初期見た目をコピー + 角丸を外す
    if (m_blackNameLabel && tlBlack) {
        tlBlack->setFont(m_blackNameLabel->font());
        tlBlack->setStyleSheet(m_blackNameLabel->styleSheet());
        enforceSquareCorners(tlBlack);
    }
    if (m_whiteClockLabel && tlWhite) {
        tlWhite->setFont(m_whiteClockLabel->font());
        tlWhite->setStyleSheet(m_whiteClockLabel->styleSheet());
        enforceSquareCorners(tlWhite);
    }
}

void ShogiView::relayoutTurnLabels_()
{
    ensureTurnLabels_();

    QLabel* tlBlack = this->findChild<QLabel*>(QStringLiteral("turnLabelBlack"));
    QLabel* tlWhite = this->findChild<QLabel*>(QStringLiteral("turnLabelWhite"));

    QLabel* bn = m_blackNameLabel;  // 先手（黒）名前
    QLabel* bc = m_blackClockLabel; // 先手（黒）時計
    QLabel* wn = m_whiteNameLabel;  // 後手（白）名前
    QLabel* wc = m_whiteClockLabel; // 後手（白）時計
    if (!bn || !bc || !wn || !wc || !tlBlack || !tlWhite) return;

    // 角丸を完全無効化（見た目を統一） ※ 可視/不可視には触らない
    auto safeSquare = [](QLabel* lab){ if (lab) enforceSquareCorners(lab); };
    safeSquare(bn); safeSquare(bc); safeSquare(wn); safeSquare(wc);
    safeSquare(tlBlack); safeSquare(tlWhite);

    // 1マス寸法（fallbackあり）
    const QSize fs = fieldSize().isValid() ? fieldSize()
                                           : QSize(m_squareSize, m_squareSize);

    // ラベル高さの安全取得
    auto hLab = [&](QLabel* lab, int fallbackPx)->int {
        if (!lab) return fallbackPx;
        int h = lab->geometry().height();
        if (h <= 0) h = lab->sizeHint().height();
        if (h <= 0) h = fallbackPx;
        return h;
    };

    // 名前ラベルのフォントを（双方）同一スケールで調整
    {
        QFont f = bn->font();
        f.setPointSizeF(qMax(8.0, fs.height() * m_nameFontScale));
        bn->setFont(f);
        wn->setFont(f);
    }

    // 外側余白は維持、ラベル間の余白は 0 にする（実際は +1px の微小スペース）
    const int marginOuter = 2; // 駒台と最上段/最下段ラベルの外側余白
    const int marginInner = 0; // ラベル間の余白ゼロ（+1は境界線的に残す）

    // 駒台外接矩形
    const QRect standBlack = blackStandBoundingRect();
    const QRect standWhite = whiteStandBoundingRect();
    if (!standBlack.isValid() || !standWhite.isValid()) return;

    const int BW = standBlack.width();
    const int BX = standBlack.left();
    const int WW = standWhite.width();
    const int WX = standWhite.left();

    // 各高さ（turn は sizeHint/既存geometry を尊重）
    const int HnBlack = hLab(bn, fs.height());
    const int HcBlack = hLab(bc, fs.height());
    const int HtBlack = hLab(tlBlack, fs.height());

    const int HnWhite = hLab(wn, fs.height());
    const int HcWhite = hLab(wc, fs.height());
    const int HtWhite = hLab(tlWhite, fs.height());

    // 直下に縦積み（駒台の下）: [lab1][lab2][lab3]
    auto stackBelowStand = [&](const QRect& stand, int X, int W,
                               QLabel* lab1, int H1,
                               QLabel* lab2, int H2,
                               QLabel* lab3, int H3)
    {
        int y = stand.bottom() + 1 + marginOuter;
        QRect r1(X, y, W, H1);
        QRect r2(X, r1.bottom() + 1 + marginInner, W, H2);
        QRect r3(X, r2.bottom() + 1 + marginInner, W, H3);

        // 画面下オーバー分は上に押し上げる（順序は保持）
        int overflow = (r3.bottom() + marginOuter) - height();
        if (overflow > 0) { r1.translate(0,-overflow); r2.translate(0,-overflow); r3.translate(0,-overflow); }

        lab1->setGeometry(r1);
        lab2->setGeometry(r2);
        lab3->setGeometry(r3);

        // 時計は枠にフィット
        if (lab2 == m_blackClockLabel || lab2 == m_whiteClockLabel) {
            fitLabelFontToRect(lab2, lab2->text(), r2, 2);
        }
    };

    // 直上に縦積み（駒台の上）: 上から [lab1][lab2][lab3]
    auto stackAboveStand = [&](const QRect& stand, int X, int W,
                               QLabel* lab1, int H1,
                               QLabel* lab2, int H2,
                               QLabel* lab3, int H3)
    {
        const int totalH = H1 + marginInner + H2 + marginInner + H3;
        int yTop = stand.top() - 1 - marginOuter - totalH;
        if (yTop < 0) yTop = 0;

        QRect r1(X, yTop, W, H1);
        QRect r2(X, r1.bottom() + 1 + marginInner, W, H2);
        QRect r3(X, r2.bottom() + 1 + marginInner, W, H3);

        lab1->setGeometry(r1);
        lab2->setGeometry(r2);
        lab3->setGeometry(r3);

        // 時計は枠にフィット
        if (lab3 == m_blackClockLabel || lab3 == m_whiteClockLabel) {
            fitLabelFontToRect(lab3, lab3->text(), r3, 2);
        }
    };

    // 並び順は以前の仕様通り（未反転: 左=後手・右=先手 / 反転: 左=先手・右=後手）
    if (!m_flipMode) {
        // 左（後手）：駒台の下に [名前][時計][次の手番]
        stackBelowStand(standWhite, WX, WW, wn, HnWhite, wc, HcWhite, tlWhite, HtWhite);
        // 右（先手）：駒台の上に [次の手番][名前][時計]
        stackAboveStand(standBlack, BX, BW, tlBlack, HtBlack, bn, HnBlack, bc, HcBlack);
    } else {
        // 左（先手）：駒台の下に [名前][時計][次の手番]
        stackBelowStand(standBlack, BX, BW, bn, HnBlack, bc, HcBlack, tlBlack, HtBlack);
        // 右（後手）：駒台の上に [次の手番][名前][時計]
        stackAboveStand(standWhite, WX, WW, tlWhite, HtWhite, wn, HnWhite, wc, HcWhite);
    }

    // Zオーダー（可視/不可視は変更しない）
    bn->raise(); bc->raise(); wn->raise(); wc->raise();
    tlBlack->raise(); tlWhite->raise();

    relayoutEditExitButton();
}

void ShogiView::updateTurnIndicator(ShogiGameController::Player now)
{
    if (!m_blackNameLabel || !m_whiteClockLabel) return;

    ensureTurnLabels_();

    QLabel* tlBlack = this->findChild<QLabel*>(QStringLiteral("turnLabelBlack"));
    QLabel* tlWhite = this->findChild<QLabel*>(QStringLiteral("turnLabelWhite"));
    if (!tlBlack || !tlWhite) return;

    // いったん両方隠す
    tlBlack->hide();
    tlWhite->hide();

    // 配置更新（黒は駒台直上アンカー／白は従来）。内部で角丸無効化・スタイル同期も実施。
    relayoutTurnLabels_();

    // ★ 起動直後など now==NoPlayer の場合でも先手を既定表示にする
    const auto side = (now == ShogiGameController::Player1 || now == ShogiGameController::Player2)
                          ? now : ShogiGameController::Player1;

    if (side == ShogiGameController::Player1) {
        tlBlack->show();
        tlBlack->raise();
    } else {
        tlWhite->show();
        tlWhite->raise();
    }
}

void ShogiView::ensureAndPlaceEditExitButton_()
{
    ensureTurnLabels_();

    QLabel* bn = m_blackNameLabel;
    QLabel* wn = m_whiteNameLabel;
    if (!bn) bn = this->findChild<QLabel*>(QStringLiteral("blackNameLabel"));
    if (!wn) wn = this->findChild<QLabel*>(QStringLiteral("whiteNameLabel"));

    QPushButton* exitBtn = this->findChild<QPushButton*>(QStringLiteral("editExitButton"));
    if (!exitBtn) {
        exitBtn = new QPushButton(tr("編集終了"), this);
        exitBtn->setObjectName(QStringLiteral("editExitButton"));
        exitBtn->setVisible(false);
        exitBtn->setFocusPolicy(Qt::NoFocus);
        exitBtn->setCursor(Qt::PointingHandCursor);
        exitBtn->setAutoDefault(false);
        exitBtn->setDefault(false);
        exitBtn->setFlat(false);
        exitBtn->raise();
    }

    // 背景は全面赤（他はそのまま）
    const QString solidRedSS = QString::fromLatin1(R"(
        QPushButton#editExitButton {
            border: 1px solid #b40000;
            border-radius: 12px;
            padding: 4px 12px;
            color: #ffffff;
            font-weight: 600;
            background-color: #e00000;
        }
        QPushButton#editExitButton:hover {
            border: 1px solid #ff4444;
            background-color: #e00000;
        }
        QPushButton#editExitButton:pressed {
            padding-top: 5px; padding-bottom: 3px;
            border: 1px solid #8a0000;
            background-color: #e00000;
        }
        QPushButton#editExitButton:disabled {
            color: rgba(255,255,255,0.75);
            border-color: #9a0000;
            background-color: #e00000;
        }
    )");
    exitBtn->setStyleSheet(solidRedSS);

    // ── 右側の“名前ラベル”を基準に配置 ──
    QLabel* base = nullptr;
    if (bn && wn) {
        const int bx = bn->geometry().center().x();
        const int wx = wn->geometry().center().x();
        base = (bx > wx) ? bn : wn;
    } else {
        base = bn ? bn : wn;
    }

    QRect baseGeo;
    if (base) {
        baseGeo = base->geometry();
        exitBtn->setFont(base->font());
    } else {
        if (m_board) {
            const QSize fs = fieldSize().isValid() ? fieldSize()
                                                   : QSize(m_squareSize, m_squareSize);
            const QRect boardRect(m_offsetX, m_offsetY,
                                  fs.width() * m_board->files(),
                                  fs.height() * m_board->ranks());
            const int sideGap  = 8;
            const int sideWide = 160;
            baseGeo = QRect(boardRect.right() + 1 + sideGap,
                            boardRect.top(), sideWide, 1);
        } else {
            baseGeo = QRect(this->width() - 180, 10, 160, 1);
        }
    }

    int x = baseGeo.x();
    int w = baseGeo.width();
    const int maxW = this->width() - x - 4;
    if (w > maxW) w = maxW;

    fitEditExitButtonFont_(exitBtn, w);

    const int hBtn = qMax(exitBtn->sizeHint().height(), 28);
    int  y = 0;
    bool yFixed = false;

    if (m_board) {
        const QSize fs = fieldSize().isValid() ? fieldSize()
                                               : QSize(m_squareSize, m_squareSize);
        const QRect boardRect(m_offsetX, m_offsetY,
                              fs.width() * m_board->files(),
                              fs.height() * m_board->ranks());
        y = boardRect.top();        // ★1段目のY
        yFixed = true;
    }

    if (!yFixed) {
        const int vGap = 4;
        y = baseGeo.y() - hBtn - vGap;
        if (y < 0) y = 0;
    }

    exitBtn->setGeometry(x, y, w, hBtn);
}

// ラベル類の再配置後に呼んでください（resizeEvent/盤サイズ変更/回転後など）。
void ShogiView::relayoutEditExitButton()
{
    ensureAndPlaceEditExitButton_();
}

// 「局面編集終了」ボタンの見た目（目立つ色・文字色）を設定
void ShogiView::styleEditExitButton_(QPushButton* btn)
{
    if (!btn) return;

    // 角丸は 0（プロジェクトの統一方針に合わせてスクエア）
    // 目立つ赤系、文字は白、ホバー/押下で濃くする
    btn->setStyleSheet(
        "QPushButton#editExitButton {"
        "  background: #e53935;"
        "  color: #ffffff;"
        "  border: 1px solid #8e0000;"
        "  padding: 6px 10px;"
        "  font-weight: 600;"
        "  border-radius: 0px;"
        "}"
        "QPushButton#editExitButton:hover {"
        "  background: #d32f2f;"
        "}"
        "QPushButton#editExitButton:pressed {"
        "  background: #b71c1c;"
        "}"
        "QPushButton#editExitButton:disabled {"
        "  background: #bdbdbd;"
        "  color: #ffffff;"
        "  border-color: #9e9e9e;"
        "}"
        );
}

// ボタンの文字列が maxWidth に必ず収まるよう、フォントサイズを自動調整（縮小のみ）
void ShogiView::fitEditExitButtonFont_(QPushButton* btn, int maxWidth)
{
    if (!btn || maxWidth <= 20) return;

    // 左右パディングと枠線ぶんを控除（styleSheet に合わせて 10px+10px + α）
    const int inner = qMax(1, maxWidth - 24);

    QFont f = btn->font();
    int point = f.pointSize();
    int pixel = f.pixelSize();

    // pointSize が -1 の場合に備えて pixelSize を優先的に使う
    if (point <= 0 && pixel <= 0) {
        // どちらも不明なら適当な既定値
        point = 12;
        f.setPointSize(point);
        btn->setFont(f);
    }

    auto fits = [&](const QFont& tf)->bool {
        QFontMetrics fm(tf);
        const int textW = fm.horizontalAdvance(btn->text());
        return textW <= inner;
    };

    // まず現在サイズで試す
    if (fits(f)) {
        btn->setFont(f);
        return;
    }

    // 縮小ループ（下限 8pt or 12px）
    const int minPoint = 8;
    const int minPixel = 12;

    if (pixel > 0) {
        int sz = pixel;
        while (sz > minPixel) {
            QFont tf = f;
            tf.setPixelSize(--sz);
            if (fits(tf)) { btn->setFont(tf); return; }
        }
        // 収まらない場合でも下限でセット
        f.setPixelSize(minPixel);
        btn->setFont(f);
    } else {
        int sz = point;
        while (sz > minPoint) {
            QFont tf = f;
            tf.setPointSize(--sz);
            if (fits(tf)) { btn->setFont(tf); return; }
        }
        f.setPointSize(minPoint);
        btn->setFont(f);
    }
}
#include "apptooltipfilter.h"
#include "globaltooltip.h"

#include <QEvent>
#include <QHelpEvent>
#include <QWidget>
#include <QMenuBar>
#include <QToolBar>
#include <QToolButton>
#include <QMenu>
#include <QAction>

/*
 * AppToolTipFilter
 * アプリ全体で「標準の QToolTip」を抑止し、代わりに GlobalToolTip を表示するためのイベントフィルタ。
 * 役割：対象ウィジェット（メニューバー/ツールバー/ボタン/メニュー等）に install して、
 *       ToolTip イベント発生時に GlobalToolTip を表示・非表示する。
 * 備考：既存の子ウィジェットに一括装着するユーティリティ（installOn）を提供。
 */

// コンストラクタ。
// 役割：イベントフィルタ本体を生成し、描画用の GlobalToolTip を用意する。
AppToolTipFilter::AppToolTipFilter(QWidget* parent)
    : QObject(parent),
    m_tip(new GlobalToolTip(parent))
{
}

// 表示フォントサイズ（pt）の変更。
// 役割：内部の GlobalToolTip へ委譲してサイズを更新。
// 注意：m_tip が nullptr の場合は何もしない（安全弁）。
void AppToolTipFilter::setPointSizeF(qreal pt) {
    if (m_tip) m_tip->setPointSizeF(pt);
}

// 指定ルートウィジェット配下にイベントフィルタを一括装着。
// 役割：ルート自身＋既存の子（メニューバー/ツールバー/メニュー/ツールボタン）へ install。
// 注意：この時点で存在する子のみ対象。動的に追加される子は別途 install が必要。
void AppToolTipFilter::installOn(QWidget* root) {
    if (!root) return;

    // ルート自身
    root->installEventFilter(this);

    // 既存の子ウィジェットへ一括装着
    const auto menuBars = root->findChildren<QMenuBar*>();
    for (QMenuBar* mb : std::as_const(menuBars))
        installOnMenuBar(mb);

    const auto toolBars = root->findChildren<QToolBar*>();
    for (QToolBar* tb : std::as_const(toolBars))
        installOnToolBar(tb);

    const auto menus = root->findChildren<QMenu*>();
    for (QMenu* menu : std::as_const(menus))
        installOnMenu(menu);

    const auto buttons = root->findChildren<QToolButton*>();
    for (QToolButton* btn : std::as_const(buttons))
        btn->installEventFilter(this);
}

// メニューバーにイベントフィルタを装着。
// 役割：QMenuBar 自体の ToolTip イベントを捕捉できるようにする。
void AppToolTipFilter::installOnMenuBar(QMenuBar* mb) {
    if (!mb) return;
    mb->installEventFilter(this);
}

// ツールバーにイベントフィルタを装着。
// 役割：QToolBar 自体および既存の QToolButton にもフィルタを適用する。
// 注意：findChildren で取得したボタン群に対して const 反復で detach を避ける。
void AppToolTipFilter::installOnToolBar(QToolBar* tb) {
    if (!tb) return;

    tb->installEventFilter(this);

    // 既存のツールボタンにも（detach回避：const 反復）
    const auto buttons = tb->findChildren<QToolButton*>();
    for (QToolButton* btn : std::as_const(buttons))
        btn->installEventFilter(this);
}

// メニューにイベントフィルタを装着。
// 役割：QMenu の ToolTip イベントを捕捉してカスタム表示に差し替える。
void AppToolTipFilter::installOnMenu(QMenu* menu) {
    if (!menu) return;
    menu->installEventFilter(this);
}

// 指定ウィジェットのツールチップ文字列を選ぶヘルパ。
// 役割：メニューバーの場合は actionAt() の結果に応じ、アイコン無し項目は非表示（空文字）とする。
//       それ以外は QWidget::toolTip() を採用し、空ならトリムして空のまま返す。
// 注意：空文字を返すと表示しない扱い。
QString AppToolTipFilter::pickTextForWidget(QWidget* w, const QPoint& localPos) const {
    if (!w) return {};

    // QMenuBar 分岐：アクションごとに判定
    if (auto* mb = qobject_cast<QMenuBar*>(w)) {
        if (QAction* act = mb->actionAt(localPos)) {
            // アイコンが無い項目はツールチップを出さない
            if (act->icon().isNull())
                return QString();  // 空を返すと表示しない

            const QString t = act->toolTip().trimmed();
            return t.isEmpty() ? act->text().trimmed() : t;
        }
    }

    // それ以外：ウィジェット自身の toolTip を採用
    return w->toolTip().trimmed();
}

// イベントフィルタ本体。
// 役割：QEvent::ToolTip を横取りし、GlobalToolTip を使って表示/非表示を制御する。
// 動作：
//  - ToolTip 受信時：表示対象テキストを pickTextForWidget で選び、非空なら表示、空なら非表示。
//  - Leave/Hide/Close/FocusOut/WindowDeactivate/MouseButtonPress で非表示にする。
// 注意：表示時は true を返して既定の QToolTip を抑止する。
bool AppToolTipFilter::eventFilter(QObject* obj, QEvent* ev) {
    // ツールチップ表示
    if (ev->type() == QEvent::ToolTip) {
        auto* w  = qobject_cast<QWidget*>(obj);
        auto* he = static_cast<QHelpEvent*>(ev);
        if (!w || !he) return QObject::eventFilter(obj, ev);

        const QString text = pickTextForWidget(w, he->pos());
        if (!text.isEmpty()) {
            m_tip->showText(he->globalPos(), text);
            return true;                 // 既定の QToolTip を抑止
        } else {
            m_tip->hideTip();
        }
    }
    // 非表示トリガ
    else if (ev->type() == QEvent::Leave      ||
             ev->type() == QEvent::Hide       ||
             ev->type() == QEvent::Close      ||
             ev->type() == QEvent::FocusOut   ||
             ev->type() == QEvent::WindowDeactivate ||
             ev->type() == QEvent::MouseButtonPress)
    {
        if (m_tip) m_tip->hideTip();
    }

    return QObject::eventFilter(obj, ev);
}

// コンパクト表示の切り替え。
// 役割：内部の GlobalToolTip に on/off を委譲し、フォント/余白/角丸を一括調整。
void AppToolTipFilter::setCompact(bool on) {
    if (m_tip) m_tip->setCompact(on);
}
#include "elidelabel.h"
#include <QPainter>
#include <QMouseEvent>

/*
 * ElideLabel
 * ラベル内テキストが「幅に収まらない場合だけ」視認性を高める工夫を行う QLabel 派生。
 * 役割：
 *  - 通常はエリプシス（…）で省略表示
 *  - ホバー中は自動で横スクロール（任意）
 *  - 左ドラッグで手動パン（任意）
 *  - 下線の簡易装飾（任意）
 * 備考：スクロールは QTimer による一定ピクセル移動（m_pxPerTick / m_intervalMs）。
 */
ElideLabel::ElideLabel(QWidget* parent)
    : QLabel(parent)
{
    // 横方向はレイアウトに合わせて広がり、縦方向はフォントに依存する固定高さにする。
    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);

    // 自動スクロール用タイマーのハンドラを設定。
    // 役割：一定間隔ごとに表示オフセット m_offset を増分し、update() で再描画を促す。
    // 注意：実際の開始/停止は startSlideIfNeeded()/stopSlide() が受け持つ（常時スクロールしない）。
    connect(&m_timer, &QTimer::timeout, this, [this]{
        m_offset += m_pxPerTick; // 1ティックあたりの移動量
        update();                // 再描画要求（paintEvent でオフセットが反映される）
    });
}

// フルテキストを設定するセッター。
// 役割：表示の元になる完全な文字列を更新し、ツールチップ／省略文字列を再計算。
// 注意：同一文字列なら何もしない（不要な再計算・再描画を抑制）。
// 副作用：ツールチップも新しいフルテキストに置き換える。
// 補足：スクロール位置（m_offset）は維持する仕様。
//       変更時にスクロールを先頭へ戻したい場合は、m_offset=0; の追加や start/stop を検討。
void ElideLabel::setFullText(const QString& t) {
    if (m_fullText == t) return;   // 変更なしなら早期 return（最適化）
    m_fullText = t;                 // 元テキストを更新
    setToolTip(m_fullText);         // ツールチップも同期
    updateElidedText();             // elidedText を再計算して再描画を促す

    // （オプション）変更時にスクロール位置を初期化したい場合：
    // m_offset = 0;
    // stopSlide();
    // startSlideIfNeeded();
}

// 現在のフルテキストを返すゲッター。
// 役割：省略やスクロールの元データとなる完全な文字列をそのまま返す。
// 副作用：なし。
QString ElideLabel::fullText() const { return m_fullText; }

// エリプシス位置（左/中/右）を設定するセッター。
// 役割：Qt::TextElideMode を更新し、現在の幅に合わせて省略文字列を再計算する。
// 注意：はみ出していない場合は見た目に変化はない（m_fullText がそのまま描画される）。
void ElideLabel::setElideMode(Qt::TextElideMode m) {
    if (m_mode == m) return;
    m_mode = m;
    updateElidedText();  // contentsRect().width() に基づいて elidedText を作り直す
}

// 現在のエリプシス位置（Qt::TextElideMode）を返すゲッター。
// 役割：描画/設定の外部参照用。
Qt::TextElideMode ElideLabel::elideMode() const { return m_mode; }

// ホバー中の自動スクロール ON/OFF を設定するセッター。
// 役割：フラグを更新し、現在の状態（ホバー中・はみ出し有無・ドラッグ中か）に応じて
//       即座に開始/停止を判定。
// 注意：ドラッグ中は自動スクロールしない仕様。
void ElideLabel::setSlideOnHover(bool on)
{
    m_slideOnHover = on;
    startSlideIfNeeded();  // 必要ならタイマー起動／停止
}

// 自動スクロールの速度（1ティックあたりの移動ピクセル）を設定。
// 役割：滑らかな見た目や可読性に合わせて速度を調整する。
// 注意：1px 未満は無効化されるため、最低 1 に丸める。
void ElideLabel::setSlideSpeed(int pxPerTick)
{
    m_pxPerTick = qMax(1, pxPerTick);
}

// 自動スクロールのティック間隔（ミリ秒）を設定。
// 役割：タイマーの発火周期を変更する。
// 注意：タイマー稼働中は即時に再スタートして反映。停止中の場合は次回開始時に有効。
void ElideLabel::setSlideInterval(int ms)
{
    m_intervalMs = qMax(1, ms);
    if (m_timer.isActive()) m_timer.start(m_intervalMs);
}

// 下線表示の ON/OFF を設定するセッター。
// 役割：見出しやリンク風の装飾として、ラベル下部に細いラインを描画するかを切り替える。
// 実装：paintEvent で QPalette::Mid の色で 1px ラインを描く。
void ElideLabel::setUnderline(bool on)
{
    m_underline = on;
    update();  // 再描画
}

// 手動パン（ドラッグでの横スクロール）を有効/無効にするセッター。
// 役割：左ドラッグによるスクロール操作の可否を切り替える（mousePress/Move/Release で参照）。
// 実装：フラグ更新後に再描画を要求（下線などの装飾が変わるケースに備える）。
void ElideLabel::setManualPanEnabled(bool on)
{
    m_manualPan = on;
    update();
}

// サイズヒントを返す。
// 役割：高さはフォントに依存、幅はレイアウトに任せる想定で QLabel 既定をそのまま利用。
// 備考：横方向は Expanding、縦方向は Fixed のサイズポリシーを前提にしている。
QSize ElideLabel::sizeHint() const
{
    QSize sz = QLabel::sizeHint();
    // 高さはフォントに合わせて、幅はレイアウト側で決まる想定
    return sz;
}

// エリプシス済みテキスト（m_elidedText）を最新化する。
// 役割：現在のフォントと内容矩形幅（contentsRect().width()）に基づき、
//       m_fullText を elidedText で省略・更新して再描画する。
// 副作用：必要条件を満たす場合は自動スクロール開始を試みる（startSlideIfNeeded）。
void ElideLabel::updateElidedText()
{
    QFontMetrics fm(font());
    m_elidedText = fm.elidedText(m_fullText, m_mode, contentsRect().width());
    update();
    startSlideIfNeeded();
}

// テキストが内容矩形に収まりきらないかを判定する。
// 役割：フルテキスト幅（horizontalAdvance）と描画領域幅を比較し、はみ出しを検出。
// 備考：結果は自動スクロールの開始条件やマウス操作可否の判定に用いられる。
bool ElideLabel::isOverflowing() const
{
    QFontMetrics fm(font());
    return fm.horizontalAdvance(m_fullText) > contentsRect().width();
}

// 自動スクロール開始条件の判定と開始処理。
// 役割：ホバー中・テキストはみ出し・非ドラッグ中・自動スクロール許可のすべてを満たすと、
//       タイマーを起動して横スクロールを開始。手動パンが許可されている場合は手のひらカーソルに。
// 注意：既にタイマーが動作中なら再起動しない。条件を満たさない場合は stopSlide() を呼ぶ。
void ElideLabel::startSlideIfNeeded()
{
    if (m_slideOnHover && underMouse() && isOverflowing() && !m_dragging) {
        if (!m_timer.isActive()) {
            m_timer.start(m_intervalMs);
            setCursor(m_manualPan ? Qt::OpenHandCursor : cursor());
        }
    } else {
        stopSlide();
    }
}

// 自動スクロールの停止処理。
// 役割：タイマーを停止し、ドラッグしていない場合はカーソルを矢印に戻す。
// 備考：ドラッグ中はカーソル復帰を行わない（mouseReleaseEvent 側で復帰）。
void ElideLabel::stopSlide()
{
    if (m_timer.isActive()) m_timer.stop();
    if (!m_dragging) setCursor(Qt::ArrowCursor);
}

#if QT_VERSION >= QT_VERSION_CHECK(6,0,0)
// ホバー開始イベント（Qt 6 以降）。
// 役割：ホバーに入ったタイミングで自動スクロール開始条件を評価。
void ElideLabel::enterEvent(QEnterEvent*) { startSlideIfNeeded(); }
#else
// ホバー開始イベント（Qt 5 系）。
// 役割：ホバーに入ったタイミングで自動スクロール開始条件を評価。
void ElideLabel::enterEvent(QEvent*) { startSlideIfNeeded(); }
#endif

// ホバー終了イベント。
// 役割：マウスが領域外へ出たら自動スクロールを止め、表示位置（m_offset）を先頭に戻す。
// 注意：オフセットを 0 に戻した後に再描画して、次回表示をリセットした状態にする。
void ElideLabel::leaveEvent(QEvent*)
{
    stopSlide();   // 自動スクロール停止＆カーソル復帰（ドラッグ中でなければ）
    m_offset = 0;  // 次回のスクロール開始位置を先頭に戻す
    update();      // 再描画
}

// リサイズイベント。
// 役割：幅が変わると省略判定が変化するため、elidedText を再計算して表示を更新。
// 注意：基底の QLabel::resizeEvent(e) を先に呼んでから、自前の再計算を行う。
void ElideLabel::resizeEvent(QResizeEvent* e)
{
    QLabel::resizeEvent(e);  // 既定の処理（レイアウト/内部状態更新など）
    updateElidedText();      // 新しい contentsRect().width() を使って省略文字列を更新
}

// マウス押下イベント。
// 役割：手動パンが有効・左クリック・はみ出し有りのとき、ドラッグスクロールを開始する。
// 手順：m_dragging を立て、基準座標（m_lastDragX）を記録、カーソルを握り手に変更、
//       自動スクロールを停止してイベントを消費。
// 注意：条件外（手動パンOFF／右クリック／はみ出し無し）の場合は既定処理へ委譲。
void ElideLabel::mousePressEvent(QMouseEvent* ev)
{
    if (m_manualPan && ev->button() == Qt::LeftButton && isOverflowing()) {
        m_dragging = true;
        m_lastDragX = ev->pos().x();
        setCursor(Qt::ClosedHandCursor);
        stopSlide(); // ドラッグ中は自動スクロール停止
        ev->accept();
        return;
    }
    QLabel::mousePressEvent(ev);
}

// マウス移動イベント（ドラッグ中）。
// 役割：前回位置との差分 dx を用いて表示オフセット m_offset を更新し、水平スクロールさせる。
// 仕様：右へドラッグすると左へスクロール（テキストが左方向へ流れる）。
// 注意：処理後は再描画を要求し、イベントを消費。非ドラッグ時は既定処理へ委譲。
void ElideLabel::mouseMoveEvent(QMouseEvent* ev)
{
    if (m_dragging) {
        int dx = ev->pos().x() - m_lastDragX;
        m_lastDragX = ev->pos().x();
        m_offset = qMax(0, m_offset - dx); // 右へドラッグで左へスクロール
        update();
        ev->accept();
        return;
    }
    QLabel::mouseMoveEvent(ev);
}

// マウス解放イベント。
// 役割：左ボタンのドラッグを終了し、カーソルを復帰。必要なら自動スクロールを再開する。
// 仕様：ホバー中で手動パン有効なら手のひら、そうでなければ矢印カーソルに。
// 注意：左ボタン以外での解放、または非ドラッグ時は既定処理へ委譲。
void ElideLabel::mouseReleaseEvent(QMouseEvent* ev)
{
    if (m_dragging && ev->button() == Qt::LeftButton) {
        m_dragging = false;
        setCursor(underMouse() ? Qt::OpenHandCursor : Qt::ArrowCursor);
        startSlideIfNeeded(); // 必要なら自動スクロール再開
        ev->accept();
        return;
    }
    QLabel::mouseReleaseEvent(ev);
}

// 描画イベント。
// 役割：テキストの表示方式を選択して描画する。
//       1) はみ出し かつ（自動スクロール中 or ドラッグ中）：無限スクロール風にループ描画
//       2) それ以外：幅に収まるならフルテキスト、収まらないならエリプシス（…）で省略描画
// 注意：ループ描画では textW+m_gap を周期とし、m_offset を mod 周期で折り返して継ぎ目を消す。
// 備考：下線オプション（m_underline）時はベースライン直上に 1px ガイドラインを引く。
void ElideLabel::paintEvent(QPaintEvent*)
{
    QPainter p(this);
    p.setRenderHint(QPainter::TextAntialiasing, true);

    const QRect cr = contentsRect();
    QFontMetrics fm(font());
    const int textW = fm.horizontalAdvance(m_fullText);
    // 中央揃え用のベースライン： ascent / descent を考慮して垂直中央に配置
    const int baseY = cr.y() + (cr.height() + fm.ascent() - fm.descent())/2;

    const bool overflow = textW > cr.width();

    if ((m_timer.isActive() || m_dragging) && overflow) {
        // ── 連続ループ描画（スクロール中） ──
        const int startX = cr.x() + 2;      // 左側に少し余白
        const int period = textW + m_gap;   // 1 周期（テキスト幅＋隙間）
        // m_offset を常に [0, period) に正規化（負値対策も含む）
        const int off = (m_offset % period + period) % period;

        // 2 回描画して継ぎ目を目立たなくする
        p.drawText(startX - off,           baseY, m_fullText);
        p.drawText(startX - off + period,  baseY, m_fullText);
    } else {
        // ── 通常描画（非スクロール） ──
        // 収まる：m_fullText、収まらない：m_elidedText（alignment は QLabel 設定を流用）
        p.drawText(cr, alignment() | Qt::AlignVCenter,
                   overflow ? m_elidedText : m_fullText);
    }

    // 下線オプション（装飾）
    if (m_underline) {
        QPen pen(palette().color(QPalette::Mid));
        p.setPen(pen);
        p.drawLine(cr.left(), cr.bottom()-1, cr.right(), cr.bottom()-1);
    }
}
#include "engineanalysistab.h"

#include <QTabWidget>
#include <QTableView>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPlainTextEdit>
#include <QTextBrowser>
#include <QGraphicsView>
#include <QGraphicsScene>
#include <QGraphicsPathItem>
#include <QGraphicsSimpleTextItem>
#include <QPainterPath>
#include <QHeaderView>
#include <QFont>
#include <QMouseEvent>
#include <QtMath>
#include <QFontMetrics>
#include <QRegularExpression>
#include <QQueue>
#include <QSet>

#include "numeric_right_align_comma_delegate.h"
#include "engineinfowidget.h"
#include "shogienginethinkingmodel.h"
#include "usicommlogmodel.h"

// ===================== コンストラクタ/UI =====================

EngineAnalysisTab::EngineAnalysisTab(QWidget* parent)
    : QWidget(parent)
{
}

void EngineAnalysisTab::buildUi()
{
    // --- QTabWidget 準備 ---
    if (!m_tab) {
        m_tab = new QTabWidget(nullptr);
        m_tab->setObjectName(QStringLiteral("analysisTabs"));
    } else {
        m_tab->clear();
    }

    // --- 思考タブ ---
    QWidget* page = new QWidget(m_tab);
    auto* v = new QVBoxLayout(page);
    v->setContentsMargins(4,4,4,4);
    v->setSpacing(4);

    m_info1 = new EngineInfoWidget(page);
    m_view1 = new QTableView(page);
    m_info2 = new EngineInfoWidget(page);
    m_view2 = new QTableView(page);

    // ヘッダのリサイズポリシー（PV 列を広く等）
    tuneColumnsForThinkingView_(m_view1);
    tuneColumnsForThinkingView_(m_view2);

    v->addWidget(m_info1);
    v->addWidget(m_view1, 1);
    v->addWidget(m_info2);
    v->addWidget(m_view2, 1);

    m_tab->addTab(page, tr("思考"));

    // --- USI通信ログ ---
    m_usiLog = new QPlainTextEdit(m_tab);
    m_usiLog->setReadOnly(true);
    m_tab->addTab(m_usiLog, tr("USI通信ログ"));

    // --- 棋譜コメント ---
    m_comment = new QTextBrowser(m_tab);
    m_comment->setOpenExternalLinks(true);
    m_tab->addTab(m_comment, tr("棋譜コメント"));

    // --- 分岐ツリー ---
    m_branchTree = new QGraphicsView(m_tab);
    m_branchTree->setRenderHint(QPainter::Antialiasing, true);
    m_branchTree->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    m_branchTree->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    m_branchTree->setAlignment(Qt::AlignLeft | Qt::AlignTop);

    m_scene = new QGraphicsScene(m_branchTree);
    m_branchTree->setScene(m_scene);

    m_tab->addTab(m_branchTree, tr("分岐ツリー"));

    // ★ 初回起動時（あるいは再構築時）にモデルが既にあるなら即時適用
    reapplyViewTuning_(m_view1, m_model1);  // 右寄せ＋3桁カンマ＆列幅チューニング
    reapplyViewTuning_(m_view2, m_model2);

    // --- 分岐ツリーのクリック検知（二重 install 防止のガード付き） ---
    if (m_branchTree && m_branchTree->viewport()) {
        QObject* vp = m_branchTree->viewport();
        if (!vp->property("branchFilterInstalled").toBool()) {
            vp->installEventFilter(this);
            vp->setProperty("branchFilterInstalled", true);
        }
    }
}

void EngineAnalysisTab::reapplyViewTuning_(QTableView* v, QAbstractItemModel* m)
{
    if (!v) return;
    // 列幅チューニング（PVを広く等）
    tuneColumnsForThinkingView_(v);
    // 数値列（Time/Depth/Nodes/Score）の右寄せ＆3桁カンマ
    if (m) applyNumericFormattingTo_(v, m);
}

void EngineAnalysisTab::onModel1Reset_()
{
    reapplyViewTuning_(m_view1, m_model1);
}

void EngineAnalysisTab::onModel2Reset_()
{
    reapplyViewTuning_(m_view2, m_model2);
}

void EngineAnalysisTab::onLog1Changed_()
{
    if (m_usiLog && m_log1) m_usiLog->appendPlainText(m_log1->usiCommLog());
}

void EngineAnalysisTab::onLog2Changed_()
{
    if (m_usiLog && m_log2) m_usiLog->appendPlainText(m_log2->usiCommLog());
}

void EngineAnalysisTab::setModels(ShogiEngineThinkingModel* m1, ShogiEngineThinkingModel* m2,
                                  UsiCommLogModel* log1, UsiCommLogModel* log2)
{
    m_model1 = m1;  m_model2 = m2;
    m_log1   = log1; m_log2  = log2;

    if (m_view1) m_view1->setModel(m1);
    if (m_view2) m_view2->setModel(m2);

    if (m_info1) m_info1->setModel(log1);
    if (m_info2) m_info2->setModel(log2);

    // モデル設定直後に再適用
    reapplyViewTuning_(m_view1, m_model1);
    reapplyViewTuning_(m_view2, m_model2);

    // modelReset時に再適用（ラムダ→関数スロット）
    if (m_model1) {
        QObject::connect(m_model1, &QAbstractItemModel::modelReset,
                         this, &EngineAnalysisTab::onModel1Reset_, Qt::UniqueConnection);
    }
    if (m_model2) {
        QObject::connect(m_model2, &QAbstractItemModel::modelReset,
                         this, &EngineAnalysisTab::onModel2Reset_, Qt::UniqueConnection);
    }

    // USIログ反映（ラムダ→関数スロット）
    if (m_log1) {
        QObject::connect(m_log1, &UsiCommLogModel::usiCommLogChanged,
                         this, &EngineAnalysisTab::onLog1Changed_, Qt::UniqueConnection);
    }
    if (m_log2) {
        QObject::connect(m_log2, &UsiCommLogModel::usiCommLogChanged,
                         this, &EngineAnalysisTab::onLog2Changed_, Qt::UniqueConnection);
    }
}

QTabWidget* EngineAnalysisTab::tab() const { return m_tab; }

void EngineAnalysisTab::setAnalysisVisible(bool on)
{
    if (this->isVisible() != on) this->setVisible(on);
}

void EngineAnalysisTab::setCommentHtml(const QString& html)
{
    if (m_comment) m_comment->setHtml(html);
}

// ===================== 分岐ツリー・データ設定 =====================

void EngineAnalysisTab::setBranchTreeRows(const QVector<ResolvedRowLite>& rows)
{
    m_rows = rows;
    rebuildBranchTree();
}

// ===================== ノード/エッジ描画（＋登録） =====================

// ノード（指し手札）を描く：row=0(本譜)/1..(分岐), ply=手数(1始まり), rawText=指し手
QGraphicsPathItem* EngineAnalysisTab::addNode(int row, int ply, const QString& rawText)
{
    // レイアウト
    static constexpr qreal STEP_X   = 110.0;
    static constexpr qreal BASE_X   = 40.0;
    static constexpr qreal SHIFT_X  = 40.0;   // ← 現在使っているオフセットと揃える
    static constexpr qreal BASE_Y   = 40.0;
    static constexpr qreal STEP_Y   = 56.0;
    static constexpr qreal RADIUS   = 8.0;
    static const    QFont LABEL_FONT(QStringLiteral("Noto Sans JP"), 10);
    static const    QFont MOVE_NO_FONT(QStringLiteral("Noto Sans JP"), 9);

    const qreal x = BASE_X + SHIFT_X + ply * STEP_X;
    const qreal y = BASE_Y + row * STEP_Y;

    // 先頭の手数数字（全角/半角）を除去
    static const QRegularExpression kDropHeadNumber(QStringLiteral(R"(^\s*[0-9０-９]+\s*)"));
    QString labelText = rawText;
    labelText.replace(kDropHeadNumber, QString());
    labelText = labelText.trimmed();

    const bool odd = (ply % 2) == 1; // 奇数=先手、偶数=後手

    // ★ 分岐も本譜と同じ配色に統一
    const QColor mainOdd (196, 230, 255); // 先手=水色
    const QColor mainEven(255, 223, 196); // 後手=ピーチ
    const QColor fill = odd ? mainOdd : mainEven;

    // 札サイズ
    const QFontMetrics fm(LABEL_FONT);
    const int  wText = fm.horizontalAdvance(labelText);
    const int  hText = fm.height();
    const qreal padX = 12.0, padY = 6.0;
    const qreal rectW = qMax<qreal>(70.0, wText + padX * 2);
    const qreal rectH = qMax<qreal>(24.0, hText + padY * 2);

    // 角丸札
    QPainterPath path;
    const QRectF rect(x - rectW / 2.0, y - rectH / 2.0, rectW, rectH);
    path.addRoundedRect(rect, RADIUS, RADIUS);

    auto* item = m_scene->addPath(path, QPen(Qt::black, 1.2));
    item->setBrush(fill);
    item->setZValue(10);
    item->setData(ROLE_ORIGINAL_BRUSH, item->brush().color().rgba());

    // メタ
    item->setData(ROLE_ROW, row);
    item->setData(ROLE_PLY, ply);
    item->setData(BR_ROLE_KIND, (row == 0) ? BNK_Main : BNK_Var);
    if (row == 0) item->setData(BR_ROLE_PLY, ply); // 既存クリック処理互換

    // 指し手ラベル（中央）
    auto* textItem = m_scene->addSimpleText(labelText, LABEL_FONT);
    const QRectF br = textItem->boundingRect();
    textItem->setParentItem(item);
    textItem->setPos(rect.center().x() - br.width() / 2.0,
                     rect.center().y() - br.height() / 2.0);

    // ★ 「n手目」ラベルは本譜の上だけに表示（分岐 row!=0 では表示しない）
    if (row == 0) {
        const QString moveNo = QString::number(ply) + QStringLiteral("手目");
        auto* noItem = m_scene->addSimpleText(moveNo, MOVE_NO_FONT);
        const QRectF nbr = noItem->boundingRect();
        noItem->setParentItem(item);
        const qreal gap = 4.0;
        noItem->setPos(rect.center().x() - nbr.width() / 2.0,
                       rect.top() - gap - nbr.height());
    }

    // クリック解決用（従来）
    m_nodeIndex.insert(qMakePair(row, ply), item);

    // ★ グラフ登録（vid はここでは row と同義で十分）
    const int nodeId = registerNode(/*vid*/row, row, ply, item);
    item->setData(ROLE_NODE_ID, nodeId);

    return item;
}

void EngineAnalysisTab::addEdge(QGraphicsPathItem* from, QGraphicsPathItem* to)
{
    if (!from || !to) return;

    // ノードの中心（シーン座標）
    const QPointF a = from->sceneBoundingRect().center();
    const QPointF b = to->sceneBoundingRect().center();

    // 緩やかなベジェ
    QPainterPath path(a);
    const QPointF c1(a.x() + 8, a.y());
    const QPointF c2(b.x() - 8, b.y());
    path.cubicTo(c1, c2, b);

    auto* edge = m_scene->addPath(path, QPen(QColor(90, 90, 90), 1.0));
    edge->setZValue(0); // ← 線は常に背面（長方形の中に罫線が見えなくなる）

    // ★ グラフ接続
    const int prevId = from->data(ROLE_NODE_ID).toInt();
    const int nextId = to  ->data(ROLE_NODE_ID).toInt();
    if (prevId > 0 && nextId > 0) linkEdge(prevId, nextId);
}

// --- 追加ヘルパ：row(>=1) の分岐元となる「親行」を決める ---
int EngineAnalysisTab::resolveParentRowForVariation_(int row) const
{
    Q_ASSERT(row >= 1 && row < m_rows.size());
    const int b = m_rows.at(row).startPly;   // この変化の開始手数（1-origin）

    for (int prev = row - 1; prev >= 1; --prev) {
        const int a = m_rows.at(prev).startPly;
        if (b > a) return prev;              // 見つけたらその変化行を親に
    }
    return 0;                                 // どれにも入らなければ本譜
}

// ===================== シーン再構築 =====================

void EngineAnalysisTab::rebuildBranchTree()
{
    if (!m_scene) return;
    m_scene->clear();
    m_nodeIndex.clear();

    // ★ グラフもクリア
    clearBranchGraph();
    m_prevSelected = nullptr;

    static constexpr qreal STEP_X   = 110.0;
    static constexpr qreal BASE_X   = 40.0;
    static constexpr qreal SHIFT_X  = 40.0;   // addNode() と同じ
    static constexpr qreal BASE_Y   = 40.0;
    static constexpr qreal STEP_Y   = 56.0;
    static constexpr qreal RADIUS   = 8.0;
    static const    QFont LABEL_FONT(QStringLiteral("Noto Sans JP"), 10);

    QGraphicsPathItem* startNode = nullptr;

    // ===== 本譜 row=0 =====
    if (!m_rows.isEmpty()) {
        const auto& main = m_rows.at(0);

        // 「開始局面」（ply=0）
        {
            const qreal x = BASE_X + SHIFT_X;
            const qreal y = BASE_Y + 0 * STEP_Y;
            const QString label = QStringLiteral("開始局面");

            const QFontMetrics fm(LABEL_FONT);
            const int  wText = fm.horizontalAdvance(label);
            const int  hText = fm.height();
            const qreal padX = 14.0, padY = 8.0;
            const qreal rectW = qMax<qreal>(84.0, wText + padX * 2);
            const qreal rectH = qMax<qreal>(26.0, hText + padY * 2);

            QPainterPath path;
            const QRectF rect(x - rectW / 2.0, y - rectH / 2.0, rectW, rectH);
            path.addRoundedRect(rect, RADIUS, RADIUS);

            startNode = m_scene->addPath(path, QPen(Qt::black, 1.4));
            startNode->setBrush(QColor(235, 235, 235));
            startNode->setZValue(10);

            startNode->setData(ROLE_ROW, 0);
            startNode->setData(ROLE_PLY, 0);
            startNode->setData(BR_ROLE_KIND, BNK_Start);
            startNode->setData(ROLE_ORIGINAL_BRUSH, startNode->brush().color().rgba());
            m_nodeIndex.insert(qMakePair(0, 0), startNode);

            auto* t = m_scene->addSimpleText(label, LABEL_FONT);
            const QRectF br = t->boundingRect();
            t->setParentItem(startNode);
            t->setPos(rect.center().x() - br.width() / 2.0,
                      rect.center().y() - br.height() / 2.0);

            // ★ 開始局面もノード登録
            const int nid = registerNode(/*vid*/0, /*row*/0, /*ply*/0, startNode);
            startNode->setData(ROLE_NODE_ID, nid);
        }

        // 本譜のノード（ply=1..）
        QGraphicsPathItem* prev = startNode;
        int ply = 0;
        for (const auto& it : main.disp) {
            ++ply;
            auto* node = addNode(0, ply, it.prettyMove);
            if (prev) addEdge(prev, node);
            prev = node;
        }
    }

    // ===== 分岐 row=1.. =====
    for (int row = 1; row < m_rows.size(); ++row) {
        const auto& rv = m_rows.at(row);
        const int startPly = qMax(1, rv.startPly);      // 1-origin

        // 1) 親行を決定
        const int parentRow = resolveParentRowForVariation_(row);

        // 2) 親と繋ぐ“合流手”は (startPly - 1) 手目のノード
        const int joinPly = startPly - 1;

        // 親の joinPly ノードを取得。無ければ本譜→開始局面へフォールバック。
        QGraphicsPathItem* prev =
            m_nodeIndex.value(qMakePair(parentRow, joinPly),
                              m_nodeIndex.value(qMakePair(0, joinPly),
                                                m_nodeIndex.value(qMakePair(0, 0), nullptr)));

        // 3) 分岐の手リストを「開始手以降だけ」にスライス
        const int cut = qMax(0, startPly - 1);              // 0-origin index
        const int total = rv.disp.size();
        const int take = (cut < total) ? (total - cut) : 0;
        if (take <= 0) continue;                            // 描くもの無し

        // 4) 切り出した手だけを絶対手数で並べる（absPly = startPly + i）
        for (int i = 0; i < take; ++i) {
            const auto& it = rv.disp.at(cut + i);
            const int absPly = startPly + i;

            auto* node = addNode(row, absPly, it.prettyMove);

            // クリック用メタ
            node->setData(BR_ROLE_STARTPLY, startPly);
            node->setData(BR_ROLE_BUCKET,    row - 1);

            if (prev) addEdge(prev, node);
            prev = node;
        }
    }

    // シーン境界
    const int mainLen = m_rows.isEmpty() ? 0 : m_rows.at(0).disp.size();
    const qreal width  = (BASE_X + SHIFT_X) + STEP_X * qMax(40, mainLen + 6) + 40.0;
    const qreal height = 30 + STEP_Y * qMax(2, m_rows.size() + 1);
    m_scene->setSceneRect(QRectF(0, 0, width, height));
}

// ===================== ハイライト（フォールバック対応） =====================

void EngineAnalysisTab::highlightBranchTreeAt(int row, int ply, bool centerOn)
{
    // まず (row,ply) 直指定
    auto it = m_nodeIndex.find(qMakePair(row, ply));
    if (it != m_nodeIndex.end()) {
        highlightNodeId_(it.value()->data(ROLE_NODE_ID).toInt(), centerOn);
        return;
    }

    // 無ければグラフでフォールバック（分岐開始前は親行へ、あるいは next/prev を辿る）
    const int nid = graphFallbackToPly_(row, ply);
    if (nid > 0) {
        highlightNodeId_(nid, centerOn);
    }
}

void EngineAnalysisTab::highlightNodeId_(int nodeId, bool centerOn)
{
    if (nodeId <= 0) return;
    const auto node = m_nodesById.value(nodeId);
    QGraphicsPathItem* item = node.item;
    if (!item) return;

    // 直前ハイライト復元
    if (m_prevSelected) {
        const auto argb = m_prevSelected->data(ROLE_ORIGINAL_BRUSH).toUInt();
        m_prevSelected->setBrush(QColor::fromRgba(argb));
        m_prevSelected->setPen(QPen(Qt::black, 1.2));
        m_prevSelected->setZValue(10);
        m_prevSelected = nullptr;
    }

    // 黄色へ
    item->setBrush(QColor(255, 235, 80));
    item->setPen(QPen(Qt::black, 1.8));
    item->setZValue(20);
    m_prevSelected = item;

    if (centerOn && m_branchTree) m_branchTree->centerOn(item);
}

// ===================== クリック検出 =====================
bool EngineAnalysisTab::eventFilter(QObject* obj, QEvent* ev)
{
    if (m_branchTree && obj == m_branchTree->viewport()
        && ev->type() == QEvent::MouseButtonRelease)
    {
        auto* me = static_cast<QMouseEvent*>(ev);
        if (!(me->button() & Qt::LeftButton)) return QWidget::eventFilter(obj, ev);

        const QPointF scenePt = m_branchTree->mapToScene(me->pos());
        QGraphicsItem* hit =
            m_branchTree->scene() ? m_branchTree->scene()->itemAt(scenePt, QTransform()) : nullptr;

        // 子(Text)に当たることがあるので親まで遡る
        while (hit && !hit->data(BR_ROLE_KIND).isValid())
            hit = hit->parentItem();
        if (!hit) return false;

        // クリックされたノードの絶対(row, ply)
        const int row = hit->data(ROLE_ROW).toInt();  // 0=Main, 1..=VarN
        const int ply = hit->data(ROLE_PLY).toInt();  // 0=開始局面, 1..=手数

        // 即時の視覚フィードバック（黄色）※任意だが体感向上
        highlightBranchTreeAt(row, ply, /*centerOn=*/false);

        // 新API：MainWindow 側で (row, ply) をそのまま適用
        emit branchNodeActivated(row, ply);
        return true;
    }
    return QWidget::eventFilter(obj, ev);
}

// ===== 互換API 実装 =====
void EngineAnalysisTab::setSecondEngineVisible(bool on)
{
    if (m_info2)  m_info2->setVisible(on);
    if (m_view2)  m_view2->setVisible(on);
}

void EngineAnalysisTab::setEngine1ThinkingModel(ShogiEngineThinkingModel* m)
{
    m_model1 = m;
    if (m_view1) m_view1->setModel(m);
    if (m_view1 && m_view1->horizontalHeader())
        m_view1->horizontalHeader()->setSectionResizeMode(4, QHeaderView::Stretch);
}

void EngineAnalysisTab::setEngine2ThinkingModel(ShogiEngineThinkingModel* m)
{
    m_model2 = m;
    if (m_view2) m_view2->setModel(m);
    if (m_view2 && m_view2->horizontalHeader())
        m_view2->horizontalHeader()->setSectionResizeMode(4, QHeaderView::Stretch);
}

void EngineAnalysisTab::setCommentText(const QString& text)
{
    // 旧コード互換：プレーンテキストで設定（HTML解釈させたくない想定）
    if (m_comment) m_comment->setPlainText(text);
}

// ===================== グラフAPI 実装 =====================

void EngineAnalysisTab::clearBranchGraph()
{
    m_nodeIdByRowPly.clear();
    m_nodesById.clear();
    m_prevIds.clear();
    m_nextIds.clear();
    m_rowEntryNode.clear();
    m_nextNodeId = 1;
}

int EngineAnalysisTab::registerNode(int vid, int row, int ply, QGraphicsPathItem* item)
{
    if (!item) return -1;
    const int id = m_nextNodeId++;

    BranchGraphNode n;
    n.id   = id;
    n.vid  = vid;
    n.row  = row;
    n.ply  = ply;
    n.item = item;

    m_nodesById.insert(id, n);
    m_nodeIdByRowPly.insert(qMakePair(row, ply), id);

    // 行のエントリノード（最初に登録されたもの）を覚えておくと探索が楽
    if (!m_rowEntryNode.contains(row))
        m_rowEntryNode.insert(row, id);

    return id;
}

void EngineAnalysisTab::linkEdge(int prevId, int nextId)
{
    if (prevId <= 0 || nextId <= 0) return;
    m_nextIds[prevId].push_back(nextId);
    m_prevIds[nextId].push_back(prevId);
}

// ===================== フォールバック探索 =====================

int EngineAnalysisTab::graphFallbackToPly_(int row, int targetPly) const
{
    // 1) まず (row, ply) にノードがあるならそれ
    const int direct = nodeIdFor(row, targetPly);
    if (direct > 0) return direct;

    // 2) 分岐行の「開始手より前」なら親行へ委譲する
    if (row >= 1 && row < m_rows.size()) {
        const int startPly = qMax(1, m_rows.at(row).startPly);
        if (targetPly < startPly) {
            const int parentRow = resolveParentRowForVariation_(row);
            return graphFallbackToPly_(parentRow, targetPly);
        }
    }

    // 3) 同じ行内で近いノードから next を辿って同一 ply を探す
    //    まず「targetPly 以下で最も近い既存 ply」を見つける
    int seedId = -1;
    for (int p = targetPly; p >= 0; --p) {
        seedId = nodeIdFor(row, p);
        if (seedId > 0) break;
    }
    if (seedId <= 0) {
        // 行に何も無ければ、行の入口（例えば開始局面や最初の手）から辿る
        seedId = m_rowEntryNode.value(row, -1);
    }

    if (seedId > 0) {
        // BFSで next を辿り、targetPly と一致する ply を持つノードを探す
        QQueue<int> q;
        QSet<int> seen;
        q.enqueue(seedId);
        seen.insert(seedId);

        while (!q.isEmpty()) {
            const int cur = q.dequeue();
            const auto node = m_nodesById.value(cur);
            if (node.ply == targetPly) return cur;

            const auto nexts = m_nextIds.value(cur);
            for (int nx : nexts) {
                if (!seen.contains(nx)) {
                    seen.insert(nx);
                    q.enqueue(nx);
                }
            }
        }
    }

    // 4) それでも見つからない場合、親行へ委譲してみる（最終手段）
    if (row >= 1 && row < m_rows.size()) {
        const int parentRow = resolveParentRowForVariation_(row);
        if (parentRow != row) {
            const int viaParent = graphFallbackToPly_(parentRow, targetPly);
            if (viaParent > 0) return viaParent;
        }
    }

    // 5) 本譜 row=0 の seed からも探索してみる
    {
        int seed0 = nodeIdFor(0, targetPly);
        if (seed0 <= 0) seed0 = m_rowEntryNode.value(0, -1);
        if (seed0 > 0) {
            QQueue<int> q;
            QSet<int> seen;
            q.enqueue(seed0);
            seen.insert(seed0);
            while (!q.isEmpty()) {
                const int cur = q.dequeue();
                const auto node = m_nodesById.value(cur);
                if (node.ply == targetPly) return cur;
                const auto nexts = m_nextIds.value(cur);
                for (int nx : nexts) if (!seen.contains(nx)) { seen.insert(nx); q.enqueue(nx); }
            }
        }
    }

    return -1;
}

void EngineAnalysisTab::tuneColumnsForThinkingView_(QTableView* v)
{
    if (!v) return;
    auto* h = v->horizontalHeader();
    if (!h) return;

    // ★ PV 列のインデックス（必要なら変更）
    constexpr int kPvCol = 4;

    // 数値系の列は固定幅にして横幅を食い過ぎないようにする
    struct ColW { int col; int w; };
    const ColW fixedCols[] = {
        {0, 48},   // depth
        {1, 56},   // seldepth
        {2, 88},   // nodes
        {3, 110},  // nps
        // 必要なら他の列もここに追加
    };
    for (const auto& cw : fixedCols) {
        if (cw.col >= 0) {
            h->setSectionResizeMode(cw.col, QHeaderView::Fixed);
            v->setColumnWidth(cw.col, cw.w);
        }
    }

    // PV 列は残りを広く使う
    h->setSectionResizeMode(kPvCol, QHeaderView::Stretch);
    h->setStretchLastSection(true);       // PV が最後の列なら有効
    h->setMinimumSectionSize(24);         // 変に潰れないように最低幅
    h->resizeSection(kPvCol, 380);        // 初期表示でしっかり広い（お好みで調整）
}

// 追加：ヘッダー名で列を探す（大文字小文字は無視）
int EngineAnalysisTab::findColumnByHeader_(QAbstractItemModel* model, const QString& title)
{
    if (!model) return -1;
    const int cols = model->columnCount();
    for (int c = 0; c < cols; ++c) {
        const QVariant hd = model->headerData(c, Qt::Horizontal, Qt::DisplayRole);
        const QString h = hd.toString().trimmed();
        if (QString::compare(h, title, Qt::CaseInsensitive) == 0) {
            return c;
        }
    }
    return -1;
}

// 追加：Time/Depth/Nodes/Score を「右寄せ＋3桁カンマ」で表示するデリゲートを適用
void EngineAnalysisTab::applyNumericFormattingTo_(QTableView* view, QAbstractItemModel* model)
{
    if (!view || !model) return;

    // 同じデリゲートを複数列に使い回す。親を view にしてメモリ管理を任せる
    auto* delegate = new NumericRightAlignCommaDelegate(view);

    const QStringList targets = { "Time", "Depth", "Nodes", "Score" };
    for (const QString& t : targets) {
        const int col = findColumnByHeader_(model, t);
        if (col >= 0) {
            view->setItemDelegateForColumn(col, delegate);
        }
    }
}
#include "engineinfowidget.h"
#include <QHBoxLayout>
#include <QLabel>
#include <QLineEdit>
#include <QFont>
#include "usicommlogmodel.h"

EngineInfoWidget::EngineInfoWidget(QWidget* parent): QWidget(parent) {
    QFont f("Noto Sans CJK JP", 8);
    auto lab = [f](const QString& t){ auto* L=new QLabel(t); L->setFont(f); return L; };
    auto ro  = [f](int w=-1){ auto* E=new QLineEdit; E->setReadOnly(true); E->setFont(f); if(w>0)E->setFixedWidth(w); return E; };

    m_engineName = ro(300);
    m_pred = ro(); m_searched = ro();
    m_depth = ro(60); m_depth->setAlignment(Qt::AlignRight);
    m_nodes = ro();  m_nodes->setAlignment(Qt::AlignRight);
    m_nps   = ro();  m_nps  ->setAlignment(Qt::AlignRight);
    m_hash  = ro(60);m_hash ->setAlignment(Qt::AlignRight);

    auto* h = new QHBoxLayout(this);
    h->addWidget(m_engineName);
    h->addWidget(lab("予想手"));    h->addWidget(m_pred);
    h->addWidget(lab("探索手"));    h->addWidget(m_searched);
    h->addWidget(lab("深さ"));      h->addWidget(m_depth);
    h->addWidget(lab("ノード数"));  h->addWidget(m_nodes);
    h->addWidget(lab("探索局面数"));h->addWidget(m_nps);
    h->addWidget(lab("ハッシュ使用率")); h->addWidget(m_hash);
    setLayout(h);
}

void EngineInfoWidget::setModel(UsiCommLogModel* m) {
    if (m_model == m) return;
    if (m_model) disconnect(m_model, nullptr, this, nullptr);
    m_model = m;
    if (!m_model) {
        // モデルが無いときは見た目を空に
        m_engineName->clear(); m_pred->clear(); m_searched->clear();
        m_depth->clear(); m_nodes->clear(); m_nps->clear(); m_hash->clear();
        return;
    }

    connect(m_model, &UsiCommLogModel::engineNameChanged,     this, &EngineInfoWidget::onNameChanged);
    connect(m_model, &UsiCommLogModel::predictiveMoveChanged, this, &EngineInfoWidget::onPredChanged);
    connect(m_model, &UsiCommLogModel::searchedMoveChanged,   this, &EngineInfoWidget::onSearchedChanged);
    connect(m_model, &UsiCommLogModel::searchDepthChanged,    this, &EngineInfoWidget::onDepthChanged);
    connect(m_model, &UsiCommLogModel::nodeCountChanged,      this, &EngineInfoWidget::onNodesChanged);
    connect(m_model, &UsiCommLogModel::nodesPerSecondChanged, this, &EngineInfoWidget::onNpsChanged);
    connect(m_model, &UsiCommLogModel::hashUsageChanged,      this, &EngineInfoWidget::onHashChanged);
    onNameChanged(); onPredChanged(); onSearchedChanged(); onDepthChanged(); onNodesChanged(); onNpsChanged(); onHashChanged();
}

void EngineInfoWidget::onPredChanged()    { m_pred->setText(m_model->predictiveMove()); }
void EngineInfoWidget::onSearchedChanged(){ m_searched->setText(m_model->searchedMove()); }
void EngineInfoWidget::onDepthChanged()   { m_depth->setText(m_model->searchDepth()); }
void EngineInfoWidget::onNodesChanged()   { m_nodes->setText(m_model->nodeCount()); }
void EngineInfoWidget::onNpsChanged()     { m_nps  ->setText(m_model->nodesPerSecond()); }
void EngineInfoWidget::onHashChanged()    { m_hash ->setText(m_model->hashUsage()); }

// engineinfowidget.cpp
void EngineInfoWidget::setDisplayNameFallback(const QString& name) {
    m_fallbackName = name;
    // モデル未設定 or まだ空ならフォールバックを表示
    if (!m_model || m_model->engineName().isEmpty()) {
        m_engineName->setText(m_fallbackName);
    }
}

void EngineInfoWidget::onNameChanged() {
    const QString n = m_model ? m_model->engineName() : QString();
    m_engineName->setText(n.isEmpty() ? m_fallbackName : n);
}

#include "evaluationchartwidget.h"

#include <QtCharts/QChartView>
#include <QtCharts/QChart>
#include <QtCharts/QLineSeries>
#include <QtCharts/QValueAxis>
#include <QVBoxLayout>
#include <QBrush>
#include <QPen>
#include <QFont>
#include <QColor>
#include <QDebug>
#include <QtGlobal> // qIsFinite
#include <QThread>

EvaluationChartWidget::EvaluationChartWidget(QWidget* parent)
    : QWidget(parent)
{
    // 軸
    m_axX = new QValueAxis(this);
    m_axY = new QValueAxis(this);

    QFont labelsFont("Noto Sans CJK JP", 6);
    m_axX->setRange(0, 1000);
    m_axX->setTickCount(201);
    m_axX->setLabelsFont(labelsFont);
    m_axX->setLabelFormat("%i");

    m_axY->setRange(-2000, 2000);
    m_axY->setTickCount(5);
    m_axY->setLabelsFont(labelsFont);
    m_axY->setLabelFormat("%i");

    const QColor lightGray(192, 192, 192);
    m_axX->setLabelsColor(lightGray);
    m_axY->setLabelsColor(lightGray);

    // チャート
    m_chart = new QChart();
    m_chart->legend()->hide();
    m_chart->setBackgroundBrush(QBrush(QColor(0, 100, 0))); // ダークグリーン

    m_chart->addAxis(m_axX, Qt::AlignBottom);
    m_chart->addAxis(m_axY, Qt::AlignLeft);

    // シリーズ
    m_s1 = new QLineSeries(this); // 先手側
    m_s2 = new QLineSeries(this); // 後手側

    {
        QPen p = m_s1->pen();
        p.setWidth(2);
        m_s1->setPen(p);
        m_s1->setPointsVisible(true);
        m_s1->setColor(Qt::white);
    }
    {
        QPen p = m_s2->pen();
        p.setWidth(2);
        m_s2->setPen(p);
        m_s2->setPointsVisible(true);
        m_s2->setColor(Qt::black);
    }

    m_chart->addSeries(m_s1);
    m_chart->addSeries(m_s2);

    m_s1->attachAxis(m_axX);
    m_s1->attachAxis(m_axY);
    m_s2->attachAxis(m_axX);
    m_s2->attachAxis(m_axY);

    // ビュー
    m_chartView = new QChartView(m_chart, this);
    m_chartView->setRenderHint(QPainter::Antialiasing);

    auto* lay = new QVBoxLayout(this);
    lay->setContentsMargins(0, 0, 0, 0);
    lay->addWidget(m_chartView);
    setLayout(lay);

    setMinimumHeight(170);
}

void EvaluationChartWidget::appendScoreP1(int ply, int cp, bool invert)
{
    if (!m_s1) { qDebug() << "[CHART][P1][ERR] series null"; return; }

    const qreal y = invert ? -cp : cp;
    if (!qIsFinite(y)) qDebug() << "[CHART][P1][WARN] non-finite y" << y << "from cp=" << cp;

    const int before = m_s1->count();
    qDebug() << "[CHART][P1] append"
             << "ply=" << ply
             << "cp=" << cp
             << "invert=" << invert
             << "y=" << y
             << "beforeCount=" << before
             << "xRange=" << (m_axX ? QPointF(m_axX->min(), m_axX->max()) : QPointF(-1, -1))
             << "yRange=" << (m_axY ? QPointF(m_axY->min(), m_axY->max()) : QPointF(-1, -1))
             << "chartView=" << static_cast<const void*>(m_chartView)
             << "thread=" << QThread::currentThread();

    m_s1->append(ply, y);

    const int after = m_s1->count();
    QPointF lastPt;
    if (after > 0) lastPt = m_s1->at(after - 1);

    qDebug() << "[CHART][P1] appended"
             << "afterCount=" << after
             << "lastPoint=" << lastPt;

    if (m_axX) {
        if (ply > m_axX->max()) {
            const qreal newMax = ply + 50;
            qDebug() << "[CHART][P1] expand X range ->" << newMax;
            m_axX->setRange(0, newMax);
        }
    } else {
        qDebug() << "[CHART][P1][WARN] m_axX is null; skip range expand";
    }

    if (m_chartView) {
        m_chartView->update();
        qDebug() << "[CHART][P1] chartView updated";
    } else {
        qDebug() << "[CHART][P1][WARN] chartView is null; not updated";
    }
}

void EvaluationChartWidget::appendScoreP2(int ply, int cp, bool invert)
{
    if (!m_s2) { qDebug() << "[CHART][P2][ERR] series null"; return; }

    const qreal y = invert ? -cp : cp;
    if (!qIsFinite(y)) qDebug() << "[CHART][P2][WARN] non-finite y" << y << "from cp=" << cp;

    const int before = m_s2->count();
    qDebug() << "[CHART][P2] append"
             << "ply=" << ply
             << "cp=" << cp
             << "invert=" << invert
             << "y=" << y
             << "beforeCount=" << before
             << "xRange=" << (m_axX ? QPointF(m_axX->min(), m_axX->max()) : QPointF(-1, -1))
             << "yRange=" << (m_axY ? QPointF(m_axY->min(), m_axY->max()) : QPointF(-1, -1))
             << "chartView=" << static_cast<const void*>(m_chartView)
             << "thread=" << QThread::currentThread();

    m_s2->append(ply, y);

    const int after = m_s2->count();
    QPointF lastPt;
    if (after > 0) lastPt = m_s2->at(after - 1);

    qDebug() << "[CHART][P2] appended"
             << "afterCount=" << after
             << "lastPoint=" << lastPt;

    if (m_axX) {
        if (ply > m_axX->max()) {
            const qreal newMax = ply + 50;
            qDebug() << "[CHART][P2] expand X range ->" << newMax;
            m_axX->setRange(0, newMax);
        }
    } else {
        qDebug() << "[CHART][P2][WARN] m_axX is null; skip range expand";
    }

    if (m_chartView) {
        m_chartView->update();
        qDebug() << "[CHART][P2] chartView updated";
    } else {
        qDebug() << "[CHART][P2][WARN] chartView is null; not updated";
    }
}

void EvaluationChartWidget::clearAll()
{
    if (m_s1) m_s1->clear();
    if (m_s2) m_s2->clear();
    if (m_axX) m_axX->setRange(0, 1000);
    if (m_axY) m_axY->setRange(-2000, 2000);
    if (m_chartView) m_chartView->update();
}

void EvaluationChartWidget::removeLastP1()
{
    if (!m_s1) return;
    const int n = m_s1->count();
    if (n > 0) m_s1->removePoints(n - 1, 1);
    if (m_chartView) m_chartView->update();
}

void EvaluationChartWidget::removeLastP2()
{
    if (!m_s2) return;
    const int n = m_s2->count();
    if (n > 0) m_s2->removePoints(n - 1, 1);
    if (m_chartView) m_chartView->update();
}

int EvaluationChartWidget::countP1() const { return m_s1 ? m_s1->count() : 0; }
int EvaluationChartWidget::countP2() const { return m_s2 ? m_s2->count() : 0; }
#include "globaltooltip.h"

#include <QHBoxLayout>
#include <QLabel>
#include <QPoint>
#include <QString>

// 軽量なツールチップ風ポップアップ（QFrame 派生）。
// 役割：指定したグローバル座標付近にプレーンテキストを表示する小さなフローティング UI を提供。
// 特徴：
//  - Qt::ToolTip | Qt::FramelessWindowHint により枠なし・フォーカス奪取なしで表示
//  - HTML を無効化し、テキストは HTML エスケープして表示（XSS 的な混入を防ぐ）
//  - setCompact(true) で余白・角丸・フォントを小さめに一括変更
GlobalToolTip::GlobalToolTip(QWidget* parent)
    : QFrame(parent, Qt::ToolTip | Qt::FramelessWindowHint)
{
    // 役割：表示してもアクティブ化しない（フォーカスを奪わないようにする）
    setAttribute(Qt::WA_ShowWithoutActivating);

    // 役割：見た目の枠はスタイルシート側で制御するためフレームは未使用
    setFrameShape(QFrame::NoFrame);
    setFrameShadow(QFrame::Plain);

    // 役割：背景・文字色・パディング・角丸の基本スタイルを指定
    setStyleSheet(
        "background-color:#FFF9C4;"
        "color:#333;"
        "padding:10px 12px;"
        "border-radius:6px;"
        );

    // 役割：単純な横並びレイアウトを作成（中身は QLabel のみ）
    auto* lay = new QHBoxLayout(this);
    lay->setContentsMargins(10, 10, 10, 10);

    // 役割：テキスト表示用のラベルを準備（HTML は使わない想定）
    m_label = new QLabel(this);
    m_label->setFrameStyle(QFrame::NoFrame);
    lay->addWidget(m_label);

    // 役割：初期フォントサイズを設定（後で setCompact で上書き可能）
    setPointSizeF(14.0);
}

// フォントサイズ（pt）を設定するセッター。
// 役割：ラベルのフォントサイズを更新し、ウィジェットのサイズも内容に合わせて調整する。
// 注意：一部スタイル環境でフォントが上書きされる可能性があるため、StyleSheet でもサイズを明示。
void GlobalToolTip::setPointSizeF(qreal pt)
{
    QFont f = m_label->font();
    f.setPointSizeF(pt);
    m_label->setFont(f);

    // 念のため CSS でも指定（テーマによる上書き対策）
    m_label->setStyleSheet(QStringLiteral("font-size:%1pt;").arg(pt));

    // 内容に合わせて自身のサイズを更新
    adjustSize();
}

// 指定位置にプレーンテキストのツールチップを表示する。
// 役割：文字列を HTML エスケープして安全に表示し、カーソルの右下へ少しオフセットして配置。
// 注意：引数 globalPos はスクリーン座標（グローバル座標）を想定。
void GlobalToolTip::showText(const QPoint& globalPos, const QString& plainText)
{
    // HTML 無効化（素の文字列として表示）
    m_label->setText(plainText.toHtmlEscaped());
    adjustSize();

    // カーソルを覆わないよう、少し右下にずらして表示
    move(globalPos + QPoint(12, 16));
    show();
}

// ツールチップを非表示にする。
// 役割：単純なラッパ（将来的にアニメーション等を入れる場合のフックにもなる）。
void GlobalToolTip::hideTip()
{
    hide();
}

// コンパクト表示の切り替え。
// 役割：フォント・余白・角丸を小さめに調整し、全体の見た目を詰める。
// 注意：レイアウトの ContentsMargins とフレームの padding を両方更新しないと充分に縮まらない。
void GlobalToolTip::setCompact(bool on)
{
    // 小さめ設定（フォント/余白/角丸）
    const int   padV   = on ? 4 : 6;       // 上下 padding
    const int   padH   = on ? 4 : 6;       // 左右 padding
    const int   radius = on ? 4 : 6;       // 角丸半径
    const qreal pt     = on ? 12.0 : 14.0; // フォントサイズ

    // フォント更新（内部で adjustSize() も実行）
    setPointSizeF(pt);

    // レイアウト余白の調整（これが無いと見た目が詰まらない）
    if (auto* lay = qobject_cast<QHBoxLayout*>(layout()))
        lay->setContentsMargins(padH, padV, padH, padV);

    // フレームの padding/角丸を更新（背景・文字色は据え置き）
    setStyleSheet(QStringLiteral(
                      "background-color:#FFF9C4;"
                      "color:#333;"
                      "padding:%1px %2px;"
                      "border-radius:%3px;"
                      ).arg(padV).arg(padH).arg(radius));

    adjustSize();
}
#include "kifuanalysisresultsdisplay.h"

// 棋譜解析結果を表示するクラス
// コンストラクタ
KifuAnalysisResultsDisplay::KifuAnalysisResultsDisplay(QObject *parent) : QObject(parent) { }

// コンストラクタ
KifuAnalysisResultsDisplay::KifuAnalysisResultsDisplay(const QString &currentMove, const QString &evaluationValue,
                                     const QString &evaluationDifference, const QString &principalVariation, QObject *parent)
    : KifuAnalysisResultsDisplay(parent)
{
    // 指し手、評価値、差、読み筋を設定する。
    m_currentMove = currentMove;
    m_evaluationValue = evaluationValue;
    m_evaluationDifference = evaluationDifference;
    m_principalVariation = principalVariation;
}

// 読み筋を取得する。
QString KifuAnalysisResultsDisplay::principalVariation() const
{
    return m_principalVariation;
}

// 評価値差を取得する。
QString KifuAnalysisResultsDisplay::evaluationDifference() const
{
    return m_evaluationDifference;
}

// 評価値を取得する。
QString KifuAnalysisResultsDisplay::evaluationValue() const
{
    return m_evaluationValue;
}

// 指し手を取得する。
QString KifuAnalysisResultsDisplay::currentMove() const
{
    return m_currentMove;
}
#include "kifubranchdisplay.h"

// 棋譜欄を表示するクラス
// コンストラクタ
KifuBranchDisplay::KifuBranchDisplay(QObject *parent) : QObject(parent) { }

// コンストラクタ
KifuBranchDisplay::KifuBranchDisplay(const QString &currentMove, QObject *parent)
    : KifuBranchDisplay(parent)
{
    // 指し手と消費時間を設定する。
    m_currentMove = currentMove;
}


// 指し手を取得する。
QString KifuBranchDisplay::currentMove() const
{
    return m_currentMove;
}

void KifuBranchDisplay::setCurrentMove(const QString &newCurrentMove)
{
    m_currentMove = newCurrentMove;
}
#include "kifudisplay.h"

// 棋譜欄を表示するクラス
// コンストラクタ
KifuDisplay::KifuDisplay(QObject *parent) : QObject(parent) { }

// コンストラクタ
KifuDisplay::KifuDisplay(const QString &currentMove, const QString &timeSpent, QObject *parent)
    : KifuDisplay(parent)
{
    // 指し手と消費時間を設定する。
    m_currentMove = currentMove;
    m_timeSpent = timeSpent;
}


// 指し手を取得する。
QString KifuDisplay::currentMove() const
{
    return m_currentMove;
}

// 消費時間を取得する。
QString KifuDisplay::timeSpent() const
{
    return m_timeSpent;
}
#include "longlongspinbox.h"
#include <QtWidgets/QLineEdit>
#include <QEvent>
#include <QKeyEvent>

// Qtには、long long型の値を直接扱うためのQSpinBoxは存在しない。
// このため、QAbstractSpinBoxを継承して、long long型の値を扱うクラス
// コンストラクタ
LongLongSpinBox::LongLongSpinBox(QWidget *parent) :
    QAbstractSpinBox(parent),

    // スピンボックスの最小値
    m_minValue(std::numeric_limits<qlonglong>::min()),

    // スピンボックスの最大値
    m_maxValue(std::numeric_limits<qlonglong>::max()),

    // 現在の値を初期化リストで0に設定する。
    m_currentValue(0),

    // 1ステップの増減幅を初期化リストで設定する。
    m_singleStepValue(1)
{
    // 初期値をスピンボックスに設定する。
    setSpinBoxValue(m_currentValue);
}

// 現在の値を返す。
qlonglong LongLongSpinBox::value() const
{
    return m_currentValue;
}

// スピンボックスに値を設定する
void LongLongSpinBox::setSpinBoxValue(qlonglong newValue)
{
    // 値が範囲内に収まるように制限する。
    const qlonglong boundedValue = qBound(m_minValue, newValue, m_maxValue);
    const QString boundedValueString = QString::number(boundedValue);

    // テキストを設定する。
    lineEdit()->setText(boundedValueString);

    // 値が変更された場合
    if (m_currentValue != boundedValue) {
        // スピンボックスの値を現在の値に設定する。
        m_currentValue = boundedValue;

        // long long型のシグナルを送信する。
        emit longLongValueChanged(boundedValue);

        // 文字列型のシグナルを送信する。
        emit textValueChanged(boundedValueString);
    }
}

// スピンボックスの範囲を設定する。
void LongLongSpinBox::setSpinBoxRange(qlonglong min, qlonglong max)
{
    // minとmaxを比較し、正しい範囲に設定する。
    // 範囲設定を行う際に、minとmaxの順序が間違って渡されても、適切に範囲が設定されるようにする。
    m_minValue = std::min(min, max);
    m_maxValue = std::max(min, max);

    // 範囲設定後に値を更新する。
    setSpinBoxValue(m_currentValue);
}

// キーボードイベントを処理する。
void LongLongSpinBox::keyPressEvent(QKeyEvent* event)
{
    // EnterキーやReturnキーが押された場合、入力を確定し、テキスト選択を更新する。
    switch (event->key()) {
    case Qt::Key_Enter:
    case Qt::Key_Return:
        // スピンボックスに入力した値を確定させ、その値が有効であれば内部の値に反映させる。
        // 入力した値が無効な場合、現在の値を再設定して入力内容をリセットする。
        finalizeEditing();
    }

    // 親クラスのイベントハンドラを呼び出す。
    QAbstractSpinBox::keyPressEvent(event);
}

// フォーカスが外れたときのイベントを処理する。
void LongLongSpinBox::focusOutEvent(QFocusEvent* event)
{
    // スピンボックスに入力した値を確定させ、その値が有効であれば内部の値に反映させる。
    // 入力した値が無効な場合、現在の値を再設定して入力内容をリセットする。
    finalizeEditing();

    // 親クラスのイベントハンドラを呼び出す。
    QAbstractSpinBox::focusOutEvent(event);
}

// スピンボックスのステップが有効かどうかを確認する。
// スピンボックスのインターフェースには、通常、値を増減するための上下ボタンが付いている。
// これらのボタンが有効（クリック可能）か無効（グレーアウトされてクリック不可）かを制御する。
QAbstractSpinBox::StepEnabled LongLongSpinBox::stepEnabled() const
{
     // 読み取り専用の場合
    if (isReadOnly()) {
        // StepEnabledのデフォルト状態（すべてのステップ操作が無効）を返す。
        return StepEnabled();
    }

    // StepEnabledはQFlags<QAbstractSpinBox::StepEnabledFlag>型のビットフィールドで、ステップアップ(StepUpEnabled)
    // およびステップダウン(StepDownEnabled)の操作を個別に有効または無効にするために使用する。
    StepEnabled enabledSteps;

    // 現在の値が最大値より小さい場合、ステップアップを有効にする。
    if (m_currentValue < m_maxValue) {
        enabledSteps |= StepUpEnabled;
    }

    // 現在の値が最小値より大きい場合、ステップダウンを有効にする。
    if (m_currentValue > m_minValue) {
        enabledSteps |= StepDownEnabled;
    }

    // 有効なステップを返す。
    return enabledSteps;
}

// スピンボックスの値をステップに応じて増減する。
void LongLongSpinBox::stepBy(int steps)
{
    // 読み取り専用の場合
    if (isReadOnly()) {
        // ステップ操作を無効化する。
        return;
    }

    // 必要に応じてエディットを終了する。
    finalizeEditingIfNeeded();

    qlonglong newValue = m_currentValue + (steps * m_singleStepValue);

    // ラッピングは行わず、範囲内に収める
    newValue = qBound(m_minValue, newValue, m_maxValue);

    setSpinBoxValue(newValue);
}

// 入力された値を検証する。
QValidator::State LongLongSpinBox::validate(QString &input, int &pos) const
{
    // まず数値として解釈を試みる
    bool ok;
    const qlonglong value = input.toLongLong(&ok);

    // 入力が空、または範囲内の数値なら受け入れる
    if (input.isEmpty() || (ok && value <= m_maxValue)) {
        return QValidator::Acceptable;
    }

    // それ以外は無効とする。
    return QValidator::Invalid;
}

// スピンボックスに入力した値を確定させ、その値が有効であれば内部の値に反映させる。
// 入力した値が無効な場合、現在の値を再設定して入力内容をリセットする。
void LongLongSpinBox::finalizeEditing()
{
    // スピンボックスの文字列を取得する。
    const QString text = lineEdit()->text();

    // 変換が成功したかどうかを示すフラグ
    bool ok;

    // 文字列をlong long型の数値に変換しようと試みる。
    // 変換が成功すればokがtrueになり、失敗すればfalseになる。
    qlonglong value = text.toLongLong(&ok);

    // 数値に変換できた場合
    if (ok) {
        // 変換された値を設定する。
        setSpinBoxValue(value);
    }
    // 数値に変換できなかった場合
    else {
        // 現在の値を再設定して入力内容を再設定する。
        setSpinBoxValue(m_currentValue);
    }
}

// 必要に応じて編集を終了する
void LongLongSpinBox::finalizeEditingIfNeeded()
{
    // 現在のテキストが期待通りでない場合、エディットを終了する
    if (QString::number(m_currentValue) != lineEdit()->text()) {
        finalizeEditing();
    }
}
#include "recordpane.h"
#include "kifurecordlistmodel.h"
#include "kifubranchlistmodel.h"

#include <QTextBrowser>
#include <QTableView>
#include <QHeaderView>
#include <QAbstractItemView>
#include <QPushButton>
#include <QTextBrowser>
#include <QSplitter>
#include <QScrollArea>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QPalette>
#include <QIcon>
#include <QSize>
#include <QModelIndex>
#include <QItemSelectionModel>
#include <QItemSelectionModel>
#include <QHeaderView>
#include <QTimer>

#include "evaluationchartwidget.h"
// KifuRecordListModel / KifuBranchListModel は前方宣言で十分（ここでは include 不要）

RecordPane::RecordPane(QWidget* parent)
    : QWidget(parent)
{
    buildUi();
    wireSignals(); // モデルに依存しないシグナルだけ先に配線
}

void RecordPane::buildUi()
{
    // --- 棋譜テーブル（左上） ---
    m_kifu = new QTableView(this);
    m_kifu->setSelectionMode(QAbstractItemView::SingleSelection);
    m_kifu->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_kifu->verticalHeader()->setVisible(false);

    // --- 矢印ボタン群（左下） ---
    m_btn1 = new QPushButton(this);
    m_btn2 = new QPushButton(this);
    m_btn3 = new QPushButton(this);
    m_btn4 = new QPushButton(this);
    m_btn5 = new QPushButton(this);
    m_btn6 = new QPushButton(this);

    // 既存実装と同じ配色（緑）
    {
        QPalette pal;
        pal.setColor(QPalette::Button, QColor(79, 146, 114));
        for (QPushButton* b : {m_btn1,m_btn2,m_btn3,m_btn4,m_btn5,m_btn6})
            b->setPalette(pal);
    }

    // アイコンとサイズ（既存のリソース名を流用）
    m_btn1->setIcon(QIcon(":/icons/gtk-media-next-rtl.png"));
    m_btn2->setIcon(QIcon(":/icons/gtk-media-forward-rtl.png"));
    m_btn3->setIcon(QIcon(":/icons/gtk-media-play-rtr.png"));
    m_btn4->setIcon(QIcon(":/icons/gtk-media-play-ltr.png"));
    m_btn5->setIcon(QIcon(":/icons/gtk-media-forward-ltr.png"));
    m_btn6->setIcon(QIcon(":/icons/gtk-media-next-ltr.png"));

    for (QPushButton* b : {m_btn1,m_btn2,m_btn3,m_btn4,m_btn5,m_btn6})
        b->setIconSize(QSize(32,32));

    auto* arrowsLay = new QHBoxLayout;
    arrowsLay->setContentsMargins(0,0,0,0);
    arrowsLay->setSpacing(6);
    arrowsLay->addWidget(m_btn1);
    arrowsLay->addWidget(m_btn2);
    arrowsLay->addWidget(m_btn3);
    arrowsLay->addWidget(m_btn4);
    arrowsLay->addWidget(m_btn5);
    arrowsLay->addWidget(m_btn6);

    m_arrows = new QWidget(this);
    m_arrows->setLayout(arrowsLay);
    m_arrows->setFixedHeight(50);
    m_arrows->setMinimumWidth(600);

    // 左側：棋譜 + 矢印 を縦積み
    auto* leftLay = new QVBoxLayout;
    leftLay->setContentsMargins(0,0,0,0);
    leftLay->setSpacing(6);
    leftLay->addWidget(m_kifu);
    leftLay->addWidget(m_arrows);

    QWidget* left = new QWidget(this);
    left->setLayout(leftLay);
    left->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);

    // --- 右側：分岐 + コメント（縦分割） ---
    m_branch = new QTableView(this);
    m_branch->setSelectionMode(QAbstractItemView::SingleSelection);
    m_branch->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_branch->verticalHeader()->setVisible(false);

    m_branchText = new QTextBrowser(this);
    m_branchText->setReadOnly(true);
    m_branchText->setOpenExternalLinks(true);
    m_branchText->setOpenLinks(true);
    m_branchText->setPlaceholderText(tr("コメントを表示"));

    // ★ 追加: アダプタに実体を紐付け
    m_commentAdapter.reset(m_branchText);

    m_right = new QSplitter(Qt::Vertical, this);
    m_right->addWidget(m_branch);
    m_right->addWidget(m_branchText);
    m_right->setChildrenCollapsible(false);
    m_right->setSizes({300, 200});

    // --- 左右分割 ---
    m_lr = new QSplitter(Qt::Horizontal, this);
    m_lr->addWidget(left);
    m_lr->addWidget(m_right);
    m_lr->setChildrenCollapsible(false);
    m_lr->setSizes({600, 400});

    // --- 評価値グラフ（スクロール） ---
    m_eval = new EvaluationChartWidget(this);
    m_eval->setMinimumHeight(170);
    m_eval->setFixedWidth(10000); // 横方向に長くしてスクロール

    auto* evalWrapLay = new QHBoxLayout;
    evalWrapLay->setContentsMargins(0,0,0,0);
    evalWrapLay->addWidget(m_eval);

    QWidget* evalWrap = new QWidget(this);
    evalWrap->setLayout(evalWrapLay);

    m_scroll = new QScrollArea(this);
    m_scroll->setFixedHeight(200);
    m_scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    m_scroll->setWidget(evalWrap);

    // --- ルート（上下積み：上=左右スプリッタ、下=評価スクロール） ---
    auto* root = new QVBoxLayout(this);
    root->setContentsMargins(0,0,0,0);
    root->setSpacing(8);
    root->addWidget(m_lr);
    root->addWidget(m_scroll);
    setLayout(root);
}

void RecordPane::wireSignals()
{
    // 既存：
    connect(m_branch, &QTableView::activated, this, &RecordPane::branchActivated, Qt::UniqueConnection);
    connect(m_branch, &QTableView::clicked, this, &RecordPane::branchActivated, Qt::UniqueConnection);

    // ★ 追加：棋譜表の選択ハイライトを黄色に
    setupKifuSelectionAppearance();

    // ★ 追加：分岐候補欄の選択ハイライトを黄色に
    setupBranchViewSelectionAppearance();
}

void RecordPane::setModels(KifuRecordListModel* recModel, KifuBranchListModel* brModel)
{
    Q_ASSERT(m_kifu);
    Q_ASSERT(m_branch);
    if (!m_kifu || !m_branch) buildUi();

    // --- 棋譜テーブル ---
    m_kifu->setModel(recModel);

    // 行追加→自動スクロール（多重接続防止）
    if (auto* model = m_kifu->model()) {
        if (m_connRowsInserted)
            disconnect(m_connRowsInserted);
        m_connRowsInserted = connect(model, &QAbstractItemModel::rowsInserted,
                                     m_kifu, [this](const QModelIndex&, int, int) {
                                         m_kifu->scrollToBottom();
                                     });
    }

    // 行選択の中継（多重接続防止 & メンバ関数スロット化）
    if (auto* sel = m_kifu->selectionModel()) {
        if (m_connRowChanged)
            disconnect(m_connRowChanged);
        m_connRowChanged = connect(sel,
                                   &QItemSelectionModel::currentRowChanged,
                                   this,
                                   &RecordPane::onKifuCurrentRowChanged,
                                   Qt::UniqueConnection);
    }

    if (auto* hh = m_kifu->horizontalHeader()) {
        hh->setSectionResizeMode(0, QHeaderView::Stretch);
        hh->setSectionResizeMode(1, QHeaderView::Stretch);
    }
    m_kifu->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_kifu->setSelectionMode(QAbstractItemView::SingleSelection);

    // ① 先に既存接続を解除
    if (m_connKifuCurrentRow) {
        QObject::disconnect(m_connKifuCurrentRow);
        m_connKifuCurrentRow = {};
    }

    // ② selectionModel() が確実にできてから接続（即時にあれば即時、なければ次のイベントループで）
    auto connectCurrentRow = [this]() {
        if (!m_kifu) return;
        if (auto* sel = m_kifu->selectionModel()) {
            // UniqueConnection は使わず、自前で前の接続を外す方が安全
            m_connKifuCurrentRow =
                connect(sel, &QItemSelectionModel::currentRowChanged,
                        this,
                        [this](const QModelIndex& idx, const QModelIndex&) {
                            emit mainRowChanged(idx.isValid() ? idx.row() : 0);
                        });
        }
    };

    if (m_kifu->selectionModel()) {
        connectCurrentRow();
    } else {
        // setModel 後すぐは selectionModel がまだ未設定なことがあるため遅延
        QTimer::singleShot(0, this, connectCurrentRow);
    }

    // --- 分岐テーブル ---
    m_branch->setModel(brModel);
    if (auto* hh2 = m_branch->horizontalHeader()) {
        hh2->setSectionResizeMode(0, QHeaderView::Stretch);
    }
}

QTableView* RecordPane::kifuView() const { return m_kifu; }
QTableView* RecordPane::branchView() const { return m_branch; }
EvaluationChartWidget* RecordPane::evalChart() const { return m_eval; }

void RecordPane::setArrowButtonsEnabled(bool on)
{
    for (QPushButton* b : {m_btn1,m_btn2,m_btn3,m_btn4,m_btn5,m_btn6})
        if (b) b->setEnabled(on);
}

void RecordPane::onKifuRowsInserted(const QModelIndex&, int, int)
{
    if (m_kifu) m_kifu->scrollToBottom();
}

void RecordPane::onKifuCurrentRowChanged(const QModelIndex& cur, const QModelIndex&)
{
    emit mainRowChanged(cur.isValid() ? cur.row() : 0);
}

void RecordPane::setBranchCommentText(const QString& text)
{
    if (m_branchText) m_branchText->setPlainText(text);
}

void RecordPane::setBranchCommentHtml(const QString& html)
{
    if (m_branchText) m_branchText->setHtml(html);
}

// ★ 追加: MainWindow から呼ばれる getter 実装
CommentTextAdapter* RecordPane::commentLabel()
{
    return &m_commentAdapter;
}

// RecordPane に「本譜に戻る」ボタンを遅延生成して差し込む。
// 右側の縦スプリッタ m_right の [分岐テーブル, ←このボタン, コメント欄] の順に挿入する。
// 既に存在する場合はそれを返す。
QPushButton* RecordPane::backToMainButton()
{
    if (!m_right) return nullptr;

    // 既に作ってあればそれを返す
    if (auto* existed = this->findChild<QPushButton*>("backToMainButton"))
        return existed;

    auto* btn = new QPushButton(tr("本譜に戻る"), this);
    btn->setObjectName(QStringLiteral("backToMainButton"));
    btn->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
    btn->setVisible(false); // 初期は非表示
    btn->setToolTip(tr("現在の手数で本譜（メインライン）に戻る"));

    // m_right の 1 番目（分岐テーブルとコメントの間）に挿入
    m_right->insertWidget(1, btn);
    return btn;
}

void RecordPane::setupKifuSelectionAppearance()
{
    if (!m_kifu) return;

    // 行選択（行全体を黄色でハイライトするために必須）
    m_kifu->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_kifu->setSelectionMode(QAbstractItemView::SingleSelection);

    // 選択ハイライト色を黄色に（フォーカスあり/なし両方に適用）
    QPalette pal = m_kifu->palette();
    const QColor kSelYellow(255, 255, 0); // 黄色
    pal.setColor(QPalette::Active,   QPalette::Highlight,       kSelYellow);
    pal.setColor(QPalette::Inactive, QPalette::Highlight,       kSelYellow);
    pal.setColor(QPalette::Active,   QPalette::HighlightedText, Qt::black);
    pal.setColor(QPalette::Inactive, QPalette::HighlightedText, Qt::black);
    m_kifu->setPalette(pal);
}

void RecordPane::setupBranchViewSelectionAppearance()
{
    if (!m_branch) return;

    // 行単位選択（行全体を黄色でハイライト）
    m_branch->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_branch->setSelectionMode(QAbstractItemView::SingleSelection);

    // フォーカスの有無に関係なく黄色でハイライト
    QPalette pal = m_branch->palette();
    const QColor kSelYellow(255, 255, 0); // 黄色
    pal.setColor(QPalette::Active,   QPalette::Highlight,       kSelYellow);
    pal.setColor(QPalette::Inactive, QPalette::Highlight,       kSelYellow);
    pal.setColor(QPalette::Active,   QPalette::HighlightedText, Qt::black);
    pal.setColor(QPalette::Inactive, QPalette::HighlightedText, Qt::black);
    m_branch->setPalette(pal);
}
