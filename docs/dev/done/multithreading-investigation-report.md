# ShogiBoardQ マルチスレッド化調査報告書

## 1. 現状の分析
ShogiBoardQは現在、主にシングルスレッド＋外部プロセス（USIエンジン）という構成で動作しています。GUIスレッドが主要なロジック（棋譜管理、UI更新、USI通信の同期待機など）の多くを担っており、重い処理や同期的な待機が発生した際にUIが一時的にフリーズしたり、再突入（re-entrancy）による複雑なバグを誘発したりするリスクがあります。

特に`UsiProtocolHandler`における`QEventLoop`を用いた同期待機や、`KifuLoadCoordinator`における大規模な棋譜ファイルのパースが課題となっています。

---

## 2. マルチスレッド化すべき箇所と提案手法

### 2.1 USIエンジン通信の非同期化 (UsiProtocolHandler)
- **現状:** `waitForUsiOk`, `waitForReadyOk`, `waitForBestMove` 等のメソッドが `QEventLoop` や `QThread::msleep` を使用して同期的に応答を待機しています。
- **問題点:** 同期待機中にGUIイベントが処理されるものの、ネストされたイベントループはスタックの増大や予期せぬ再突入を招きます。また、応答が遅いエンジンを使用した場合にUIのレスポンスが低下します。
- **改善案:** 
    - **手法:** `UsiProtocolHandler` 自体を `QObject::moveToThread` で専用のバックグラウンドスレッド（Worker Thread）に移動します。
    - **実装:** 
        - 通信制御スレッドを立ち上げ、エンジンプロセスとのI/O（標準入出力）をそこで管理します。
        - UIスレッドとの通信は、シグナルとスロット（`QueuedConnection`）のみで行います。
        - 同期的な `waitFor...` メソッドを廃止し、ステートマシンまたは非同期なコールバック形式に移行します。

### 2.2 棋譜のパースと読み込み (KifuLoadCoordinator)
- **現状:** `loadKifuCommon` 内で行われる `parseFunc`（KIF/CSA/JKF等のパース）がUIスレッドで同期的に実行されています。
- **問題点:** 数千手を超える分岐を含む巨大な棋譜や、多数のファイルを一括読み込みする場合、解析が終わるまでUIが完全にフリーズします。
- **改善案:**
    - **手法:** `QtConcurrent::run` を使用してパース処理をスレッドプールに委譲します。
    - **実装:**
        ```cpp
        // 概念コード
        auto future = QtConcurrent::run([=]() {
            KifParseResult res;
            parseFunc(filePath, res, &warn);
            return res;
        });
        // QFutureWatcherで完了を監視し、結果をUIに反映
        ```
    - **補足:** パース中はプログレスダイアログを表示し、ユーザーがキャンセルできるようにします。

### 2.3 詰将棋自動生成 (TsumeshogiGenerator)
- **現状:** エンジンとのやり取りは非同期ですが、局面の生成、SFENの文字列操作、トリミング候補の列挙などがUIスレッドで行われています。
- **問題点:** 大量の候補をトリミング（駒を除去して詰みを確認）する際、一回のループは短くても、回数が多いとGUIスレッドを占有し続けます。
- **改善案:**
    - **手法:** `QRunnable` と `QThreadPool` を使用して、個々の「詰みチェックタスク」を並列化します。
    - **実装:** 複数のエンジンインスタンスを並行して実行できる環境であれば、異なるスレッドから複数のエンジンに問い合わせを行うことで、生成速度を劇的に向上させられます。

### 2.4 評価値データのバルク処理 (EvaluationChartWidget / Analysis)
- **現状:** 棋譜解析結果をグラフにプロットする際、一点ずつ追加していますが、解析済み棋譜を読み込んだ際の全データプロットが重くなる可能性があります。
- **改善案:**
    - **手法:** 描画用のデータ系列（`QLineSeries`）に渡すためのデータ変換（座標計算やフィルタリング）を `QtConcurrent::blockingMap` 等で並列化します。

### 2.5 大規模な指し手生成・検証 (MoveValidator / Perft)
- **現状:** 現在は一手の検証のみを想定していますが、将来的に「棋譜全体の全着手が合法かチェックする」などの機能を追加する場合、シングルスレッドでは不十分です。
- **改善案:**
    - **手法:** 盤面状態をコピーし、`QtConcurrent::map` を使用して各局面の指し手生成をマルチコアで並列実行します。

### 2.6 画像のバッチ書き出し (BoardImageExporter)
- **現状:** 現在は現在の局面のみを保存・コピーする機能ですが、将来的に「対局全体の全局面を画像として一括書き出しする」機能を追加する場合、枚数に比例して時間がかかります。
- **改善案:**
    - **手法:** 各局面のレンダリング（QPainterによる描画）とファイル保存を `QtConcurrent::run` で並列化します。
    - **注意:** GUI部品（QWidget）の `grab()` はUIスレッドでしか実行できないため、オフスクリーンレンダリング（`QImage` への直接描画）に移行した上でマルチスレッド化する必要があります。

---

## 3. 実装上の注意点（スレッド安全性）

1. **GUIコンポーネントの操作:** 
   - バックグラウンドスレッドから直接 `QWidget` や `QGraphicsItem` を操作することは厳禁です。必ずシグナル/スロットを通じてUIスレッドに依頼してください。
2. **共有データへのアクセス:**
   - `ShogiBoard` や `KifuBranchTree` などのデータ構造に複数スレッドからアクセスする場合、`QMutex` や `QReadWriteLock` による排他制御が必要です。
   - 可能な限り、データの「コピー」をワーカースレッドに渡し、結果を新しいオブジェクトとして返す設計（イミュータブルな設計）を推奨します。
3. **オブジェクトの所有権 (Ownership):**
   - スレッドを跨ぐ際、`parent` が設定されているオブジェクトはスレッド移動ができない制約に注意してください。

## 4. 期待される効果
- **GUIの完全な非同期化:** 重い棋譜読み込み中もウィンドウの移動やメニュー操作がスムーズになります。
- **計算能力の最大活用:** マルチコアCPUを活かした高速な詰将棋生成や棋譜解析が可能になります。
- **堅牢性の向上:** ネストされたイベントループを排除することで、予期せぬ順序でのイベント処理によるクラッシュを防止できます。
