# Task 18: delete 削減バッチ2 — 中リスク（ISSUE-041）

## フェーズ
E: 所有権統一の仕上げ

## 前提条件
- Task 17（ISSUE-040: delete 削減バッチ1）が完了していること

## 目的
モデル/ダイアログ/エンジン領域の所有権を統一し、手動 `delete` を削減する。

## 対象ファイル
- `src/models/kifurecordlistmodel.cpp` — 棋譜レコードリストモデル
- `src/dialogs/menuwindow.cpp` — メニューウィンドウ
- `src/engine/shogienginethinkingmodel.cpp` — エンジン思考モデル

## 詳細手順

### Step 1: kifurecordlistmodel.cpp の分析と修正

#### 分析
1. ファイルを読み、`delete` の使用箇所を特定
2. モデルアイテムの所有権を追跡:
   - `QStandardItem` はモデルが所有する（`takeItem()` で所有権移転される場合あり）
   - `setItem()` でモデルに渡した後は手動 `delete` 不要
3. 置換方針を決定

#### 修正
- モデル所有のアイテムは `delete` を削除（Qt の所有権管理に委ねる）
- `takeItem()` で取り出したアイテムは `unique_ptr` で管理

### Step 2: menuwindow.cpp の分析と修正

#### 分析
1. ファイルを読み、`delete` の使用箇所を特定
2. ウィジェットの所有権を追跡:
   - レイアウトに追加されたウィジェットはレイアウト→親ウィジェットが所有
   - ダイアログの動的生成ウィジェットの管理

#### 修正
- parent ownership に統一できる箇所を修正
- 動的ウィジェットは parent 設定で `delete` を削除

### Step 3: shogienginethinkingmodel.cpp の分析と修正

#### 分析
1. ファイルを読み、`delete` の使用箇所を特定
2. エンジン思考データの所有権を追跡

#### 修正
- 所有権ルールに従い置換

### Step 4: ビルド・テスト
```bash
cmake --build build
cd build && ctest --output-on-failure
```

## 注意事項
- `QAbstractItemModel` のアイテム管理は Qt 固有のルールがある（`setItem()` で所有権移転）
- 二重解放を防ぐため、所有権の移転タイミングを正確に追跡する
- `deleteLater()` が適切な場合もある（signal 処理中の削除回避）

## 完了条件
- [ ] 二重解放/リーク回避が確認できる（全テスト Pass）
- [ ] 対象3ファイルの `delete` が削減されている
- [ ] 所有者が明確になっている
- [ ] 構造KPIテストが Pass

## 検証コマンド
```bash
cmake --build build
cd build && ctest --output-on-failure
grep -rn 'delete ' src --include="*.cpp" | grep -v '//' | grep -v '#include' | wc -l
cd build && ctest --output-on-failure -R tst_structural_kpi
```
